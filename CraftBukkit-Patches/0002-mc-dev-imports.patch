From 4fb010dd6b5507a47f48993899029b58f863845e Mon Sep 17 00:00:00 2001
From: md_5 <md_5@live.com.au>
Date: Sun, 1 Dec 2013 15:10:48 +1100
Subject: [PATCH] mc-dev imports

Imported files which are only modified by Spigot, not upstream. Files here should be completely unmodified aside from trivial changes such as adding throws statements to ensure proper compilation. You may need to add unrelated files in order to ensure a compilable result in the face of synthetic methods.

diff --git a/src/main/java/net/minecraft/server/AttributeRanged.java b/src/main/java/net/minecraft/server/AttributeRanged.java
new file mode 100644
index 0000000..d424f04
--- /dev/null
+++ b/src/main/java/net/minecraft/server/AttributeRanged.java
@@ -0,0 +1,42 @@
+package net.minecraft.server;
+
+public class AttributeRanged extends AttributeBase {
+
+    private final double a;
+    private final double b;
+    private String c;
+
+    public AttributeRanged(String s, double d0, double d1, double d2) {
+        super(s, d0);
+        this.a = d1;
+        this.b = d2;
+        if (d1 > d2) {
+            throw new IllegalArgumentException("Minimum value cannot be bigger than maximum value!");
+        } else if (d0 < d1) {
+            throw new IllegalArgumentException("Default value cannot be lower than minimum value!");
+        } else if (d0 > d2) {
+            throw new IllegalArgumentException("Default value cannot be bigger than maximum value!");
+        }
+    }
+
+    public AttributeRanged a(String s) {
+        this.c = s;
+        return this;
+    }
+
+    public String f() {
+        return this.c;
+    }
+
+    public double a(double d0) {
+        if (d0 < this.a) {
+            d0 = this.a;
+        }
+
+        if (d0 > this.b) {
+            d0 = this.b;
+        }
+
+        return d0;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BanEntrySerializer.java b/src/main/java/net/minecraft/server/BanEntrySerializer.java
new file mode 100644
index 0000000..3b4b596
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BanEntrySerializer.java
@@ -0,0 +1,89 @@
+package net.minecraft.server;
+
+import java.lang.reflect.Type;
+import java.text.ParseException;
+import java.util.Date;
+import java.util.UUID;
+
+import net.minecraft.util.com.google.gson.JsonDeserializationContext;
+import net.minecraft.util.com.google.gson.JsonDeserializer;
+import net.minecraft.util.com.google.gson.JsonElement;
+import net.minecraft.util.com.google.gson.JsonObject;
+import net.minecraft.util.com.google.gson.JsonSerializationContext;
+import net.minecraft.util.com.google.gson.JsonSerializer;
+import net.minecraft.util.com.mojang.authlib.GameProfile;
+
+class BanEntrySerializer implements JsonDeserializer, JsonSerializer {
+
+    final UserCache a;
+
+    private BanEntrySerializer(UserCache usercache) {
+        this.a = usercache;
+    }
+
+    public JsonElement a(UserCacheEntry usercacheentry, Type type, JsonSerializationContext jsonserializationcontext) {
+        JsonObject jsonobject = new JsonObject();
+
+        jsonobject.addProperty("name", usercacheentry.a().getName());
+        UUID uuid = usercacheentry.a().getId();
+
+        jsonobject.addProperty("uuid", uuid == null ? "" : uuid.toString());
+        jsonobject.addProperty("expiresOn", UserCache.a.format(usercacheentry.b()));
+        return jsonobject;
+    }
+
+    public UserCacheEntry a(JsonElement jsonelement, Type type, JsonDeserializationContext jsondeserializationcontext) {
+        if (jsonelement.isJsonObject()) {
+            JsonObject jsonobject = jsonelement.getAsJsonObject();
+            JsonElement jsonelement1 = jsonobject.get("name");
+            JsonElement jsonelement2 = jsonobject.get("uuid");
+            JsonElement jsonelement3 = jsonobject.get("expiresOn");
+
+            if (jsonelement1 != null && jsonelement2 != null) {
+                String s = jsonelement2.getAsString();
+                String s1 = jsonelement1.getAsString();
+                Date date = null;
+
+                if (jsonelement3 != null) {
+                    try {
+                        date = UserCache.a.parse(jsonelement3.getAsString());
+                    } catch (ParseException parseexception) {
+                        date = null;
+                    }
+                }
+
+                if (s1 != null && s != null) {
+                    UUID uuid;
+
+                    try {
+                        uuid = UUID.fromString(s);
+                    } catch (Throwable throwable) {
+                        return null;
+                    }
+
+                    UserCacheEntry usercacheentry = new UserCacheEntry(this.a, new GameProfile(uuid, s1), date, (GameProfileLookup) null);
+
+                    return usercacheentry;
+                } else {
+                    return null;
+                }
+            } else {
+                return null;
+            }
+        } else {
+            return null;
+        }
+    }
+
+    public JsonElement serialize(Object object, Type type, JsonSerializationContext jsonserializationcontext) {
+        return this.a((UserCacheEntry) object, type, jsonserializationcontext);
+    }
+
+    public Object deserialize(JsonElement jsonelement, Type type, JsonDeserializationContext jsondeserializationcontext) {
+        return this.a(jsonelement, type, jsondeserializationcontext);
+    }
+
+    BanEntrySerializer(UserCache usercache, GameProfileLookup gameprofilelookup) {
+        this(usercache);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BiomeDecorator.java b/src/main/java/net/minecraft/server/BiomeDecorator.java
new file mode 100644
index 0000000..c5701f6
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BiomeDecorator.java
@@ -0,0 +1,279 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class BiomeDecorator {
+
+    protected World a;
+    protected Random b;
+    protected int c;
+    protected int d;
+    protected WorldGenerator e = new WorldGenClay(4);
+    protected WorldGenerator f;
+    protected WorldGenerator g;
+    protected WorldGenerator h;
+    protected WorldGenerator i;
+    protected WorldGenerator j;
+    protected WorldGenerator k;
+    protected WorldGenerator l;
+    protected WorldGenerator m;
+    protected WorldGenerator n;
+    protected WorldGenerator o;
+    protected WorldGenFlowers p;
+    protected WorldGenerator q;
+    protected WorldGenerator r;
+    protected WorldGenerator s;
+    protected WorldGenerator t;
+    protected WorldGenerator u;
+    protected WorldGenerator v;
+    protected int w;
+    protected int x;
+    protected int y;
+    protected int z;
+    protected int A;
+    protected int B;
+    protected int C;
+    protected int D;
+    protected int E;
+    protected int F;
+    protected int G;
+    protected int H;
+    public boolean I;
+
+    public BiomeDecorator() {
+        this.f = new WorldGenSand(Blocks.SAND, 7);
+        this.g = new WorldGenSand(Blocks.GRAVEL, 6);
+        this.h = new WorldGenMinable(Blocks.DIRT, 32);
+        this.i = new WorldGenMinable(Blocks.GRAVEL, 32);
+        this.j = new WorldGenMinable(Blocks.COAL_ORE, 16);
+        this.k = new WorldGenMinable(Blocks.IRON_ORE, 8);
+        this.l = new WorldGenMinable(Blocks.GOLD_ORE, 8);
+        this.m = new WorldGenMinable(Blocks.REDSTONE_ORE, 7);
+        this.n = new WorldGenMinable(Blocks.DIAMOND_ORE, 7);
+        this.o = new WorldGenMinable(Blocks.LAPIS_ORE, 6);
+        this.p = new WorldGenFlowers(Blocks.YELLOW_FLOWER);
+        this.q = new WorldGenFlowers(Blocks.BROWN_MUSHROOM);
+        this.r = new WorldGenFlowers(Blocks.RED_MUSHROOM);
+        this.s = new WorldGenHugeMushroom();
+        this.t = new WorldGenReed();
+        this.u = new WorldGenCactus();
+        this.v = new WorldGenWaterLily();
+        this.y = 2;
+        this.z = 1;
+        this.E = 1;
+        this.F = 3;
+        this.G = 1;
+        this.I = true;
+    }
+
+    public void a(World world, Random random, BiomeBase biomebase, int i, int j) {
+        if (this.a != null) {
+            throw new RuntimeException("Already decorating!!");
+        } else {
+            this.a = world;
+            this.b = random;
+            this.c = i;
+            this.d = j;
+            this.a(biomebase);
+            this.a = null;
+            this.b = null;
+        }
+    }
+
+    protected void a(BiomeBase biomebase) {
+        this.a();
+
+        int i;
+        int j;
+        int k;
+
+        for (i = 0; i < this.F; ++i) {
+            j = this.c + this.b.nextInt(16) + 8;
+            k = this.d + this.b.nextInt(16) + 8;
+            this.f.generate(this.a, this.b, j, this.a.i(j, k), k);
+        }
+
+        for (i = 0; i < this.G; ++i) {
+            j = this.c + this.b.nextInt(16) + 8;
+            k = this.d + this.b.nextInt(16) + 8;
+            this.e.generate(this.a, this.b, j, this.a.i(j, k), k);
+        }
+
+        for (i = 0; i < this.E; ++i) {
+            j = this.c + this.b.nextInt(16) + 8;
+            k = this.d + this.b.nextInt(16) + 8;
+            this.g.generate(this.a, this.b, j, this.a.i(j, k), k);
+        }
+
+        i = this.x;
+        if (this.b.nextInt(10) == 0) {
+            ++i;
+        }
+
+        int l;
+        int i1;
+
+        for (j = 0; j < i; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            i1 = this.a.getHighestBlockYAt(k, l);
+            WorldGenTreeAbstract worldgentreeabstract = biomebase.a(this.b);
+
+            worldgentreeabstract.a(1.0D, 1.0D, 1.0D);
+            if (worldgentreeabstract.generate(this.a, this.b, k, i1, l)) {
+                worldgentreeabstract.b(this.a, this.b, k, i1, l);
+            }
+        }
+
+        for (j = 0; j < this.H; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            this.s.generate(this.a, this.b, k, this.a.getHighestBlockYAt(k, l), l);
+        }
+
+        for (j = 0; j < this.y; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            i1 = this.b.nextInt(this.a.getHighestBlockYAt(k, l) + 32);
+            String s = biomebase.a(this.b, k, i1, l);
+            BlockFlowers blockflowers = BlockFlowers.e(s);
+
+            if (blockflowers.getMaterial() != Material.AIR) {
+                this.p.a(blockflowers, BlockFlowers.f(s));
+                this.p.generate(this.a, this.b, k, i1, l);
+            }
+        }
+
+        for (j = 0; j < this.z; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            i1 = this.b.nextInt(this.a.getHighestBlockYAt(k, l) * 2);
+            WorldGenerator worldgenerator = biomebase.b(this.b);
+
+            worldgenerator.generate(this.a, this.b, k, i1, l);
+        }
+
+        for (j = 0; j < this.A; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            i1 = this.b.nextInt(this.a.getHighestBlockYAt(k, l) * 2);
+            (new WorldGenDeadBush(Blocks.DEAD_BUSH)).generate(this.a, this.b, k, i1, l);
+        }
+
+        for (j = 0; j < this.w; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+
+            for (i1 = this.b.nextInt(this.a.getHighestBlockYAt(k, l) * 2); i1 > 0 && this.a.isEmpty(k, i1 - 1, l); --i1) {
+                ;
+            }
+
+            this.v.generate(this.a, this.b, k, i1, l);
+        }
+
+        for (j = 0; j < this.B; ++j) {
+            if (this.b.nextInt(4) == 0) {
+                k = this.c + this.b.nextInt(16) + 8;
+                l = this.d + this.b.nextInt(16) + 8;
+                i1 = this.a.getHighestBlockYAt(k, l);
+                this.q.generate(this.a, this.b, k, i1, l);
+            }
+
+            if (this.b.nextInt(8) == 0) {
+                k = this.c + this.b.nextInt(16) + 8;
+                l = this.d + this.b.nextInt(16) + 8;
+                i1 = this.b.nextInt(this.a.getHighestBlockYAt(k, l) * 2);
+                this.r.generate(this.a, this.b, k, i1, l);
+            }
+        }
+
+        if (this.b.nextInt(4) == 0) {
+            j = this.c + this.b.nextInt(16) + 8;
+            k = this.d + this.b.nextInt(16) + 8;
+            l = this.b.nextInt(this.a.getHighestBlockYAt(j, k) * 2);
+            this.q.generate(this.a, this.b, j, l, k);
+        }
+
+        if (this.b.nextInt(8) == 0) {
+            j = this.c + this.b.nextInt(16) + 8;
+            k = this.d + this.b.nextInt(16) + 8;
+            l = this.b.nextInt(this.a.getHighestBlockYAt(j, k) * 2);
+            this.r.generate(this.a, this.b, j, l, k);
+        }
+
+        for (j = 0; j < this.C; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            i1 = this.b.nextInt(this.a.getHighestBlockYAt(k, l) * 2);
+            this.t.generate(this.a, this.b, k, i1, l);
+        }
+
+        for (j = 0; j < 10; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            i1 = this.b.nextInt(this.a.getHighestBlockYAt(k, l) * 2);
+            this.t.generate(this.a, this.b, k, i1, l);
+        }
+
+        if (this.b.nextInt(32) == 0) {
+            j = this.c + this.b.nextInt(16) + 8;
+            k = this.d + this.b.nextInt(16) + 8;
+            l = this.b.nextInt(this.a.getHighestBlockYAt(j, k) * 2);
+            (new WorldGenPumpkin()).generate(this.a, this.b, j, l, k);
+        }
+
+        for (j = 0; j < this.D; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            i1 = this.b.nextInt(this.a.getHighestBlockYAt(k, l) * 2);
+            this.u.generate(this.a, this.b, k, i1, l);
+        }
+
+        if (this.I) {
+            for (j = 0; j < 50; ++j) {
+                k = this.c + this.b.nextInt(16) + 8;
+                l = this.b.nextInt(this.b.nextInt(248) + 8);
+                i1 = this.d + this.b.nextInt(16) + 8;
+                (new WorldGenLiquids(Blocks.WATER)).generate(this.a, this.b, k, l, i1);
+            }
+
+            for (j = 0; j < 20; ++j) {
+                k = this.c + this.b.nextInt(16) + 8;
+                l = this.b.nextInt(this.b.nextInt(this.b.nextInt(240) + 8) + 8);
+                i1 = this.d + this.b.nextInt(16) + 8;
+                (new WorldGenLiquids(Blocks.LAVA)).generate(this.a, this.b, k, l, i1);
+            }
+        }
+    }
+
+    protected void a(int i, WorldGenerator worldgenerator, int j, int k) {
+        for (int l = 0; l < i; ++l) {
+            int i1 = this.c + this.b.nextInt(16);
+            int j1 = this.b.nextInt(k - j) + j;
+            int k1 = this.d + this.b.nextInt(16);
+
+            worldgenerator.generate(this.a, this.b, i1, j1, k1);
+        }
+    }
+
+    protected void b(int i, WorldGenerator worldgenerator, int j, int k) {
+        for (int l = 0; l < i; ++l) {
+            int i1 = this.c + this.b.nextInt(16);
+            int j1 = this.b.nextInt(k) + this.b.nextInt(k) + (j - k);
+            int k1 = this.d + this.b.nextInt(16);
+
+            worldgenerator.generate(this.a, this.b, i1, j1, k1);
+        }
+    }
+
+    protected void a() {
+        this.a(20, this.h, 0, 256);
+        this.a(10, this.i, 0, 256);
+        this.a(20, this.j, 0, 128);
+        this.a(20, this.k, 0, 64);
+        this.a(2, this.l, 0, 32);
+        this.a(8, this.m, 0, 16);
+        this.a(1, this.n, 0, 16);
+        this.b(1, this.o, 16, 16);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockAnvil.java b/src/main/java/net/minecraft/server/BlockAnvil.java
new file mode 100644
index 0000000..9e1ce2f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockAnvil.java
@@ -0,0 +1,79 @@
+package net.minecraft.server;
+
+public class BlockAnvil extends BlockFalling {
+
+    public static final String[] a = new String[] { "intact", "slightlyDamaged", "veryDamaged"};
+    private static final String[] N = new String[] { "anvil_top_damaged_0", "anvil_top_damaged_1", "anvil_top_damaged_2"};
+
+    protected BlockAnvil() {
+        super(Material.HEAVY);
+        this.g(0);
+        this.a(CreativeModeTab.c);
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public void postPlace(World world, int i, int j, int k, EntityLiving entityliving, ItemStack itemstack) {
+        int l = MathHelper.floor((double) (entityliving.yaw * 4.0F / 360.0F) + 0.5D) & 3;
+        int i1 = world.getData(i, j, k) >> 2;
+
+        ++l;
+        l %= 4;
+        if (l == 0) {
+            world.setData(i, j, k, 2 | i1 << 2, 2);
+        }
+
+        if (l == 1) {
+            world.setData(i, j, k, 3 | i1 << 2, 2);
+        }
+
+        if (l == 2) {
+            world.setData(i, j, k, 0 | i1 << 2, 2);
+        }
+
+        if (l == 3) {
+            world.setData(i, j, k, 1 | i1 << 2, 2);
+        }
+    }
+
+    public boolean interact(World world, int i, int j, int k, EntityHuman entityhuman, int l, float f, float f1, float f2) {
+        if (world.isStatic) {
+            return true;
+        } else {
+            entityhuman.openAnvil(i, j, k);
+            return true;
+        }
+    }
+
+    public int b() {
+        return 35;
+    }
+
+    public int getDropData(int i) {
+        return i >> 2;
+    }
+
+    public void updateShape(IBlockAccess iblockaccess, int i, int j, int k) {
+        int l = iblockaccess.getData(i, j, k) & 3;
+
+        if (l != 3 && l != 1) {
+            this.a(0.125F, 0.0F, 0.0F, 0.875F, 1.0F, 1.0F);
+        } else {
+            this.a(0.0F, 0.0F, 0.125F, 1.0F, 1.0F, 0.875F);
+        }
+    }
+
+    protected void a(EntityFallingBlock entityfallingblock) {
+        entityfallingblock.a(true);
+    }
+
+    public void a(World world, int i, int j, int k, int l) {
+        world.triggerEffect(1022, i, j, k, 0);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockBrewingStand.java b/src/main/java/net/minecraft/server/BlockBrewingStand.java
new file mode 100644
index 0000000..6ce80db
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockBrewingStand.java
@@ -0,0 +1,109 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+
+public class BlockBrewingStand extends BlockContainer {
+
+    private Random a = new Random();
+
+    public BlockBrewingStand() {
+        super(Material.ORE);
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public int b() {
+        return 25;
+    }
+
+    public TileEntity a(World world, int i) {
+        return new TileEntityBrewingStand();
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public void a(World world, int i, int j, int k, AxisAlignedBB axisalignedbb, List list, Entity entity) {
+        this.a(0.4375F, 0.0F, 0.4375F, 0.5625F, 0.875F, 0.5625F);
+        super.a(world, i, j, k, axisalignedbb, list, entity);
+        this.g();
+        super.a(world, i, j, k, axisalignedbb, list, entity);
+    }
+
+    public void g() {
+        this.a(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
+    }
+
+    public boolean interact(World world, int i, int j, int k, EntityHuman entityhuman, int l, float f, float f1, float f2) {
+        if (world.isStatic) {
+            return true;
+        } else {
+            TileEntityBrewingStand tileentitybrewingstand = (TileEntityBrewingStand) world.getTileEntity(i, j, k);
+
+            if (tileentitybrewingstand != null) {
+                entityhuman.openBrewingStand(tileentitybrewingstand);
+            }
+
+            return true;
+        }
+    }
+
+    public void postPlace(World world, int i, int j, int k, EntityLiving entityliving, ItemStack itemstack) {
+        if (itemstack.hasName()) {
+            ((TileEntityBrewingStand) world.getTileEntity(i, j, k)).a(itemstack.getName());
+        }
+    }
+
+    public void remove(World world, int i, int j, int k, Block block, int l) {
+        TileEntity tileentity = world.getTileEntity(i, j, k);
+
+        if (tileentity instanceof TileEntityBrewingStand) {
+            TileEntityBrewingStand tileentitybrewingstand = (TileEntityBrewingStand) tileentity;
+
+            for (int i1 = 0; i1 < tileentitybrewingstand.getSize(); ++i1) {
+                ItemStack itemstack = tileentitybrewingstand.getItem(i1);
+
+                if (itemstack != null) {
+                    float f = this.a.nextFloat() * 0.8F + 0.1F;
+                    float f1 = this.a.nextFloat() * 0.8F + 0.1F;
+                    float f2 = this.a.nextFloat() * 0.8F + 0.1F;
+
+                    while (itemstack.count > 0) {
+                        int j1 = this.a.nextInt(21) + 10;
+
+                        if (j1 > itemstack.count) {
+                            j1 = itemstack.count;
+                        }
+
+                        itemstack.count -= j1;
+                        EntityItem entityitem = new EntityItem(world, (double) ((float) i + f), (double) ((float) j + f1), (double) ((float) k + f2), new ItemStack(itemstack.getItem(), j1, itemstack.getData()));
+                        float f3 = 0.05F;
+
+                        entityitem.motX = (double) ((float) this.a.nextGaussian() * f3);
+                        entityitem.motY = (double) ((float) this.a.nextGaussian() * f3 + 0.2F);
+                        entityitem.motZ = (double) ((float) this.a.nextGaussian() * f3);
+                        world.addEntity(entityitem);
+                    }
+                }
+            }
+        }
+
+        super.remove(world, i, j, k, block, l);
+    }
+
+    public Item getDropType(int i, Random random, int j) {
+        return Items.BREWING_STAND;
+    }
+
+    public boolean isComplexRedstone() {
+        return true;
+    }
+
+    public int g(World world, int i, int j, int k, int l) {
+        return Container.b((IInventory) world.getTileEntity(i, j, k));
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockFlowerPot.java b/src/main/java/net/minecraft/server/BlockFlowerPot.java
new file mode 100644
index 0000000..aa82a50
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockFlowerPot.java
@@ -0,0 +1,186 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class BlockFlowerPot extends BlockContainer {
+
+    public BlockFlowerPot() {
+        super(Material.ORIENTABLE);
+        this.g();
+    }
+
+    public void g() {
+        float f = 0.375F;
+        float f1 = f / 2.0F;
+
+        this.a(0.5F - f1, 0.0F, 0.5F - f1, 0.5F + f1, f, 0.5F + f1);
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public int b() {
+        return 33;
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public boolean interact(World world, int i, int j, int k, EntityHuman entityhuman, int l, float f, float f1, float f2) {
+        ItemStack itemstack = entityhuman.inventory.getItemInHand();
+
+        if (itemstack != null && itemstack.getItem() instanceof ItemBlock) {
+            TileEntityFlowerPot tileentityflowerpot = this.e(world, i, j, k);
+
+            if (tileentityflowerpot != null) {
+                if (tileentityflowerpot.a() != null) {
+                    return false;
+                } else {
+                    Block block = Block.a(itemstack.getItem());
+
+                    if (!this.a(block, itemstack.getData())) {
+                        return false;
+                    } else {
+                        tileentityflowerpot.a(itemstack.getItem(), itemstack.getData());
+                        tileentityflowerpot.update();
+                        if (!world.setData(i, j, k, itemstack.getData(), 2)) {
+                            world.notify(i, j, k);
+                        }
+
+                        if (!entityhuman.abilities.canInstantlyBuild && --itemstack.count <= 0) {
+                            entityhuman.inventory.setItem(entityhuman.inventory.itemInHandIndex, (ItemStack) null);
+                        }
+
+                        return true;
+                    }
+                }
+            } else {
+                return false;
+            }
+        } else {
+            return false;
+        }
+    }
+
+    private boolean a(Block block, int i) {
+        return block != Blocks.YELLOW_FLOWER && block != Blocks.RED_ROSE && block != Blocks.CACTUS && block != Blocks.BROWN_MUSHROOM && block != Blocks.RED_MUSHROOM && block != Blocks.SAPLING && block != Blocks.DEAD_BUSH ? block == Blocks.LONG_GRASS && i == 2 : true;
+    }
+
+    public int getDropData(World world, int i, int j, int k) {
+        TileEntityFlowerPot tileentityflowerpot = this.e(world, i, j, k);
+
+        return tileentityflowerpot != null && tileentityflowerpot.a() != null ? tileentityflowerpot.b() : 0;
+    }
+
+    public boolean canPlace(World world, int i, int j, int k) {
+        return super.canPlace(world, i, j, k) && World.a((IBlockAccess) world, i, j - 1, k);
+    }
+
+    public void doPhysics(World world, int i, int j, int k, Block block) {
+        if (!World.a((IBlockAccess) world, i, j - 1, k)) {
+            this.b(world, i, j, k, world.getData(i, j, k), 0);
+            world.setAir(i, j, k);
+        }
+    }
+
+    public void remove(World world, int i, int j, int k, Block block, int l) {
+        TileEntityFlowerPot tileentityflowerpot = this.e(world, i, j, k);
+
+        if (tileentityflowerpot != null && tileentityflowerpot.a() != null) {
+            this.a(world, i, j, k, new ItemStack(tileentityflowerpot.a(), 1, tileentityflowerpot.b()));
+        }
+
+        super.remove(world, i, j, k, block, l);
+    }
+
+    public void a(World world, int i, int j, int k, int l, EntityHuman entityhuman) {
+        super.a(world, i, j, k, l, entityhuman);
+        if (entityhuman.abilities.canInstantlyBuild) {
+            TileEntityFlowerPot tileentityflowerpot = this.e(world, i, j, k);
+
+            if (tileentityflowerpot != null) {
+                tileentityflowerpot.a(Item.getById(0), 0);
+            }
+        }
+    }
+
+    public Item getDropType(int i, Random random, int j) {
+        return Items.FLOWER_POT;
+    }
+
+    private TileEntityFlowerPot e(World world, int i, int j, int k) {
+        TileEntity tileentity = world.getTileEntity(i, j, k);
+
+        return tileentity != null && tileentity instanceof TileEntityFlowerPot ? (TileEntityFlowerPot) tileentity : null;
+    }
+
+    public TileEntity a(World world, int i) {
+        Object object = null;
+        byte b0 = 0;
+
+        switch (i) {
+        case 1:
+            object = Blocks.RED_ROSE;
+            b0 = 0;
+            break;
+
+        case 2:
+            object = Blocks.YELLOW_FLOWER;
+            break;
+
+        case 3:
+            object = Blocks.SAPLING;
+            b0 = 0;
+            break;
+
+        case 4:
+            object = Blocks.SAPLING;
+            b0 = 1;
+            break;
+
+        case 5:
+            object = Blocks.SAPLING;
+            b0 = 2;
+            break;
+
+        case 6:
+            object = Blocks.SAPLING;
+            b0 = 3;
+            break;
+
+        case 7:
+            object = Blocks.RED_MUSHROOM;
+            break;
+
+        case 8:
+            object = Blocks.BROWN_MUSHROOM;
+            break;
+
+        case 9:
+            object = Blocks.CACTUS;
+            break;
+
+        case 10:
+            object = Blocks.DEAD_BUSH;
+            break;
+
+        case 11:
+            object = Blocks.LONG_GRASS;
+            b0 = 2;
+            break;
+
+        case 12:
+            object = Blocks.SAPLING;
+            b0 = 4;
+            break;
+
+        case 13:
+            object = Blocks.SAPLING;
+            b0 = 5;
+        }
+
+        return new TileEntityFlowerPot(Item.getItemOf((Block) object), b0);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockTNT.java b/src/main/java/net/minecraft/server/BlockTNT.java
new file mode 100644
index 0000000..8cc7d5e
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockTNT.java
@@ -0,0 +1,80 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class BlockTNT extends Block {
+
+    public BlockTNT() {
+        super(Material.TNT);
+        this.a(CreativeModeTab.d);
+    }
+
+    public void onPlace(World world, int i, int j, int k) {
+        super.onPlace(world, i, j, k);
+        if (world.isBlockIndirectlyPowered(i, j, k)) {
+            this.postBreak(world, i, j, k, 1);
+            world.setAir(i, j, k);
+        }
+    }
+
+    public void doPhysics(World world, int i, int j, int k, Block block) {
+        if (world.isBlockIndirectlyPowered(i, j, k)) {
+            this.postBreak(world, i, j, k, 1);
+            world.setAir(i, j, k);
+        }
+    }
+
+    public int a(Random random) {
+        return 1;
+    }
+
+    public void wasExploded(World world, int i, int j, int k, Explosion explosion) {
+        if (!world.isStatic) {
+            EntityTNTPrimed entitytntprimed = new EntityTNTPrimed(world, (double) ((float) i + 0.5F), (double) ((float) j + 0.5F), (double) ((float) k + 0.5F), explosion.c());
+
+            entitytntprimed.fuseTicks = world.random.nextInt(entitytntprimed.fuseTicks / 4) + entitytntprimed.fuseTicks / 8;
+            world.addEntity(entitytntprimed);
+        }
+    }
+
+    public void postBreak(World world, int i, int j, int k, int l) {
+        this.a(world, i, j, k, l, (EntityLiving) null);
+    }
+
+    public void a(World world, int i, int j, int k, int l, EntityLiving entityliving) {
+        if (!world.isStatic) {
+            if ((l & 1) == 1) {
+                EntityTNTPrimed entitytntprimed = new EntityTNTPrimed(world, (double) ((float) i + 0.5F), (double) ((float) j + 0.5F), (double) ((float) k + 0.5F), entityliving);
+
+                world.addEntity(entitytntprimed);
+                world.makeSound(entitytntprimed, "game.tnt.primed", 1.0F, 1.0F);
+            }
+        }
+    }
+
+    public boolean interact(World world, int i, int j, int k, EntityHuman entityhuman, int l, float f, float f1, float f2) {
+        if (entityhuman.bF() != null && entityhuman.bF().getItem() == Items.FLINT_AND_STEEL) {
+            this.a(world, i, j, k, 1, entityhuman);
+            world.setAir(i, j, k);
+            entityhuman.bF().damage(1, entityhuman);
+            return true;
+        } else {
+            return super.interact(world, i, j, k, entityhuman, l, f, f1, f2);
+        }
+    }
+
+    public void a(World world, int i, int j, int k, Entity entity) {
+        if (entity instanceof EntityArrow && !world.isStatic) {
+            EntityArrow entityarrow = (EntityArrow) entity;
+
+            if (entityarrow.isBurning()) {
+                this.a(world, i, j, k, 1, entityarrow.shooter instanceof EntityLiving ? (EntityLiving) entityarrow.shooter : null);
+                world.setAir(i, j, k);
+            }
+        }
+    }
+
+    public boolean a(Explosion explosion) {
+        return false;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/CommandDispatcher.java b/src/main/java/net/minecraft/server/CommandDispatcher.java
new file mode 100644
index 0000000..0644276
--- /dev/null
+++ b/src/main/java/net/minecraft/server/CommandDispatcher.java
@@ -0,0 +1,94 @@
+package net.minecraft.server;
+
+import java.util.Iterator;
+
+public class CommandDispatcher extends CommandHandler implements ICommandDispatcher {
+
+    public CommandDispatcher() {
+        this.a(new CommandTime());
+        this.a(new CommandGamemode());
+        this.a(new CommandDifficulty());
+        this.a(new CommandGamemodeDefault());
+        this.a(new CommandKill());
+        this.a(new CommandToggleDownfall());
+        this.a(new CommandWeather());
+        this.a(new CommandXp());
+        this.a(new CommandTp());
+        this.a(new CommandGive());
+        this.a(new CommandEffect());
+        this.a(new CommandEnchant());
+        this.a(new CommandMe());
+        this.a(new CommandSeed());
+        this.a(new CommandHelp());
+        this.a(new CommandDebug());
+        this.a(new CommandTell());
+        this.a(new CommandSay());
+        this.a(new CommandSpawnpoint());
+        this.a(new CommandSetWorldSpawn());
+        this.a(new CommandGamerule());
+        this.a(new CommandClear());
+        this.a(new CommandTestFor());
+        this.a(new CommandSpreadPlayers());
+        this.a(new CommandPlaySound());
+        this.a(new CommandScoreboard());
+        this.a(new CommandAchievement());
+        this.a(new CommandSummon());
+        this.a(new CommandSetBlock());
+        this.a(new CommandTestForBlock());
+        this.a(new CommandTellRaw());
+        if (MinecraftServer.getServer().X()) {
+            this.a(new CommandOp());
+            this.a(new CommandDeop());
+            this.a(new CommandStop());
+            this.a(new CommandSaveAll());
+            this.a(new CommandSaveOff());
+            this.a(new CommandSaveOn());
+            this.a(new CommandBanIp());
+            this.a(new CommandPardonIP());
+            this.a(new CommandBan());
+            this.a(new CommandBanList());
+            this.a(new CommandPardon());
+            this.a(new CommandKick());
+            this.a(new CommandList());
+            this.a(new CommandWhitelist());
+            this.a(new CommandIdleTimeout());
+            this.a(new CommandNetstat());
+        } else {
+            this.a(new CommandPublish());
+        }
+
+        CommandAbstract.a((ICommandDispatcher) this);
+    }
+
+    public void a(ICommandListener icommandlistener, ICommand icommand, int i, String s, Object... aobject) {
+        boolean flag = true;
+
+        if (icommandlistener instanceof CommandBlockListenerAbstract && !MinecraftServer.getServer().worldServer[0].getGameRules().getBoolean("commandBlockOutput")) {
+            flag = false;
+        }
+
+        ChatMessage chatmessage = new ChatMessage("chat.type.admin", new Object[] { icommandlistener.getName(), new ChatMessage(s, aobject)});
+
+        chatmessage.getChatModifier().setColor(EnumChatFormat.GRAY);
+        chatmessage.getChatModifier().setItalic(Boolean.valueOf(true));
+        if (flag) {
+            Iterator iterator = MinecraftServer.getServer().getPlayerList().players.iterator();
+
+            while (iterator.hasNext()) {
+                EntityHuman entityhuman = (EntityHuman) iterator.next();
+
+                if (entityhuman != icommandlistener && MinecraftServer.getServer().getPlayerList().isOp(entityhuman.getProfile()) && icommand.canUse(entityhuman) && (!(icommandlistener instanceof RemoteControlCommandListener) || MinecraftServer.getServer().m())) {
+                    entityhuman.sendMessage(chatmessage);
+                }
+            }
+        }
+
+        if (icommandlistener != MinecraftServer.getServer()) {
+            MinecraftServer.getServer().sendMessage(chatmessage);
+        }
+
+        if ((i & 1) != 1) {
+            icommandlistener.sendMessage(new ChatMessage(s, aobject));
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/DataWatcher.java b/src/main/java/net/minecraft/server/DataWatcher.java
new file mode 100644
index 0000000..2d1da33
--- /dev/null
+++ b/src/main/java/net/minecraft/server/DataWatcher.java
@@ -0,0 +1,306 @@
+package net.minecraft.server;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import net.minecraft.util.org.apache.commons.lang3.ObjectUtils;
+
+public class DataWatcher {
+
+    private final Entity a;
+    private boolean b = true;
+    private static final HashMap c = new HashMap();
+    private final Map d = new HashMap();
+    private boolean e;
+    private ReadWriteLock f = new ReentrantReadWriteLock();
+
+    public DataWatcher(Entity entity) {
+        this.a = entity;
+    }
+
+    public void a(int i, Object object) {
+        Integer integer = (Integer) c.get(object.getClass());
+
+        if (integer == null) {
+            throw new IllegalArgumentException("Unknown data type: " + object.getClass());
+        } else if (i > 31) {
+            throw new IllegalArgumentException("Data value id is too big with " + i + "! (Max is " + 31 + ")");
+        } else if (this.d.containsKey(Integer.valueOf(i))) {
+            throw new IllegalArgumentException("Duplicate id value for " + i + "!");
+        } else {
+            WatchableObject watchableobject = new WatchableObject(integer.intValue(), i, object);
+
+            this.f.writeLock().lock();
+            this.d.put(Integer.valueOf(i), watchableobject);
+            this.f.writeLock().unlock();
+            this.b = false;
+        }
+    }
+
+    public void add(int i, int j) {
+        WatchableObject watchableobject = new WatchableObject(j, i, null);
+
+        this.f.writeLock().lock();
+        this.d.put(Integer.valueOf(i), watchableobject);
+        this.f.writeLock().unlock();
+        this.b = false;
+    }
+
+    public byte getByte(int i) {
+        return ((Byte) this.i(i).b()).byteValue();
+    }
+
+    public short getShort(int i) {
+        return ((Short) this.i(i).b()).shortValue();
+    }
+
+    public int getInt(int i) {
+        return ((Integer) this.i(i).b()).intValue();
+    }
+
+    public float getFloat(int i) {
+        return ((Float) this.i(i).b()).floatValue();
+    }
+
+    public String getString(int i) {
+        return (String) this.i(i).b();
+    }
+
+    public ItemStack getItemStack(int i) {
+        return (ItemStack) this.i(i).b();
+    }
+
+    private WatchableObject i(int i) {
+        this.f.readLock().lock();
+
+        WatchableObject watchableobject;
+
+        try {
+            watchableobject = (WatchableObject) this.d.get(Integer.valueOf(i));
+        } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.a(throwable, "Getting synched entity data");
+            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Synched entity data");
+
+            crashreportsystemdetails.a("Data ID", Integer.valueOf(i));
+            throw new ReportedException(crashreport);
+        }
+
+        this.f.readLock().unlock();
+        return watchableobject;
+    }
+
+    public void watch(int i, Object object) {
+        WatchableObject watchableobject = this.i(i);
+
+        if (ObjectUtils.notEqual(object, watchableobject.b())) {
+            watchableobject.a(object);
+            this.a.i(i);
+            watchableobject.a(true);
+            this.e = true;
+        }
+    }
+
+    public void update(int i) {
+        WatchableObject.a(this.i(i), true);
+        this.e = true;
+    }
+
+    public boolean a() {
+        return this.e;
+    }
+
+    public static void a(List list, PacketDataSerializer packetdataserializer) {
+        if (list != null) {
+            Iterator iterator = list.iterator();
+
+            while (iterator.hasNext()) {
+                WatchableObject watchableobject = (WatchableObject) iterator.next();
+
+                a(packetdataserializer, watchableobject);
+            }
+        }
+
+        packetdataserializer.writeByte(127);
+    }
+
+    public List b() {
+        ArrayList arraylist = null;
+
+        if (this.e) {
+            this.f.readLock().lock();
+            Iterator iterator = this.d.values().iterator();
+
+            while (iterator.hasNext()) {
+                WatchableObject watchableobject = (WatchableObject) iterator.next();
+
+                if (watchableobject.d()) {
+                    watchableobject.a(false);
+                    if (arraylist == null) {
+                        arraylist = new ArrayList();
+                    }
+
+                    arraylist.add(watchableobject);
+                }
+            }
+
+            this.f.readLock().unlock();
+        }
+
+        this.e = false;
+        return arraylist;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.f.readLock().lock();
+        Iterator iterator = this.d.values().iterator();
+
+        while (iterator.hasNext()) {
+            WatchableObject watchableobject = (WatchableObject) iterator.next();
+
+            a(packetdataserializer, watchableobject);
+        }
+
+        this.f.readLock().unlock();
+        packetdataserializer.writeByte(127);
+    }
+
+    public List c() {
+        ArrayList arraylist = null;
+
+        this.f.readLock().lock();
+
+        WatchableObject watchableobject;
+
+        for (Iterator iterator = this.d.values().iterator(); iterator.hasNext(); arraylist.add(watchableobject)) {
+            watchableobject = (WatchableObject) iterator.next();
+            if (arraylist == null) {
+                arraylist = new ArrayList();
+            }
+        }
+
+        this.f.readLock().unlock();
+        return arraylist;
+    }
+
+    private static void a(PacketDataSerializer packetdataserializer, WatchableObject watchableobject) {
+        int i = (watchableobject.c() << 5 | watchableobject.a() & 31) & 255;
+
+        packetdataserializer.writeByte(i);
+        switch (watchableobject.c()) {
+        case 0:
+            packetdataserializer.writeByte(((Byte) watchableobject.b()).byteValue());
+            break;
+
+        case 1:
+            packetdataserializer.writeShort(((Short) watchableobject.b()).shortValue());
+            break;
+
+        case 2:
+            packetdataserializer.writeInt(((Integer) watchableobject.b()).intValue());
+            break;
+
+        case 3:
+            packetdataserializer.writeFloat(((Float) watchableobject.b()).floatValue());
+            break;
+
+        case 4:
+            try {
+                packetdataserializer.a((String) watchableobject.b());
+            } catch (java.io.IOException ex) {
+                throw new RuntimeException(ex);
+            }
+            break;
+
+        case 5:
+            ItemStack itemstack = (ItemStack) watchableobject.b();
+
+            packetdataserializer.a(itemstack);
+            break;
+
+        case 6:
+            ChunkCoordinates chunkcoordinates = (ChunkCoordinates) watchableobject.b();
+
+            packetdataserializer.writeInt(chunkcoordinates.x);
+            packetdataserializer.writeInt(chunkcoordinates.y);
+            packetdataserializer.writeInt(chunkcoordinates.z);
+        }
+    }
+
+    public static List b(PacketDataSerializer packetdataserializer) {
+        ArrayList arraylist = null;
+
+        for (byte b0 = packetdataserializer.readByte(); b0 != 127; b0 = packetdataserializer.readByte()) {
+            if (arraylist == null) {
+                arraylist = new ArrayList();
+            }
+
+            int i = (b0 & 224) >> 5;
+            int j = b0 & 31;
+            WatchableObject watchableobject = null;
+
+            switch (i) {
+            case 0:
+                watchableobject = new WatchableObject(i, j, Byte.valueOf(packetdataserializer.readByte()));
+                break;
+
+            case 1:
+                watchableobject = new WatchableObject(i, j, Short.valueOf(packetdataserializer.readShort()));
+                break;
+
+            case 2:
+                watchableobject = new WatchableObject(i, j, Integer.valueOf(packetdataserializer.readInt()));
+                break;
+
+            case 3:
+                watchableobject = new WatchableObject(i, j, Float.valueOf(packetdataserializer.readFloat()));
+                break;
+
+            case 4:
+                try {
+                    watchableobject = new WatchableObject(i, j, packetdataserializer.c(32767));
+                } catch (java.io.IOException ex) {
+                    throw new RuntimeException(ex);
+                }
+                break;
+
+            case 5:
+                watchableobject = new WatchableObject(i, j, packetdataserializer.c());
+                break;
+
+            case 6:
+                int k = packetdataserializer.readInt();
+                int l = packetdataserializer.readInt();
+                int i1 = packetdataserializer.readInt();
+
+                watchableobject = new WatchableObject(i, j, new ChunkCoordinates(k, l, i1));
+            }
+
+            arraylist.add(watchableobject);
+        }
+
+        return arraylist;
+    }
+
+    public boolean d() {
+        return this.b;
+    }
+
+    public void e() {
+        this.e = false;
+    }
+
+    static {
+        c.put(Byte.class, Integer.valueOf(0));
+        c.put(Short.class, Integer.valueOf(1));
+        c.put(Integer.class, Integer.valueOf(2));
+        c.put(Float.class, Integer.valueOf(3));
+        c.put(String.class, Integer.valueOf(4));
+        c.put(ItemStack.class, Integer.valueOf(5));
+        c.put(ChunkCoordinates.class, Integer.valueOf(6));
+    }
+}
diff --git a/src/main/java/net/minecraft/server/GameProfileBanEntry.java b/src/main/java/net/minecraft/server/GameProfileBanEntry.java
new file mode 100644
index 0000000..2943244
--- /dev/null
+++ b/src/main/java/net/minecraft/server/GameProfileBanEntry.java
@@ -0,0 +1,48 @@
+package net.minecraft.server;
+
+import java.util.Date;
+import java.util.UUID;
+
+import net.minecraft.util.com.google.gson.JsonObject;
+import net.minecraft.util.com.mojang.authlib.GameProfile;
+
+public class GameProfileBanEntry extends ExpirableListEntry {
+
+    public GameProfileBanEntry(GameProfile gameprofile) {
+        this(gameprofile, (Date) null, (String) null, (Date) null, (String) null);
+    }
+
+    public GameProfileBanEntry(GameProfile gameprofile, Date date, String s, Date date1, String s1) {
+        super(gameprofile, date1, s, date1, s1);
+    }
+
+    public GameProfileBanEntry(JsonObject jsonobject) {
+        super(b(jsonobject), jsonobject);
+    }
+
+    protected void a(JsonObject jsonobject) {
+        if (this.getKey() != null) {
+            jsonobject.addProperty("uuid", ((GameProfile) this.getKey()).getId() == null ? "" : ((GameProfile) this.getKey()).getId().toString());
+            jsonobject.addProperty("name", ((GameProfile) this.getKey()).getName());
+            super.a(jsonobject);
+        }
+    }
+
+    private static GameProfile b(JsonObject jsonobject) {
+        if (jsonobject.has("uuid") && jsonobject.has("name")) {
+            String s = jsonobject.get("uuid").getAsString();
+
+            UUID uuid;
+
+            try {
+                uuid = UUID.fromString(s);
+            } catch (Throwable throwable) {
+                return null;
+            }
+
+            return new GameProfile(uuid, jsonobject.get("name").getAsString());
+        } else {
+            return null;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/GenericAttributes.java b/src/main/java/net/minecraft/server/GenericAttributes.java
new file mode 100644
index 0000000..6202bba
--- /dev/null
+++ b/src/main/java/net/minecraft/server/GenericAttributes.java
@@ -0,0 +1,105 @@
+package net.minecraft.server;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.UUID;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class GenericAttributes {
+
+    private static final Logger f = LogManager.getLogger();
+    public static final IAttribute maxHealth = (new AttributeRanged("generic.maxHealth", 20.0D, 0.0D, Double.MAX_VALUE)).a("Max Health").a(true);
+    public static final IAttribute b = (new AttributeRanged("generic.followRange", 32.0D, 0.0D, 2048.0D)).a("Follow Range");
+    public static final IAttribute c = (new AttributeRanged("generic.knockbackResistance", 0.0D, 0.0D, 1.0D)).a("Knockback Resistance");
+    public static final IAttribute d = (new AttributeRanged("generic.movementSpeed", 0.699999988079071D, 0.0D, Double.MAX_VALUE)).a("Movement Speed").a(true);
+    public static final IAttribute e = new AttributeRanged("generic.attackDamage", 2.0D, 0.0D, Double.MAX_VALUE);
+
+    public static NBTTagList a(AttributeMapBase attributemapbase) {
+        NBTTagList nbttaglist = new NBTTagList();
+        Iterator iterator = attributemapbase.a().iterator();
+
+        while (iterator.hasNext()) {
+            AttributeInstance attributeinstance = (AttributeInstance) iterator.next();
+
+            nbttaglist.add(a(attributeinstance));
+        }
+
+        return nbttaglist;
+    }
+
+    private static NBTTagCompound a(AttributeInstance attributeinstance) {
+        NBTTagCompound nbttagcompound = new NBTTagCompound();
+        IAttribute iattribute = attributeinstance.getAttribute();
+
+        nbttagcompound.setString("Name", iattribute.getName());
+        nbttagcompound.setDouble("Base", attributeinstance.b());
+        Collection collection = attributeinstance.c();
+
+        if (collection != null && !collection.isEmpty()) {
+            NBTTagList nbttaglist = new NBTTagList();
+            Iterator iterator = collection.iterator();
+
+            while (iterator.hasNext()) {
+                AttributeModifier attributemodifier = (AttributeModifier) iterator.next();
+
+                if (attributemodifier.e()) {
+                    nbttaglist.add(a(attributemodifier));
+                }
+            }
+
+            nbttagcompound.set("Modifiers", nbttaglist);
+        }
+
+        return nbttagcompound;
+    }
+
+    private static NBTTagCompound a(AttributeModifier attributemodifier) {
+        NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+        nbttagcompound.setString("Name", attributemodifier.b());
+        nbttagcompound.setDouble("Amount", attributemodifier.d());
+        nbttagcompound.setInt("Operation", attributemodifier.c());
+        nbttagcompound.setLong("UUIDMost", attributemodifier.a().getMostSignificantBits());
+        nbttagcompound.setLong("UUIDLeast", attributemodifier.a().getLeastSignificantBits());
+        return nbttagcompound;
+    }
+
+    public static void a(AttributeMapBase attributemapbase, NBTTagList nbttaglist) {
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            NBTTagCompound nbttagcompound = nbttaglist.get(i);
+            AttributeInstance attributeinstance = attributemapbase.a(nbttagcompound.getString("Name"));
+
+            if (attributeinstance != null) {
+                a(attributeinstance, nbttagcompound);
+            } else {
+                f.warn("Ignoring unknown attribute \'" + nbttagcompound.getString("Name") + "\'");
+            }
+        }
+    }
+
+    private static void a(AttributeInstance attributeinstance, NBTTagCompound nbttagcompound) {
+        attributeinstance.setValue(nbttagcompound.getDouble("Base"));
+        if (nbttagcompound.hasKeyOfType("Modifiers", 9)) {
+            NBTTagList nbttaglist = nbttagcompound.getList("Modifiers", 10);
+
+            for (int i = 0; i < nbttaglist.size(); ++i) {
+                AttributeModifier attributemodifier = a(nbttaglist.get(i));
+                AttributeModifier attributemodifier1 = attributeinstance.a(attributemodifier.a());
+
+                if (attributemodifier1 != null) {
+                    attributeinstance.b(attributemodifier1);
+                }
+
+                attributeinstance.a(attributemodifier);
+            }
+        }
+    }
+
+    public static AttributeModifier a(NBTTagCompound nbttagcompound) {
+        UUID uuid = new UUID(nbttagcompound.getLong("UUIDMost"), nbttagcompound.getLong("UUIDLeast"));
+
+        return new AttributeModifier(uuid, nbttagcompound.getString("Name"), nbttagcompound.getDouble("Amount"), nbttagcompound.getInt("Operation"));
+    }
+}
diff --git a/src/main/java/net/minecraft/server/IntCache.java b/src/main/java/net/minecraft/server/IntCache.java
new file mode 100644
index 0000000..9858720
--- /dev/null
+++ b/src/main/java/net/minecraft/server/IntCache.java
@@ -0,0 +1,63 @@
+package net.minecraft.server;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class IntCache {
+
+    private static int a = 256;
+    private static List b = new ArrayList();
+    private static List c = new ArrayList();
+    private static List d = new ArrayList();
+    private static List e = new ArrayList();
+
+    public static synchronized int[] a(int i) {
+        int[] aint;
+
+        if (i <= 256) {
+            if (b.isEmpty()) {
+                aint = new int[256];
+                c.add(aint);
+                return aint;
+            } else {
+                aint = (int[]) b.remove(b.size() - 1);
+                c.add(aint);
+                return aint;
+            }
+        } else if (i > a) {
+            a = i;
+            d.clear();
+            e.clear();
+            aint = new int[a];
+            e.add(aint);
+            return aint;
+        } else if (d.isEmpty()) {
+            aint = new int[a];
+            e.add(aint);
+            return aint;
+        } else {
+            aint = (int[]) d.remove(d.size() - 1);
+            e.add(aint);
+            return aint;
+        }
+    }
+
+    public static synchronized void a() {
+        if (!d.isEmpty()) {
+            d.remove(d.size() - 1);
+        }
+
+        if (!b.isEmpty()) {
+            b.remove(b.size() - 1);
+        }
+
+        d.addAll(e);
+        b.addAll(c);
+        e.clear();
+        c.clear();
+    }
+
+    public static synchronized String b() {
+        return "cache: " + d.size() + ", tcache: " + b.size() + ", allocated: " + e.size() + ", tallocated: " + c.size();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ItemSkull.java b/src/main/java/net/minecraft/server/ItemSkull.java
new file mode 100644
index 0000000..4a40068
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemSkull.java
@@ -0,0 +1,111 @@
+package net.minecraft.server;
+
+import java.util.UUID;
+
+import net.minecraft.util.com.mojang.authlib.GameProfile;
+
+public class ItemSkull extends Item {
+
+    private static final String[] b = new String[] { "skeleton", "wither", "zombie", "char", "creeper"};
+    public static final String[] a = new String[] { "skeleton", "wither", "zombie", "steve", "creeper"};
+
+    public ItemSkull() {
+        this.a(CreativeModeTab.c);
+        this.setMaxDurability(0);
+        this.a(true);
+    }
+
+    public boolean interactWith(ItemStack itemstack, EntityHuman entityhuman, World world, int i, int j, int k, int l, float f, float f1, float f2) {
+        if (l == 0) {
+            return false;
+        } else if (!world.getType(i, j, k).getMaterial().isBuildable()) {
+            return false;
+        } else {
+            if (l == 1) {
+                ++j;
+            }
+
+            if (l == 2) {
+                --k;
+            }
+
+            if (l == 3) {
+                ++k;
+            }
+
+            if (l == 4) {
+                --i;
+            }
+
+            if (l == 5) {
+                ++i;
+            }
+
+            if (!world.isStatic) {
+                world.setTypeAndData(i, j, k, Blocks.SKULL, l, 2);
+                int i1 = 0;
+
+                if (l == 1) {
+                    i1 = MathHelper.floor((double) (entityhuman.yaw * 16.0F / 360.0F) + 0.5D) & 15;
+                }
+
+                TileEntity tileentity = world.getTileEntity(i, j, k);
+
+                if (tileentity != null && tileentity instanceof TileEntitySkull) {
+                    if (itemstack.getData() == 3) {
+                        GameProfile gameprofile = null;
+
+                        if (itemstack.hasTag()) {
+                            NBTTagCompound nbttagcompound = itemstack.getTag();
+
+                            if (nbttagcompound.hasKeyOfType("SkullOwner", 10)) {
+                                gameprofile = GameProfileSerializer.deserialize(nbttagcompound.getCompound("SkullOwner"));
+                            } else if (nbttagcompound.hasKeyOfType("SkullOwner", 8) && nbttagcompound.getString("SkullOwner").length() > 0) {
+                                gameprofile = new GameProfile((UUID) null, nbttagcompound.getString("SkullOwner"));
+                            }
+                        }
+
+                        ((TileEntitySkull) tileentity).setGameProfile(gameprofile);
+                    } else {
+                        ((TileEntitySkull) tileentity).setSkullType(itemstack.getData());
+                    }
+
+                    ((TileEntitySkull) tileentity).setRotation(i1);
+                    ((BlockSkull) Blocks.SKULL).a(world, i, j, k, (TileEntitySkull) tileentity);
+                }
+
+                --itemstack.count;
+            }
+
+            return true;
+        }
+    }
+
+    public int filterData(int i) {
+        return i;
+    }
+
+    public String a(ItemStack itemstack) {
+        int i = itemstack.getData();
+
+        if (i < 0 || i >= b.length) {
+            i = 0;
+        }
+
+        return super.getName() + "." + b[i];
+    }
+
+    public String n(ItemStack itemstack) {
+        if (itemstack.getData() == 3 && itemstack.hasTag()) {
+            if (itemstack.getTag().hasKeyOfType("SkullOwner", 10)) {
+                return LocaleI18n.get("item.skull.player.name", new Object[] { GameProfileSerializer.deserialize(itemstack.getTag().getCompound("SkullOwner")).getName()});
+            }
+
+            if (itemstack.getTag().hasKeyOfType("SkullOwner", 8)) {
+                return LocaleI18n.get("item.skull.player.name", new Object[] { itemstack.getTag().getString("SkullOwner")});
+            }
+        }
+
+        return super.n(itemstack);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NBTBase.java b/src/main/java/net/minecraft/server/NBTBase.java
new file mode 100644
index 0000000..af13af5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NBTBase.java
@@ -0,0 +1,83 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public abstract class NBTBase {
+
+    public static final String[] a = new String[] { "END", "BYTE", "SHORT", "INT", "LONG", "FLOAT", "DOUBLE", "BYTE[]", "STRING", "LIST", "COMPOUND", "INT[]"};
+
+    abstract void write(DataOutput dataoutput) throws IOException;
+
+    abstract void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException;
+
+    public abstract String toString();
+
+    public abstract byte getTypeId();
+
+    protected NBTBase() {}
+
+    protected static NBTBase createTag(byte b0) {
+        switch (b0) {
+        case 0:
+            return new NBTTagEnd();
+
+        case 1:
+            return new NBTTagByte();
+
+        case 2:
+            return new NBTTagShort();
+
+        case 3:
+            return new NBTTagInt();
+
+        case 4:
+            return new NBTTagLong();
+
+        case 5:
+            return new NBTTagFloat();
+
+        case 6:
+            return new NBTTagDouble();
+
+        case 7:
+            return new NBTTagByteArray();
+
+        case 8:
+            return new NBTTagString();
+
+        case 9:
+            return new NBTTagList();
+
+        case 10:
+            return new NBTTagCompound();
+
+        case 11:
+            return new NBTTagIntArray();
+
+        default:
+            return null;
+        }
+    }
+
+    public abstract NBTBase clone();
+
+    public boolean equals(Object object) {
+        if (!(object instanceof NBTBase)) {
+            return false;
+        } else {
+            NBTBase nbtbase = (NBTBase) object;
+
+            return this.getTypeId() == nbtbase.getTypeId();
+        }
+    }
+
+    public int hashCode() {
+        return this.getTypeId();
+    }
+
+    protected String a_() {
+        return this.toString();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NBTCompressedStreamTools.java b/src/main/java/net/minecraft/server/NBTCompressedStreamTools.java
new file mode 100644
index 0000000..20fe0f1
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NBTCompressedStreamTools.java
@@ -0,0 +1,132 @@
+package net.minecraft.server;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInput;
+import java.io.DataInputStream;
+import java.io.DataOutput;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.GZIPOutputStream;
+
+public class NBTCompressedStreamTools {
+
+    public static NBTTagCompound a(InputStream inputstream) {
+        try {
+        DataInputStream datainputstream = new DataInputStream(new BufferedInputStream(new GZIPInputStream(inputstream)));
+
+        NBTTagCompound nbttagcompound;
+
+        try {
+            nbttagcompound = a((DataInput) datainputstream, NBTReadLimiter.a);
+        } finally {
+            datainputstream.close();
+        }
+
+        return nbttagcompound;
+        } catch (IOException ex) { org.spigotmc.SneakyThrow.sneaky( ex ); } return null;
+    }
+
+    public static void a(NBTTagCompound nbttagcompound, OutputStream outputstream) {
+        try {
+        DataOutputStream dataoutputstream = new DataOutputStream(new BufferedOutputStream(new GZIPOutputStream(outputstream)));
+
+        try {
+            a(nbttagcompound, (DataOutput) dataoutputstream);
+        } finally {
+            dataoutputstream.close();
+        }
+        } catch (IOException ex) { org.spigotmc.SneakyThrow.sneaky( ex ); }
+    }
+
+    public static NBTTagCompound a(byte[] abyte, NBTReadLimiter nbtreadlimiter) {
+        try {
+        DataInputStream datainputstream = new DataInputStream(new BufferedInputStream(new GZIPInputStream(new ByteArrayInputStream(abyte))));
+
+        NBTTagCompound nbttagcompound;
+
+        try {
+            nbttagcompound = a((DataInput) datainputstream, nbtreadlimiter);
+        } finally {
+            datainputstream.close();
+        }
+
+        return nbttagcompound;
+        } catch (IOException ex) { org.spigotmc.SneakyThrow.sneaky( ex ); } return null;
+    }
+
+    public static byte[] a(NBTTagCompound nbttagcompound) {
+        try {
+        ByteArrayOutputStream bytearrayoutputstream = new ByteArrayOutputStream();
+        DataOutputStream dataoutputstream = new DataOutputStream(new GZIPOutputStream(bytearrayoutputstream));
+
+        try {
+            a(nbttagcompound, (DataOutput) dataoutputstream);
+        } finally {
+            dataoutputstream.close();
+        }
+
+        return bytearrayoutputstream.toByteArray();
+        } catch (IOException ex) { org.spigotmc.SneakyThrow.sneaky( ex ); } return null;
+    }
+
+    public static NBTTagCompound a(DataInputStream datainputstream) {
+        return a((DataInput) datainputstream, NBTReadLimiter.a);
+    }
+
+    public static NBTTagCompound a(DataInput datainput, NBTReadLimiter nbtreadlimiter) {
+        try {
+        NBTBase nbtbase = a(datainput, 0, nbtreadlimiter);
+
+        if (nbtbase instanceof NBTTagCompound) {
+            return (NBTTagCompound) nbtbase;
+        } else {
+            throw new IOException("Root tag must be a named compound tag");
+        }
+        } catch (IOException ex) { org.spigotmc.SneakyThrow.sneaky( ex ); } return null;
+    }
+
+    public static void a(NBTTagCompound nbttagcompound, DataOutput dataoutput) {
+        a((NBTBase) nbttagcompound, dataoutput);
+    }
+
+    private static void a(NBTBase nbtbase, DataOutput dataoutput) {
+        try {
+        dataoutput.writeByte(nbtbase.getTypeId());
+        if (nbtbase.getTypeId() != 0) {
+            dataoutput.writeUTF("");
+            nbtbase.write(dataoutput);
+        }
+        } catch (IOException ex) { org.spigotmc.SneakyThrow.sneaky( ex ); }
+    }
+
+    private static NBTBase a(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+        try {
+        byte b0 = datainput.readByte();
+
+        if (b0 == 0) {
+            return new NBTTagEnd();
+        } else {
+            datainput.readUTF();
+            NBTBase nbtbase = NBTBase.createTag(b0);
+
+            try {
+                nbtbase.load(datainput, i, nbtreadlimiter);
+                return nbtbase;
+            } catch (IOException ioexception) {
+                CrashReport crashreport = CrashReport.a(ioexception, "Loading NBT data");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("NBT Tag");
+
+                crashreportsystemdetails.a("Tag name", "[UNNAMED TAG]");
+                crashreportsystemdetails.a("Tag type", Byte.valueOf(b0));
+                throw new ReportedException(crashreport);
+            }
+        }
+        } catch (IOException ex) { org.spigotmc.SneakyThrow.sneaky( ex ); } return null;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NBTTagByteArray.java b/src/main/java/net/minecraft/server/NBTTagByteArray.java
new file mode 100644
index 0000000..3eeed3e
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NBTTagByteArray.java
@@ -0,0 +1,57 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.Arrays;
+
+public class NBTTagByteArray extends NBTBase {
+
+    private byte[] data;
+
+    NBTTagByteArray() {}
+
+    public NBTTagByteArray(byte[] abyte) {
+        this.data = abyte;
+    }
+
+    void write(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.data.length);
+        dataoutput.write(this.data);
+    }
+
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+        int j = datainput.readInt();
+
+        nbtreadlimiter.a((long) (8 * j));
+        this.data = new byte[j];
+        datainput.readFully(this.data);
+    }
+
+    public byte getTypeId() {
+        return (byte) 7;
+    }
+
+    public String toString() {
+        return "[" + this.data.length + " bytes]";
+    }
+
+    public NBTBase clone() {
+        byte[] abyte = new byte[this.data.length];
+
+        System.arraycopy(this.data, 0, abyte, 0, this.data.length);
+        return new NBTTagByteArray(abyte);
+    }
+
+    public boolean equals(Object object) {
+        return super.equals(object) ? Arrays.equals(this.data, ((NBTTagByteArray) object).data) : false;
+    }
+
+    public int hashCode() {
+        return super.hashCode() ^ Arrays.hashCode(this.data);
+    }
+
+    public byte[] c() {
+        return this.data;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NBTTagIntArray.java b/src/main/java/net/minecraft/server/NBTTagIntArray.java
new file mode 100644
index 0000000..c7cea7f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NBTTagIntArray.java
@@ -0,0 +1,73 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.Arrays;
+
+public class NBTTagIntArray extends NBTBase {
+
+    private int[] data;
+
+    NBTTagIntArray() {}
+
+    public NBTTagIntArray(int[] aint) {
+        this.data = aint;
+    }
+
+    void write(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.data.length);
+
+        for (int i = 0; i < this.data.length; ++i) {
+            dataoutput.writeInt(this.data[i]);
+        }
+    }
+
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+        int j = datainput.readInt();
+
+        nbtreadlimiter.a((long) (32 * j));
+        this.data = new int[j];
+
+        for (int k = 0; k < j; ++k) {
+            this.data[k] = datainput.readInt();
+        }
+    }
+
+    public byte getTypeId() {
+        return (byte) 11;
+    }
+
+    public String toString() {
+        String s = "[";
+        int[] aint = this.data;
+        int i = aint.length;
+
+        for (int j = 0; j < i; ++j) {
+            int k = aint[j];
+
+            s = s + k + ",";
+        }
+
+        return s + "]";
+    }
+
+    public NBTBase clone() {
+        int[] aint = new int[this.data.length];
+
+        System.arraycopy(this.data, 0, aint, 0, this.data.length);
+        return new NBTTagIntArray(aint);
+    }
+
+    public boolean equals(Object object) {
+        return super.equals(object) ? Arrays.equals(this.data, ((NBTTagIntArray) object).data) : false;
+    }
+
+    public int hashCode() {
+        return super.hashCode() ^ Arrays.hashCode(this.data);
+    }
+
+    public int[] c() {
+        return this.data;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NextTickListEntry.java b/src/main/java/net/minecraft/server/NextTickListEntry.java
new file mode 100644
index 0000000..cbb3576
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NextTickListEntry.java
@@ -0,0 +1,60 @@
+package net.minecraft.server;
+
+public class NextTickListEntry implements Comparable {
+
+    private static long f;
+    private final Block g;
+    public int a;
+    public int b;
+    public int c;
+    public long d;
+    public int e;
+    private long h;
+
+    public NextTickListEntry(int i, int j, int k, Block block) {
+        this.h = (long) (f++);
+        this.a = i;
+        this.b = j;
+        this.c = k;
+        this.g = block;
+    }
+
+    public boolean equals(Object object) {
+        if (!(object instanceof NextTickListEntry)) {
+            return false;
+        } else {
+            NextTickListEntry nextticklistentry = (NextTickListEntry) object;
+
+            return this.a == nextticklistentry.a && this.b == nextticklistentry.b && this.c == nextticklistentry.c && Block.a(this.g, nextticklistentry.g);
+        }
+    }
+
+    public int hashCode() {
+        return (this.a * 1024 * 1024 + this.c * 1024 + this.b) * 256;
+    }
+
+    public NextTickListEntry a(long i) {
+        this.d = i;
+        return this;
+    }
+
+    public void a(int i) {
+        this.e = i;
+    }
+
+    public int compareTo(NextTickListEntry nextticklistentry) {
+        return this.d < nextticklistentry.d ? -1 : (this.d > nextticklistentry.d ? 1 : (this.e != nextticklistentry.e ? this.e - nextticklistentry.e : (this.h < nextticklistentry.h ? -1 : (this.h > nextticklistentry.h ? 1 : 0))));
+    }
+
+    public String toString() {
+        return Block.getId(this.g) + ": (" + this.a + ", " + this.b + ", " + this.c + "), " + this.d + ", " + this.e + ", " + this.h;
+    }
+
+    public Block a() {
+        return this.g;
+    }
+
+    public int compareTo(Object object) {
+        return this.compareTo((NextTickListEntry) object);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NibbleArray.java b/src/main/java/net/minecraft/server/NibbleArray.java
new file mode 100644
index 0000000..5d75a54
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NibbleArray.java
@@ -0,0 +1,40 @@
+package net.minecraft.server;
+
+public class NibbleArray {
+
+    public final byte[] a;
+    private final int b;
+    private final int c;
+
+    public NibbleArray(int i, int j) {
+        this.a = new byte[i >> 1];
+        this.b = j;
+        this.c = j + 4;
+    }
+
+    public NibbleArray(byte[] abyte, int i) {
+        this.a = abyte;
+        this.b = i;
+        this.c = i + 4;
+    }
+
+    public int a(int i, int j, int k) {
+        int l = j << this.c | k << this.b | i;
+        int i1 = l >> 1;
+        int j1 = l & 1;
+
+        return j1 == 0 ? this.a[i1] & 15 : this.a[i1] >> 4 & 15;
+    }
+
+    public void a(int i, int j, int k, int l) {
+        int i1 = j << this.c | k << this.b | i;
+        int j1 = i1 >> 1;
+        int k1 = i1 & 1;
+
+        if (k1 == 0) {
+            this.a[j1] = (byte) (this.a[j1] & 240 | l & 15);
+        } else {
+            this.a[j1] = (byte) (this.a[j1] & 15 | (l & 15) << 4);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/OldChunkLoader.java b/src/main/java/net/minecraft/server/OldChunkLoader.java
new file mode 100644
index 0000000..fcb9912
--- /dev/null
+++ b/src/main/java/net/minecraft/server/OldChunkLoader.java
@@ -0,0 +1,120 @@
+package net.minecraft.server;
+
+public class OldChunkLoader {
+
+    public static OldChunk a(NBTTagCompound nbttagcompound) {
+        int i = nbttagcompound.getInt("xPos");
+        int j = nbttagcompound.getInt("zPos");
+        OldChunk oldchunk = new OldChunk(i, j);
+
+        oldchunk.g = nbttagcompound.getByteArray("Blocks");
+        oldchunk.f = new OldNibbleArray(nbttagcompound.getByteArray("Data"), 7);
+        oldchunk.e = new OldNibbleArray(nbttagcompound.getByteArray("SkyLight"), 7);
+        oldchunk.d = new OldNibbleArray(nbttagcompound.getByteArray("BlockLight"), 7);
+        oldchunk.c = nbttagcompound.getByteArray("HeightMap");
+        oldchunk.b = nbttagcompound.getBoolean("TerrainPopulated");
+        oldchunk.h = nbttagcompound.getList("Entities", 10);
+        oldchunk.i = nbttagcompound.getList("TileEntities", 10);
+        oldchunk.j = nbttagcompound.getList("TileTicks", 10);
+
+        try {
+            oldchunk.a = nbttagcompound.getLong("LastUpdate");
+        } catch (ClassCastException classcastexception) {
+            oldchunk.a = (long) nbttagcompound.getInt("LastUpdate");
+        }
+
+        return oldchunk;
+    }
+
+    public static void a(OldChunk oldchunk, NBTTagCompound nbttagcompound, WorldChunkManager worldchunkmanager) {
+        nbttagcompound.setInt("xPos", oldchunk.k);
+        nbttagcompound.setInt("zPos", oldchunk.l);
+        nbttagcompound.setLong("LastUpdate", oldchunk.a);
+        int[] aint = new int[oldchunk.c.length];
+
+        for (int i = 0; i < oldchunk.c.length; ++i) {
+            aint[i] = oldchunk.c[i];
+        }
+
+        nbttagcompound.setIntArray("HeightMap", aint);
+        nbttagcompound.setBoolean("TerrainPopulated", oldchunk.b);
+        NBTTagList nbttaglist = new NBTTagList();
+
+        int j;
+
+        for (int k = 0; k < 8; ++k) {
+            boolean flag = true;
+
+            for (j = 0; j < 16 && flag; ++j) {
+                int l = 0;
+
+                while (l < 16 && flag) {
+                    int i1 = 0;
+
+                    while (true) {
+                        if (i1 < 16) {
+                            int j1 = j << 11 | i1 << 7 | l + (k << 4);
+                            byte b0 = oldchunk.g[j1];
+
+                            if (b0 == 0) {
+                                ++i1;
+                                continue;
+                            }
+
+                            flag = false;
+                        }
+
+                        ++l;
+                        break;
+                    }
+                }
+            }
+
+            if (!flag) {
+                byte[] abyte = new byte[4096];
+                NibbleArray nibblearray = new NibbleArray(abyte.length, 4);
+                NibbleArray nibblearray1 = new NibbleArray(abyte.length, 4);
+                NibbleArray nibblearray2 = new NibbleArray(abyte.length, 4);
+
+                for (int k1 = 0; k1 < 16; ++k1) {
+                    for (int l1 = 0; l1 < 16; ++l1) {
+                        for (int i2 = 0; i2 < 16; ++i2) {
+                            int j2 = k1 << 11 | i2 << 7 | l1 + (k << 4);
+                            byte b1 = oldchunk.g[j2];
+
+                            abyte[l1 << 8 | i2 << 4 | k1] = (byte) (b1 & 255);
+                            nibblearray.a(k1, l1, i2, oldchunk.f.a(k1, l1 + (k << 4), i2));
+                            nibblearray1.a(k1, l1, i2, oldchunk.e.a(k1, l1 + (k << 4), i2));
+                            nibblearray2.a(k1, l1, i2, oldchunk.d.a(k1, l1 + (k << 4), i2));
+                        }
+                    }
+                }
+
+                NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+                nbttagcompound1.setByte("Y", (byte) (k & 255));
+                nbttagcompound1.setByteArray("Blocks", abyte);
+                nbttagcompound1.setByteArray("Data", nibblearray.a);
+                nbttagcompound1.setByteArray("SkyLight", nibblearray1.a);
+                nbttagcompound1.setByteArray("BlockLight", nibblearray2.a);
+                nbttaglist.add(nbttagcompound1);
+            }
+        }
+
+        nbttagcompound.set("Sections", nbttaglist);
+        byte[] abyte1 = new byte[256];
+
+        for (int k2 = 0; k2 < 16; ++k2) {
+            for (j = 0; j < 16; ++j) {
+                abyte1[j << 4 | k2] = (byte) (worldchunkmanager.getBiome(oldchunk.k << 4 | k2, oldchunk.l << 4 | j).id & 255);
+            }
+        }
+
+        nbttagcompound.setByteArray("Biomes", abyte1);
+        nbttagcompound.set("Entities", oldchunk.h);
+        nbttagcompound.set("TileEntities", oldchunk.i);
+        if (oldchunk.j != null) {
+            nbttagcompound.set("TileTicks", oldchunk.j);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
new file mode 100644
index 0000000..734faef
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
@@ -0,0 +1,189 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+import java.util.zip.DataFormatException;
+import java.util.zip.Deflater;
+import java.util.zip.Inflater;
+
+public class PacketPlayOutMapChunk extends Packet {
+
+    private int a;
+    private int b;
+    private int c;
+    private int d;
+    private byte[] e;
+    private byte[] f;
+    private boolean g;
+    private int h;
+    private static byte[] i = new byte[196864];
+
+    public PacketPlayOutMapChunk() {}
+
+    public PacketPlayOutMapChunk(Chunk chunk, boolean flag, int i) {
+        this.a = chunk.locX;
+        this.b = chunk.locZ;
+        this.g = flag;
+        ChunkMap chunkmap = a(chunk, flag, i);
+        Deflater deflater = new Deflater(-1);
+
+        this.d = chunkmap.c;
+        this.c = chunkmap.b;
+
+        try {
+            this.f = chunkmap.a;
+            deflater.setInput(chunkmap.a, 0, chunkmap.a.length);
+            deflater.finish();
+            this.e = new byte[chunkmap.a.length];
+            this.h = deflater.deflate(this.e);
+        } finally {
+            deflater.end();
+        }
+    }
+
+    public static int c() {
+        return 196864;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.readInt();
+        this.b = packetdataserializer.readInt();
+        this.g = packetdataserializer.readBoolean();
+        this.c = packetdataserializer.readShort();
+        this.d = packetdataserializer.readShort();
+        this.h = packetdataserializer.readInt();
+        if (i.length < this.h) {
+            i = new byte[this.h];
+        }
+
+        packetdataserializer.readBytes(i, 0, this.h);
+        int i = 0;
+
+        int j;
+
+        for (j = 0; j < 16; ++j) {
+            i += this.c >> j & 1;
+        }
+
+        j = 12288 * i;
+        if (this.g) {
+            j += 256;
+        }
+
+        this.f = new byte[j];
+        Inflater inflater = new Inflater();
+
+        inflater.setInput(PacketPlayOutMapChunk.i, 0, this.h);
+
+        try {
+            inflater.inflate(this.f);
+        } catch (DataFormatException dataformatexception) {
+            throw new IOException("Bad compressed data format");
+        } finally {
+            inflater.end();
+        }
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeInt(this.a);
+        packetdataserializer.writeInt(this.b);
+        packetdataserializer.writeBoolean(this.g);
+        packetdataserializer.writeShort((short) (this.c & '\uffff'));
+        packetdataserializer.writeShort((short) (this.d & '\uffff'));
+        packetdataserializer.writeInt(this.h);
+        packetdataserializer.writeBytes(this.e, 0, this.h);
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public String b() {
+        return String.format("x=%d, z=%d, full=%b, sects=%d, add=%d, size=%d", new Object[] { Integer.valueOf(this.a), Integer.valueOf(this.b), Boolean.valueOf(this.g), Integer.valueOf(this.c), Integer.valueOf(this.d), Integer.valueOf(this.h)});
+    }
+
+    public static ChunkMap a(Chunk chunk, boolean flag, int i) {
+        int j = 0;
+        ChunkSection[] achunksection = chunk.getSections();
+        int k = 0;
+        ChunkMap chunkmap = new ChunkMap();
+        byte[] abyte = PacketPlayOutMapChunk.i;
+
+        if (flag) {
+            chunk.q = true;
+        }
+
+        int l;
+
+        for (l = 0; l < achunksection.length; ++l) {
+            if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && (i & 1 << l) != 0) {
+                chunkmap.b |= 1 << l;
+                if (achunksection[l].getExtendedIdArray() != null) {
+                    chunkmap.c |= 1 << l;
+                    ++k;
+                }
+            }
+        }
+
+        for (l = 0; l < achunksection.length; ++l) {
+            if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && (i & 1 << l) != 0) {
+                byte[] abyte1 = achunksection[l].getIdArray();
+
+                System.arraycopy(abyte1, 0, abyte, j, abyte1.length);
+                j += abyte1.length;
+            }
+        }
+
+        NibbleArray nibblearray;
+
+        for (l = 0; l < achunksection.length; ++l) {
+            if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && (i & 1 << l) != 0) {
+                nibblearray = achunksection[l].getDataArray();
+                System.arraycopy(nibblearray.a, 0, abyte, j, nibblearray.a.length);
+                j += nibblearray.a.length;
+            }
+        }
+
+        for (l = 0; l < achunksection.length; ++l) {
+            if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && (i & 1 << l) != 0) {
+                nibblearray = achunksection[l].getEmittedLightArray();
+                System.arraycopy(nibblearray.a, 0, abyte, j, nibblearray.a.length);
+                j += nibblearray.a.length;
+            }
+        }
+
+        if (!chunk.world.worldProvider.g) {
+            for (l = 0; l < achunksection.length; ++l) {
+                if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && (i & 1 << l) != 0) {
+                    nibblearray = achunksection[l].getSkyLightArray();
+                    System.arraycopy(nibblearray.a, 0, abyte, j, nibblearray.a.length);
+                    j += nibblearray.a.length;
+                }
+            }
+        }
+
+        if (k > 0) {
+            for (l = 0; l < achunksection.length; ++l) {
+                if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && achunksection[l].getExtendedIdArray() != null && (i & 1 << l) != 0) {
+                    nibblearray = achunksection[l].getExtendedIdArray();
+                    System.arraycopy(nibblearray.a, 0, abyte, j, nibblearray.a.length);
+                    j += nibblearray.a.length;
+                }
+            }
+        }
+
+        if (flag) {
+            byte[] abyte2 = chunk.m();
+
+            System.arraycopy(abyte2, 0, abyte, j, abyte2.length);
+            j += abyte2.length;
+        }
+
+        chunkmap.a = new byte[j];
+        System.arraycopy(abyte, 0, chunkmap.a, 0, j);
+        return chunkmap;
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutOpenWindow.java b/src/main/java/net/minecraft/server/PacketPlayOutOpenWindow.java
new file mode 100644
index 0000000..f6d7b2b
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutOpenWindow.java
@@ -0,0 +1,58 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+
+public class PacketPlayOutOpenWindow extends Packet {
+
+    private int a;
+    private int b;
+    private String c;
+    private int d;
+    private boolean e;
+    private int f;
+
+    public PacketPlayOutOpenWindow() {}
+
+    public PacketPlayOutOpenWindow(int i, int j, String s, int k, boolean flag) {
+        this.a = i;
+        this.b = j;
+        this.c = s;
+        this.d = k;
+        this.e = flag;
+    }
+
+    public PacketPlayOutOpenWindow(int i, int j, String s, int k, boolean flag, int l) {
+        this(i, j, s, k, flag);
+        this.f = l;
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.readUnsignedByte();
+        this.b = packetdataserializer.readUnsignedByte();
+        this.c = packetdataserializer.c(32);
+        this.d = packetdataserializer.readUnsignedByte();
+        this.e = packetdataserializer.readBoolean();
+        if (this.b == 11) {
+            this.f = packetdataserializer.readInt();
+        }
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.writeByte(this.a);
+        packetdataserializer.writeByte(this.b);
+        packetdataserializer.a(this.c);
+        packetdataserializer.writeByte(this.d);
+        packetdataserializer.writeBoolean(this.e);
+        if (this.b == 11) {
+            packetdataserializer.writeInt(this.f);
+        }
+    }
+
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PersistentCollection.java b/src/main/java/net/minecraft/server/PersistentCollection.java
new file mode 100644
index 0000000..4684e89
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PersistentCollection.java
@@ -0,0 +1,185 @@
+package net.minecraft.server;
+
+import java.io.DataInputStream;
+import java.io.DataOutput;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+public class PersistentCollection {
+
+    private IDataManager a;
+    private Map b = new HashMap();
+    private List c = new ArrayList();
+    private Map d = new HashMap();
+
+    public PersistentCollection(IDataManager idatamanager) {
+        this.a = idatamanager;
+        this.b();
+    }
+
+    public PersistentBase get(Class oclass, String s) {
+        PersistentBase persistentbase = (PersistentBase) this.b.get(s);
+
+        if (persistentbase != null) {
+            return persistentbase;
+        } else {
+            if (this.a != null) {
+                try {
+                    File file1 = this.a.getDataFile(s);
+
+                    if (file1 != null && file1.exists()) {
+                        try {
+                            persistentbase = (PersistentBase) oclass.getConstructor(new Class[] { String.class}).newInstance(new Object[] { s});
+                        } catch (Exception exception) {
+                            throw new RuntimeException("Failed to instantiate " + oclass.toString(), exception);
+                        }
+
+                        FileInputStream fileinputstream = new FileInputStream(file1);
+                        NBTTagCompound nbttagcompound = NBTCompressedStreamTools.a((InputStream) fileinputstream);
+
+                        fileinputstream.close();
+                        persistentbase.a(nbttagcompound.getCompound("data"));
+                    }
+                } catch (Exception exception1) {
+                    exception1.printStackTrace();
+                }
+            }
+
+            if (persistentbase != null) {
+                this.b.put(s, persistentbase);
+                this.c.add(persistentbase);
+            }
+
+            return persistentbase;
+        }
+    }
+
+    public void a(String s, PersistentBase persistentbase) {
+        if (persistentbase == null) {
+            throw new RuntimeException("Can\'t set null data");
+        } else {
+            if (this.b.containsKey(s)) {
+                this.c.remove(this.b.remove(s));
+            }
+
+            this.b.put(s, persistentbase);
+            this.c.add(persistentbase);
+        }
+    }
+
+    public void a() {
+        for (int i = 0; i < this.c.size(); ++i) {
+            PersistentBase persistentbase = (PersistentBase) this.c.get(i);
+
+            if (persistentbase.d()) {
+                this.a(persistentbase);
+                persistentbase.a(false);
+            }
+        }
+    }
+
+    private void a(PersistentBase persistentbase) {
+        if (this.a != null) {
+            try {
+                File file1 = this.a.getDataFile(persistentbase.id);
+
+                if (file1 != null) {
+                    NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+                    persistentbase.b(nbttagcompound);
+                    NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+                    nbttagcompound1.set("data", nbttagcompound);
+                    FileOutputStream fileoutputstream = new FileOutputStream(file1);
+
+                    NBTCompressedStreamTools.a(nbttagcompound1, (OutputStream) fileoutputstream);
+                    fileoutputstream.close();
+                }
+            } catch (Exception exception) {
+                exception.printStackTrace();
+            }
+        }
+    }
+
+    private void b() {
+        try {
+            this.d.clear();
+            if (this.a == null) {
+                return;
+            }
+
+            File file1 = this.a.getDataFile("idcounts");
+
+            if (file1 != null && file1.exists()) {
+                DataInputStream datainputstream = new DataInputStream(new FileInputStream(file1));
+                NBTTagCompound nbttagcompound = NBTCompressedStreamTools.a(datainputstream);
+
+                datainputstream.close();
+                Iterator iterator = nbttagcompound.c().iterator();
+
+                while (iterator.hasNext()) {
+                    String s = (String) iterator.next();
+                    NBTBase nbtbase = nbttagcompound.get(s);
+
+                    if (nbtbase instanceof NBTTagShort) {
+                        NBTTagShort nbttagshort = (NBTTagShort) nbtbase;
+                        short short1 = nbttagshort.e();
+
+                        this.d.put(s, Short.valueOf(short1));
+                    }
+                }
+            }
+        } catch (Exception exception) {
+            exception.printStackTrace();
+        }
+    }
+
+    public int a(String s) {
+        Short oshort = (Short) this.d.get(s);
+
+        if (oshort == null) {
+            oshort = Short.valueOf((short) 0);
+        } else {
+            oshort = Short.valueOf((short) (oshort.shortValue() + 1));
+        }
+
+        this.d.put(s, oshort);
+        if (this.a == null) {
+            return oshort.shortValue();
+        } else {
+            try {
+                File file1 = this.a.getDataFile("idcounts");
+
+                if (file1 != null) {
+                    NBTTagCompound nbttagcompound = new NBTTagCompound();
+                    Iterator iterator = this.d.keySet().iterator();
+
+                    while (iterator.hasNext()) {
+                        String s1 = (String) iterator.next();
+                        short short1 = ((Short) this.d.get(s1)).shortValue();
+
+                        nbttagcompound.setShort(s1, short1);
+                    }
+
+                    DataOutputStream dataoutputstream = new DataOutputStream(new FileOutputStream(file1));
+
+                    NBTCompressedStreamTools.a(nbttagcompound, (DataOutput) dataoutputstream);
+                    dataoutputstream.close();
+                }
+            } catch (Exception exception) {
+                exception.printStackTrace();
+            }
+
+            return oshort.shortValue();
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/RegionFileCache.java b/src/main/java/net/minecraft/server/RegionFileCache.java
new file mode 100644
index 0000000..900ed68
--- /dev/null
+++ b/src/main/java/net/minecraft/server/RegionFileCache.java
@@ -0,0 +1,67 @@
+package net.minecraft.server;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+public class RegionFileCache {
+
+    private static final Map a = new HashMap();
+
+    public static synchronized RegionFile a(File file1, int i, int j) {
+        File file2 = new File(file1, "region");
+        File file3 = new File(file2, "r." + (i >> 5) + "." + (j >> 5) + ".mca");
+        RegionFile regionfile = (RegionFile) a.get(file3);
+
+        if (regionfile != null) {
+            return regionfile;
+        } else {
+            if (!file2.exists()) {
+                file2.mkdirs();
+            }
+
+            if (a.size() >= 256) {
+                a();
+            }
+
+            RegionFile regionfile1 = new RegionFile(file3);
+
+            a.put(file3, regionfile1);
+            return regionfile1;
+        }
+    }
+
+    public static synchronized void a() {
+        Iterator iterator = a.values().iterator();
+
+        while (iterator.hasNext()) {
+            RegionFile regionfile = (RegionFile) iterator.next();
+
+            try {
+                if (regionfile != null) {
+                    regionfile.c();
+                }
+            } catch (IOException ioexception) {
+                ioexception.printStackTrace();
+            }
+        }
+
+        a.clear();
+    }
+
+    public static DataInputStream c(File file1, int i, int j) {
+        RegionFile regionfile = a(file1, i, j);
+
+        return regionfile.a(i & 31, j & 31);
+    }
+
+    public static DataOutputStream d(File file1, int i, int j) {
+        RegionFile regionfile = a(file1, i, j);
+
+        return regionfile.b(i & 31, j & 31);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ServerConnection.java b/src/main/java/net/minecraft/server/ServerConnection.java
new file mode 100644
index 0000000..c2194af
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ServerConnection.java
@@ -0,0 +1,102 @@
+package net.minecraft.server;
+
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.Callable;
+
+import net.minecraft.util.com.google.common.util.concurrent.ThreadFactoryBuilder;
+import net.minecraft.util.io.netty.bootstrap.ServerBootstrap;
+import net.minecraft.util.io.netty.channel.ChannelFuture;
+import net.minecraft.util.io.netty.channel.nio.NioEventLoopGroup;
+import net.minecraft.util.io.netty.channel.socket.nio.NioServerSocketChannel;
+import net.minecraft.util.io.netty.util.concurrent.GenericFutureListener;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class ServerConnection {
+
+    private static final Logger b = LogManager.getLogger();
+    private static final NioEventLoopGroup c = new NioEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty IO #%d").setDaemon(true).build());
+    private final MinecraftServer d;
+    public volatile boolean a;
+    private final List e = Collections.synchronizedList(new ArrayList());
+    private final List f = Collections.synchronizedList(new ArrayList());
+
+    public ServerConnection(MinecraftServer minecraftserver) {
+        this.d = minecraftserver;
+        this.a = true;
+    }
+
+    public void a(InetAddress inetaddress, int i) {
+        List list = this.e;
+
+        synchronized (this.e) {
+            this.e.add(((ServerBootstrap) ((ServerBootstrap) (new ServerBootstrap()).channel(NioServerSocketChannel.class)).childHandler(new ServerConnectionChannel(this)).group(c).localAddress(inetaddress, i)).bind().syncUninterruptibly());
+        }
+    }
+
+    public void b() {
+        this.a = false;
+        Iterator iterator = this.e.iterator();
+
+        while (iterator.hasNext()) {
+            ChannelFuture channelfuture = (ChannelFuture) iterator.next();
+
+            channelfuture.channel().close().syncUninterruptibly();
+        }
+    }
+
+    public void c() {
+        List list = this.f;
+
+        synchronized (this.f) {
+            Iterator iterator = this.f.iterator();
+
+            while (iterator.hasNext()) {
+                NetworkManager networkmanager = (NetworkManager) iterator.next();
+
+                if (!networkmanager.isConnected()) {
+                    iterator.remove();
+                    if (networkmanager.f() != null) {
+                        networkmanager.getPacketListener().a(networkmanager.f());
+                    } else if (networkmanager.getPacketListener() != null) {
+                        networkmanager.getPacketListener().a(new ChatComponentText("Disconnected"));
+                    }
+                } else {
+                    try {
+                        networkmanager.a();
+                    } catch (Exception exception) {
+                        if (networkmanager.c()) {
+                            CrashReport crashreport = CrashReport.a(exception, "Ticking memory connection");
+                            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Ticking connection");
+
+                            crashreportsystemdetails.a("Connection", (Callable) (new CrashReportServerConnection(this, networkmanager)));
+                            throw new ReportedException(crashreport);
+                        }
+
+                        b.warn("Failed to handle packet for " + networkmanager.getSocketAddress(), exception);
+                        ChatComponentText chatcomponenttext = new ChatComponentText("Internal server error");
+
+                        networkmanager.handle(new PacketPlayOutKickDisconnect(chatcomponenttext), new GenericFutureListener[] { new ServerConnectionFuture(this, networkmanager, chatcomponenttext)});
+                        networkmanager.g();
+                    }
+                }
+            }
+        }
+    }
+
+    public MinecraftServer d() {
+        return this.d;
+    }
+
+    static List a(ServerConnection serverconnection) {
+        return serverconnection.f;
+    }
+
+    static MinecraftServer b(ServerConnection serverconnection) {
+        return serverconnection.d;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ServerConnectionChannel.java b/src/main/java/net/minecraft/server/ServerConnectionChannel.java
new file mode 100644
index 0000000..d7d93a0
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ServerConnectionChannel.java
@@ -0,0 +1,37 @@
+package net.minecraft.server;
+
+import net.minecraft.util.io.netty.channel.Channel;
+import net.minecraft.util.io.netty.channel.ChannelException;
+import net.minecraft.util.io.netty.channel.ChannelInitializer;
+import net.minecraft.util.io.netty.channel.ChannelOption;
+import net.minecraft.util.io.netty.handler.timeout.ReadTimeoutHandler;
+
+class ServerConnectionChannel extends ChannelInitializer {
+
+    final ServerConnection a;
+
+    ServerConnectionChannel(ServerConnection serverconnection) {
+        this.a = serverconnection;
+    }
+
+    protected void initChannel(Channel channel) {
+        try {
+            channel.config().setOption(ChannelOption.IP_TOS, Integer.valueOf(24));
+        } catch (ChannelException channelexception) {
+            ;
+        }
+
+        try {
+            channel.config().setOption(ChannelOption.TCP_NODELAY, Boolean.valueOf(false));
+        } catch (ChannelException channelexception1) {
+            ;
+        }
+
+        channel.pipeline().addLast("timeout", new ReadTimeoutHandler(30)).addLast("legacy_query", new LegacyPingHandler(this.a)).addLast("splitter", new PacketSplitter()).addLast("decoder", new PacketDecoder(NetworkManager.h)).addLast("prepender", new PacketPrepender()).addLast("encoder", new PacketEncoder(NetworkManager.h));
+        NetworkManager networkmanager = new NetworkManager(false);
+
+        ServerConnection.a(this.a).add(networkmanager);
+        channel.pipeline().addLast("packet_handler", networkmanager);
+        networkmanager.a((PacketListener) (new HandshakeListener(ServerConnection.b(this.a), networkmanager)));
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ServerStatisticManager.java b/src/main/java/net/minecraft/server/ServerStatisticManager.java
new file mode 100644
index 0000000..57a501f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ServerStatisticManager.java
@@ -0,0 +1,202 @@
+package net.minecraft.server;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Constructor;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.Map.Entry;
+
+import net.minecraft.util.com.google.common.collect.Maps;
+import net.minecraft.util.com.google.common.collect.Sets;
+import net.minecraft.util.com.google.gson.JsonElement;
+import net.minecraft.util.com.google.gson.JsonObject;
+import net.minecraft.util.com.google.gson.JsonParseException;
+import net.minecraft.util.com.google.gson.JsonParser;
+import net.minecraft.util.org.apache.commons.io.FileUtils;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class ServerStatisticManager extends StatisticManager {
+
+    private static final Logger b = LogManager.getLogger();
+    private final MinecraftServer c;
+    private final File d;
+    private final Set e = Sets.newHashSet();
+    private int f = -300;
+    private boolean g = false;
+
+    public ServerStatisticManager(MinecraftServer minecraftserver, File file1) {
+        this.c = minecraftserver;
+        this.d = file1;
+    }
+
+    public void a() {
+        if (this.d.isFile()) {
+            try {
+                this.a.clear();
+                this.a.putAll(this.a(FileUtils.readFileToString(this.d)));
+            } catch (IOException ioexception) {
+                b.error("Couldn\'t read statistics file " + this.d, ioexception);
+            } catch (JsonParseException jsonparseexception) {
+                b.error("Couldn\'t parse statistics file " + this.d, jsonparseexception);
+            }
+        }
+    }
+
+    public void b() {
+        try {
+            FileUtils.writeStringToFile(this.d, a(this.a));
+        } catch (IOException ioexception) {
+            b.error("Couldn\'t save stats", ioexception);
+        }
+    }
+
+    public void setStatistic(EntityHuman entityhuman, Statistic statistic, int i) {
+        int j = statistic.d() ? this.getStatisticValue(statistic) : 0;
+
+        super.setStatistic(entityhuman, statistic, i);
+        this.e.add(statistic);
+        if (statistic.d() && j == 0 && i > 0) {
+            this.g = true;
+            if (this.c.at()) {
+                this.c.getPlayerList().sendMessage(new ChatMessage("chat.type.achievement", new Object[] { entityhuman.getScoreboardDisplayName(), statistic.j()}));
+            }
+        }
+    }
+
+    public Set c() {
+        HashSet hashset = Sets.newHashSet(this.e);
+
+        this.e.clear();
+        this.g = false;
+        return hashset;
+    }
+
+    public Map a(String s) {
+        JsonElement jsonelement = (new JsonParser()).parse(s);
+
+        if (!jsonelement.isJsonObject()) {
+            return Maps.newHashMap();
+        } else {
+            JsonObject jsonobject = jsonelement.getAsJsonObject();
+            HashMap hashmap = Maps.newHashMap();
+            Iterator iterator = jsonobject.entrySet().iterator();
+
+            while (iterator.hasNext()) {
+                Entry entry = (Entry) iterator.next();
+                Statistic statistic = StatisticList.getStatistic((String) entry.getKey());
+
+                if (statistic != null) {
+                    StatisticWrapper statisticwrapper = new StatisticWrapper();
+
+                    if (((JsonElement) entry.getValue()).isJsonPrimitive() && ((JsonElement) entry.getValue()).getAsJsonPrimitive().isNumber()) {
+                        statisticwrapper.a(((JsonElement) entry.getValue()).getAsInt());
+                    } else if (((JsonElement) entry.getValue()).isJsonObject()) {
+                        JsonObject jsonobject1 = ((JsonElement) entry.getValue()).getAsJsonObject();
+
+                        if (jsonobject1.has("value") && jsonobject1.get("value").isJsonPrimitive() && jsonobject1.get("value").getAsJsonPrimitive().isNumber()) {
+                            statisticwrapper.a(jsonobject1.getAsJsonPrimitive("value").getAsInt());
+                        }
+
+                        if (jsonobject1.has("progress") && statistic.l() != null) {
+                            try {
+                                Constructor constructor = statistic.l().getConstructor(new Class[0]);
+                                IJsonStatistic ijsonstatistic = (IJsonStatistic) constructor.newInstance(new Object[0]);
+
+                                ijsonstatistic.a(jsonobject1.get("progress"));
+                                statisticwrapper.a(ijsonstatistic);
+                            } catch (Throwable throwable) {
+                                b.warn("Invalid statistic progress in " + this.d, throwable);
+                            }
+                        }
+                    }
+
+                    hashmap.put(statistic, statisticwrapper);
+                } else {
+                    b.warn("Invalid statistic in " + this.d + ": Don\'t know what " + (String) entry.getKey() + " is");
+                }
+            }
+
+            return hashmap;
+        }
+    }
+
+    public static String a(Map map) {
+        JsonObject jsonobject = new JsonObject();
+        Iterator iterator = map.entrySet().iterator();
+
+        while (iterator.hasNext()) {
+            Entry entry = (Entry) iterator.next();
+
+            if (((StatisticWrapper) entry.getValue()).b() != null) {
+                JsonObject jsonobject1 = new JsonObject();
+
+                jsonobject1.addProperty("value", Integer.valueOf(((StatisticWrapper) entry.getValue()).a()));
+
+                try {
+                    jsonobject1.add("progress", ((StatisticWrapper) entry.getValue()).b().a());
+                } catch (Throwable throwable) {
+                    b.warn("Couldn\'t save statistic " + ((Statistic) entry.getKey()).e() + ": error serializing progress", throwable);
+                }
+
+                jsonobject.add(((Statistic) entry.getKey()).name, jsonobject1);
+            } else {
+                jsonobject.addProperty(((Statistic) entry.getKey()).name, Integer.valueOf(((StatisticWrapper) entry.getValue()).a()));
+            }
+        }
+
+        return jsonobject.toString();
+    }
+
+    public void d() {
+        Iterator iterator = this.a.keySet().iterator();
+
+        while (iterator.hasNext()) {
+            Statistic statistic = (Statistic) iterator.next();
+
+            this.e.add(statistic);
+        }
+    }
+
+    public void a(EntityPlayer entityplayer) {
+        int i = this.c.al();
+        HashMap hashmap = Maps.newHashMap();
+
+        if (this.g || i - this.f > 300) {
+            this.f = i;
+            Iterator iterator = this.c().iterator();
+
+            while (iterator.hasNext()) {
+                Statistic statistic = (Statistic) iterator.next();
+
+                hashmap.put(statistic, Integer.valueOf(this.getStatisticValue(statistic)));
+            }
+        }
+
+        entityplayer.playerConnection.sendPacket(new PacketPlayOutStatistic(hashmap));
+    }
+
+    public void updateStatistics(EntityPlayer entityplayer) {
+        HashMap hashmap = Maps.newHashMap();
+        Iterator iterator = AchievementList.e.iterator();
+
+        while (iterator.hasNext()) {
+            Achievement achievement = (Achievement) iterator.next();
+
+            if (this.hasAchievement(achievement)) {
+                hashmap.put(achievement, Integer.valueOf(this.getStatisticValue(achievement)));
+                this.e.remove(achievement);
+            }
+        }
+
+        entityplayer.playerConnection.sendPacket(new PacketPlayOutStatistic(hashmap));
+    }
+
+    public boolean e() {
+        return this.g;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/StructureGenerator.java b/src/main/java/net/minecraft/server/StructureGenerator.java
new file mode 100644
index 0000000..97308d0
--- /dev/null
+++ b/src/main/java/net/minecraft/server/StructureGenerator.java
@@ -0,0 +1,219 @@
+package net.minecraft.server;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.concurrent.Callable;
+
+public abstract class StructureGenerator extends WorldGenBase {
+
+    private PersistentStructure e;
+    protected Map d = new HashMap();
+
+    public StructureGenerator() {}
+
+    public abstract String a();
+
+    protected final void a(World world, int i, int j, int k, int l, Block[] ablock) {
+        this.a(world);
+        if (!this.d.containsKey(Long.valueOf(ChunkCoordIntPair.a(i, j)))) {
+            this.b.nextInt();
+
+            try {
+                if (this.a(i, j)) {
+                    StructureStart structurestart = this.b(i, j);
+
+                    this.d.put(Long.valueOf(ChunkCoordIntPair.a(i, j)), structurestart);
+                    this.a(i, j, structurestart);
+                }
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Exception preparing structure feature");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Feature being prepared");
+
+                crashreportsystemdetails.a("Is feature chunk", (Callable) (new CrashReportIsFeatureChunk(this, i, j)));
+                crashreportsystemdetails.a("Chunk location", String.format("%d,%d", new Object[] { Integer.valueOf(i), Integer.valueOf(j)}));
+                crashreportsystemdetails.a("Chunk pos hash", (Callable) (new CrashReportChunkPosHash(this, i, j)));
+                crashreportsystemdetails.a("Structure type", (Callable) (new CrashReportStructureType(this)));
+                throw new ReportedException(crashreport);
+            }
+        }
+    }
+
+    public boolean a(World world, Random random, int i, int j) {
+        this.a(world);
+        int k = (i << 4) + 8;
+        int l = (j << 4) + 8;
+        boolean flag = false;
+        Iterator iterator = this.d.values().iterator();
+
+        while (iterator.hasNext()) {
+            StructureStart structurestart = (StructureStart) iterator.next();
+
+            if (structurestart.d() && structurestart.a().a(k, l, k + 15, l + 15)) {
+                structurestart.a(world, random, new StructureBoundingBox(k, l, k + 15, l + 15));
+                flag = true;
+                this.a(structurestart.e(), structurestart.f(), structurestart);
+            }
+        }
+
+        return flag;
+    }
+
+    public boolean b(int i, int j, int k) {
+        this.a(this.c);
+        return this.c(i, j, k) != null;
+    }
+
+    protected StructureStart c(int i, int j, int k) {
+        Iterator iterator = this.d.values().iterator();
+
+        while (iterator.hasNext()) {
+            StructureStart structurestart = (StructureStart) iterator.next();
+
+            if (structurestart.d() && structurestart.a().a(i, k, i, k)) {
+                Iterator iterator1 = structurestart.b().iterator();
+
+                while (iterator1.hasNext()) {
+                    StructurePiece structurepiece = (StructurePiece) iterator1.next();
+
+                    if (structurepiece.c().b(i, j, k)) {
+                        return structurestart;
+                    }
+                }
+            }
+        }
+
+        return null;
+    }
+
+    public boolean d(int i, int j, int k) {
+        this.a(this.c);
+        Iterator iterator = this.d.values().iterator();
+
+        StructureStart structurestart;
+
+        do {
+            if (!iterator.hasNext()) {
+                return false;
+            }
+
+            structurestart = (StructureStart) iterator.next();
+        } while (!structurestart.d());
+
+        return structurestart.a().a(i, k, i, k);
+    }
+
+    public ChunkPosition getNearestGeneratedFeature(World world, int i, int j, int k) {
+        this.c = world;
+        this.a(world);
+        this.b.setSeed(world.getSeed());
+        long l = this.b.nextLong();
+        long i1 = this.b.nextLong();
+        long j1 = (long) (i >> 4) * l;
+        long k1 = (long) (k >> 4) * i1;
+
+        this.b.setSeed(j1 ^ k1 ^ world.getSeed());
+        this.a(world, i >> 4, k >> 4, 0, 0, (Block[]) null);
+        double d0 = Double.MAX_VALUE;
+        ChunkPosition chunkposition = null;
+        Iterator iterator = this.d.values().iterator();
+
+        ChunkPosition chunkposition1;
+        int l1;
+        int i2;
+        double d1;
+        int j2;
+
+        while (iterator.hasNext()) {
+            StructureStart structurestart = (StructureStart) iterator.next();
+
+            if (structurestart.d()) {
+                StructurePiece structurepiece = (StructurePiece) structurestart.b().get(0);
+
+                chunkposition1 = structurepiece.a();
+                i2 = chunkposition1.x - i;
+                l1 = chunkposition1.y - j;
+                j2 = chunkposition1.z - k;
+                d1 = (double) (i2 * i2 + l1 * l1 + j2 * j2);
+                if (d1 < d0) {
+                    d0 = d1;
+                    chunkposition = chunkposition1;
+                }
+            }
+        }
+
+        if (chunkposition != null) {
+            return chunkposition;
+        } else {
+            List list = this.o_();
+
+            if (list != null) {
+                ChunkPosition chunkposition2 = null;
+                Iterator iterator1 = list.iterator();
+
+                while (iterator1.hasNext()) {
+                    chunkposition1 = (ChunkPosition) iterator1.next();
+                    i2 = chunkposition1.x - i;
+                    l1 = chunkposition1.y - j;
+                    j2 = chunkposition1.z - k;
+                    d1 = (double) (i2 * i2 + l1 * l1 + j2 * j2);
+                    if (d1 < d0) {
+                        d0 = d1;
+                        chunkposition2 = chunkposition1;
+                    }
+                }
+
+                return chunkposition2;
+            } else {
+                return null;
+            }
+        }
+    }
+
+    protected List o_() {
+        return null;
+    }
+
+    private void a(World world) {
+        if (this.e == null) {
+            this.e = (PersistentStructure) world.a(PersistentStructure.class, this.a());
+            if (this.e == null) {
+                this.e = new PersistentStructure(this.a());
+                world.a(this.a(), (PersistentBase) this.e);
+            } else {
+                NBTTagCompound nbttagcompound = this.e.a();
+                Iterator iterator = nbttagcompound.c().iterator();
+
+                while (iterator.hasNext()) {
+                    String s = (String) iterator.next();
+                    NBTBase nbtbase = nbttagcompound.get(s);
+
+                    if (nbtbase.getTypeId() == 10) {
+                        NBTTagCompound nbttagcompound1 = (NBTTagCompound) nbtbase;
+
+                        if (nbttagcompound1.hasKey("ChunkX") && nbttagcompound1.hasKey("ChunkZ")) {
+                            int i = nbttagcompound1.getInt("ChunkX");
+                            int j = nbttagcompound1.getInt("ChunkZ");
+                            StructureStart structurestart = WorldGenFactory.a(nbttagcompound1, world);
+
+                            if (structurestart != null) {
+                                this.d.put(Long.valueOf(ChunkCoordIntPair.a(i, j)), structurestart);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private void a(int i, int j, StructureStart structurestart) {
+        this.e.a(structurestart.a(i, j), i, j);
+        this.e.c();
+    }
+
+    protected abstract boolean a(int i, int j);
+
+    protected abstract StructureStart b(int i, int j);
+}
diff --git a/src/main/java/net/minecraft/server/UserCache.java b/src/main/java/net/minecraft/server/UserCache.java
new file mode 100644
index 0000000..a283204
--- /dev/null
+++ b/src/main/java/net/minecraft/server/UserCache.java
@@ -0,0 +1,247 @@
+package net.minecraft.server;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.lang.reflect.ParameterizedType;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.UUID;
+
+import net.minecraft.util.com.google.common.base.Charsets;
+import net.minecraft.util.com.google.common.collect.Iterators;
+import net.minecraft.util.com.google.common.collect.Lists;
+import net.minecraft.util.com.google.common.collect.Maps;
+import net.minecraft.util.com.google.common.io.Files;
+import net.minecraft.util.com.google.gson.Gson;
+import net.minecraft.util.com.google.gson.GsonBuilder;
+import net.minecraft.util.com.mojang.authlib.Agent;
+import net.minecraft.util.com.mojang.authlib.GameProfile;
+import net.minecraft.util.org.apache.commons.io.IOUtils;
+
+public class UserCache {
+
+    public static final SimpleDateFormat a = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
+    private final Map c = Maps.newHashMap();
+    private final Map d = Maps.newHashMap();
+    private final LinkedList e = Lists.newLinkedList();
+    private final MinecraftServer f;
+    protected final Gson b;
+    private final File g;
+    private static final ParameterizedType h = new UserCacheEntryType();
+
+    public UserCache(MinecraftServer minecraftserver, File file1) {
+        this.f = minecraftserver;
+        this.g = file1;
+        GsonBuilder gsonbuilder = new GsonBuilder();
+
+        gsonbuilder.registerTypeHierarchyAdapter(UserCacheEntry.class, new BanEntrySerializer(this, (GameProfileLookup) null));
+        this.b = gsonbuilder.create();
+        this.b();
+    }
+
+    private static GameProfile a(MinecraftServer minecraftserver, String s) {
+        GameProfile[] agameprofile = new GameProfile[1];
+        GameProfileLookup gameprofilelookup = new GameProfileLookup(agameprofile);
+
+        minecraftserver.getGameProfileRepository().findProfilesByNames(new String[] { s}, Agent.MINECRAFT, gameprofilelookup);
+        if (!minecraftserver.getOnlineMode() && agameprofile[0] == null) {
+            UUID uuid = EntityHuman.a(new GameProfile((UUID) null, s));
+            GameProfile gameprofile = new GameProfile(uuid, s);
+
+            gameprofilelookup.onProfileLookupSucceeded(gameprofile);
+        }
+
+        return agameprofile[0];
+    }
+
+    public void a(GameProfile gameprofile) {
+        this.a(gameprofile, (Date) null);
+    }
+
+    private void a(GameProfile gameprofile, Date date) {
+        UUID uuid = gameprofile.getId();
+
+        if (date == null) {
+            Calendar calendar = Calendar.getInstance();
+
+            calendar.setTime(new Date());
+            calendar.add(2, 1);
+            date = calendar.getTime();
+        }
+
+        String s = gameprofile.getName().toLowerCase(Locale.ROOT);
+        UserCacheEntry usercacheentry = new UserCacheEntry(this, gameprofile, date, (GameProfileLookup) null);
+        LinkedList linkedlist = this.e;
+
+        synchronized (this.e) {
+            if (this.d.containsKey(uuid)) {
+                UserCacheEntry usercacheentry1 = (UserCacheEntry) this.d.get(uuid);
+
+                this.c.remove(usercacheentry1.a().getName().toLowerCase(Locale.ROOT));
+                this.c.put(gameprofile.getName().toLowerCase(Locale.ROOT), usercacheentry);
+                this.e.remove(gameprofile);
+            } else {
+                this.d.put(uuid, usercacheentry);
+                this.c.put(s, usercacheentry);
+            }
+
+            this.e.addFirst(gameprofile);
+        }
+    }
+
+    public GameProfile getProfile(String s) {
+        String s1 = s.toLowerCase(Locale.ROOT);
+        UserCacheEntry usercacheentry = (UserCacheEntry) this.c.get(s1);
+
+        if (usercacheentry != null && (new Date()).getTime() >= UserCacheEntry.a(usercacheentry).getTime()) {
+            this.d.remove(usercacheentry.a().getId());
+            this.c.remove(usercacheentry.a().getName().toLowerCase(Locale.ROOT));
+            LinkedList linkedlist = this.e;
+
+            synchronized (this.e) {
+                this.e.remove(usercacheentry.a());
+            }
+
+            usercacheentry = null;
+        }
+
+        GameProfile gameprofile;
+
+        if (usercacheentry != null) {
+            gameprofile = usercacheentry.a();
+            LinkedList linkedlist1 = this.e;
+
+            synchronized (this.e) {
+                this.e.remove(gameprofile);
+                this.e.addFirst(gameprofile);
+            }
+        } else {
+            gameprofile = a(this.f, s1);
+            if (gameprofile != null) {
+                this.a(gameprofile);
+                usercacheentry = (UserCacheEntry) this.c.get(s1);
+            }
+        }
+
+        this.c();
+        return usercacheentry == null ? null : usercacheentry.a();
+    }
+
+    public String[] a() {
+        ArrayList arraylist = Lists.newArrayList(this.c.keySet());
+
+        return (String[]) arraylist.toArray(new String[arraylist.size()]);
+    }
+
+    public GameProfile a(UUID uuid) {
+        UserCacheEntry usercacheentry = (UserCacheEntry) this.d.get(uuid);
+
+        return usercacheentry == null ? null : usercacheentry.a();
+    }
+
+    private UserCacheEntry b(UUID uuid) {
+        UserCacheEntry usercacheentry = (UserCacheEntry) this.d.get(uuid);
+
+        if (usercacheentry != null) {
+            GameProfile gameprofile = usercacheentry.a();
+            LinkedList linkedlist = this.e;
+
+            synchronized (this.e) {
+                this.e.remove(gameprofile);
+                this.e.addFirst(gameprofile);
+            }
+        }
+
+        return usercacheentry;
+    }
+
+    public void b() {
+        List list = null;
+        BufferedReader bufferedreader = null;
+
+        label81: {
+            try {
+                bufferedreader = Files.newReader(this.g, Charsets.UTF_8);
+                list = (List) this.b.fromJson(bufferedreader, h);
+                break label81;
+            } catch (FileNotFoundException filenotfoundexception) {
+                ;
+            } finally {
+                IOUtils.closeQuietly(bufferedreader);
+            }
+
+            return;
+        }
+
+        if (list != null) {
+            this.c.clear();
+            this.d.clear();
+            LinkedList linkedlist = this.e;
+
+            synchronized (this.e) {
+                this.e.clear();
+            }
+
+            list = Lists.reverse(list);
+            Iterator iterator = list.iterator();
+
+            while (iterator.hasNext()) {
+                UserCacheEntry usercacheentry = (UserCacheEntry) iterator.next();
+
+                if (usercacheentry != null) {
+                    this.a(usercacheentry.a(), usercacheentry.b());
+                }
+            }
+        }
+    }
+
+    public void c() {
+        String s = this.b.toJson(this.a(1000));
+        BufferedWriter bufferedwriter = null;
+
+        try {
+            bufferedwriter = Files.newWriter(this.g, Charsets.UTF_8);
+            bufferedwriter.write(s);
+            return;
+        } catch (FileNotFoundException filenotfoundexception) {
+            return;
+        } catch (IOException ioexception) {
+            ;
+        } finally {
+            IOUtils.closeQuietly(bufferedwriter);
+        }
+    }
+
+    private List a(int i) {
+        ArrayList arraylist = Lists.newArrayList();
+        LinkedList linkedlist = this.e;
+        ArrayList arraylist1;
+
+        synchronized (this.e) {
+            arraylist1 = Lists.newArrayList(Iterators.limit(this.e.iterator(), i));
+        }
+
+        Iterator iterator = arraylist1.iterator();
+
+        while (iterator.hasNext()) {
+            GameProfile gameprofile = (GameProfile) iterator.next();
+            UserCacheEntry usercacheentry = this.b(gameprofile.getId());
+
+            if (usercacheentry != null) {
+                arraylist.add(usercacheentry);
+            }
+        }
+
+        return arraylist;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/UserCacheEntry.java b/src/main/java/net/minecraft/server/UserCacheEntry.java
new file mode 100644
index 0000000..fe129a5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/UserCacheEntry.java
@@ -0,0 +1,34 @@
+package net.minecraft.server;
+
+import java.util.Date;
+
+import net.minecraft.util.com.mojang.authlib.GameProfile;
+
+class UserCacheEntry {
+
+    private final GameProfile b;
+    private final Date c;
+    final UserCache a;
+
+    private UserCacheEntry(UserCache usercache, GameProfile gameprofile, Date date) {
+        this.a = usercache;
+        this.b = gameprofile;
+        this.c = date;
+    }
+
+    public GameProfile a() {
+        return this.b;
+    }
+
+    public Date b() {
+        return this.c;
+    }
+
+    UserCacheEntry(UserCache usercache, GameProfile gameprofile, Date date, GameProfileLookup gameprofilelookup) {
+        this(usercache, gameprofile, date);
+    }
+
+    static Date a(UserCacheEntry usercacheentry) {
+        return usercacheentry.c;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/WatchableObject.java b/src/main/java/net/minecraft/server/WatchableObject.java
new file mode 100644
index 0000000..678aa91
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WatchableObject.java
@@ -0,0 +1,44 @@
+package net.minecraft.server;
+
+public class WatchableObject {
+
+    private final int a;
+    private final int b;
+    private Object c;
+    private boolean d;
+
+    public WatchableObject(int i, int j, Object object) {
+        this.b = j;
+        this.c = object;
+        this.a = i;
+        this.d = true;
+    }
+
+    public int a() {
+        return this.b;
+    }
+
+    public void a(Object object) {
+        this.c = object;
+    }
+
+    public Object b() {
+        return this.c;
+    }
+
+    public int c() {
+        return this.a;
+    }
+
+    public boolean d() {
+        return this.d;
+    }
+
+    public void a(boolean flag) {
+        this.d = flag;
+    }
+
+    static boolean a(WatchableObject watchableobject, boolean flag) {
+        return watchableobject.d = flag;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/WorldGenForestTree.java b/src/main/java/net/minecraft/server/WorldGenForestTree.java
new file mode 100644
index 0000000..c0d0ff9
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WorldGenForestTree.java
@@ -0,0 +1,166 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class WorldGenForestTree extends WorldGenTreeAbstract {
+
+    public WorldGenForestTree(boolean flag) {
+        super(flag);
+    }
+
+    public boolean generate(World world, Random random, int i, int j, int k) {
+        int l = random.nextInt(3) + random.nextInt(2) + 6;
+        boolean flag = true;
+
+        if (j >= 1 && j + l + 1 <= 256) {
+            int i1;
+            int j1;
+
+            for (int k1 = j; k1 <= j + 1 + l; ++k1) {
+                byte b0 = 1;
+
+                if (k1 == j) {
+                    b0 = 0;
+                }
+
+                if (k1 >= j + 1 + l - 2) {
+                    b0 = 2;
+                }
+
+                for (i1 = i - b0; i1 <= i + b0 && flag; ++i1) {
+                    for (j1 = k - b0; j1 <= k + b0 && flag; ++j1) {
+                        if (k1 >= 0 && k1 < 256) {
+                            Block block = world.getType(i1, k1, j1);
+
+                            if (!this.a(block)) {
+                                flag = false;
+                            }
+                        } else {
+                            flag = false;
+                        }
+                    }
+                }
+            }
+
+            if (!flag) {
+                return false;
+            } else {
+                Block block1 = world.getType(i, j - 1, k);
+
+                if ((block1 == Blocks.GRASS || block1 == Blocks.DIRT) && j < 256 - l - 1) {
+                    this.setType(world, i, j - 1, k, Blocks.DIRT);
+                    this.setType(world, i + 1, j - 1, k, Blocks.DIRT);
+                    this.setType(world, i + 1, j - 1, k + 1, Blocks.DIRT);
+                    this.setType(world, i, j - 1, k + 1, Blocks.DIRT);
+                    int l1 = random.nextInt(4);
+
+                    i1 = l - random.nextInt(4);
+                    j1 = 2 - random.nextInt(3);
+                    int i2 = i;
+                    int j2 = k;
+                    int k2 = 0;
+
+                    int l2;
+                    int i3;
+
+                    for (l2 = 0; l2 < l; ++l2) {
+                        i3 = j + l2;
+                        if (l2 >= i1 && j1 > 0) {
+                            i2 += Direction.a[l1];
+                            j2 += Direction.b[l1];
+                            --j1;
+                        }
+
+                        Block block2 = world.getType(i2, i3, j2);
+
+                        if (block2.getMaterial() == Material.AIR || block2.getMaterial() == Material.LEAVES) {
+                            this.setTypeAndData(world, i2, i3, j2, Blocks.LOG2, 1);
+                            this.setTypeAndData(world, i2 + 1, i3, j2, Blocks.LOG2, 1);
+                            this.setTypeAndData(world, i2, i3, j2 + 1, Blocks.LOG2, 1);
+                            this.setTypeAndData(world, i2 + 1, i3, j2 + 1, Blocks.LOG2, 1);
+                            k2 = i3;
+                        }
+                    }
+
+                    for (l2 = -2; l2 <= 0; ++l2) {
+                        for (i3 = -2; i3 <= 0; ++i3) {
+                            byte b1 = -1;
+
+                            this.a(world, i2 + l2, k2 + b1, j2 + i3);
+                            this.a(world, 1 + i2 - l2, k2 + b1, j2 + i3);
+                            this.a(world, i2 + l2, k2 + b1, 1 + j2 - i3);
+                            this.a(world, 1 + i2 - l2, k2 + b1, 1 + j2 - i3);
+                            if ((l2 > -2 || i3 > -1) && (l2 != -1 || i3 != -2)) {
+                                byte b2 = 1;
+
+                                this.a(world, i2 + l2, k2 + b2, j2 + i3);
+                                this.a(world, 1 + i2 - l2, k2 + b2, j2 + i3);
+                                this.a(world, i2 + l2, k2 + b2, 1 + j2 - i3);
+                                this.a(world, 1 + i2 - l2, k2 + b2, 1 + j2 - i3);
+                            }
+                        }
+                    }
+
+                    if (random.nextBoolean()) {
+                        this.a(world, i2, k2 + 2, j2);
+                        this.a(world, i2 + 1, k2 + 2, j2);
+                        this.a(world, i2 + 1, k2 + 2, j2 + 1);
+                        this.a(world, i2, k2 + 2, j2 + 1);
+                    }
+
+                    for (l2 = -3; l2 <= 4; ++l2) {
+                        for (i3 = -3; i3 <= 4; ++i3) {
+                            if ((l2 != -3 || i3 != -3) && (l2 != -3 || i3 != 4) && (l2 != 4 || i3 != -3) && (l2 != 4 || i3 != 4) && (Math.abs(l2) < 3 || Math.abs(i3) < 3)) {
+                                this.a(world, i2 + l2, k2, j2 + i3);
+                            }
+                        }
+                    }
+
+                    for (l2 = -1; l2 <= 2; ++l2) {
+                        for (i3 = -1; i3 <= 2; ++i3) {
+                            if ((l2 < 0 || l2 > 1 || i3 < 0 || i3 > 1) && random.nextInt(3) <= 0) {
+                                int j3 = random.nextInt(3) + 2;
+
+                                int k3;
+
+                                for (k3 = 0; k3 < j3; ++k3) {
+                                    this.setTypeAndData(world, i + l2, k2 - k3 - 1, k + i3, Blocks.LOG2, 1);
+                                }
+
+                                int l3;
+
+                                for (k3 = -1; k3 <= 1; ++k3) {
+                                    for (l3 = -1; l3 <= 1; ++l3) {
+                                        this.a(world, i2 + l2 + k3, k2 - 0, j2 + i3 + l3);
+                                    }
+                                }
+
+                                for (k3 = -2; k3 <= 2; ++k3) {
+                                    for (l3 = -2; l3 <= 2; ++l3) {
+                                        if (Math.abs(k3) != 2 || Math.abs(l3) != 2) {
+                                            this.a(world, i2 + l2 + k3, k2 - 1, j2 + i3 + l3);
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+
+                    return true;
+                } else {
+                    return false;
+                }
+            }
+        } else {
+            return false;
+        }
+    }
+
+    private void a(World world, int i, int j, int k) {
+        Block block = world.getType(i, j, k);
+
+        if (block.getMaterial() == Material.AIR) {
+            this.setTypeAndData(world, i, j, k, Blocks.LEAVES2, 1);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/WorldGenLargeFeature.java b/src/main/java/net/minecraft/server/WorldGenLargeFeature.java
new file mode 100644
index 0000000..1e5efc4
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WorldGenLargeFeature.java
@@ -0,0 +1,97 @@
+package net.minecraft.server;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.Map.Entry;
+
+public class WorldGenLargeFeature extends StructureGenerator {
+
+    private static List e = Arrays.asList(new BiomeBase[] { BiomeBase.DESERT, BiomeBase.DESERT_HILLS, BiomeBase.JUNGLE, BiomeBase.JUNGLE_HILLS, BiomeBase.SWAMPLAND});
+    private List f;
+    private int g;
+    private int h;
+
+    public WorldGenLargeFeature() {
+        this.f = new ArrayList();
+        this.g = 32;
+        this.h = 8;
+        this.f.add(new BiomeMeta(EntityWitch.class, 1, 1, 1));
+    }
+
+    public WorldGenLargeFeature(Map map) {
+        this();
+        Iterator iterator = map.entrySet().iterator();
+
+        while (iterator.hasNext()) {
+            Entry entry = (Entry) iterator.next();
+
+            if (((String) entry.getKey()).equals("distance")) {
+                this.g = MathHelper.a((String) entry.getValue(), this.g, this.h + 1);
+            }
+        }
+    }
+
+    public String a() {
+        return "Temple";
+    }
+
+    protected boolean a(int i, int j) {
+        int k = i;
+        int l = j;
+
+        if (i < 0) {
+            i -= this.g - 1;
+        }
+
+        if (j < 0) {
+            j -= this.g - 1;
+        }
+
+        int i1 = i / this.g;
+        int j1 = j / this.g;
+        Random random = this.c.A(i1, j1, 14357617);
+
+        i1 *= this.g;
+        j1 *= this.g;
+        i1 += random.nextInt(this.g - this.h);
+        j1 += random.nextInt(this.g - this.h);
+        if (k == i1 && l == j1) {
+            BiomeBase biomebase = this.c.getWorldChunkManager().getBiome(k * 16 + 8, l * 16 + 8);
+            Iterator iterator = e.iterator();
+
+            while (iterator.hasNext()) {
+                BiomeBase biomebase1 = (BiomeBase) iterator.next();
+
+                if (biomebase == biomebase1) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    protected StructureStart b(int i, int j) {
+        return new WorldGenLargeFeatureStart(this.c, this.b, i, j);
+    }
+
+    public boolean a(int i, int j, int k) {
+        StructureStart structurestart = this.c(i, j, k);
+
+        if (structurestart != null && structurestart instanceof WorldGenLargeFeatureStart && !structurestart.a.isEmpty()) {
+            StructurePiece structurepiece = (StructurePiece) structurestart.a.getFirst();
+
+            return structurepiece instanceof WorldGenWitchHut;
+        } else {
+            return false;
+        }
+    }
+
+    public List b() {
+        return this.f;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/WorldGenPackedIce2.java b/src/main/java/net/minecraft/server/WorldGenPackedIce2.java
new file mode 100644
index 0000000..c207a9c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WorldGenPackedIce2.java
@@ -0,0 +1,101 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class WorldGenPackedIce2 extends WorldGenerator {
+
+    public WorldGenPackedIce2() {}
+
+    public boolean generate(World world, Random random, int i, int j, int k) {
+        while (world.isEmpty(i, j, k) && j > 2) {
+            --j;
+        }
+
+        if (world.getType(i, j, k) != Blocks.SNOW_BLOCK) {
+            return false;
+        } else {
+            j += random.nextInt(4);
+            int l = random.nextInt(4) + 7;
+            int i1 = l / 4 + random.nextInt(2);
+
+            if (i1 > 1 && random.nextInt(60) == 0) {
+                j += 10 + random.nextInt(30);
+            }
+
+            int j1;
+            int k1;
+            int l1;
+
+            for (j1 = 0; j1 < l; ++j1) {
+                float f = (1.0F - (float) j1 / (float) l) * (float) i1;
+
+                k1 = MathHelper.f(f);
+
+                for (l1 = -k1; l1 <= k1; ++l1) {
+                    float f1 = (float) MathHelper.a(l1) - 0.25F;
+
+                    for (int i2 = -k1; i2 <= k1; ++i2) {
+                        float f2 = (float) MathHelper.a(i2) - 0.25F;
+
+                        if ((l1 == 0 && i2 == 0 || f1 * f1 + f2 * f2 <= f * f) && (l1 != -k1 && l1 != k1 && i2 != -k1 && i2 != k1 || random.nextFloat() <= 0.75F)) {
+                            Block block = world.getType(i + l1, j + j1, k + i2);
+
+                            if (block.getMaterial() == Material.AIR || block == Blocks.DIRT || block == Blocks.SNOW_BLOCK || block == Blocks.ICE) {
+                                this.setType(world, i + l1, j + j1, k + i2, Blocks.PACKED_ICE);
+                            }
+
+                            if (j1 != 0 && k1 > 1) {
+                                block = world.getType(i + l1, j - j1, k + i2);
+                                if (block.getMaterial() == Material.AIR || block == Blocks.DIRT || block == Blocks.SNOW_BLOCK || block == Blocks.ICE) {
+                                    this.setType(world, i + l1, j - j1, k + i2, Blocks.PACKED_ICE);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            j1 = i1 - 1;
+            if (j1 < 0) {
+                j1 = 0;
+            } else if (j1 > 1) {
+                j1 = 1;
+            }
+
+            for (int j2 = -j1; j2 <= j1; ++j2) {
+                k1 = -j1;
+
+                while (k1 <= j1) {
+                    l1 = j - 1;
+                    int k2 = 50;
+
+                    if (Math.abs(j2) == 1 && Math.abs(k1) == 1) {
+                        k2 = random.nextInt(5);
+                    }
+
+                    while (true) {
+                        if (l1 > 50) {
+                            Block block1 = world.getType(i + j2, l1, k + k1);
+
+                            if (block1.getMaterial() == Material.AIR || block1 == Blocks.DIRT || block1 == Blocks.SNOW_BLOCK || block1 == Blocks.ICE || block1 == Blocks.PACKED_ICE) {
+                                this.setType(world, i + j2, l1, k + k1, Blocks.PACKED_ICE);
+                                --l1;
+                                --k2;
+                                if (k2 <= 0) {
+                                    l1 -= random.nextInt(5) + 1;
+                                    k2 = random.nextInt(5);
+                                }
+                                continue;
+                            }
+                        }
+
+                        ++k1;
+                        break;
+                    }
+                }
+            }
+
+            return true;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/WorldGenVillage.java b/src/main/java/net/minecraft/server/WorldGenVillage.java
new file mode 100644
index 0000000..7ca18a1
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WorldGenVillage.java
@@ -0,0 +1,75 @@
+package net.minecraft.server;
+
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.Map.Entry;
+
+public class WorldGenVillage extends StructureGenerator {
+
+    public static final List e = Arrays.asList(new BiomeBase[] { BiomeBase.PLAINS, BiomeBase.DESERT, BiomeBase.SAVANNA});
+    private int f;
+    private int g;
+    private int h;
+
+    public WorldGenVillage() {
+        this.g = 32;
+        this.h = 8;
+    }
+
+    public WorldGenVillage(Map map) {
+        this();
+        Iterator iterator = map.entrySet().iterator();
+
+        while (iterator.hasNext()) {
+            Entry entry = (Entry) iterator.next();
+
+            if (((String) entry.getKey()).equals("size")) {
+                this.f = MathHelper.a((String) entry.getValue(), this.f, 0);
+            } else if (((String) entry.getKey()).equals("distance")) {
+                this.g = MathHelper.a((String) entry.getValue(), this.g, this.h + 1);
+            }
+        }
+    }
+
+    public String a() {
+        return "Village";
+    }
+
+    protected boolean a(int i, int j) {
+        int k = i;
+        int l = j;
+
+        if (i < 0) {
+            i -= this.g - 1;
+        }
+
+        if (j < 0) {
+            j -= this.g - 1;
+        }
+
+        int i1 = i / this.g;
+        int j1 = j / this.g;
+        Random random = this.c.A(i1, j1, 10387312);
+
+        i1 *= this.g;
+        j1 *= this.g;
+        i1 += random.nextInt(this.g - this.h);
+        j1 += random.nextInt(this.g - this.h);
+        if (k == i1 && l == j1) {
+            boolean flag = this.c.getWorldChunkManager().a(k * 16 + 8, l * 16 + 8, 0, e);
+
+            if (flag) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    protected StructureStart b(int i, int j) {
+        return new WorldGenVillageStart(this.c, this.b, i, j, this.f);
+    }
+}
diff --git a/src/main/java/org/spigotmc/SneakyThrow.java b/src/main/java/org/spigotmc/SneakyThrow.java
new file mode 100644
index 0000000..31fc0a9
--- /dev/null
+++ b/src/main/java/org/spigotmc/SneakyThrow.java
@@ -0,0 +1,15 @@
+package org.spigotmc;
+
+public class SneakyThrow
+{
+
+    public static void sneaky(Throwable t)
+    {
+        throw SneakyThrow.<RuntimeException>superSneaky( t );
+    }
+
+    private static <T extends Throwable> T superSneaky(Throwable t) throws T
+    {
+        throw (T) t;
+    }
+}
diff --git a/src/main/resources/org/spigotmc/SneakyThrow.class b/src/main/resources/org/spigotmc/SneakyThrow.class
new file mode 100644
index 0000000000000000000000000000000000000000..635518693adaeee6f771d2a4c9f92672048a4c4d
GIT binary patch
literal 184
zcmX^0Z`VEsW(HjbE=C64;Jnnt?8=agqWp5bEOrKVMh1bb#Ii*FoW#6zegCAa)Z`LI
z2Cm@z(xT*4x6GVWMg|t={1hN1q2Ys22-csNl#^<$83vTfFG|-hF33#JFUd{TN3wyD
ufvp&9A3M-~MFu7YP6iNQ1kxM~Y(Sb7$m0Xjj6j-6Yd=U5$YufY7#IQ5^(s;T

literal 0
HcmV?d00001

-- 
1.9.1


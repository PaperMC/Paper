--- a/net/minecraft/world/level/block/Block.java
+++ b/net/minecraft/world/level/block/Block.java
@@ -89,29 +_,46 @@
                 return !Shapes.joinIsNotEmpty(Shapes.block(), shape, BooleanOp.NOT_SAME);
             }
         });
-    public static final int UPDATE_NEIGHBORS = 1;
-    public static final int UPDATE_CLIENTS = 2;
-    public static final int UPDATE_INVISIBLE = 4;
-    public static final int UPDATE_IMMEDIATE = 8;
-    public static final int UPDATE_KNOWN_SHAPE = 16;
-    public static final int UPDATE_SUPPRESS_DROPS = 32;
-    public static final int UPDATE_MOVE_BY_PISTON = 64;
-    public static final int UPDATE_SKIP_SHAPE_UPDATE_ON_WIRE = 128;
-    public static final int UPDATE_SKIP_BLOCK_ENTITY_SIDEEFFECTS = 256;
-    public static final int UPDATE_SKIP_ON_PLACE = 512;
-    @Block.UpdateFlags
-    public static final int UPDATE_NONE = 260;
-    @Block.UpdateFlags
-    public static final int UPDATE_ALL = 3;
-    @Block.UpdateFlags
-    public static final int UPDATE_ALL_IMMEDIATE = 11;
-    @Block.UpdateFlags
-    public static final int UPDATE_SKIP_ALL_SIDEEFFECTS = 816;
+    // Paper start - diff on change - all listed in UpdateFlags annotation
+    public static final int UPDATE_NEIGHBORS = 1; // Paper - diff on change - all listed in UpdateFlags annotation
+    public static final int UPDATE_CLIENTS = 2; // Paper - diff on change - all listed in UpdateFlags annotation
+    public static final int UPDATE_INVISIBLE = 4; // Paper - diff on change - all listed in UpdateFlags annotation
+    public static final int UPDATE_IMMEDIATE = 8; // Paper - diff on change - all listed in UpdateFlags annotation
+    public static final int UPDATE_KNOWN_SHAPE = 16; // Paper - diff on change - all listed in UpdateFlags annotation
+    public static final int UPDATE_SUPPRESS_DROPS = 32; // Paper - diff on change - all listed in UpdateFlags annotation
+    public static final int UPDATE_MOVE_BY_PISTON = 64; // Paper - diff on change - all listed in UpdateFlags annotation
+    public static final int UPDATE_SKIP_SHAPE_UPDATE_ON_WIRE = 128; // Paper - diff on change - all listed in UpdateFlags annotation
+    public static final int UPDATE_SKIP_BLOCK_ENTITY_SIDEEFFECTS = 256; // Paper - diff on change - all listed in UpdateFlags annotation
+    public static final int UPDATE_SKIP_ON_PLACE = 512; // Paper - diff on change - all listed in UpdateFlags annotation
+    // Paper end - diff on change - all listed in UpdateFlags annotation
+    @Block.UpdateFlags
+    public static final int UPDATE_NONE = UPDATE_INVISIBLE | UPDATE_SKIP_BLOCK_ENTITY_SIDEEFFECTS; // Paper - help unpick a bit
+    @Block.UpdateFlags
+    public static final int UPDATE_ALL = UPDATE_NEIGHBORS | UPDATE_CLIENTS; // Paper - help unpick a bit
+    @Block.UpdateFlags
+    public static final int UPDATE_ALL_IMMEDIATE = UPDATE_NEIGHBORS | UPDATE_CLIENTS | UPDATE_IMMEDIATE; // Paper - help unpick a bit
+    @Block.UpdateFlags
+    public static final int UPDATE_SKIP_ALL_SIDEEFFECTS = UPDATE_KNOWN_SHAPE | UPDATE_SUPPRESS_DROPS | UPDATE_SKIP_BLOCK_ENTITY_SIDEEFFECTS | UPDATE_SKIP_ON_PLACE; // Paper - help unpick a bit
     public static final float INDESTRUCTIBLE = -1.0F;
     public static final float INSTANT = 0.0F;
     public static final int UPDATE_LIMIT = 512;
     protected final StateDefinition<Block, BlockState> stateDefinition;
     private BlockState defaultBlockState;
+    // Paper start - Protect Bedrock and End Portal/Frames from being destroyed
+    public final boolean isDestroyable() {
+        return io.papermc.paper.configuration.GlobalConfiguration.get().unsupportedSettings.allowPermanentBlockBreakExploits ||
+            this != Blocks.BARRIER &&
+            this != Blocks.BEDROCK &&
+            this != Blocks.END_PORTAL_FRAME &&
+            this != Blocks.END_PORTAL &&
+            this != Blocks.END_GATEWAY &&
+            this != Blocks.COMMAND_BLOCK &&
+            this != Blocks.REPEATING_COMMAND_BLOCK &&
+            this != Blocks.CHAIN_COMMAND_BLOCK &&
+            this != Blocks.STRUCTURE_BLOCK &&
+            this != Blocks.JIGSAW;
+    }
+    // Paper end - Protect Bedrock and End Portal/Frames from being destroyed
     private @Nullable Item item;
     private static final int CACHE_SIZE = 256;
     private static final ThreadLocal<Object2ByteLinkedOpenHashMap<Block.ShapePairKey>> OCCLUSION_CACHE = ThreadLocal.withInitial(() -> {
@@ -382,6 +_,27 @@
         return state.getDrops(params);
     }
 
+    // Paper start - Add BlockBreakBlockEvent
+    public static boolean dropResources(final BlockState state, final Level level, final BlockPos pos, final @Nullable BlockEntity blockEntity, final BlockPos source) {
+        if (level instanceof ServerLevel serverLevel) {
+            List<org.bukkit.inventory.ItemStack> items = new java.util.ArrayList<>();
+            for (ItemStack drop : Block.getDrops(state, serverLevel, pos, blockEntity)) {
+                items.add(org.bukkit.craftbukkit.inventory.CraftItemStack.asBukkitCopy(drop));
+            }
+            Block block = state.getBlock(); // Paper - Properly handle xp dropping
+            io.papermc.paper.event.block.BlockBreakBlockEvent event = new io.papermc.paper.event.block.BlockBreakBlockEvent(org.bukkit.craftbukkit.block.CraftBlock.at(level, pos), org.bukkit.craftbukkit.block.CraftBlock.at(level, source), items);
+            event.setExpToDrop(block.getExpDrop(state, serverLevel, pos, net.minecraft.world.item.ItemStack.EMPTY, true)); // Paper - Properly handle xp dropping
+            event.callEvent();
+            for (org.bukkit.inventory.ItemStack drop : event.getDrops()) {
+                popResource(serverLevel, pos, org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(drop));
+            }
+            state.spawnAfterBreak(serverLevel, pos, ItemStack.EMPTY, false); // Paper - Properly handle xp dropping
+            block.popExperience(serverLevel, pos, event.getExpToDrop()); // Paper - Properly handle xp dropping
+        }
+        return true;
+    }
+    // Paper end - Add BlockBreakBlockEvent
+
     public static void dropResources(final BlockState state, final Level level, final BlockPos pos) {
         if (level instanceof ServerLevel serverLevel) {
             getDrops(state, serverLevel, pos, null).forEach(stack -> popResource(level, pos, stack));
@@ -396,6 +_,12 @@
         }
     }
 
+    // Paper start - Properly handle xp dropping
+    public static void dropResources(final BlockState state, final Level level, final BlockPos pos, final @Nullable BlockEntity blockEntity, final @Nullable Entity breaker, final ItemStack tool) {
+        dropResources(state, level, pos, blockEntity, breaker, tool, true);
+    }
+    // Paper end - Properly handle xp dropping
+
     public static void dropResources(
         final BlockState state,
         final Level level,
@@ -403,10 +_,11 @@
         final @Nullable BlockEntity blockEntity,
         final @Nullable Entity breaker,
         final ItemStack tool
+        , final boolean dropExperience // Paper - Properly handle xp dropping
     ) {
         if (level instanceof ServerLevel serverLevel) {
             getDrops(state, serverLevel, pos, blockEntity, breaker, tool).forEach(stack -> popResource(level, pos, stack));
-            state.spawnAfterBreak(serverLevel, pos, tool, true);
+            state.spawnAfterBreak(serverLevel, pos, tool, dropExperience); // Paper - Properly handle xp dropping
         }
     }
 
@@ -439,13 +_,25 @@
         if (level instanceof ServerLevel serverLevel && !itemStack.isEmpty() && serverLevel.getGameRules().get(GameRules.BLOCK_DROPS)) {
             ItemEntity entity = entityFactory.get();
             entity.setDefaultPickUpDelay();
-            level.addFreshEntity(entity);
+            // CraftBukkit start
+            if (level.captureDrops != null) {
+                level.captureDrops.add(entity);
+            } else {
+                level.addFreshEntity(entity);
+            }
+            // CraftBukkit end
         }
     }
 
     public void popExperience(final ServerLevel level, final BlockPos pos, final int amount) {
+        // Paper start - add entity parameter
+        popExperience(level, pos, amount, null);
+    }
+
+    public void popExperience(ServerLevel level, BlockPos pos, int amount, net.minecraft.world.entity.@Nullable Entity entity) {
+        // Paper end - add entity parameter
         if (level.getGameRules().get(GameRules.BLOCK_DROPS)) {
-            ExperienceOrb.award(level, Vec3.atCenterOf(pos), amount);
+            ExperienceOrb.awardWithDirection(level, Vec3.atCenterOf(pos), net.minecraft.world.phys.Vec3.ZERO, amount, org.bukkit.entity.ExperienceOrb.SpawnReason.BLOCK_BREAK, entity, null); // Paper
         }
     }
 
@@ -463,6 +_,13 @@
         return this.defaultBlockState();
     }
 
+    // Paper start - fix drops not preventing stats/food exhaustion
+    @Deprecated @io.papermc.paper.annotation.DoNotUse
+    public void playerDestroy(final Level level, final Player player, final BlockPos pos, final BlockState state, final @Nullable BlockEntity blockEntity, final ItemStack destroyedWith) {
+        playerDestroy(level, player, pos, state, blockEntity, destroyedWith, true, true);
+    }
+    // Paper end - fix drops not preventing stats/food exhaustion
+
     public void playerDestroy(
         final Level level,
         final Player player,
@@ -470,10 +_,13 @@
         final BlockState state,
         final @Nullable BlockEntity blockEntity,
         final ItemStack destroyedWith
+        , final boolean includeDrops, final boolean dropExp // Paper - fix drops not preventing stats/food exhaustion
     ) {
         player.awardStat(Stats.BLOCK_MINED.get(this));
-        player.causeFoodExhaustion(0.005F);
-        dropResources(state, level, pos, blockEntity, player, destroyedWith);
+        player.causeFoodExhaustion(0.005F, org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason.BLOCK_MINED); // CraftBukkit - EntityExhaustionEvent
+        if (includeDrops) { // Paper - fix drops not preventing stats/food exhaustion
+        dropResources(state, level, pos, blockEntity, player, destroyedWith, dropExp); // Paper - Properly handle xp dropping
+        } // Paper - fix drops not preventing stats/food exhaustion
     }
 
     public void setPlacedBy(final Level level, final BlockPos pos, final BlockState state, final @Nullable LivingEntity by, final ItemStack itemStack) {
@@ -613,12 +_,20 @@
         return this.builtInRegistryHolder;
     }
 
-    protected void tryDropExperience(final ServerLevel level, final BlockPos pos, final ItemStack tool, final IntProvider xpRange) {
+    protected int tryDropExperience(final ServerLevel level, final BlockPos pos, final ItemStack tool, final IntProvider xpRange) { // CraftBukkit
         int experience = EnchantmentHelper.processBlockExperience(level, tool, xpRange.sample(level.getRandom()));
         if (experience > 0) {
-            this.popExperience(level, pos, experience);
+            // CraftBukkit start
+            // this.popExperience(level, pos, experience);
+            return experience;
         }
-    }
+        return 0;
+    }
+
+    public int getExpDrop(final BlockState state, final ServerLevel level, final BlockPos pos, final ItemStack tool, final boolean dropExperience) {
+        return 0;
+    }
+    // CraftBukkit end
 
     private record ShapePairKey(VoxelShape first, VoxelShape second) {
         @Override
@@ -634,6 +_,7 @@
 
     @Retention(RetentionPolicy.CLASS)
     @Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE, ElementType.METHOD, ElementType.TYPE_USE})
+    @org.intellij.lang.annotations.MagicConstant(flags = {UPDATE_NEIGHBORS, UPDATE_CLIENTS, UPDATE_INVISIBLE, UPDATE_IMMEDIATE, UPDATE_KNOWN_SHAPE, UPDATE_SUPPRESS_DROPS, UPDATE_MOVE_BY_PISTON, UPDATE_SKIP_SHAPE_UPDATE_ON_WIRE, UPDATE_SKIP_BLOCK_ENTITY_SIDEEFFECTS, UPDATE_SKIP_ON_PLACE}) // Paper - add back source-retention annotation for IDE
     public @interface UpdateFlags {
     }
 }

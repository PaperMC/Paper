--- a/net/minecraft/world/level/block/piston/PistonBaseBlock.java
+++ b/net/minecraft/world/level/block/piston/PistonBaseBlock.java
@@ -151,6 +_,12 @@
     @Override
     protected boolean triggerEvent(BlockState state, Level level, BlockPos pos, int id, int param) {
         Direction direction = state.getValue(FACING);
+        // Paper start - Protect Bedrock and End Portal/Frames from being destroyed; prevent retracting when we're facing the wrong way (we were replaced before retraction could occur)
+        Direction directionQueuedAs = Direction.from3DDataValue(param & 7); // Paper - copied from below
+        if (!io.papermc.paper.configuration.GlobalConfiguration.get().unsupportedSettings.allowPermanentBlockBreakExploits && direction != directionQueuedAs) {
+            return false;
+        }
+        // Paper end - Protect Bedrock and End Portal/Frames from being destroyed
         BlockState blockState = state.setValue(EXTENDED, true);
         if (!level.isClientSide()) {
             boolean neighborSignal = this.getNeighborSignal(level, pos, direction);
@@ -165,7 +_,7 @@
         }
 
         if (id == 0) {
-            if (!this.moveBlocks(level, pos, direction, true)) {
+            if (this.moveBlocks(level, state, pos, direction, true) != MoveBlocksResult.SUCCESS) { // Paper - Fix sticky piston retract event
                 return false;
             }
 
@@ -182,40 +_,70 @@
                 .defaultBlockState()
                 .setValue(MovingPistonBlock.FACING, direction)
                 .setValue(MovingPistonBlock.TYPE, this.isSticky ? PistonType.STICKY : PistonType.DEFAULT);
+            // Paper start - Fix sticky pistons and BlockPistonRetractEvent; Move empty piston retract call to fix multiple event fires
+            if (!this.isSticky) {
+                if (!new org.bukkit.event.block.BlockPistonRetractEvent(org.bukkit.craftbukkit.block.CraftBlock.at(level, pos), java.util.Collections.emptyList(), org.bukkit.craftbukkit.block.CraftBlock.notchToBlockFace(direction.getOpposite())).callEvent()) {
+                    return false;
+                }
+            }
+            // Paper end - Fix sticky pistons and BlockPistonRetractEvent
             level.setBlock(pos, blockState1, 276);
             level.setBlockEntity(
                 MovingPistonBlock.newMovingBlockEntity(
-                    pos, blockState1, this.defaultBlockState().setValue(FACING, Direction.from3DDataValue(param & 7)), direction, false, true
+                    pos, blockState1, this.defaultBlockState().setValue(FACING, Direction.from3DDataValue(param & 7)), direction, false, true // Paper - Protect Bedrock and End Portal/Frames from being destroyed; diff on change
                 )
             );
             level.updateNeighborsAt(pos, blockState1.getBlock());
-            blockState1.updateNeighbourShapes(level, pos, 2);
+            if (!this.isSticky) blockState1.updateNeighbourShapes(level, pos, Block.UPDATE_CLIENTS); // Paper - move sticky update down until after piston event
             if (this.isSticky) {
                 BlockPos blockPos = pos.offset(direction.getStepX() * 2, direction.getStepY() * 2, direction.getStepZ() * 2);
                 BlockState blockState2 = level.getBlockState(blockPos);
-                boolean flag = false;
+                boolean isWorkingMovingPiston = false; // Paper - OBFHELPER
                 if (blockState2.is(Blocks.MOVING_PISTON)
                     && level.getBlockEntity(blockPos) instanceof PistonMovingBlockEntity pistonMovingBlockEntity
                     && pistonMovingBlockEntity.getDirection() == direction
                     && pistonMovingBlockEntity.isExtending()) {
                     pistonMovingBlockEntity.finalTick();
-                    flag = true;
+                    isWorkingMovingPiston = true; // Paper - OBFHELPER
                 }
 
-                if (!flag) {
+                if (isWorkingMovingPiston) blockState1.updateNeighbourShapes(level, pos, Block.UPDATE_CLIENTS); // Paper - Fix sticky piston retract event; Move update to after event call
+                if (!isWorkingMovingPiston) { // Paper - OBFHELPER
                     if (id != 1
                         || blockState2.isAir()
                         || !isPushable(blockState2, level, blockPos, direction.getOpposite(), false, direction)
                         || blockState2.getPistonPushReaction() != PushReaction.NORMAL
                             && !blockState2.is(Blocks.PISTON)
                             && !blockState2.is(Blocks.STICKY_PISTON)) {
+                        // Paper start - Fix sticky pistons and BlockPistonRetractEvent; fire BlockPistonRetractEvent for sticky pistons retracting un-pushable block or air
+                        if (id == TRIGGER_CONTRACT) {
+                            if (!new org.bukkit.event.block.BlockPistonRetractEvent(org.bukkit.craftbukkit.block.CraftBlock.at(level, pos), java.util.Collections.emptyList(), org.bukkit.craftbukkit.block.CraftBlock.notchToBlockFace(direction.getOpposite())).callEvent()) {
+                                level.removeBlockEntity(pos);
+                                level.setBlock(pos, state, Block.UPDATE_KNOWN_SHAPE | Block.UPDATE_SKIP_ON_PLACE);
+                                return false;
+                            }
+                        }
+                        blockState1.updateNeighbourShapes(level, pos, Block.UPDATE_CLIENTS); // move this from right after creating the moving piston block entity to after the event call
+                        // Paper end - Fix sticky pistons and BlockPistonRetractEvent
                         level.removeBlock(pos.relative(direction), false);
                     } else {
-                        this.moveBlocks(level, pos, direction, false);
+                        // Paper start - Fix sticky piston retract event
+                        if (this.moveBlocks(level, state, pos, direction, false) == MoveBlocksResult.CANCEL) {
+                            return false;
+                        }
+                        blockState1.updateNeighbourShapes(level, pos, Block.UPDATE_CLIENTS); // move this from right after creating the moving piston block entity to after the event call
+                        // Paper end - Fix sticky piston retract event
                     }
                 }
             } else {
-                level.removeBlock(pos.relative(direction), false);
+                // Paper start - Protect Bedrock and End Portal/Frames from being destroyed; fix headless pistons breaking blocks
+                BlockPos headPos = pos.relative(direction);
+                if (io.papermc.paper.configuration.GlobalConfiguration.get().unsupportedSettings.allowPermanentBlockBreakExploits || level.getBlockState(headPos) == Blocks.PISTON_HEAD.defaultBlockState().setValue(FACING, direction)) { // double check to make sure we're not a headless piston
+                    level.removeBlock(headPos, false);
+                } else {
+                    ((ServerLevel) level).getChunkSource().blockChanged(headPos); // ... fix client desync
+                }
+                // Paper end - Protect Bedrock and End Portal/Frames from being destroyed
             }
 
             level.playSound(null, pos, SoundEvents.PISTON_CONTRACT, SoundSource.BLOCKS, 0.5F, level.random.nextFloat() * 0.15F + 0.6F);
@@ -226,7 +_,7 @@
     }
 
     public static boolean isPushable(BlockState state, Level level, BlockPos pos, Direction movementDirection, boolean allowDestroy, Direction pistonFacing) {
-        if (pos.getY() < level.getMinY() || pos.getY() > level.getMaxY() || !level.getWorldBorder().isWithinBounds(pos)) {
+        if (pos.getY() < level.getMinY() || pos.getY() > level.getMaxY() || !level.getWorldBorder().isWithinBounds(pos) || !level.getWorldBorder().isWithinBounds(pos.relative(movementDirection))) { // Paper - Fix piston world border check
             return false;
         } else if (state.isAir()) {
             return true;
@@ -258,15 +_,31 @@
         }
     }
 
-    private boolean moveBlocks(Level level, BlockPos pos, Direction facing, boolean extending) {
+    private enum MoveBlocksResult { FAIL, CANCEL, SUCCESS } // Paper - Fix sticky piston retract event
+
+    private MoveBlocksResult moveBlocks(Level level, BlockState oldState, BlockPos pos, Direction facing, boolean extending) { // Paper - Fix sticky piston retract event
         BlockPos blockPos = pos.relative(facing);
-        if (!extending && level.getBlockState(blockPos).is(Blocks.PISTON_HEAD)) {
+        // Paper start - Fix sticky piston retract event
+        final BlockState pistonHead = level.getBlockState(blockPos);
+        if (!extending && pistonHead.is(Blocks.PISTON_HEAD)) {
+            // Paper end - Fix sticky piston retract event
             level.setBlock(blockPos, Blocks.AIR.defaultBlockState(), 276);
         }
 
         PistonStructureResolver pistonStructureResolver = new PistonStructureResolver(level, pos, facing, extending);
+        Direction direction = extending ? facing : facing.getOpposite(); // Paper - Fix sticky piston retract event; moved from below
         if (!pistonStructureResolver.resolve()) {
-            return false;
+            // Paper start - Fix sticky piston retract event; Fire event if piston retracts without moving blocks
+            if (!extending) {
+                if (!new org.bukkit.event.block.BlockPistonRetractEvent(org.bukkit.craftbukkit.block.CraftBlock.at(level, pos), java.util.Collections.emptyList(), org.bukkit.craftbukkit.block.CraftBlock.notchToBlockFace(direction)).callEvent()) {
+                    level.removeBlockEntity(pos);
+                    level.setBlock(pos, oldState, Block.UPDATE_KNOWN_SHAPE | Block.UPDATE_SKIP_ON_PLACE);
+                    level.setBlock(blockPos, pistonHead, Block.UPDATE_KNOWN_SHAPE | Block.UPDATE_SKIP_ON_PLACE);
+                    return MoveBlocksResult.CANCEL;
+                }
+            }
+            return MoveBlocksResult.FAIL;
+            // Paper end - Fix sticky piston retract event
         } else {
             Map<BlockPos, BlockState> map = Maps.newHashMap();
             List<BlockPos> toPush = pistonStructureResolver.getToPush();
@@ -280,14 +_,61 @@
 
             List<BlockPos> toDestroy = pistonStructureResolver.getToDestroy();
             BlockState[] blockStates = new BlockState[toPush.size() + toDestroy.size()];
-            Direction direction = extending ? facing : facing.getOpposite();
+            // Paper - Fix sticky piston retract event; moved up
             int i = 0;
+            // CraftBukkit start
+            final org.bukkit.block.Block bukkitBlock = org.bukkit.craftbukkit.block.CraftBlock.at(level, pos);
+
+            final List<BlockPos> moved = pistonStructureResolver.getToPush();
+            final List<BlockPos> broken = pistonStructureResolver.getToDestroy();
+
+            List<org.bukkit.block.Block> blocks = new java.util.AbstractList<>() {
+
+                @Override
+                public int size() {
+                    return moved.size() + broken.size();
+                }
+
+                @Override
+                public org.bukkit.block.Block get(int index) {
+                    if (index >= this.size() || index < 0) {
+                        throw new ArrayIndexOutOfBoundsException(index);
+                    }
+
+                    BlockPos pos = index < moved.size() ? moved.get(index) : broken.get(index - moved.size());
+                    return org.bukkit.craftbukkit.block.CraftBlock.at(level, pos);
+                }
+            };
+
+            final org.bukkit.event.block.BlockPistonEvent event;
+            if (extending) {
+                event = new org.bukkit.event.block.BlockPistonExtendEvent(bukkitBlock, blocks, org.bukkit.craftbukkit.block.CraftBlock.notchToBlockFace(direction));
+            } else {
+                event = new org.bukkit.event.block.BlockPistonRetractEvent(bukkitBlock, blocks, org.bukkit.craftbukkit.block.CraftBlock.notchToBlockFace(direction));
+            }
+            if (!event.callEvent()) {
+                if (!extending) {
+                    level.removeBlockEntity(pos);
+                    level.setBlock(pos, oldState, Block.UPDATE_KNOWN_SHAPE | Block.UPDATE_SKIP_ON_PLACE);
+                    level.setBlock(blockPos, pistonHead, Block.UPDATE_KNOWN_SHAPE | Block.UPDATE_SKIP_ON_PLACE);
+                }
+                for (BlockPos brokenPos : broken) {
+                    level.sendBlockUpdated(brokenPos, Blocks.AIR.defaultBlockState(), level.getBlockState(brokenPos), Block.UPDATE_ALL);
+                }
+                for (BlockPos movedPos : moved) {
+                    level.sendBlockUpdated(movedPos, Blocks.AIR.defaultBlockState(), level.getBlockState(movedPos), Block.UPDATE_ALL);
+                    movedPos = movedPos.relative(direction);
+                    level.sendBlockUpdated(movedPos, Blocks.AIR.defaultBlockState(), level.getBlockState(movedPos), Block.UPDATE_ALL);
+                }
+                return MoveBlocksResult.CANCEL;
+            }
+            // CraftBukkit end
 
             for (int i1 = toDestroy.size() - 1; i1 >= 0; i1--) {
                 BlockPos blockPos2 = toDestroy.get(i1);
                 BlockState blockState1 = level.getBlockState(blockPos2);
                 BlockEntity blockEntity = blockState1.hasBlockEntity() ? level.getBlockEntity(blockPos2) : null;
-                dropResources(blockState1, level, blockPos2, blockEntity);
+                dropResources(blockState1, level, blockPos2, blockEntity, pos); // Paper - Add BlockBreakBlockEvent
                 if (!blockState1.is(BlockTags.FIRE) && level.isClientSide()) {
                     level.levelEvent(2001, blockPos2, getId(blockState1));
                 }
@@ -298,13 +_,26 @@
             }
 
             for (int i1 = toPush.size() - 1; i1 >= 0; i1--) {
-                BlockPos blockPos2 = toPush.get(i1);
-                BlockState blockState1 = level.getBlockState(blockPos2);
+                // Paper start - fix a variety of piston desync dupes
+                boolean allowDesync = io.papermc.paper.configuration.GlobalConfiguration.get().unsupportedSettings.allowPistonDuplication;
+                BlockPos blockPos2;
+                BlockPos oldPos = blockPos2 = toPush.get(i1);
+                BlockState blockState1 = allowDesync ? level.getBlockState(oldPos) : null;
+                // Paper end - fix a variety of piston desync dupes
                 blockPos2 = blockPos2.relative(direction);
                 map.remove(blockPos2);
                 BlockState blockState2 = Blocks.MOVING_PISTON.defaultBlockState().setValue(FACING, facing);
                 level.setBlock(blockPos2, blockState2, 324);
-                level.setBlockEntity(MovingPistonBlock.newMovingBlockEntity(blockPos2, blockState2, list.get(i1), facing, extending, false));
+                // Paper start - fix a variety of piston desync dupes
+                if (!allowDesync) {
+                    blockState1 = level.getBlockState(oldPos);
+                    map.replace(oldPos, blockState1);
+                }
+                level.setBlockEntity(MovingPistonBlock.newMovingBlockEntity(blockPos2, blockState2, allowDesync ? list.get(i1) : blockState1, facing, extending, false));
+                if (!allowDesync) {
+                    level.setBlock(oldPos, Blocks.AIR.defaultBlockState(), Block.UPDATE_CLIENTS | Block.UPDATE_KNOWN_SHAPE | Block.UPDATE_MOVE_BY_PISTON | Block.UPDATE_SKIP_ON_PLACE); // set air to prevent later physics updates from seeing this block
+                }
+                // Paper end - fix a variety of piston desync dupes
                 blockStates[i++] = blockState1;
             }
 
@@ -359,7 +_,7 @@
                 level.updateNeighborsAt(blockPos, Blocks.PISTON_HEAD, orientation);
             }
 
-            return true;
+            return MoveBlocksResult.SUCCESS; // Paper - Fix sticky piston retract event
         }
     }
 

--- a/net/minecraft/world/level/chunk/storage/ChunkStorage.java
+++ b/net/minecraft/world/level/chunk/storage/ChunkStorage.java
@@ -38,17 +_,63 @@
         return this.worker.isOldChunkAround(pos, radius);
     }
 
+    // CraftBukkit start
+    private boolean check(net.minecraft.server.level.ServerChunkCache cps, int x, int z) {
+        if (true) return true; // Paper - Perf: this isn't even needed anymore, light is purged updating to 1.14+, why are we holding up the conversion process reading chunk data off disk - return true, we need to set light populated to true so the converter recognizes the chunk as being "full"
+        ChunkPos pos = new ChunkPos(x, z);
+        if (cps != null) {
+            com.google.common.base.Preconditions.checkState(org.bukkit.Bukkit.isPrimaryThread(), "primary thread");
+            if (cps.hasChunk(x, z)) {
+                return true;
+            }
+        }
+
+        CompoundTag nbt;
+        try {
+            nbt = this.read(pos).get().orElse(null);
+        } catch (InterruptedException | java.util.concurrent.ExecutionException ex) {
+            throw new RuntimeException(ex);
+        }
+        if (nbt != null) {
+            CompoundTag level = nbt.getCompound("Level");
+            if (level.getBoolean("TerrainPopulated")) {
+                return true;
+            }
+
+            net.minecraft.world.level.chunk.status.ChunkStatus status = net.minecraft.world.level.chunk.status.ChunkStatus.byName(level.getString("Status"));
+            if (status != null && status.isOrAfter(net.minecraft.world.level.chunk.status.ChunkStatus.FEATURES)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
     public CompoundTag upgradeChunkTag(
-        ResourceKey<Level> levelKey,
+        ResourceKey<net.minecraft.world.level.dimension.LevelStem> levelKey,
         Supplier<DimensionDataStorage> storage,
         CompoundTag chunkData,
-        Optional<ResourceKey<MapCodec<? extends ChunkGenerator>>> chunkGeneratorKey
+        Optional<ResourceKey<MapCodec<? extends ChunkGenerator>>> chunkGeneratorKey,
+        ChunkPos pos,
+        @Nullable net.minecraft.world.level.LevelAccessor generatoraccess
+        // CraftBukkit end
     ) {
         int version = getVersion(chunkData);
         if (version == SharedConstants.getCurrentVersion().getDataVersion().getVersion()) {
             return chunkData;
         } else {
             try {
+                // CraftBukkit start
+                if (version < 1466) {
+                    CompoundTag level = chunkData.getCompound("Level");
+                    if (level.getBoolean("TerrainPopulated") && !level.getBoolean("LightPopulated")) {
+                        net.minecraft.server.level.ServerChunkCache cps = (generatoraccess == null) ? null : ((net.minecraft.server.level.ServerLevel) generatoraccess).getChunkSource();
+                        if (this.check(cps, pos.x - 1, pos.z) && this.check(cps, pos.x - 1, pos.z - 1) && this.check(cps, pos.x, pos.z - 1)) {
+                            level.putBoolean("LightPopulated", true);
+                        }
+                    }
+                }
+                // CraftBukkit end
                 if (version < 1493) {
                     chunkData = DataFixTypes.CHUNK.update(this.fixerUpper, chunkData, version, 1493);
                     if (chunkData.getCompound("Level").getBoolean("hasLegacyStructureData")) {
@@ -57,8 +_,22 @@
                     }
                 }
 
+                // Spigot start - SPIGOT-6806: Quick and dirty way to prevent below zero generation in old chunks, by setting the status to heightmap instead of empty
+                boolean stopBelowZero = false;
+                boolean belowZeroGenerationInExistingChunks = (generatoraccess != null) ? ((net.minecraft.server.level.ServerLevel) generatoraccess).spigotConfig.belowZeroGenerationInExistingChunks : org.spigotmc.SpigotConfig.belowZeroGenerationInExistingChunks;
+
+                if (version <= 2730 && !belowZeroGenerationInExistingChunks) {
+                    stopBelowZero = "full".equals(chunkData.getCompound("Level").getString("Status"));
+                }
+                // Spigot end
+
                 injectDatafixingContext(chunkData, levelKey, chunkGeneratorKey);
                 chunkData = DataFixTypes.CHUNK.updateToCurrentVersion(this.fixerUpper, chunkData, Math.max(1493, version));
+                // Spigot start
+                if (stopBelowZero) {
+                    chunkData.putString("Status", net.minecraft.core.registries.BuiltInRegistries.CHUNK_STATUS.getKey(net.minecraft.world.level.chunk.status.ChunkStatus.SPAWN).toString());
+                }
+                // Spigot end
                 removeDatafixingContext(chunkData);
                 NbtUtils.addCurrentDataVersion(chunkData);
                 return chunkData;
@@ -71,7 +_,7 @@
         }
     }
 
-    private LegacyStructureDataHandler getLegacyStructureHandler(ResourceKey<Level> level, Supplier<DimensionDataStorage> storage) {
+    private LegacyStructureDataHandler getLegacyStructureHandler(ResourceKey<net.minecraft.world.level.dimension.LevelStem> level, Supplier<DimensionDataStorage> storage) { // CraftBukkit
         LegacyStructureDataHandler legacyStructureDataHandler = this.legacyStructureHandler;
         if (legacyStructureDataHandler == null) {
             synchronized (this) {
@@ -86,7 +_,7 @@
     }
 
     public static void injectDatafixingContext(
-        CompoundTag chunkData, ResourceKey<Level> levelKey, Optional<ResourceKey<MapCodec<? extends ChunkGenerator>>> chunkGeneratorKey
+        CompoundTag chunkData, ResourceKey<net.minecraft.world.level.dimension.LevelStem> levelKey, Optional<ResourceKey<MapCodec<? extends ChunkGenerator>>> chunkGeneratorKey // CraftBukkit
     ) {
         CompoundTag compoundTag = new CompoundTag();
         compoundTag.putString("dimension", levelKey.location().toString());
@@ -107,8 +_,19 @@
     }
 
     public CompletableFuture<Void> write(ChunkPos pos, Supplier<CompoundTag> tagSupplier) {
+        // Paper start - guard against possible chunk pos desync
+        final Supplier<CompoundTag> guardedPosCheck = () -> {
+            CompoundTag nbt = tagSupplier.get();
+            if (nbt != null && !pos.equals(SerializableChunkData.getChunkCoordinate(nbt))) {
+                final String world = (ChunkStorage.this instanceof net.minecraft.server.level.ChunkMap) ? ((net.minecraft.server.level.ChunkMap) ChunkStorage.this).level.getWorld().getName() : null;
+                throw new IllegalArgumentException("Chunk coordinate and serialized data do not have matching coordinates, trying to serialize coordinate " + pos
+                    + " but compound says coordinate is " + SerializableChunkData.getChunkCoordinate(nbt) + (world == null ? " for an unknown world" : (" for world: " + world)));
+            }
+            return nbt;
+        };
+        // Paper end - guard against possible chunk pos desync
         this.handleLegacyStructureIndex(pos);
-        return this.worker.store(pos, tagSupplier);
+        return this.worker.store(pos, guardedPosCheck); // Paper - guard against possible chunk pos desync
     }
 
     protected void handleLegacyStructureIndex(ChunkPos chunkPos) {

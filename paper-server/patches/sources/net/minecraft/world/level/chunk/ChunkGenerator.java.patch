--- a/net/minecraft/world/level/chunk/ChunkGenerator.java
+++ b/net/minecraft/world/level/chunk/ChunkGenerator.java
@@ -104,8 +_,8 @@
 
     protected abstract MapCodec<? extends ChunkGenerator> codec();
 
-    public ChunkGeneratorStructureState createState(HolderLookup<StructureSet> structureSetLookup, RandomState randomState, long seed) {
-        return ChunkGeneratorStructureState.createForNormal(randomState, seed, this.biomeSource, structureSetLookup);
+    public ChunkGeneratorStructureState createState(HolderLookup<StructureSet> structureSetLookup, RandomState randomState, long seed, org.spigotmc.SpigotWorldConfig conf) { // Spigot
+        return ChunkGeneratorStructureState.createForNormal(randomState, seed, this.biomeSource, structureSetLookup, conf); // Spigot
     }
 
     public Optional<ResourceKey<MapCodec<? extends ChunkGenerator>>> getTypeNameForDataFixer() {
@@ -127,6 +_,24 @@
     public Pair<BlockPos, Holder<Structure>> findNearestMapStructure(
         ServerLevel level, HolderSet<Structure> structure, BlockPos pos, int searchRadius, boolean skipKnownStructures
     ) {
+        // Paper start - StructuresLocateEvent
+        final org.bukkit.World bukkitWorld = level.getWorld();
+        final org.bukkit.Location origin = io.papermc.paper.util.MCUtil.toLocation(level, pos);
+        final List<org.bukkit.generator.structure.Structure> apiStructures = structure.stream().map(Holder::value).map(nms -> org.bukkit.craftbukkit.generator.structure.CraftStructure.minecraftToBukkit(nms)).toList();
+        if (!apiStructures.isEmpty()) {
+            final io.papermc.paper.event.world.StructuresLocateEvent event = new io.papermc.paper.event.world.StructuresLocateEvent(bukkitWorld, origin, apiStructures, searchRadius, skipKnownStructures);
+            if (!event.callEvent()) {
+                return null;
+            }
+            if (event.getResult() != null) {
+                return Pair.of(io.papermc.paper.util.MCUtil.toBlockPos(event.getResult().pos()), level.registryAccess().lookupOrThrow(Registries.STRUCTURE).wrapAsHolder(org.bukkit.craftbukkit.generator.structure.CraftStructure.bukkitToMinecraft(event.getResult().structure())));
+            }
+            pos = io.papermc.paper.util.MCUtil.toBlockPosition(event.getOrigin());
+            searchRadius = event.getRadius();
+            skipKnownStructures = event.shouldFindUnexplored();
+            structure = HolderSet.direct(api -> level.registryAccess().lookupOrThrow(Registries.STRUCTURE).wrapAsHolder(org.bukkit.craftbukkit.generator.structure.CraftStructure.bukkitToMinecraft(api)), event.getStructures());
+        }
+        // Paper end
         ChunkGeneratorStructureState generatorState = level.getChunkSource().getGeneratorState();
         Map<StructurePlacement, Set<Holder<Structure>>> map = new Object2ObjectArrayMap<>();
 
@@ -222,6 +_,7 @@
             BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
 
             for (ChunkPos chunkPos : ringPositionsFor) {
+                if (!level.paperConfig().environment.locateStructuresOutsideWorldBorder && !level.getWorldBorder().isChunkInBounds(chunkPos.x, chunkPos.z)) { continue; } // Paper - Bound treasure maps to world border
                 mutableBlockPos.set(SectionPos.sectionToBlockCoord(chunkPos.x, 8), 32, SectionPos.sectionToBlockCoord(chunkPos.z, 8));
                 double d1 = mutableBlockPos.distSqr(pos);
                 boolean flag = pair == null || d1 < d;
@@ -255,11 +_,15 @@
         int spacing = spreadPlacement.spacing();
 
         for (int i = -z; i <= z; i++) {
-            boolean flag = i == -z || i == z;
+            // Paper start - Perf: iterate over border chunks instead of entire square chunk area
+            final int radius = z;
+            boolean flag = i == -z || i == z; final boolean onBorderAlongZAxis = flag; // Paper - OBFHELPER
 
-            for (int i1 = -z; i1 <= z; i1++) {
-                boolean flag1 = i1 == -z || i1 == z;
-                if (flag || flag1) {
+            for (int i1 = -radius; i1 <= radius; i1 += onBorderAlongZAxis ? 1 : radius * 2) {
+                // boolean flag1 = i1 == -z || i1 == z;
+                // if (flag || flag1) {
+                if (true) {
+            // Paper end - Perf: iterate over border chunks instead of entire square chunk area
                     int i2 = x + spacing * i;
                     int i3 = y + spacing * i1;
                     ChunkPos potentialStructureChunk = spreadPlacement.getPotentialStructureChunk(seed, i2, i3);
@@ -312,7 +_,7 @@
         }
     }
 
-    public void applyBiomeDecoration(WorldGenLevel level, ChunkAccess chunk, StructureManager structureManager) {
+    public void addVanillaDecorations(WorldGenLevel level, ChunkAccess chunk, StructureManager structureManager) { // CraftBukkit - rename
         ChunkPos pos = chunk.getPos();
         if (!SharedConstants.debugVoidTerrain(pos)) {
             SectionPos sectionPos = SectionPos.of(pos, level.getMinSectionY());
@@ -338,30 +_,7 @@
                 int max = Math.max(GenerationStep.Decoration.values().length, size);
 
                 for (int i = 0; i < max; i++) {
-                    int i1 = 0;
-                    if (structureManager.shouldGenerateStructures()) {
-                        for (Structure structure : map.getOrDefault(i, Collections.emptyList())) {
-                            worldgenRandom.setFeatureSeed(l, i1, i);
-                            Supplier<String> supplier = () -> registry.getResourceKey(structure).map(Object::toString).orElseGet(structure::toString);
-
-                            try {
-                                level.setCurrentlyGenerating(supplier);
-                                structureManager.startsForStructure(sectionPos, structure)
-                                    .forEach(
-                                        structureStart -> structureStart.placeInChunk(
-                                            level, structureManager, this, worldgenRandom, getWritableArea(chunk), pos
-                                        )
-                                    );
-                            } catch (Exception var29) {
-                                CrashReport crashReport = CrashReport.forThrowable(var29, "Feature placement");
-                                crashReport.addCategory("Feature").setDetail("Description", supplier::get);
-                                throw new ReportedException(crashReport);
-                            }
-
-                            i1++;
-                        }
-                    }
-
+                    this.placeStructuresInStep(i, l, level, chunk, structureManager, sectionPos, map, registry, worldgenRandom); // Paper - fix structures not generating when decorations are disabled
                     if (i < size) {
                         IntSet set1 = new IntArraySet();
 
@@ -385,7 +_,14 @@
                             int i3 = ints[i2];
                             PlacedFeature placedFeature = stepFeatureData1.features().get(i3);
                             Supplier<String> supplier1 = () -> registry1.getResourceKey(placedFeature).map(Object::toString).orElseGet(placedFeature::toString);
-                            worldgenRandom.setFeatureSeed(l, i3, i);
+                            // Paper start - Configurable feature seeds; change populationSeed used in random
+                            long featurePopulationSeed = l;
+                            final long configFeatureSeed = level.getMinecraftWorld().paperConfig().featureSeeds.features.getLong(placedFeature.feature());
+                            if (configFeatureSeed != -1) {
+                                featurePopulationSeed = worldgenRandom.setDecorationSeed(configFeatureSeed, blockPos.getX(), blockPos.getZ()); // See WorldgenRandom.setDecorationSeed from above
+                            }
+                            worldgenRandom.setFeatureSeed(featurePopulationSeed, i3, i);
+                            // Paper end - Configurable feature seeds
 
                             try {
                                 level.setCurrentlyGenerating(supplier1);
@@ -407,6 +_,45 @@
             }
         }
     }
+   // CraftBukkit start
+    public void applyBiomeDecoration(WorldGenLevel level, ChunkAccess chunk, StructureManager structureManager) {
+        this.applyBiomeDecoration(level, chunk, structureManager, true);
+    }
+
+    public void applyBiomeDecoration(WorldGenLevel level, ChunkAccess chunk, StructureManager structureManager, boolean addVanillaDecorations) {
+        if (addVanillaDecorations) {
+            this.addVanillaDecorations(level, chunk, structureManager);
+        } else if (structureManager.shouldGenerateStructures()) { // Paper start - fix structures not generating when decorations are disabled
+            ChunkPos pos = chunk.getPos();
+            SectionPos sectionPos = SectionPos.of(pos, level.getMinSectionY());
+            Registry<Structure> registry = level.registryAccess().lookupOrThrow(Registries.STRUCTURE);
+            Map<Integer, List<Structure>> structureStepMap = registry.stream()
+                .collect(Collectors.groupingBy(s -> s.step().ordinal()));
+            List<FeatureSorter.StepFeatureData> features = this.featuresPerStep.get();
+            WorldgenRandom rand = new WorldgenRandom(new XoroshiroRandomSource(RandomSupport.generateUniqueSeed()));
+            long seed = rand.setDecorationSeed(level.getSeed(), pos.getMinBlockX(), pos.getMinBlockZ());
+            for (int i = 0; i < features.size(); i++) {
+                this.placeStructuresInStep(i, seed, level, chunk, structureManager, sectionPos, structureStepMap, registry, rand);
+            }
+        }
+        // Paper end - fix structures not generating when decorations are disabled
+
+        org.bukkit.World world = level.getMinecraftWorld().getWorld();
+        // only call when a populator is present (prevents unnecessary entity conversion)
+        if (!world.getPopulators().isEmpty()) {
+            org.bukkit.craftbukkit.generator.CraftLimitedRegion limitedRegion = new org.bukkit.craftbukkit.generator.CraftLimitedRegion(level, chunk.getPos());
+            int x = chunk.getPos().x;
+            int z = chunk.getPos().z;
+            for (org.bukkit.generator.BlockPopulator populator : world.getPopulators()) {
+                WorldgenRandom seededrandom = new WorldgenRandom(new net.minecraft.world.level.levelgen.LegacyRandomSource(level.getSeed()));
+                seededrandom.setDecorationSeed(level.getSeed(), x, z);
+                populator.populate(world, new org.bukkit.craftbukkit.util.RandomSourceWrapper.RandomWrapper(seededrandom), x, z, limitedRegion);
+            }
+            limitedRegion.saveEntities();
+            limitedRegion.breakLink();
+        }
+    }
+    // CraftBukkit end
 
     private static BoundingBox getWritableArea(ChunkAccess chunk) {
         ChunkPos pos = chunk.getPos();
@@ -483,7 +_,7 @@
                         }
                     }
 
-                    if (structurePlacement.isStructureChunk(structureState, pos.x, pos.z)) {
+                    if (structurePlacement.isStructureChunk(structureState, pos.x, pos.z, structurePlacement instanceof net.minecraft.world.level.chunk.ChunkGeneratorStructureState.KeyedRandomSpreadStructurePlacement keyed ? keyed.key : null)) { // Paper - Add missing structure set seed configs
                         if (list.size() == 1) {
                             this.tryGenerateStructure(
                                 list.get(0),
@@ -577,6 +_,14 @@
             predicate
         );
         if (structureStart.isValid()) {
+            // CraftBukkit start
+            BoundingBox box = structureStart.getBoundingBox();
+            org.bukkit.event.world.AsyncStructureSpawnEvent event = new org.bukkit.event.world.AsyncStructureSpawnEvent(structureManager.level.getMinecraftWorld().getWorld(), org.bukkit.craftbukkit.generator.structure.CraftStructure.minecraftToBukkit(structure), new org.bukkit.util.BoundingBox(box.minX(), box.minY(), box.minZ(), box.maxX(), box.maxY(), box.maxZ()), chunkPos.x, chunkPos.z);
+            org.bukkit.Bukkit.getPluginManager().callEvent(event);
+            if (event.isCancelled()) {
+                return true;
+            }
+            // CraftBukkit end
             structureManager.setStartForStructure(sectionPos, structure, structureStart, chunk);
             return true;
         } else {
@@ -648,4 +_,42 @@
     public BiomeGenerationSettings getBiomeGenerationSettings(Holder<Biome> biome) {
         return this.generationSettingsGetter.apply(biome);
     }
+
+    // Paper start - fix structures not generating when decorations are disabled
+    private void placeStructuresInStep(
+        int stepIndex,
+        long decorationSeed,
+        WorldGenLevel level,
+        ChunkAccess chunk,
+        StructureManager structureManager,
+        SectionPos sectionPos,
+        Map<Integer, List<Structure>> structureStepMap,
+        Registry<Structure> structureRegistry,
+        WorldgenRandom worldgenRandom
+    ) {
+        int i1 = 0;
+        ChunkPos pos = chunk.getPos();
+        if (structureManager.shouldGenerateStructures()) {
+            for (Structure structure : structureStepMap.getOrDefault(stepIndex, Collections.emptyList())) {
+                worldgenRandom.setFeatureSeed(decorationSeed, i1, stepIndex);
+                Supplier<String> supplier = () -> structureRegistry.getResourceKey(structure).map(Object::toString).orElseGet(structure::toString);
+
+                try {
+                    level.setCurrentlyGenerating(supplier);
+                    structureManager.startsForStructure(sectionPos, structure)
+                        .forEach(
+                            structureStart -> structureStart.placeInChunk(
+                                level, structureManager, this, worldgenRandom, getWritableArea(chunk), pos)
+                        );
+                } catch (Exception var29) {
+                    CrashReport crashReport = CrashReport.forThrowable(var29, "Feature placement");
+                    crashReport.addCategory("Feature").setDetail("Description", supplier::get);
+                    throw new ReportedException(crashReport);
+                }
+
+                i1++;
+            }
+        }
+    }
+    // Paper end - fix structures not generating when decorations are disabled
 }

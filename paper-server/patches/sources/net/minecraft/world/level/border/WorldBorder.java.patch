--- a/net/minecraft/world/level/border/WorldBorder.java
+++ b/net/minecraft/world/level/border/WorldBorder.java
@@ -33,6 +_,8 @@
     double centerZ;
     int absoluteMaxSize = 29999984;
     WorldBorder.BorderExtent extent = new WorldBorder.StaticBorderExtent(5.999997E7F);
+    public net.minecraft.server.level.@org.jspecify.annotations.Nullable ServerLevel world; // CraftBukkit
+    private int lastTick = -1; // Paper - Prevent ticking virtual world borders multiple times per server tick
 
     public WorldBorder() {
         this(WorldBorder.Settings.DEFAULT);
@@ -54,6 +_,20 @@
         return this.isWithinBounds(chunkPos.getMinBlockX(), chunkPos.getMinBlockZ()) && this.isWithinBounds(chunkPos.getMaxBlockX(), chunkPos.getMaxBlockZ());
     }
 
+    // Paper start - Bound treasure maps to world border
+    private final BlockPos.MutableBlockPos mutPos = new BlockPos.MutableBlockPos();
+
+    public boolean isBlockInBounds(int x, int z) {
+        this.mutPos.set(x, 64, z);
+        return this.isWithinBounds(this.mutPos);
+    }
+
+    public boolean isChunkInBounds(int chunkX, int chunkZ) {
+        this.mutPos.set(((chunkX << 4) + 15), 64, (chunkZ << 4) + 15);
+        return this.isWithinBounds(this.mutPos);
+    }
+    // Paper end - Bound treasure maps to world border
+
     public boolean isWithinBounds(AABB box) {
         return this.isWithinBounds(box.minX, box.minZ, box.maxX - 1.0E-5F, box.maxZ - 1.0E-5F);
     }
@@ -158,6 +_,14 @@
     }
 
     public void setCenter(double x, double z) {
+        // Paper start - Add worldborder events
+        if (this.world != null) {
+            io.papermc.paper.event.world.border.WorldBorderCenterChangeEvent event = new io.papermc.paper.event.world.border.WorldBorderCenterChangeEvent(world.getWorld(), world.getWorld().getWorldBorder(), new org.bukkit.Location(world.getWorld(), this.getCenterX(), 0, this.getCenterZ()), new org.bukkit.Location(world.getWorld(), x, 0, z));
+            if (!event.callEvent()) return;
+            x = event.getNewCenter().getX();
+            z = event.getNewCenter().getZ();
+        }
+        // Paper end - Add worldborder events
         this.centerX = x;
         this.centerZ = z;
         this.extent.onCenterChange();
@@ -181,6 +_,17 @@
     }
 
     public void setSize(double size) {
+        // Paper start - Add worldborder events
+        if (this.world != null) {
+            io.papermc.paper.event.world.border.WorldBorderBoundsChangeEvent event = new io.papermc.paper.event.world.border.WorldBorderBoundsChangeEvent(world.getWorld(), world.getWorld().getWorldBorder(), io.papermc.paper.event.world.border.WorldBorderBoundsChangeEvent.Type.INSTANT_MOVE, getSize(), size, 0);
+            if (!event.callEvent()) return;
+            if (event.getType() == io.papermc.paper.event.world.border.WorldBorderBoundsChangeEvent.Type.STARTED_MOVE && event.getDurationTicks() > 0) { // If changed to a timed transition
+                lerpSizeBetween(event.getOldSize(), event.getNewSize(), event.getDurationTicks(), this.world.getGameTime());
+                return;
+            }
+            size = event.getNewSize();
+        }
+        // Paper end - Add worldborder events
         this.extent = new WorldBorder.StaticBorderExtent(size);
         this.setDirty();
 
@@ -190,6 +_,20 @@
     }
 
     public void lerpSizeBetween(double oldSize, double newSize, long time, long startTime) {
+        // Paper start - Add worldborder events
+        if (this.world != null) {
+            io.papermc.paper.event.world.border.WorldBorderBoundsChangeEvent.Type type;
+            if (oldSize == newSize) { // new size = old size
+                type = io.papermc.paper.event.world.border.WorldBorderBoundsChangeEvent.Type.INSTANT_MOVE; // Use INSTANT_MOVE because below it creates a Static border if they are equal.
+            } else {
+                type = io.papermc.paper.event.world.border.WorldBorderBoundsChangeEvent.Type.STARTED_MOVE;
+            }
+            io.papermc.paper.event.world.border.WorldBorderBoundsChangeEvent event = new io.papermc.paper.event.world.border.WorldBorderBoundsChangeEvent(world.getWorld(), world.getWorld().getWorldBorder(), type, oldSize, newSize, time);
+            if (!event.callEvent()) return;
+            newSize = event.getNewSize();
+            time = event.getDurationTicks();
+        }
+        // Paper end - Add worldborder events
         this.extent = (WorldBorder.BorderExtent)(oldSize == newSize
             ? new WorldBorder.StaticBorderExtent(newSize)
             : new WorldBorder.MovingBorderExtent(oldSize, newSize, time, startTime));
@@ -205,6 +_,7 @@
     }
 
     public void addListener(BorderChangeListener listener) {
+        if (this.listeners.contains(listener)) return; // CraftBukkit
         this.listeners.add(listener);
     }
 
@@ -278,6 +_,12 @@
     }
 
     public void tick() {
+        // Paper start - Prevent ticking virtual world borders multiple times per server tick
+        if (this.lastTick == net.minecraft.server.MinecraftServer.currentTick) {
+            return;
+        }
+        this.lastTick = net.minecraft.server.MinecraftServer.currentTick;
+        // Paper end - Prevent ticking virtual world borders multiple times per server tick
         this.extent = this.extent.update();
     }
 
@@ -298,6 +_,22 @@
         }
     }
 
+    // Paper start - add back applySettings
+    public void applySettings(net.minecraft.world.level.border.WorldBorder.Settings settings) {
+        this.setCenter(settings.centerX(), settings.centerZ());
+        this.setDamagePerBlock(settings.damagePerBlock());
+        this.setSafeZone(settings.safeZone());
+        this.setWarningBlocks(settings.warningBlocks());
+        this.setWarningTime(settings.warningTime());
+        if (settings.lerpTime() > 0L) {
+            final long startTime = (this.world != null) ? this.world.getGameTime() : 0; // Virtual Borders don't have a World
+            this.lerpSizeBetween(settings.size(), settings.lerpTarget(), settings.lerpTime(), startTime);
+        } else {
+            this.setSize(settings.size());
+        }
+    }
+    // Paper end - add back applySettings
+
     interface BorderExtent {
         double getMinX(float partialTick);
 
@@ -432,6 +_,7 @@
             this.previousSize = this.size;
             this.size = this.calculateSize();
             if (this.lerpProgress <= 0L) {
+                if (world != null) new io.papermc.paper.event.world.border.WorldBorderBoundsChangeFinishEvent(world.getWorld(), world.getWorld().getWorldBorder(), this.from, this.to, this.lerpDuration).callEvent(); // Paper - Add worldborder events
                 WorldBorder.this.setDirty();
                 return WorldBorder.this.new StaticBorderExtent(this.to);
             } else {

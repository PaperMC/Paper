--- a/net/minecraft/world/entity/player/Player.java
+++ b/net/minecraft/world/entity/player/Player.java
@@ -151,7 +_,7 @@
     private static final int DEFAULT_CURRENT_IMPULSE_CONTEXT_RESET_GRACE_TIME = 0;
     public static final float CREATIVE_ENTITY_INTERACTION_RANGE_MODIFIER_VALUE = 2.0F;
     final Inventory inventory;
-    protected PlayerEnderChestContainer enderChestInventory = new PlayerEnderChestContainer();
+    protected PlayerEnderChestContainer enderChestInventory = new PlayerEnderChestContainer(this); // CraftBukkit - add "this" to constructor
     public final InventoryMenu inventoryMenu;
     public AbstractContainerMenu containerMenu;
     protected FoodData foodData = new FoodData();
@@ -177,6 +_,18 @@
     public @Nullable Entity currentExplosionCause;
     private boolean ignoreFallDamageFromCurrentImpulse = false;
     private int currentImpulseContextResetGraceTime = 0;
+    public boolean affectsSpawning = true; // Paper - Affects Spawning API
+    public net.kyori.adventure.util.TriState flyingFallDamage = net.kyori.adventure.util.TriState.NOT_SET; // Paper - flying fall damage
+
+    // CraftBukkit start
+    public boolean fauxSleeping;
+    public int oldLevel = -1;
+
+    @Override
+    public org.bukkit.craftbukkit.entity.CraftHumanEntity getBukkitEntity() {
+        return (org.bukkit.craftbukkit.entity.CraftHumanEntity) super.getBukkitEntity();
+    }
+    // CraftBukkit end
 
     public Player(Level level, GameProfile gameProfile) {
         super(EntityType.PLAYER, level);
@@ -244,6 +_,13 @@
 
         if (this.isSleeping()) {
             this.sleepCounter++;
+            // Paper start - Add PlayerDeepSleepEvent
+            if (this.sleepCounter == SLEEP_DURATION) {
+                if (!new io.papermc.paper.event.player.PlayerDeepSleepEvent((org.bukkit.entity.Player) getBukkitEntity()).callEvent()) {
+                    this.sleepCounter = Integer.MIN_VALUE;
+                }
+            }
+            // Paper end - Add PlayerDeepSleepEvent
             if (this.sleepCounter > 100) {
                 this.sleepCounter = 100;
             }
@@ -273,7 +_,7 @@
         ItemStack mainHandItem = this.getMainHandItem();
         if (!ItemStack.matches(this.lastItemInMainHand, mainHandItem)) {
             if (!ItemStack.isSameItem(this.lastItemInMainHand, mainHandItem)) {
-                this.resetAttackStrengthTicker();
+                this.resetAttackStrengthTicker(); // Paper - diff on change (detectEquipmentUpdates override)
             }
 
             this.lastItemInMainHand = mainHandItem.copy();
@@ -327,7 +_,7 @@
     }
 
     private void turtleHelmetTick() {
-        this.addEffect(new MobEffectInstance(MobEffects.WATER_BREATHING, 200, 0, false, false, true));
+        this.addEffect(new MobEffectInstance(MobEffects.WATER_BREATHING, 200, 0, false, false, true), org.bukkit.event.entity.EntityPotionEffectEvent.Cause.TURTLE_HELMET); // CraftBukkit
     }
 
     private boolean isEquipped(Item item) {
@@ -428,6 +_,18 @@
         }
     }
 
+    // Paper start - Inventory close reason; unused code, but to keep signatures aligned
+    public void closeContainer(org.bukkit.event.inventory.InventoryCloseEvent.Reason reason) {
+        this.closeContainer();
+        this.containerMenu = this.inventoryMenu;
+    }
+    // Paper end - Inventory close reason
+    // Paper start - special close for unloaded inventory
+    public void closeUnloadedInventory(org.bukkit.event.inventory.InventoryCloseEvent.Reason reason) {
+        this.containerMenu = this.inventoryMenu;
+    }
+    // Paper end - special close for unloaded inventory
+
     public void closeContainer() {
         this.containerMenu = this.inventoryMenu;
     }
@@ -439,8 +_,14 @@
     public void rideTick() {
         if (!this.level().isClientSide() && this.wantsToStopRiding() && this.isPassenger()) {
             this.stopRiding();
-            this.setShiftKeyDown(false);
-        } else {
+            // CraftBukkit start - SPIGOT-7316: no longer passenger, dismount and return
+            if (!this.isPassenger()) {
+                this.setShiftKeyDown(false);
+                return;
+            }
+        }
+        {
+            // CraftBukkit end
             super.rideTick();
         }
     }
@@ -699,10 +_,10 @@
             if (this.isDeadOrDying()) {
                 return false;
             } else {
-                this.removeEntitiesOnShoulder();
+                // this.removeEntitiesOnShoulder(); // CraftBukkit - moved down
                 if (damageSource.scalesWithDifficulty()) {
                     if (level.getDifficulty() == Difficulty.PEACEFUL) {
-                        amount = 0.0F;
+                        return false; // CraftBukkit - f = 0.0f -> return false
                     }
 
                     if (level.getDifficulty() == Difficulty.EASY) {
@@ -714,7 +_,14 @@
                     }
                 }
 
-                return amount != 0.0F && super.hurtServer(level, damageSource, amount);
+                // return amount != 0.0F && super.hurtServer(level, damageSource, amount);
+                // CraftBukkit start - Don't filter out 0 damage
+                boolean damaged = super.hurtServer(level, damageSource, amount);
+                if (damaged) {
+                    this.removeEntitiesOnShoulder();
+                }
+                return damaged;
+                // CraftBukkit end
             }
         }
     }
@@ -726,7 +_,7 @@
         BlocksAttacks blocksAttacks = itemBlockingWith != null ? itemBlockingWith.get(DataComponents.BLOCKS_ATTACKS) : null;
         float secondsToDisableBlocking = entity.getSecondsToDisableBlocking();
         if (secondsToDisableBlocking > 0.0F && blocksAttacks != null) {
-            blocksAttacks.disable(level, this, secondsToDisableBlocking, itemBlockingWith);
+            blocksAttacks.disable(level, this, secondsToDisableBlocking, itemBlockingWith, entity); // Paper - Add PlayerShieldDisableEvent
         }
     }
 
@@ -736,9 +_,29 @@
     }
 
     public boolean canHarmPlayer(Player other) {
-        Team team = this.getTeam();
-        Team team1 = other.getTeam();
-        return team == null || !team.isAlliedTo(team1) || team.isAllowFriendlyFire();
+        // CraftBukkit start - Change to check OTHER player's scoreboard team according to API
+        // To summarize this method's logic, it's "Can parameter hurt this"
+        org.bukkit.scoreboard.Team team;
+        if (other instanceof ServerPlayer) {
+            ServerPlayer thatPlayer = (ServerPlayer) other;
+            team = thatPlayer.getBukkitEntity().getScoreboard().getPlayerTeam(thatPlayer.getBukkitEntity());
+            if (team == null || team.allowFriendlyFire()) {
+                return true;
+            }
+        } else {
+            // This should never be called, but is implemented anyway
+            org.bukkit.OfflinePlayer thisPlayer = other.level().getCraftServer().getOfflinePlayer(other.getScoreboardName());
+            team = other.level().getCraftServer().getScoreboardManager().getMainScoreboard().getPlayerTeam(thisPlayer);
+            if (team == null || team.allowFriendlyFire()) {
+                return true;
+            }
+        }
+
+        if (this instanceof ServerPlayer) {
+            return !team.hasPlayer(((ServerPlayer) this).getBukkitEntity());
+        }
+        return !team.hasPlayer(this.level().getCraftServer().getOfflinePlayer(this.getScoreboardName()));
+        // CraftBukkit end
     }
 
     @Override
@@ -752,7 +_,12 @@
     }
 
     @Override
-    protected void actuallyHurt(ServerLevel level, DamageSource damageSource, float amount) {
+    // CraftBukkit start
+    protected boolean actuallyHurt(ServerLevel level, DamageSource damageSource, float amount, org.bukkit.event.entity.EntityDamageEvent event) { // void -> boolean
+        if (true) {
+            return super.actuallyHurt(level, damageSource, amount, event);
+        }
+        // CraftBukkit end
         if (!this.isInvulnerableTo(level, damageSource)) {
             amount = this.getDamageAfterArmorAbsorb(damageSource, amount);
             amount = this.getDamageAfterMagicAbsorb(damageSource, amount);
@@ -764,7 +_,7 @@
             }
 
             if (var8 != 0.0F) {
-                this.causeFoodExhaustion(damageSource.getFoodExhaustion());
+                this.causeFoodExhaustion(damageSource.getFoodExhaustion(), org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason.DAMAGED); // CraftBukkit - EntityExhaustionEvent
                 this.getCombatTracker().recordDamage(damageSource, var8);
                 this.setHealth(this.getHealth() - var8);
                 if (var8 < 3.4028235E37F) {
@@ -774,6 +_,7 @@
                 this.gameEvent(GameEvent.ENTITY_DAMAGE);
             }
         }
+        return false; // CraftBukkit
     }
 
     public boolean isTextFilteringEnabled() {
@@ -860,14 +_,16 @@
     }
 
     @Override
-    public void removeVehicle() {
-        super.removeVehicle();
+    // Paper start - Force entity dismount during teleportation
+    public void removeVehicle(boolean suppressCancellation) {
+        super.removeVehicle(suppressCancellation);
+        // Paper end - Force entity dismount during teleportation
         this.boardingCooldown = 0;
     }
 
     @Override
     protected boolean isImmobile() {
-        return super.isImmobile() || this.isSleeping();
+        return super.isImmobile() || this.isSleeping() || this.isRemoved() || !valid; // Paper - players who are dead or not in a world shouldn't move...
     }
 
     @Override
@@ -946,15 +_,25 @@
     }
 
     public void attack(Entity target) {
-        if (!this.cannotAttack(target)) {
+        // Paper start - PlayerAttackEntityEvent
+        boolean willAttack = !this.cannotAttack(target); // Vanilla logic
+        io.papermc.paper.event.player.PrePlayerAttackEntityEvent playerAttackEntityEvent = new io.papermc.paper.event.player.PrePlayerAttackEntityEvent(
+            (org.bukkit.entity.Player) this.getBukkitEntity(),
+            target.getBukkitEntity(),
+            willAttack
+        );
+
+        if (playerAttackEntityEvent.callEvent() && willAttack) { // Logic moved to willAttack local variable.
+        // Paper end - PlayerAttackEntityEvent
             float f = this.isAutoSpinAttack() ? this.autoSpinAttackDmg : (float)this.getAttributeValue(Attributes.ATTACK_DAMAGE);
             ItemStack weaponItem = this.getWeaponItem();
-            DamageSource damageSource = this.createAttackSource(weaponItem);
+            DamageSource damageSource = this.createAttackSource(weaponItem); final DamageSource dmgSourceFinal = damageSource; // Paper - damage events
             float attackStrengthScale = this.getAttackStrengthScale(0.5F);
             float f1 = attackStrengthScale * (this.getEnchantedDamage(target, f, damageSource) - f);
             f *= this.baseDamageScaleFactor();
             this.onAttack();
-            if (!this.deflectProjectile(target)) {
+            final float dmgFinal = f1; // Paper - damage events
+            if (!this.deflectProjectile(target, () -> !org.bukkit.craftbukkit.event.CraftEventFactory.handleNonLivingEntityDamageEvent(target, dmgSourceFinal, dmgFinal, false))) {
                 if (f > 0.0F || f1 > 0.0F) {
                     boolean flag = attackStrengthScale > 0.9F;
                     boolean flag1;
@@ -967,7 +_,9 @@
 
                     f += weaponItem.getItem().getAttackDamageBonus(target, f, damageSource);
                     boolean flag2 = flag && this.canCriticalAttack(target);
+                    flag2 = flag2 && !this.level().paperConfig().entities.behavior.disablePlayerCrits; // Paper - Toggleable player crits
                     if (flag2) {
+                        damageSource = damageSource.critical(); // Paper - critical damage API
                         f *= 1.5F;
                     }
 
@@ -990,7 +_,7 @@
                         this.setLastHurtMob(target);
                         this.itemAttackInteraction(target, weaponItem, damageSource, true);
                         this.damageStatsAndHearts(target, f3);
-                        this.causeFoodExhaustion(0.1F);
+                        this.causeFoodExhaustion(this.level().spigotConfig.combatExhaustion, org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason.ATTACK); // CraftBukkit - EntityExhaustionEvent // Spigot - Change to use configurable value
                     } else {
                         this.playServerSideSound(SoundEvents.PLAYER_ATTACK_NODAMAGE);
                     }
@@ -1002,7 +_,7 @@
     }
 
     private void playServerSideSound(SoundEvent sound) {
-        this.level().playSound(null, this.getX(), this.getY(), this.getZ(), sound, this.getSoundSource(), 1.0F, 1.0F);
+        sendSoundEffect(this, this.getX(), this.getY(), this.getZ(), sound, this.getSoundSource(), 1.0F, 1.0F); // Paper - send while respecting visibility
     }
 
     private DamageSource createAttackSource(ItemStack stack) {
@@ -1013,11 +_,12 @@
         return !target.isAttackable() || target.skipAttackInteraction(this);
     }
 
-    private boolean deflectProjectile(Entity target) {
+    private boolean deflectProjectile(Entity target, java.util.function.BooleanSupplier callEvent) { // Paper - damage events
         if (target.getType().is(EntityTypeTags.REDIRECTABLE_PROJECTILE)
             && target instanceof Projectile projectile
+            && callEvent.getAsBoolean() // Paper - damage events
             && projectile.deflect(ProjectileDeflection.AIM_DEFLECT, this, EntityReference.of(this), true)) {
-            this.level().playSound(null, this.getX(), this.getY(), this.getZ(), SoundEvents.PLAYER_ATTACK_NODAMAGE, this.getSoundSource());
+            this.makeSound(SoundEvents.PLAYER_ATTACK_NODAMAGE); // Paper - Use makeSound to avoid duplicating client-side sound for source player
             return true;
         } else {
             return false;
@@ -1110,21 +_,43 @@
     public void causeExtraKnockback(Entity target, float strength, Vec3 currentMovement) {
         if (strength > 0.0F) {
             if (target instanceof LivingEntity livingEntity) {
-                livingEntity.knockback(strength, Mth.sin(this.getYRot() * (float) (Math.PI / 180.0)), -Mth.cos(this.getYRot() * (float) (Math.PI / 180.0)));
+                livingEntity.knockback(strength, Mth.sin(this.getYRot() * (float) (Math.PI / 180.0)), -Mth.cos(this.getYRot() * (float) (Math.PI / 180.0)), this, io.papermc.paper.event.entity.EntityKnockbackEvent.Cause.ENTITY_ATTACK); // Paper - knockback events
             } else {
                 target.push(
                     -Mth.sin(this.getYRot() * (float) (Math.PI / 180.0)) * strength, 0.1, Mth.cos(this.getYRot() * (float) (Math.PI / 180.0)) * strength
+                    , this // Paper - Add EntityKnockbackByEntityEvent and EntityPushedByEntityAttackEvent
                 );
             }
 
             this.setDeltaMovement(this.getDeltaMovement().multiply(0.6, 1.0, 0.6));
+            // Paper start - Configurable sprint interruption on attack
+            if (!this.level().paperConfig().misc.disableSprintInterruptionOnAttack) {
             this.setSprinting(false);
+            }
+            // Paper end - Configurable sprint interruption on attack
         }
 
         if (target instanceof ServerPlayer && target.hurtMarked) {
+            // CraftBukkit start - Add Velocity Event
+            boolean cancelled = false;
+            org.bukkit.entity.Player player = (org.bukkit.entity.Player) target.getBukkitEntity();
+            org.bukkit.util.Vector velocity = org.bukkit.craftbukkit.util.CraftVector.toBukkit(currentMovement);
+
+            org.bukkit.event.player.PlayerVelocityEvent event = new org.bukkit.event.player.PlayerVelocityEvent(player, velocity.clone());
+            this.level().getCraftServer().getPluginManager().callEvent(event);
+
+            if (event.isCancelled()) {
+                cancelled = true;
+            } else if (!velocity.equals(event.getVelocity())) {
+                player.setVelocity(event.getVelocity());
+            }
+
+            if (!cancelled) {
             ((ServerPlayer)target).connection.send(new ClientboundSetEntityMotionPacket(target));
             target.hurtMarked = false;
             target.setDeltaMovement(currentMovement);
+            }
+            // CraftBukkit end
         }
     }
 
@@ -1145,8 +_,11 @@
                     && !(livingEntity instanceof ArmorStand armorStand && armorStand.isMarker())
                     && this.distanceToSqr(livingEntity) < 9.0) {
                     float f1 = this.getEnchantedDamage(livingEntity, var12, damageSource) * strengthScale;
-                    if (livingEntity.hurtServer(serverLevel, damageSource, f1)) {
-                        livingEntity.knockback(0.4F, Mth.sin(this.getYRot() * (float) (Math.PI / 180.0)), -Mth.cos(this.getYRot() * (float) (Math.PI / 180.0)));
+                    // Paper start - Only apply knockback if the event is not canceled
+                    livingEntity.lastDamageCancelled = false;
+                    if (livingEntity.hurtServer(serverLevel, damageSource.knownCause(org.bukkit.event.entity.EntityDamageEvent.DamageCause.ENTITY_SWEEP_ATTACK), f1) && !livingEntity.lastDamageCancelled) {
+                        // Paper end - Only apply knockback if the event is not canceled
+                        livingEntity.knockback(0.4F, Mth.sin(this.getYRot() * (float) (Math.PI / 180.0)), -Mth.cos(this.getYRot() * (float) (Math.PI / 180.0)), this, io.papermc.paper.event.entity.EntityKnockbackEvent.Cause.SWEEP_ATTACK); // Paper - knockback events
                         EnchantmentHelper.doPostAttackEffects(serverLevel, livingEntity, damageSource);
                     }
                 }
@@ -1177,7 +_,16 @@
 
     @Override
     public boolean stabAttack(EquipmentSlot slot, Entity target, float damageAmount, boolean damage, boolean knockback, boolean dismount) {
-        if (this.cannotAttack(target)) {
+        // Paper start - PlayerAttackEntityEvent
+        boolean cannotAttack = this.cannotAttack(target); // Vanilla logic
+        io.papermc.paper.event.player.PrePlayerAttackEntityEvent playerAttackEntityEvent = new io.papermc.paper.event.player.PrePlayerAttackEntityEvent(
+            (org.bukkit.entity.Player) this.getBukkitEntity(),
+            target.getBukkitEntity(),
+            !cannotAttack
+        );
+
+        if (!playerAttackEntityEvent.callEvent() || cannotAttack) { // Logic moved to cannotAttack local variable.
+        // Paper end - PlayerAttackEntityEvent
             return false;
         } else {
             ItemStack itemBySlot = this.getItemBySlot(slot);
@@ -1188,7 +_,8 @@
                 damageAmount *= this.baseDamageScaleFactor();
             }
 
-            if (knockback && this.deflectProjectile(target)) {
+            final float dmgFinal = f; // Paper - damage events
+            if (knockback && this.deflectProjectile(target, () -> !org.bukkit.craftbukkit.event.CraftEventFactory.handleNonLivingEntityDamageEvent(target, damageSource, dmgFinal, false))) { // Paper - damage events
                 return true;
             } else {
                 float f1 = damage ? damageAmount + f : 0.0F;
@@ -1216,7 +_,7 @@
                     this.setLastHurtMob(target);
                     this.itemAttackInteraction(target, itemBySlot, damageSource, flag);
                     this.damageStatsAndHearts(target, f2);
-                    this.causeFoodExhaustion(0.1F);
+                    this.causeFoodExhaustion(this.level().spigotConfig.combatExhaustion, org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason.ATTACK); // CraftBukkit - EntityExhaustionEvent // Spigot - Change to use configurable value
                     return true;
                 }
             }
@@ -1227,8 +_,8 @@
     }
 
     @Override
-    public void remove(Entity.RemovalReason reason) {
-        super.remove(reason);
+    public void remove(Entity.RemovalReason reason, org.bukkit.event.entity.EntityRemoveEvent.@Nullable Cause eventCause) { // CraftBukkit - add Bukkit remove cause
+        super.remove(reason, eventCause); // CraftBukkit - add Bukkit remove cause
         this.inventoryMenu.removed(this);
         if (this.hasContainerOpen()) {
             this.doCloseContainer();
@@ -1296,6 +_,12 @@
     }
 
     public Either<Player.BedSleepingProblem, Unit> startSleepInBed(BlockPos bedPos) {
+        // CraftBukkit start
+        return this.startSleepInBed(bedPos, false);
+    }
+
+    public Either<Player.BedSleepingProblem, Unit> startSleepInBed(BlockPos bedPos, boolean force) {
+        // CraftBukkit end
         this.startSleeping(bedPos);
         this.sleepCounter = 0;
         return Either.right(Unit.INSTANCE);
@@ -1407,7 +_,7 @@
 
     @Override
     public boolean causeFallDamage(double fallDistance, float damageMultiplier, DamageSource damageSource) {
-        if (this.abilities.mayfly) {
+        if (this.abilities.mayfly && !this.flyingFallDamage.toBooleanOrElse(false)) { // Paper - flying fall damage
             return false;
         } else {
             if (fallDistance >= 2.0) {
@@ -1448,7 +_,15 @@
     }
 
     public void startFallFlying() {
-        this.setSharedFlag(Entity.FLAG_FALL_FLYING, true);
+        // CraftBukkit start
+        if (!org.bukkit.craftbukkit.event.CraftEventFactory.callToggleGlideEvent(this, true).isCancelled()) {
+            this.setSharedFlag(Entity.FLAG_FALL_FLYING, true);
+        } else {
+            // SPIGOT-5542: must toggle like below
+            this.setSharedFlag(Entity.FLAG_FALL_FLYING, true);
+            this.setSharedFlag(Entity.FLAG_FALL_FLYING, false);
+        }
+        // CraftBukkit end
     }
 
     @Override
@@ -1546,7 +_,7 @@
 
         if (levels > 0 && this.experienceLevel % 5 == 0 && this.lastLevelUpTime < this.tickCount - 100.0F) {
             float f = this.experienceLevel > 30 ? 1.0F : this.experienceLevel / 30.0F;
-            this.level().playSound(null, this.getX(), this.getY(), this.getZ(), SoundEvents.PLAYER_LEVELUP, this.getSoundSource(), f * 0.75F, 1.0F);
+            Player.sendSoundEffect(this, this.getX(), this.getY(), this.getZ(), SoundEvents.PLAYER_LEVELUP, this.getSoundSource(), f * 0.75F, 1.0F); // Paper - send while respecting visibility
             this.lastLevelUpTime = this.tickCount;
         }
     }
@@ -1554,15 +_,35 @@
     public int getXpNeededForNextLevel() {
         if (this.experienceLevel >= 30) {
             return 112 + (this.experienceLevel - 30) * 9;
-        } else {
+        } else { // Paper - diff on change; calculateTotalExperiencePoints
             return this.experienceLevel >= 15 ? 37 + (this.experienceLevel - 15) * 5 : 7 + this.experienceLevel * 2;
         }
     }
 
+    // Paper start - send while respecting visibility
+    private static void sendSoundEffect(Player fromEntity, double x, double y, double z, SoundEvent soundEffect, SoundSource soundCategory, float volume, float pitch) {
+        fromEntity.level().playSound(fromEntity, x, y, z, soundEffect, soundCategory, volume, pitch); // This will not send the effect to the entity itself
+        if (fromEntity instanceof ServerPlayer serverPlayer) {
+            serverPlayer.connection.send(new net.minecraft.network.protocol.game.ClientboundSoundPacket(net.minecraft.core.registries.BuiltInRegistries.SOUND_EVENT.wrapAsHolder(soundEffect), soundCategory, x, y, z, volume, pitch, fromEntity.random.nextLong()));
+        }
+    }
+    // Paper end - send while respecting visibility
+
     public void causeFoodExhaustion(float exhaustion) {
+        // CraftBukkit start
+        this.causeFoodExhaustion(exhaustion, org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason.UNKNOWN);
+    }
+
+    public void causeFoodExhaustion(float exhaustion, org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason reason) {
+        // CraftBukkit end
         if (!this.abilities.invulnerable) {
             if (!this.level().isClientSide()) {
-                this.foodData.addExhaustion(exhaustion);
+                // CraftBukkit start
+                org.bukkit.event.entity.EntityExhaustionEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerExhaustionEvent(this, reason, exhaustion);
+                if (!event.isCancelled()) {
+                    this.foodData.addExhaustion(event.getExhaustion());
+                }
+                // CraftBukkit end
             }
         }
     }
@@ -1821,10 +_,31 @@
 
     @Override
     public void onAttack() {
-        this.resetOnlyAttackStrengthTicker();
+        // this.resetOnlyAttackStrengthTicker(); // CraftBukkit - Moved to EntityLiving to reset the cooldown after the damage is dealt
         super.onAttack();
     }
 
+    // Paper start - Force update attributes.
+    @Override
+    public void detectEquipmentUpdates() {
+        super.detectEquipmentUpdates();
+
+        if (!io.papermc.paper.configuration.GlobalConfiguration.get().unsupportedSettings.updateEquipmentOnPlayerActions) {
+            return;
+        }
+
+        // Copied from the tick method
+        ItemStack mainHandItem = this.getMainHandItem();
+        if (!ItemStack.matches(this.lastItemInMainHand, mainHandItem)) {
+            if (!ItemStack.isSameItem(this.lastItemInMainHand, mainHandItem)) {
+                this.resetAttackStrengthTicker();
+            }
+
+            this.lastItemInMainHand = mainHandItem.copy();
+        }
+    }
+    // Paper end - Force update attributes.
+
     public void resetOnlyAttackStrengthTicker() {
         this.attackStrengthTicker = 0;
     }
@@ -1856,17 +_,32 @@
         return ImmutableList.of(Pose.STANDING, Pose.CROUCHING, Pose.SWIMMING);
     }
 
+    // Paper start - PlayerReadyArrowEvent
+    // We pass a result mutable boolean in to allow the caller of this method to know if the event was cancelled.
+    protected boolean tryReadyArrow(ItemStack bow, ItemStack itemstack, final org.apache.commons.lang3.mutable.MutableBoolean cancelled) {
+        if (!(this instanceof final ServerPlayer serverPlayer)) return true;
+        final boolean notCancelled = new com.destroystokyo.paper.event.player.PlayerReadyArrowEvent(
+            serverPlayer.getBukkitEntity(),
+            org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(bow),
+            org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemstack)
+        ).callEvent();
+        if (!notCancelled) cancelled.setValue(true);
+        return notCancelled;
+    }
+    // Paper end - PlayerReadyArrowEvent
+
     @Override
     public ItemStack getProjectile(ItemStack shootable) {
         if (!(shootable.getItem() instanceof ProjectileWeaponItem)) {
             return ItemStack.EMPTY;
         } else {
-            Predicate<ItemStack> supportedHeldProjectiles = ((ProjectileWeaponItem)shootable.getItem()).getSupportedHeldProjectiles();
+            final org.apache.commons.lang3.mutable.MutableBoolean anyEventCancelled = new org.apache.commons.lang3.mutable.MutableBoolean(); // Paper - PlayerReadyArrowEvent
+            Predicate<ItemStack> supportedHeldProjectiles = ((ProjectileWeaponItem)shootable.getItem()).getSupportedHeldProjectiles().and(item -> this.tryReadyArrow(shootable, item, anyEventCancelled)); // Paper - PlayerReadyArrowEvent
             ItemStack heldProjectile = ProjectileWeaponItem.getHeldProjectile(this, supportedHeldProjectiles);
             if (!heldProjectile.isEmpty()) {
                 return heldProjectile;
             } else {
-                supportedHeldProjectiles = ((ProjectileWeaponItem)shootable.getItem()).getAllSupportedProjectiles();
+                supportedHeldProjectiles = ((ProjectileWeaponItem)shootable.getItem()).getAllSupportedProjectiles().and(item -> this.tryReadyArrow(shootable, item, anyEventCancelled)); // Paper - PlayerReadyArrowEvent
 
                 for (int i = 0; i < this.inventory.getContainerSize(); i++) {
                     ItemStack item = this.inventory.getItem(i);
@@ -1875,6 +_,7 @@
                     }
                 }
 
+                if (anyEventCancelled.booleanValue() && !this.abilities.instabuild && this instanceof final ServerPlayer player) this.resyncUsingItem(player); // Paper - resync if no item matched the Predicate
                 return this.hasInfiniteMaterials() ? new ItemStack(Items.ARROW) : ItemStack.EMPTY;
             }
         }
@@ -2055,5 +_,6 @@
         public static final Player.BedSleepingProblem OBSTRUCTED = new Player.BedSleepingProblem(Component.translatable("block.minecraft.bed.obstructed"));
         public static final Player.BedSleepingProblem OTHER_PROBLEM = new Player.BedSleepingProblem(null);
         public static final Player.BedSleepingProblem NOT_SAFE = new Player.BedSleepingProblem(Component.translatable("block.minecraft.bed.not_safe"));
+        public static final Player.BedSleepingProblem EXPLOSION = new Player.BedSleepingProblem(null); // Paper - Added to properly handle explosions in bed events
     }
 }

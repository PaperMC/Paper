--- a/net/minecraft/world/entity/projectile/Projectile.java
+++ b/net/minecraft/world/entity/projectile/Projectile.java
@@ -35,6 +35,9 @@
 import net.minecraft.world.phys.EntityHitResult;
 import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
+// CraftBukkit start
+import org.bukkit.projectiles.ProjectileSource;
+// CraftBukkit end
 
 public abstract class Projectile extends Entity implements TraceableEntity {
 
@@ -47,6 +50,10 @@
     @Nullable
     private Entity lastDeflectedBy;
 
+    // CraftBukkit start
+    protected boolean hitCancelled = false;
+    // CraftBukkit end
+
     Projectile(EntityType<? extends Projectile> type, Level world) {
         super(type, world);
     }
@@ -56,16 +63,35 @@
             this.ownerUUID = entity.getUUID();
             this.cachedOwner = entity;
         }
-
+        // Paper start - Refresh ProjectileSource for projectiles
+        else {
+            this.ownerUUID = null;
+            this.cachedOwner = null;
+            this.projectileSource = null;
+        }
+        // Paper end - Refresh ProjectileSource for projectiles
+        this.refreshProjectileSource(false); // Paper
     }
+    // Paper start - Refresh ProjectileSource for projectiles
+    public void refreshProjectileSource(boolean fillCache) {
+        if (fillCache) {
+            this.getOwner();
+        }
+        if (this.cachedOwner != null && !this.cachedOwner.isRemoved() && this.projectileSource == null && this.cachedOwner.getBukkitEntity() instanceof ProjectileSource projSource) {
+            this.projectileSource = projSource;
+        }
+    }
+    // Paper end - Refresh ProjectileSource for projectiles
 
     @Nullable
     @Override
     public Entity getOwner() {
         if (this.cachedOwner != null && !this.cachedOwner.isRemoved()) {
+            this.refreshProjectileSource(false); // Paper - Refresh ProjectileSource for projectiles
             return this.cachedOwner;
         } else if (this.ownerUUID != null) {
             this.cachedOwner = this.findOwner(this.ownerUUID);
+            this.refreshProjectileSource(false); // Paper - Refresh ProjectileSource for projectiles
             return this.cachedOwner;
         } else {
             return null;
@@ -184,12 +210,20 @@
 
         this.shoot((double) f5, (double) f6, (double) f7, speed, divergence);
         Vec3 vec3d = shooter.getKnownMovement();
-
+        // Paper start - allow disabling relative velocity
+        if (!shooter.level().paperConfig().misc.disableRelativeProjectileVelocity) {
         this.setDeltaMovement(this.getDeltaMovement().add(vec3d.x, shooter.onGround() ? 0.0D : vec3d.y, vec3d.z));
+        }
+        // Paper end - allow disabling relative velocity
     }
 
     public static <T extends Projectile> T spawnProjectileFromRotation(Projectile.ProjectileFactory<T> creator, ServerLevel world, ItemStack projectileStack, LivingEntity shooter, float roll, float power, float divergence) {
-        return Projectile.spawnProjectile(creator.create(world, shooter, projectileStack), world, projectileStack, (iprojectile) -> {
+    // Paper start - PlayerLaunchProjectileEvent
+        return spawnProjectileFromRotationDelayed(creator, world, projectileStack, shooter, roll, power, divergence).spawn();
+    }
+    public static <T extends Projectile> Delayed<T> spawnProjectileFromRotationDelayed(Projectile.ProjectileFactory<T> creator, ServerLevel world, ItemStack projectileStack, LivingEntity shooter, float roll, float power, float divergence) {
+        return Projectile.spawnProjectileDelayed(creator.create(world, shooter, projectileStack), world, projectileStack, (iprojectile) -> {
+    // Paper end - PlayerLaunchProjectileEvent
             iprojectile.shootFromRotation(shooter, shooter.getXRot(), shooter.getYRot(), roll, power, divergence);
         });
     }
@@ -201,7 +235,12 @@
     }
 
     public static <T extends Projectile> T spawnProjectileUsingShoot(T projectile, ServerLevel world, ItemStack projectileStack, double velocityX, double velocityY, double velocityZ, float power, float divergence) {
-        return Projectile.spawnProjectile(projectile, world, projectileStack, (iprojectile) -> {
+    // Paper start - fixes and addition to spawn reason API
+        return spawnProjectileUsingShootDelayed(projectile, world, projectileStack, velocityX, velocityY, velocityZ, power, divergence).spawn();
+    }
+    public static <T extends Projectile> Delayed<T> spawnProjectileUsingShootDelayed(T projectile, ServerLevel world, ItemStack projectileStack, double velocityX, double velocityY, double velocityZ, float power, float divergence) {
+        return Projectile.spawnProjectileDelayed(projectile, world, projectileStack, (iprojectile) -> {
+    // Paper end - fixes and addition to spawn reason API
             projectile.shoot(velocityX, velocityY, velocityZ, power, divergence);
         });
     }
@@ -209,13 +248,47 @@
     public static <T extends Projectile> T spawnProjectile(T projectile, ServerLevel world, ItemStack projectileStack) {
         return Projectile.spawnProjectile(projectile, world, projectileStack, (iprojectile) -> {
         });
+    }
+
+    // Paper start - delayed projectile spawning
+    public record Delayed<T extends Projectile>(
+        T projectile,
+        ServerLevel world,
+        ItemStack projectileStack
+    ) {
+        // Taken from net.minecraft.world.entity.projectile.Projectile.spawnProjectile(T, net.minecraft.server.level.ServerLevel, net.minecraft.world.item.ItemStack, java.util.function.Consumer<T>)
+        public boolean attemptSpawn() {
+            if (!world.addFreshEntity(projectile)) return false;
+            projectile.applyOnProjectileSpawned(this.world, this.projectileStack);
+            return true;
+        }
+
+        public T spawn() {
+            this.attemptSpawn();
+            return projectile();
+        }
+
+        public boolean attemptSpawn(final org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason) {
+            if (!world.addFreshEntity(projectile, reason)) return false;
+            projectile.applyOnProjectileSpawned(this.world, this.projectileStack);
+            return true;
+        }
+
+        public T spawn(final org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason) {
+            this.attemptSpawn(reason);
+            return projectile();
+        }
     }
+    // Paper end - delayed projectile spawning
 
     public static <T extends Projectile> T spawnProjectile(T projectile, ServerLevel world, ItemStack projectileStack, Consumer<T> beforeSpawn) {
+    // Paper start - delayed projectile spawning
+        return spawnProjectileDelayed(projectile, world, projectileStack, beforeSpawn).spawn();
+    }
+    public static <T extends Projectile> Delayed<T> spawnProjectileDelayed(T projectile, ServerLevel world, ItemStack projectileStack, Consumer<T> beforeSpawn) {
+    // Paper end - delayed projectile spawning
         beforeSpawn.accept(projectile);
-        world.addFreshEntity(projectile);
-        projectile.applyOnProjectileSpawned(world, projectileStack);
-        return projectile;
+        return new Delayed<>(projectile, world, projectileStack); // Paper - delayed projectile spawning
     }
 
     public void applyOnProjectileSpawned(ServerLevel world, ItemStack projectileStack) {
@@ -232,6 +305,17 @@
 
     }
 
+    // CraftBukkit start - call projectile hit event
+    public ProjectileDeflection preHitTargetOrDeflectSelf(HitResult movingobjectposition) { // Paper - protected -> public
+        org.bukkit.event.entity.ProjectileHitEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callProjectileHitEvent(this, movingobjectposition);
+        this.hitCancelled = event != null && event.isCancelled();
+        if (movingobjectposition.getType() == HitResult.Type.BLOCK || !this.hitCancelled) {
+            return this.hitTargetOrDeflectSelf(movingobjectposition);
+        }
+        return ProjectileDeflection.NONE;
+    }
+    // CraftBukkit end
+
     protected ProjectileDeflection hitTargetOrDeflectSelf(HitResult hitResult) {
         if (hitResult.getType() == HitResult.Type.ENTITY) {
             EntityHitResult movingobjectpositionentity = (EntityHitResult) hitResult;
@@ -269,7 +353,13 @@
     public boolean deflect(ProjectileDeflection deflection, @Nullable Entity deflector, @Nullable Entity owner, boolean fromAttack) {
         deflection.deflect(this, deflector, this.random);
         if (!this.level().isClientSide) {
-            this.setOwner(owner);
+            // Paper start - Fix PickupStatus getting reset
+            if (this instanceof AbstractArrow arrow) {
+                arrow.setOwner(owner, false);
+            } else {
+                this.setOwner(owner);
+            }
+            // Paper end - Fix PickupStatus getting reset
             this.onDeflection(deflector, fromAttack);
         }
 
@@ -309,6 +399,11 @@
     protected void onHitEntity(EntityHitResult entityHitResult) {}
 
     protected void onHitBlock(BlockHitResult blockHitResult) {
+        // CraftBukkit start - cancellable hit event
+        if (this.hitCancelled) {
+            return;
+        }
+        // CraftBukkit end
         BlockState iblockdata = this.level().getBlockState(blockHitResult.getBlockPos());
 
         iblockdata.onProjectileHit(this.level(), iblockdata, blockHitResult, this);
@@ -320,6 +415,15 @@
         } else {
             Entity entity1 = this.getOwner();
 
+            // Paper start - Cancel hit for vanished players
+            if (entity1 instanceof net.minecraft.server.level.ServerPlayer && entity instanceof net.minecraft.server.level.ServerPlayer) {
+                org.bukkit.entity.Player collided = (org.bukkit.entity.Player) entity.getBukkitEntity();
+                org.bukkit.entity.Player shooter = (org.bukkit.entity.Player) entity1.getBukkitEntity();
+                if (!shooter.canSee(collided)) {
+                    return false;
+                }
+            }
+            // Paper end - Cancel hit for vanished players
             return entity1 == null || this.leftOwner || !entity1.isPassengerOfSameVehicle(entity);
         }
     }
@@ -333,14 +437,8 @@
     }
 
     protected static float lerpRotation(float prevRot, float newRot) {
-        while (newRot - prevRot < -180.0F) {
-            prevRot -= 360.0F;
-        }
+        prevRot += Math.round((newRot - prevRot) / 360.0F) * 360.0F; // Paper - stop large look changes from crashing the server
 
-        while (newRot - prevRot >= 180.0F) {
-            prevRot += 360.0F;
-        }
-
         return Mth.lerp(0.2F, prevRot, newRot);
     }
 

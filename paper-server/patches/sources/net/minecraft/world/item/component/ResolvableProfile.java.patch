--- a/net/minecraft/world/item/component/ResolvableProfile.java
+++ b/net/minecraft/world/item/component/ResolvableProfile.java
@@ -46,7 +_,7 @@
     private static ResolvableProfile create(Either<GameProfile, ResolvableProfile.Partial> contents, PlayerSkin.Patch skinPatch) {
         return contents.map(
             gameProfile -> new ResolvableProfile.Static(Either.left(gameProfile), skinPatch),
-            partial -> (ResolvableProfile)(partial.properties.isEmpty() && partial.id.isPresent() != partial.name.isPresent()
+            partial -> (ResolvableProfile)(partial.properties.isEmpty() && partial.id.isPresent() != partial.name.isPresent() // Paper - diff on change - heuristic for dynamic vs static resolvable profile - used in CraftPlayerProfile#buildResolvable
                 ? partial.name
                     .<ResolvableProfile>map(string -> new ResolvableProfile.Dynamic(Either.left(string), skinPatch))
                     .orElseGet(() -> new ResolvableProfile.Dynamic(Either.right(partial.id.get()), skinPatch))
@@ -139,9 +_,10 @@
             instance -> instance.group(
                     ExtraCodecs.PLAYER_NAME.optionalFieldOf("name").forGetter(ResolvableProfile.Partial::name),
                     UUIDUtil.CODEC.optionalFieldOf("id").forGetter(ResolvableProfile.Partial::id),
+                    UUIDUtil.STRING_CODEC.lenientOptionalFieldOf("Id").forGetter($ -> Optional.empty()), // Paper
                     ExtraCodecs.PROPERTY_MAP.optionalFieldOf("properties", PropertyMap.EMPTY).forGetter(ResolvableProfile.Partial::properties)
                 )
-                .apply(instance, ResolvableProfile.Partial::new)
+                .apply(instance, (name, uuid, uuid2, propertyMap) -> new ResolvableProfile.Partial(name, uuid2.or(() -> uuid), propertyMap)) // Paper
         );
         public static final StreamCodec<ByteBuf, ResolvableProfile.Partial> STREAM_CODEC = StreamCodec.composite(
             ByteBufCodecs.PLAYER_NAME.apply(ByteBufCodecs::optional),

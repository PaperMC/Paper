--- a/net/minecraft/world/item/crafting/RecipeManager.java
+++ b/net/minecraft/world/item/crafting/RecipeManager.java
@@ -87,7 +_,26 @@
         LOGGER.info("Loaded {} recipes", recipes.values().size());
     }
 
+    // CraftBukkit start
+    public void addRecipe(RecipeHolder<?> holder) {
+        org.spigotmc.AsyncCatcher.catchOp("Recipe Add"); // Spigot
+        this.recipes.addRecipe(holder);
+        this.finalizeRecipeLoading();
+    }
+
+    private FeatureFlagSet featureflagset;
+
+    public void finalizeRecipeLoading() {
+        if (this.featureflagset != null) {
+            this.finalizeRecipeLoading(this.featureflagset);
+
+            net.minecraft.server.MinecraftServer.getServer().getPlayerList().reloadResources();
+        }
+    }
+
     public void finalizeRecipeLoading(final FeatureFlagSet enabledFlags) {
+        this.featureflagset = enabledFlags;
+        // CraftBukkit end
         List<SelectableRecipe.SingleInputEntry<StonecutterRecipe>> stonecutterRecipes = new ArrayList<>();
         List<RecipeManager.IngredientCollector> propertySetCollectors = RECIPE_PROPERTY_SETS.entrySet()
             .stream()
@@ -144,7 +_,10 @@
     }
 
     public <I extends RecipeInput, T extends Recipe<I>> Optional<RecipeHolder<T>> getRecipeFor(final RecipeType<T> type, final I input, final Level level) {
-        return this.recipes.getRecipesFor(type, input, level).findFirst();
+        // CraftBukkit start
+        List<RecipeHolder<T>> list = this.recipes.getRecipesFor(type, input, level).toList();
+        return (list.isEmpty()) ? Optional.empty() : Optional.of(list.getLast()); // CraftBukkit - SPIGOT-4638: last recipe gets priority
+        // CraftBukkit end
     }
 
     public Optional<RecipeHolder<?>> byKey(final ResourceKey<Recipe<?>> recipeId) {
@@ -195,6 +_,22 @@
         Recipe<?> recipe = Recipe.CODEC.parse(registries.createSerializationContext(JsonOps.INSTANCE), object).getOrThrow(JsonParseException::new);
         return new RecipeHolder<>(id, recipe);
     }
+
+    // CraftBukkit start
+    public boolean removeRecipe(ResourceKey<Recipe<?>> mcKey) {
+        boolean removed = this.recipes.removeRecipe((ResourceKey<Recipe<RecipeInput>>) (ResourceKey) mcKey); // Paper - generic fix
+        if (removed) {
+            this.finalizeRecipeLoading();
+        }
+
+        return removed;
+    }
+
+    public void clearRecipes() {
+        this.recipes = RecipeMap.create(java.util.Collections.emptyList());
+        this.finalizeRecipeLoading();
+    }
+    // CraftBukkit end
 
     public static <I extends RecipeInput, T extends Recipe<I>> RecipeManager.CachedCheck<I, T> createCheck(final RecipeType<T> type) {
         return new RecipeManager.CachedCheck<I, T>() {

--- a/net/minecraft/commands/Commands.java
+++ b/net/minecraft/commands/Commands.java
@@ -157,6 +_,7 @@
 import org.slf4j.Logger;
 
 public class Commands {
+    public interface RestrictedMarker { } // Paper - restricted api
     public static final String COMMAND_PREFIX = "/";
     private static final ThreadLocal<@Nullable ExecutionContext<CommandSourceStack>> CURRENT_EXECUTION_CONTEXT = new ThreadLocal<>();
     private static final Logger LOGGER = LogUtils.getLogger();
@@ -181,6 +_,7 @@
 
         @Override
         public boolean isRestricted(final CommandNode<CommandSourceStack> node) {
+            if (node.getRequirement() instanceof RestrictedMarker) return true; // Paper - restricted api
             Predicate<CommandSourceStack> requirement = node.getRequirement();
             return !requirement.test(this.noPermissionSource);
         }
@@ -188,6 +_,11 @@
     private final CommandDispatcher<CommandSourceStack> dispatcher = new CommandDispatcher<>();
 
     public Commands(final Commands.CommandSelection commandSelection, final CommandBuildContext context) {
+    // Paper start - Brigadier API - modern minecraft overloads that do not use redirects but are copies instead
+        this(selection, context, false);
+    }
+    public Commands(final Commands.CommandSelection commandSelection, final CommandBuildContext context, final boolean modern) {
+    // Paper end - Brigadier API - modern minecraft overloads that do not use redirects but are copies instead
         AdvancementCommands.register(this.dispatcher);
         AttributeCommand.register(this.dispatcher, context);
         ExecuteCommand.register(this.dispatcher, context);
@@ -299,6 +_,42 @@
             PublishCommand.register(this.dispatcher);
         }
 
+        // Paper start - Vanilla command permission fixes
+        for (final CommandNode<CommandSourceStack> node : this.dispatcher.getRoot().getChildren()) {
+            if (node.getRequirement() == com.mojang.brigadier.builder.ArgumentBuilder.<CommandSourceStack>defaultRequirement()) {
+                node.requirement = stack -> stack.source == CommandSource.NULL || stack.getBukkitSender().hasPermission(org.bukkit.craftbukkit.command.VanillaCommandWrapper.getPermission(node));
+            } else if (node.getRequirement() instanceof PermissionProviderCheck<CommandSourceStack> check) {
+                check.vanillaNode().set(node);
+            }
+        }
+        // Paper end - Vanilla command permission fixes
+        // Paper start - Brigadier Command API
+        // Create legacy minecraft namespace commands
+        for (final CommandNode<CommandSourceStack> node : new java.util.ArrayList<>(this.dispatcher.getRoot().getChildren())) {
+            if (modern) {
+                // Modern behaviour that simply creates a full copy of the commands node.
+                // Avoids plenty of issues around registering redirects *to* these nodes from the API
+                this.dispatcher.getRoot().addChild(
+                    io.papermc.paper.command.brigadier.PaperBrigadier.copyLiteral(
+                        "minecraft:" + node.getName(),
+                        (com.mojang.brigadier.tree.LiteralCommandNode<CommandSourceStack>) node
+                    )
+                );
+                continue;
+            }
+
+            // Legacy behaviour of creating a flattened redirecting node.
+            // Used by CommandArgumentUpgrader
+            CommandNode<CommandSourceStack> flattenedAliasTarget = node;
+            while (flattenedAliasTarget.getRedirect() != null) flattenedAliasTarget = flattenedAliasTarget.getRedirect();
+
+            this.dispatcher.register(
+                com.mojang.brigadier.builder.LiteralArgumentBuilder.<CommandSourceStack>literal("minecraft:" + node.getName())
+                    .executes(flattenedAliasTarget.getCommand())
+                    .requires(flattenedAliasTarget.getRequirement())
+                    .redirect(flattenedAliasTarget));
+        }
+        // Paper end - Brigadier Command API
         this.dispatcher.setConsumer(ExecutionCommandSource.resultConsumer());
     }
 
@@ -318,6 +_,13 @@
     }
 
     public void performCommand(final ParseResults<CommandSourceStack> command, final String commandString) {
+        // Paper start
+        this.performCommand(command, commandString, false);
+    }
+
+    public void performCommand(final ParseResults<CommandSourceStack> command, final String commandString, final boolean throwCommandError) {
+        org.spigotmc.AsyncCatcher.catchOp("Cannot perform command async");
+        // Paper end
         CommandSourceStack sender = command.getContext().getSource();
         Profiler.get().push(() -> "/" + commandString);
         ContextChain<CommandSourceStack> commandChain = finishParsing(command, commandString, sender);
@@ -331,10 +_,12 @@
                     )
                 );
             }
-        } catch (Exception var12) {
+            // Paper start
+        } catch (Throwable var12) { // always gracefully handle it, no matter how bad:tm:
+            if (throwCommandError) throw var12; // rethrow directly if requested
             MutableComponent hover = Component.literal(var12.getMessage() == null ? var12.getClass().getName() : var12.getMessage());
-            if (LOGGER.isDebugEnabled()) {
-                LOGGER.error("Command exception: /{}", commandString, var12);
+            LOGGER.error("Command exception: /{}", commandString, var12); // Paper - always show execution exception in console log
+            if (sender.getServer().isDebugging() || LOGGER.isDebugEnabled()) { // Paper - Debugging
                 StackTraceElement[] stackTrace = var12.getStackTrace();
 
                 for (int i = 0; i < Math.min(stackTrace.length, 3); i++) {
@@ -365,7 +_,11 @@
             return ContextChain.tryFlatten(command.getContext().build(commandString))
                 .orElseThrow(() -> CommandSyntaxException.BUILT_IN_EXCEPTIONS.dispatcherUnknownCommand().createWithContext(command.getReader()));
         } catch (CommandSyntaxException var7) {
-            sender.sendFailure(ComponentUtils.fromMessage(var7.getRawMessage()));
+            // Paper start - Add UnknownCommandEvent
+            final net.kyori.adventure.text.TextComponent.Builder builder = net.kyori.adventure.text.Component.text();
+            // sender.sendFailure(ComponentUtils.fromMessage(var7.getRawMessage()));
+            builder.color(net.kyori.adventure.text.format.NamedTextColor.RED).append(io.papermc.paper.command.brigadier.MessageComponentSerializer.message().deserialize(var7.getRawMessage()));
+            // Paper end - Add UnknownCommandEvent
             if (var7.getInput() != null && var7.getCursor() >= 0) {
                 int cursor = Math.min(var7.getInput().length(), var7.getCursor());
                 MutableComponent context = Component.empty()
@@ -382,7 +_,17 @@
                 }
 
                 context.append(Component.translatable("command.context.here").withStyle(ChatFormatting.RED, ChatFormatting.ITALIC));
-                sender.sendFailure(context);
+                // Paper start - Add UnknownCommandEvent
+                // sender.sendFailure(context);
+                builder
+                    .append(net.kyori.adventure.text.Component.newline())
+                    .append(io.papermc.paper.adventure.PaperAdventure.asAdventure(context));
+            }
+            org.bukkit.event.command.UnknownCommandEvent event = new org.bukkit.event.command.UnknownCommandEvent(source, command, org.spigotmc.SpigotConfig.unknownCommandMessage.isEmpty() ? null : builder.build());
+            org.bukkit.Bukkit.getServer().getPluginManager().callEvent(event);
+            if (event.message() != null) {
+                sender.sendFailure(io.papermc.paper.adventure.PaperAdventure.asVanilla(event.message()), false);
+                // Paper end - Add UnknownCommandEvent
             }
 
             return null;
@@ -410,19 +_,112 @@
     }
 
     public void sendCommands(final ServerPlayer player) {
+        // Paper start - Send empty commands if tab completion is disabled
+        if (org.spigotmc.SpigotConfig.tabComplete < 0) {
+            player.connection.send(new ClientboundCommandsPacket(new RootCommandNode<>(), COMMAND_NODE_INSPECTOR));
+            return;
+        }
+        // Paper end - Send empty commands if tab completion is disabled
+        // CraftBukkit start
+        // Register Vanilla commands into builtRoot as before
+        // Paper start - Perf: Async command map building
+        // Copy root children to avoid concurrent modification during building
+        final java.util.Collection<CommandNode<CommandSourceStack>> commandNodes = new java.util.ArrayList<>(this.dispatcher.getRoot().getChildren());
+        COMMAND_SENDING_POOL.execute(() -> this.sendAsync(player, commandNodes));
+    }
+
+    // Fixed pool, but with discard policy
+    public static final java.util.concurrent.ExecutorService COMMAND_SENDING_POOL = new java.util.concurrent.ThreadPoolExecutor(
+        2, 2, 0, java.util.concurrent.TimeUnit.MILLISECONDS,
+        new java.util.concurrent.LinkedBlockingQueue<>(),
+        new com.google.common.util.concurrent.ThreadFactoryBuilder()
+            .setNameFormat("Paper Async Command Builder Thread Pool - %1$d")
+            .setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(net.minecraft.server.MinecraftServer.LOGGER))
+            .build(),
+        new java.util.concurrent.ThreadPoolExecutor.DiscardPolicy()
+    );
+
+    private void sendAsync(ServerPlayer player, java.util.Collection<CommandNode<CommandSourceStack>> dispatcherRootChildren) {
+        // Paper end - Perf: Async command map building
         Map<CommandNode<CommandSourceStack>, CommandNode<CommandSourceStack>> playerCommands = new HashMap<>();
         RootCommandNode<CommandSourceStack> root = new RootCommandNode<>();
         playerCommands.put(this.dispatcher.getRoot(), root);
-        fillUsableCommands(this.dispatcher.getRoot(), root, player.createCommandSourceStack(), playerCommands);
+        fillUsableCommands(dispatcherRootChildren, root, player.createCommandSourceStack(), playerCommands); // Paper - Perf: Async command map building; pass copy of children
+
+        java.util.Collection<String> bukkit = new java.util.LinkedHashSet<>();
+        for (CommandNode node : root.getChildren()) {
+            bukkit.add(node.getName());
+        }
+        // Paper start - Perf: Async command map building
+        new com.destroystokyo.paper.event.brigadier.AsyncPlayerSendCommandsEvent<CommandSourceStack>(player.getBukkitEntity(), (RootCommandNode) root, false).callEvent(); // Paper - Brigadier API
+        net.minecraft.server.MinecraftServer.getServer().execute(() -> {
+            runSync(player, bukkit, root);
+        });
+    }
+
+    private void runSync(ServerPlayer player, java.util.Collection<String> bukkit, RootCommandNode<CommandSourceStack> root) {
+        // Paper end - Perf: Async command map building
+        new com.destroystokyo.paper.event.brigadier.AsyncPlayerSendCommandsEvent<CommandSourceStack>(player.getBukkitEntity(), (RootCommandNode) root, true).callEvent(); // Paper - Brigadier API
+        org.bukkit.event.player.PlayerCommandSendEvent event = new org.bukkit.event.player.PlayerCommandSendEvent(player.getBukkitEntity(), new java.util.LinkedHashSet<>(bukkit));
+        event.getPlayer().getServer().getPluginManager().callEvent(event);
+
+        // Remove labels that were removed during the event
+        for (String orig : bukkit) {
+            if (!event.getCommands().contains(orig)) {
+                root.removeCommand(orig);
+            }
+        }
+        // CraftBukkit end
         player.connection.send(new ClientboundCommandsPacket(root, COMMAND_NODE_INSPECTOR));
     }
 
     private static <S> void fillUsableCommands(
-        final CommandNode<S> source, final CommandNode<S> target, final S commandFilter, final Map<CommandNode<S>, CommandNode<S>> converted
+        final java.util.Collection<CommandNode<S>> children, final CommandNode<S> target, final S commandFilter, final Map<CommandNode<S>, CommandNode<S>> converted // Paper - Perf: Async command map building; pass copy of children
     ) {
-        for (CommandNode<S> child : source.getChildren()) {
+        for (CommandNode<S> child : children) {  // Paper - Perf: Async command map building; pass copy of children
+            // Paper start - Brigadier API
+            if (child.clientNode != null) {
+                child = child.clientNode;
+            }
+            // Paper end - Brigadier API
+            if (!org.spigotmc.SpigotConfig.sendNamespaced && child.getName().contains(":")) continue; // Spigot
             if (child.canUse(commandFilter)) {
                 ArgumentBuilder<S, ?> builder = child.createBuilder();
+                // Paper start
+                /*
+                Because of how commands can be yeeted right left and center due to bad bukkit practices
+                we need to be able to ensure that ALL commands are registered (even redirects).
+
+                What this will do is IF the redirect seems to be "dead" it will create a builder and essentially populate (flatten)
+                all the children from the dead redirect to the node.
+
+                So, if minecraft:msg redirects to msg but the original msg node has been overriden minecraft:msg will now act as msg and will explicilty inherit its children.
+
+                The only way to fix this is to either:
+                - Send EVERYTHING flattened, don't use redirects
+                - Don't allow command nodes to be deleted
+                - Do this :)
+                 */
+                // Is there an invalid command redirect?
+                if (builder.getRedirect() != null && converted.get(builder.getRedirect()) == null) {
+                    // Create the argument builder with the same values as the specified node, but with a different literal and populated children
+
+                    final CommandNode<S> redirect = builder.getRedirect();
+                    // Diff copied from LiteralCommand#createBuilder
+                    final com.mojang.brigadier.builder.LiteralArgumentBuilder<S> redirectBuilder = com.mojang.brigadier.builder.LiteralArgumentBuilder.literal(child.getName());
+                    redirectBuilder.requires(redirect.getRequirement());
+                    // builder.forward(redirect.getRedirect(), redirect.getRedirectModifier(), redirect.isFork()); We don't want to migrate the forward, since it's invalid.
+                    if (redirect.getCommand() != null) {
+                        redirectBuilder.executes(redirect.getCommand());
+                    }
+                    // Diff copied from LiteralCommand#createBuilder
+                    for (final CommandNode<S> redirectChild : redirect.getChildren()) {
+                        redirectBuilder.then(redirectChild);
+                    }
+
+                    builder = redirectBuilder;
+                }
+                // Paper end
                 if (builder.getRedirect() != null) {
                     builder.redirect(converted.get(builder.getRedirect()));
                 }
@@ -431,7 +_,7 @@
                 converted.put(child, node);
                 target.addChild(node);
                 if (!child.getChildren().isEmpty()) {
-                    fillUsableCommands(child, node, commandFilter, converted);
+                    fillUsableCommands(child.getChildren(), node, commandFilter, converted); // Paper - Perf: Async command map building; pass copy of children
                 }
             }
         }

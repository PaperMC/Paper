--- a/net/minecraft/server/players/PlayerList.java
+++ b/net/minecraft/server/players/PlayerList.java
@@ -109,14 +_,16 @@
     private static final int SEND_PLAYER_INFO_INTERVAL = 600;
     private static final SimpleDateFormat BAN_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd 'at' HH:mm:ss z");
     private final MinecraftServer server;
-    public final List<ServerPlayer> players = Lists.newArrayList();
+    public final List<ServerPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
     private final Map<UUID, ServerPlayer> playersByUUID = Maps.newHashMap();
     private final UserBanList bans;
     private final IpBanList ipBans;
     private final ServerOpList ops;
     private final UserWhiteList whitelist;
-    private final Map<UUID, ServerStatsCounter> stats = Maps.newHashMap();
-    private final Map<UUID, PlayerAdvancements> advancements = Maps.newHashMap();
+    // CraftBukkit start
+    // private final Map<UUID, ServerStatsCounter> stats = Maps.newHashMap();
+    // private final Map<UUID, PlayerAdvancements> advancements = Maps.newHashMap();
+    // CraftBukkit end
     public final PlayerDataStorage playerIo;
     private final LayeredRegistryAccess<RegistryLayer> registries;
     private int viewDistance;
@@ -124,9 +_,17 @@
     private boolean allowCommandsForAllPlayers;
     private int sendAllPlayerInfoIn;
 
+    // CraftBukkit start
+    private org.bukkit.craftbukkit.CraftServer cserver;
+    private final Map<String,ServerPlayer> playersByName = new java.util.HashMap<>();
+    public @Nullable String collideRuleTeamName; // Paper - Configurable player collision
+
     public PlayerList(
         MinecraftServer server, LayeredRegistryAccess<RegistryLayer> registries, PlayerDataStorage playerIo, NotificationService notificationService
     ) {
+        this.cserver = server.server = new org.bukkit.craftbukkit.CraftServer((net.minecraft.server.dedicated.DedicatedServer) server, this);
+        server.console = new com.destroystokyo.paper.console.TerminalConsoleCommandSender(); // Paper
+        // CraftBukkit end
         this.server = server;
         this.registries = registries;
         this.playerIo = playerIo;
@@ -136,23 +_,19 @@
         this.ipBans = new IpBanList(IPBANLIST_FILE, notificationService);
     }
 
+    abstract public void loadAndSaveFiles(); // Paper - fix converting txt to json file; moved from DedicatedPlayerList constructor
+
     public void placeNewPlayer(Connection connection, ServerPlayer player, CommonListenerCookie cookie) {
+        player.isRealPlayer = true; // Paper
+        player.loginTime = System.currentTimeMillis(); // Paper - Replace OfflinePlayer#getLastPlayed
         NameAndId nameAndId = player.nameAndId();
         UserNameToIdResolver userNameToIdResolver = this.server.services().nameToIdCache();
         Optional<NameAndId> optional = userNameToIdResolver.get(nameAndId.id());
         String string = optional.map(NameAndId::name).orElse(nameAndId.name());
+        if (player.lastKnownName != null) { string = player.lastKnownName; player.lastKnownName = null; } // CraftBukkit - Better rename detection
         userNameToIdResolver.add(nameAndId);
         ServerLevel serverLevel = player.level();
         String loggableAddress = connection.getLoggableAddress(this.server.logIPs());
-        LOGGER.info(
-            "{}[{}] logged in with entity id {} at ({}, {}, {})",
-            player.getPlainTextName(),
-            loggableAddress,
-            player.getId(),
-            player.getX(),
-            player.getY(),
-            player.getZ()
-        );
         LevelData levelData = serverLevel.getLevelData();
         ServerGamePacketListenerImpl serverGamePacketListenerImpl = new ServerGamePacketListenerImpl(this.server, connection, player, cookie);
         connection.setupInboundProtocol(
@@ -169,8 +_,8 @@
                 levelData.isHardcore(),
                 this.server.levelKeys(),
                 this.getMaxPlayers(),
-                this.getViewDistance(),
-                this.getSimulationDistance(),
+                serverLevel.spigotConfig.viewDistance, // Spigot - view distance
+                serverLevel.spigotConfig.simulationDistance, // Spigot - simulation distance
                 _boolean1,
                 !_boolean,
                 _boolean2,
@@ -178,6 +_,7 @@
                 this.server.enforceSecureProfile()
             )
         );
+        player.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         serverGamePacketListenerImpl.send(new ClientboundChangeDifficultyPacket(levelData.getDifficulty(), levelData.isDifficultyLocked()));
         serverGamePacketListenerImpl.send(new ClientboundPlayerAbilitiesPacket(player.getAbilities()));
         serverGamePacketListenerImpl.send(new ClientboundSetHeldSlotPacket(player.getInventory().getSelectedSlot()));
@@ -197,23 +_,128 @@
             mutableComponent = Component.translatable("multiplayer.player.joined.renamed", player.getDisplayName(), string);
         }
 
-        this.broadcastSystemMessage(mutableComponent.withStyle(ChatFormatting.YELLOW), false);
+        // CraftBukkit start
+        mutableComponent.withStyle(ChatFormatting.YELLOW);
+        Component joinMessage = mutableComponent; // Paper - Adventure
         serverGamePacketListenerImpl.teleport(player.getX(), player.getY(), player.getZ(), player.getYRot(), player.getXRot());
         ServerStatus status = this.server.getStatus();
         if (status != null && !cookie.transferred()) {
             player.sendServerStatus(status);
         }
 
-        player.connection.send(ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(this.players));
+        // player.connection.send(ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(this.players)); // CraftBukkit - replaced with loop below
         this.players.add(player);
+        this.playersByName.put(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT), player); // Spigot
         this.playersByUUID.put(player.getUUID(), player);
-        this.broadcastAll(ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(List.of(player)));
+        // this.broadcastAll(ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(List.of(player))); // CraftBukkit - replaced with loop below
+        // Paper start - Fire PlayerJoinEvent when Player is actually ready; correctly register player BEFORE PlayerJoinEvent, so the entity is valid and doesn't require tick delay hacks
+        player.suppressTrackerForLogin = true;
         this.sendLevelInfo(player, serverLevel);
         serverLevel.addNewPlayer(player);
-        this.server.getCustomBossEvents().onPlayerConnect(player);
+        this.server.getCustomBossEvents().onPlayerConnect(player); // see commented out section below serverLevel.addPlayerJoin(player);
+        // Paper end - Fire PlayerJoinEvent when Player is actually ready
+        player.initInventoryMenu();
+        // CraftBukkit start
+        org.bukkit.craftbukkit.entity.CraftPlayer bukkitPlayer = player.getBukkitEntity();
+
+        // Ensure that player inventory is populated with its viewer
+        player.containerMenu.transferTo(player.containerMenu, bukkitPlayer);
+
+        org.bukkit.event.player.PlayerJoinEvent playerJoinEvent = new org.bukkit.event.player.PlayerJoinEvent(bukkitPlayer, io.papermc.paper.adventure.PaperAdventure.asAdventure(mutableComponent)); // Paper - Adventure
+        this.cserver.getPluginManager().callEvent(playerJoinEvent);
+
+        if (!player.connection.isAcceptingMessages()) {
+            return;
+        }
+
+        final net.kyori.adventure.text.Component jm = playerJoinEvent.joinMessage();
+
+        if (jm != null && !jm.equals(net.kyori.adventure.text.Component.empty())) { // Paper - Adventure
+            joinMessage = io.papermc.paper.adventure.PaperAdventure.asVanilla(jm); // Paper - Adventure
+            this.server.getPlayerList().broadcastSystemMessage(joinMessage, false); // Paper - Adventure
+        }
+        // CraftBukkit end
+
+        // CraftBukkit start - sendAll above replaced with this loop
+        ClientboundPlayerInfoUpdatePacket packet = ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(List.of(player)); // Paper - Add Listing API for Player
+
+        final List<ServerPlayer> onlinePlayers = Lists.newArrayListWithExpectedSize(this.players.size() - 1); // Paper - Use single player info update packet on join
+        for (int i = 0; i < this.players.size(); ++i) {
+            ServerPlayer entityplayer1 = (ServerPlayer) this.players.get(i);
+
+            if (entityplayer1.getBukkitEntity().canSee(bukkitPlayer)) {
+                // Paper start - Add Listing API for Player
+                if (entityplayer1.getBukkitEntity().isListed(bukkitPlayer)) {
+                    // Paper end - Add Listing API for Player
+                    entityplayer1.connection.send(packet);
+                    // Paper start - Add Listing API for Player
+                } else {
+                    entityplayer1.connection.send(ClientboundPlayerInfoUpdatePacket.createSinglePlayerInitializing(player, false));
+                }
+                // Paper end - Add Listing API for Player
+            }
+
+            if (entityplayer1 == player || !bukkitPlayer.canSee(entityplayer1.getBukkitEntity())) { // Paper - Use single player info update packet on join; Don't include joining player
+                continue;
+            }
+
+            onlinePlayers.add(entityplayer1); // Paper - Use single player info update packet on join
+        }
+        // Paper start - Use single player info update packet on join
+        if (!onlinePlayers.isEmpty()) {
+            player.connection.send(ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(onlinePlayers, player)); // Paper - Add Listing API for Player
+        }
+        // Paper end - Use single player info update packet on join
+        player.sentListPacket = true;
+        player.suppressTrackerForLogin = false; // Paper - Fire PlayerJoinEvent when Player is actually ready
+        ((ServerLevel)player.level()).getChunkSource().chunkMap.addEntity(player); // Paper - Fire PlayerJoinEvent when Player is actually ready; track entity now
+        // CraftBukkit end
+
+        //player.refreshEntityData(player); // CraftBukkit - BungeeCord#2321, send complete data to self on spawn // Paper - THIS IS NOT NEEDED ANYMORE
+
+        this.sendLevelInfo(player, serverLevel);
+
+        // CraftBukkit start - Only add if the player wasn't moved in the event
+        if (player.level() == serverLevel && !serverLevel.players().contains(player)) {
+            serverLevel.addNewPlayer(player);
+            this.server.getCustomBossEvents().onPlayerConnect(player);
+        }
+
+        serverLevel = player.level(); // CraftBukkit - Update in case join event changed it
+        // CraftBukkit end
         this.sendActivePlayerEffects(player);
+        // Paper - move loading pearls / parent vehicle up
         player.initInventoryMenu();
         this.server.notificationManager().playerJoined(player);
+        // Paper start - Configurable player collision; Add to collideRule team if needed
+        final net.minecraft.world.scores.Scoreboard scoreboard = this.getServer().getLevel(Level.OVERWORLD).getScoreboard();
+        final PlayerTeam collideRuleTeam = scoreboard.getPlayerTeam(this.collideRuleTeamName);
+        if (this.collideRuleTeamName != null && collideRuleTeam != null && player.getTeam() == null) {
+            scoreboard.addPlayerToTeam(player.getScoreboardName(), collideRuleTeam);
+        }
+        // Paper end - Configurable player collision
+        // CraftBukkit start - moved down
+        LOGGER.info(
+            "{}[{}] logged in with entity id {} at ([{}]{}, {}, {})", // CraftBukkit - add world name
+            player.getPlainTextName(),
+            loggableAddress,
+            player.getId(),
+            serverLevel.serverLevelData.getLevelName(), // CraftBukkit - add world name
+            player.getX(),
+            player.getY(),
+            player.getZ()
+        );
+        // CraftBukkit end - moved down
+        // Paper start - Send empty chunk, so players aren't stuck in the world loading screen with our chunk system not sending chunks when dead
+        if (player.isDeadOrDying()) {
+            net.minecraft.core.Holder<net.minecraft.world.level.biome.Biome> plains = serverLevel.registryAccess().lookupOrThrow(net.minecraft.core.registries.Registries.BIOME)
+                .getOrThrow(net.minecraft.world.level.biome.Biomes.PLAINS);
+            player.connection.send(new net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket(
+                new net.minecraft.world.level.chunk.EmptyLevelChunk(serverLevel, player.chunkPosition(), plains),
+                serverLevel.getLightEngine(), (java.util.BitSet)null, (java.util.BitSet) null)
+            );
+        }
+        // Paper end - Send empty chunk
     }
 
     public void updateEntireScoreboard(ServerScoreboard scoreboard, ServerPlayer player) {
@@ -235,31 +_,40 @@
         }
     }
 
+    // Paper start - virtual world border API
+    private void broadcastWorldborder(Packet<?> packet, ResourceKey<Level> dimension) {
+        for (ServerPlayer serverPlayer : this.players) {
+            if (serverPlayer.level().dimension() == dimension && serverPlayer.getBukkitEntity().getWorldBorder() == null) {
+                serverPlayer.connection.send(packet);
+            }
+        }
+    }
+    // Paper end - virtual world border API
     public void addWorldborderListener(final ServerLevel level) {
         level.getWorldBorder().addListener(new BorderChangeListener() {
             @Override
             public void onSetSize(WorldBorder border, double size) {
-                PlayerList.this.broadcastAll(new ClientboundSetBorderSizePacket(border), level.dimension());
+                PlayerList.this.broadcastWorldborder(new ClientboundSetBorderSizePacket(border), level.dimension()); // Paper - virtual world border API
             }
 
             @Override
             public void onLerpSize(WorldBorder border, double oldSize, double newSize, long time) {
-                PlayerList.this.broadcastAll(new ClientboundSetBorderLerpSizePacket(border), level.dimension());
+                PlayerList.this.broadcastWorldborder(new ClientboundSetBorderLerpSizePacket(border), level.dimension()); // Paper - virtual world border API
             }
 
             @Override
             public void onSetCenter(WorldBorder border, double x, double z) {
-                PlayerList.this.broadcastAll(new ClientboundSetBorderCenterPacket(border), level.dimension());
+                PlayerList.this.broadcastWorldborder(new ClientboundSetBorderCenterPacket(border), level.dimension()); // Paper - virtual world border API
             }
 
             @Override
             public void onSetWarningTime(WorldBorder border, int warningTime) {
-                PlayerList.this.broadcastAll(new ClientboundSetBorderWarningDelayPacket(border), level.dimension());
+                PlayerList.this.broadcastWorldborder(new ClientboundSetBorderWarningDelayPacket(border), level.dimension()); // Paper - virtual world border API
             }
 
             @Override
             public void onSetWarningBlocks(WorldBorder border, int warningBlocks) {
-                PlayerList.this.broadcastAll(new ClientboundSetBorderWarningDistancePacket(border), level.dimension());
+                PlayerList.this.broadcastWorldborder(new ClientboundSetBorderWarningDistancePacket(border), level.dimension()); // Paper - virtual world border API
             }
 
             @Override
@@ -283,57 +_,137 @@
     }
 
     protected void save(ServerPlayer player) {
+        if (!player.getBukkitEntity().isPersistent()) return; // CraftBukkit
         this.playerIo.save(player);
-        ServerStatsCounter serverStatsCounter = this.stats.get(player.getUUID());
+        ServerStatsCounter serverStatsCounter = player.getStats(); // CraftBukkit
         if (serverStatsCounter != null) {
             serverStatsCounter.save();
         }
 
-        PlayerAdvancements playerAdvancements = this.advancements.get(player.getUUID());
+        PlayerAdvancements playerAdvancements = player.getAdvancements(); // CraftBukkit
         if (playerAdvancements != null) {
             playerAdvancements.save();
         }
     }
 
-    public void remove(ServerPlayer player) {
+    public @Nullable net.kyori.adventure.text.Component remove(ServerPlayer player) { // CraftBukkit - return string // Paper - return Component
+        // Paper start - Fix kick event leave message not being sent
+        return this.remove(player, net.kyori.adventure.text.Component.translatable("multiplayer.player.left", net.kyori.adventure.text.format.NamedTextColor.YELLOW, io.papermc.paper.configuration.GlobalConfiguration.get().messages.useDisplayNameInQuitMessage ? player.getBukkitEntity().displayName() : io.papermc.paper.adventure.PaperAdventure.asAdventure(player.getDisplayName())));
+    }
+    public @Nullable net.kyori.adventure.text.Component remove(ServerPlayer player, net.kyori.adventure.text.Component leaveMessage) {
+        // Paper end - Fix kick event leave message not being sent
         ServerLevel serverLevel = player.level();
         player.awardStat(Stats.LEAVE_GAME);
+        // CraftBukkit start - Quitting must be before we do final save of data, in case plugins need to modify it
+        // See SPIGOT-5799, SPIGOT-6145
+        if (player.containerMenu != player.inventoryMenu) {
+            player.closeContainer(org.bukkit.event.inventory.InventoryCloseEvent.Reason.DISCONNECT); // Paper - Inventory close reason
+        }
+
+        org.bukkit.event.player.PlayerQuitEvent playerQuitEvent = new org.bukkit.event.player.PlayerQuitEvent(player.getBukkitEntity(), leaveMessage, player.quitReason); // Paper - Adventure & Add API for quit reason
+        this.cserver.getPluginManager().callEvent(playerQuitEvent);
+        player.getBukkitEntity().disconnect();
+
+        if (this.server.isSameThread()) player.doTick(); // SPIGOT-924 // Paper - Improved watchdog support; don't tick during emergency shutdowns
+        // CraftBukkit end
+
+        // Paper start - Configurable player collision; Remove from collideRule team if needed
+        if (this.collideRuleTeamName != null) {
+            final net.minecraft.world.scores.Scoreboard scoreBoard = this.server.getLevel(Level.OVERWORLD).getScoreboard();
+            final PlayerTeam team = scoreBoard.getPlayersTeam(this.collideRuleTeamName);
+            if (player.getTeam() == team && team != null) {
+                scoreBoard.removePlayerFromTeam(player.getScoreboardName(), team);
+            }
+        }
+        // Paper end - Configurable player collision
+
+        // Paper - Drop carried item when player has disconnected
+        if (!player.containerMenu.getCarried().isEmpty()) {
+            net.minecraft.world.item.ItemStack carried = player.containerMenu.getCarried();
+            player.containerMenu.setCarried(net.minecraft.world.item.ItemStack.EMPTY);
+            player.drop(carried, false);
+        }
+        // Paper end - Drop carried item when player has disconnected
         this.save(player);
         if (player.isPassenger()) {
             Entity rootVehicle = player.getRootVehicle();
             if (rootVehicle.hasExactlyOnePlayerPassenger()) {
                 LOGGER.debug("Removing player mount");
                 player.stopRiding();
-                rootVehicle.getPassengersAndSelf().forEach(entity -> entity.setRemoved(Entity.RemovalReason.UNLOADED_WITH_PLAYER));
+                rootVehicle.getPassengersAndSelf().forEach(entity -> {
+                    // Paper start - Fix villager boat exploit
+                    if (entity instanceof net.minecraft.world.entity.npc.AbstractVillager villager) {
+                        final net.minecraft.world.entity.player.Player human = villager.getTradingPlayer();
+                        if (human != null) {
+                            villager.setTradingPlayer(null);
+                        }
+                    }
+                    // Paper end - Fix villager boat exploit
+                    entity.setRemoved(Entity.RemovalReason.UNLOADED_WITH_PLAYER, org.bukkit.event.entity.EntityRemoveEvent.Cause.PLAYER_QUIT); // CraftBukkit - add Bukkit remove cause
+                });
             }
         }
 
         player.unRide();
 
         for (ThrownEnderpearl thrownEnderpearl : player.getEnderPearls()) {
-            thrownEnderpearl.setRemoved(Entity.RemovalReason.UNLOADED_WITH_PLAYER);
+            // Paper start - Allow using old ender pearl behavior
+            if (!thrownEnderpearl.level().paperConfig().misc.legacyEnderPearlBehavior) {
+                thrownEnderpearl.setRemoved(Entity.RemovalReason.UNLOADED_WITH_PLAYER, org.bukkit.event.entity.EntityRemoveEvent.Cause.PLAYER_QUIT); // CraftBukkit - add Bukkit remove cause
+            }
+            // Paper end - Allow using old ender pearl behavior
         }
 
         serverLevel.removePlayerImmediately(player, Entity.RemovalReason.UNLOADED_WITH_PLAYER);
+        player.retireScheduler(); // Paper - Folia schedulers
         player.getAdvancements().stopListening();
         this.players.remove(player);
+        this.playersByName.remove(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT)); // Spigot
         this.server.getCustomBossEvents().onPlayerDisconnect(player);
         UUID uuid = player.getUUID();
         ServerPlayer serverPlayer = this.playersByUUID.get(uuid);
         if (serverPlayer == player) {
             this.playersByUUID.remove(uuid);
-            this.stats.remove(uuid);
-            this.advancements.remove(uuid);
+            // CraftBukkit start
+            // this.stats.remove(uuid);
+            // this.advancements.remove(uuid);
+            // CraftBukkit end
             this.server.notificationManager().playerLeft(player);
         }
 
-        this.broadcastAll(new ClientboundPlayerInfoRemovePacket(List.of(player.getUUID())));
-    }
-
-    @Nullable
-    public Component canPlayerLogin(SocketAddress socketAddress, NameAndId nameAndId) {
-        if (this.bans.isBanned(nameAndId)) {
-            UserBanListEntry userBanListEntry = this.bans.get(nameAndId);
+        // CraftBukkit start
+        // this.broadcastAll(new ClientboundPlayerInfoRemovePacket(List.of(player.getUUID())));
+        ClientboundPlayerInfoRemovePacket packet = new ClientboundPlayerInfoRemovePacket(List.of(player.getUUID()));
+        for (int i = 0; i < this.players.size(); i++) {
+            ServerPlayer otherPlayer = this.players.get(i);
+
+            if (otherPlayer.getBukkitEntity().canSee(player.getBukkitEntity())) {
+                otherPlayer.connection.send(packet);
+            } else {
+                otherPlayer.getBukkitEntity().onEntityRemove(player);
+            }
+        }
+        // This removes the scoreboard (and player reference) for the specific player in the manager
+        this.cserver.getScoreboardManager().removePlayer(player.getBukkitEntity());
+        // CraftBukkit end
+        return playerQuitEvent.quitMessage(); // Paper - Adventure
+    }
+
+    // Paper start - PlayerLoginEvent
+    public record LoginResult(@Nullable Component message, @org.jetbrains.annotations.NotNull org.bukkit.event.player.PlayerLoginEvent.Result result) {
+        public static LoginResult ALLOW = new net.minecraft.server.players.PlayerList.LoginResult(null, org.bukkit.event.player.PlayerLoginEvent.Result.ALLOWED);
+
+        public boolean isAllowed() {
+            return this == ALLOW;
+        }
+    }
+    // Paper end - PlayerLoginEvent
+    public LoginResult canPlayerLogin(SocketAddress socketAddress, NameAndId nameAndId) { // Paper - PlayerLoginEvent
+        LoginResult whitelistEventResult; // Paper
+        // Paper start - Fix MC-158900
+        UserBanListEntry userBanListEntry;
+        if (this.bans.isBanned(nameAndId) && (userBanListEntry = this.bans.get(nameAndId)) != null) {
+            // Paper end - Fix MC-158900
             MutableComponent mutableComponent = Component.translatable("multiplayer.disconnect.banned.reason", userBanListEntry.getReasonMessage());
             if (userBanListEntry.getExpires() != null) {
                 mutableComponent.append(
@@ -341,9 +_,11 @@
                 );
             }
 
-            return mutableComponent;
-        } else if (!this.isWhiteListed(nameAndId)) {
-            return Component.translatable("multiplayer.disconnect.not_whitelisted");
+            return new LoginResult(mutableComponent, org.bukkit.event.player.PlayerLoginEvent.Result.KICK_BANNED); // Paper - PlayerLoginEvent
+            // Paper start - whitelist event
+        } else if ((whitelistEventResult = this.isWhiteListedLogin(nameAndId)).result == org.bukkit.event.player.PlayerLoginEvent.Result.KICK_WHITELIST) {
+            return whitelistEventResult;
+            // Paper end
         } else if (this.ipBans.isBanned(socketAddress)) {
             IpBanListEntry ipBanListEntry = this.ipBans.get(socketAddress);
             MutableComponent mutableComponent = Component.translatable("multiplayer.disconnect.banned_ip.reason", ipBanListEntry.getReasonMessage());
@@ -353,19 +_,18 @@
                 );
             }
 
-            return mutableComponent;
+            return new LoginResult(mutableComponent, org.bukkit.event.player.PlayerLoginEvent.Result.KICK_BANNED); // Paper - PlayerLoginEvent
         } else {
-            return this.players.size() >= this.getMaxPlayers() && !this.canBypassPlayerLimit(nameAndId)
-                ? Component.translatable("multiplayer.disconnect.server_full")
-                : null;
+            return this.canBypassFullServerLogin(nameAndId, new LoginResult(Component.translatable("multiplayer.disconnect.server_full"), org.bukkit.event.player.PlayerLoginEvent.Result.KICK_FULL)); // Paper - PlayerServerFullCheckEvent
         }
     }
 
-    public boolean disconnectAllPlayersWithProfile(UUID profileId) {
+    public boolean disconnectAllPlayersWithProfile(GameProfile profile) { // Paper - validate usernames
+        UUID profileId = profile.id(); // Paper - validate usernames
         Set<ServerPlayer> set = Sets.newIdentityHashSet();
 
         for (ServerPlayer serverPlayer : this.players) {
-            if (serverPlayer.getUUID().equals(profileId)) {
+            if (serverPlayer.getUUID().equals(profileId) || (io.papermc.paper.configuration.GlobalConfiguration.get().proxies.isProxyOnlineMode() && serverPlayer.getGameProfile().name().equalsIgnoreCase(profile.name()))) { // Paper - validate usernames
                 set.add(serverPlayer);
             }
         }
@@ -376,23 +_,31 @@
         }
 
         for (ServerPlayer serverPlayer2 : set) {
-            serverPlayer2.connection.disconnect(DUPLICATE_LOGIN_DISCONNECT_MESSAGE);
+            serverPlayer2.connection.disconnect(DUPLICATE_LOGIN_DISCONNECT_MESSAGE, io.papermc.paper.connection.DisconnectionReason.DUPLICATE_LOGIN_MESSAGE); // Paper - disconnect API
         }
 
         return !set.isEmpty();
     }
 
-    public ServerPlayer respawn(ServerPlayer player, boolean keepInventory, Entity.RemovalReason reason) {
-        TeleportTransition teleportTransition = player.findRespawnPositionAndUseSpawnBlock(!keepInventory, TeleportTransition.DO_NOTHING);
+    // Paper start - respawn event
+    public ServerPlayer respawn(ServerPlayer player, boolean keepInventory, Entity.RemovalReason reason, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason respawnReason) {
+        ServerPlayer.RespawnResult result = player.findRespawnPositionAndUseSpawnBlock0(!keepInventory, TeleportTransition.DO_NOTHING, respawnReason);
+        if (result == null) { // disconnected player during the respawn event
+            return player;
+        }
+        TeleportTransition teleportTransition = result.transition();
+        Level fromLevel = player.level();
+        // Paper end - respawn event
         this.players.remove(player);
+        this.playersByName.remove(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT)); // Paper
         player.level().removePlayerImmediately(player, reason);
         ServerLevel level = teleportTransition.newLevel();
-        ServerPlayer serverPlayer = new ServerPlayer(this.server, level, player.getGameProfile(), player.clientInformation());
+        ServerPlayer serverPlayer = player; // Paper - TODO - recreate instance
         serverPlayer.connection = player.connection;
         serverPlayer.restoreFrom(player, keepInventory);
         serverPlayer.setId(player.getId());
         serverPlayer.setMainArm(player.getMainArm());
-        if (!teleportTransition.missingRespawnBlock()) {
+        if (false && !teleportTransition.missingRespawnBlock()) { // Paper - Once we not reuse the player entity, this can be flipped again but without the events being fired
             serverPlayer.copyRespawnPosition(player);
         }
 
@@ -400,17 +_,26 @@
             serverPlayer.addTag(string);
         }
 
+        // Paper start - Once we not reuse the player entity we can remove this.
+        if (!keepInventory) player.reset();
+        serverPlayer.spawnIn(level);
+        serverPlayer.unsetRemoved();
+        serverPlayer.setShiftKeyDown(false);
+        // Paper end
         Vec3 vec3 = teleportTransition.position();
         serverPlayer.snapTo(vec3.x, vec3.y, vec3.z, teleportTransition.yRot(), teleportTransition.xRot());
+        serverPlayer.connection.resetPosition(); // Paper - Fix SPIGOT-1903, MC-98153
+        level.getChunkSource().addTicketWithRadius(net.minecraft.server.level.TicketType.POST_TELEPORT, new net.minecraft.world.level.ChunkPos(net.minecraft.util.Mth.floor(vec3.x()) >> 4, net.minecraft.util.Mth.floor(vec3.z()) >> 4), 1); // Paper - post teleport ticket type
         if (teleportTransition.missingRespawnBlock()) {
             serverPlayer.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.NO_RESPAWN_BLOCK_AVAILABLE, 0.0F));
+            serverPlayer.setRespawnPosition(null, false, com.destroystokyo.paper.event.player.PlayerSetSpawnEvent.Cause.PLAYER_RESPAWN); // CraftBukkit - SPIGOT-5988: Clear respawn location when obstructed
         }
 
         byte b = (byte)(keepInventory ? 1 : 0);
         ServerLevel serverLevel = serverPlayer.level();
         LevelData levelData = serverLevel.getLevelData();
         serverPlayer.connection.send(new ClientboundRespawnPacket(serverPlayer.createCommonSpawnInfo(serverLevel), b));
-        serverPlayer.connection.teleport(serverPlayer.getX(), serverPlayer.getY(), serverPlayer.getZ(), serverPlayer.getYRot(), serverPlayer.getXRot());
+        serverPlayer.connection.internalTeleport(serverPlayer.getX(), serverPlayer.getY(), serverPlayer.getZ(), serverPlayer.getYRot(), serverPlayer.getXRot()); // Paper
         serverPlayer.connection.send(new ClientboundSetDefaultSpawnPositionPacket(level.getRespawnData()));
         serverPlayer.connection.send(new ClientboundChangeDifficultyPacket(levelData.getDifficulty(), levelData.isDifficultyLocked()));
         serverPlayer.connection
@@ -420,9 +_,15 @@
         this.sendPlayerPermissionLevel(serverPlayer);
         level.addRespawnedPlayer(serverPlayer);
         this.players.add(serverPlayer);
+        this.playersByName.put(serverPlayer.getScoreboardName().toLowerCase(java.util.Locale.ROOT), serverPlayer); // Paper
         this.playersByUUID.put(serverPlayer.getUUID(), serverPlayer);
         serverPlayer.initInventoryMenu();
         serverPlayer.setHealth(serverPlayer.getHealth());
+        // Paper start - Once we not reuse the player entity we can remove this.
+        // But we have to resend the player info as it's not marked as dirty
+        this.sendAllPlayerInfo(player); // Update health
+        player.onUpdateAbilities(); // Update inventory, etc
+        // Paper end
         ServerPlayer.RespawnConfig respawnConfig = serverPlayer.getRespawnConfig();
         if (!keepInventory && respawnConfig != null) {
             LevelData.RespawnData respawnData = respawnConfig.respawnData();
@@ -448,6 +_,29 @@
             }
         }
 
+        // Paper start
+        // Save player file again if they were disconnected
+        if (serverPlayer.connection.isDisconnected()) {
+            this.save(serverPlayer);
+        }
+
+        // It's possible for respawn to be in a diff dimension
+        if (fromLevel != level) {
+            new org.bukkit.event.player.PlayerChangedWorldEvent(serverPlayer.getBukkitEntity(), fromLevel.getWorld()).callEvent();
+            serverPlayer.triggerDimensionChangeTriggers(level);
+        }
+
+        // Call post respawn event
+        new com.destroystokyo.paper.event.player.PlayerPostRespawnEvent(
+            serverPlayer.getBukkitEntity(),
+            org.bukkit.craftbukkit.util.CraftLocation.toBukkit(teleportTransition.position(), level, teleportTransition.yRot(), teleportTransition.xRot()),
+            result.isBedSpawn(),
+            result.isAnchorSpawn(),
+            teleportTransition.missingRespawnBlock(),
+            respawnReason
+        ).callEvent();
+        // Paper end
+
         return serverPlayer;
     }
 
@@ -456,23 +_,58 @@
     }
 
     public void sendActiveEffects(LivingEntity entity, ServerGamePacketListenerImpl connection) {
+        // Paper start - collect packets
+        this.sendActiveEffects(entity, connection::send);
+    }
+    public void sendActiveEffects(LivingEntity entity, java.util.function.Consumer<Packet<? super net.minecraft.network.protocol.game.ClientGamePacketListener>> packetConsumer) {
+        // Paper end - collect packets
         for (MobEffectInstance mobEffectInstance : entity.getActiveEffects()) {
-            connection.send(new ClientboundUpdateMobEffectPacket(entity.getId(), mobEffectInstance, false));
+            packetConsumer.accept(new ClientboundUpdateMobEffectPacket(entity.getId(), mobEffectInstance, false)); // Paper - collect packets
         }
     }
 
     public void sendPlayerPermissionLevel(ServerPlayer player) {
+        // Paper start - avoid recalculating permissions if possible
+        this.sendPlayerPermissionLevel(player, true);
+    }
+
+    public void sendPlayerPermissionLevel(ServerPlayer player, boolean recalculatePermissions) {
+        // Paper end - avoid recalculating permissions if possible
         int profilePermissions = this.server.getProfilePermissions(player.nameAndId());
-        this.sendPlayerPermissionLevel(player, profilePermissions);
+        this.sendPlayerPermissionLevel(player, profilePermissions, recalculatePermissions); // Paper - avoid recalculating permissions if possible
     }
 
     public void tick() {
         if (++this.sendAllPlayerInfoIn > 600) {
-            this.broadcastAll(new ClientboundPlayerInfoUpdatePacket(EnumSet.of(ClientboundPlayerInfoUpdatePacket.Action.UPDATE_LATENCY), this.players));
+            // CraftBukkit start
+            for (int i = 0; i < this.players.size(); ++i) {
+                final ServerPlayer target = this.players.get(i);
+
+                target.connection.send(new ClientboundPlayerInfoUpdatePacket(EnumSet.of(ClientboundPlayerInfoUpdatePacket.Action.UPDATE_LATENCY), com.google.common.collect.Collections2.filter(this.players, t -> target.getBukkitEntity().canSee(t.getBukkitEntity()))));
+            }
+            // CraftBukkit end
             this.sendAllPlayerInfoIn = 0;
         }
     }
 
+    // CraftBukkit start - add a world/entity limited version
+    public void broadcastAll(Packet packet, net.minecraft.world.entity.player.Player entityhuman) {
+        for (ServerPlayer entityplayer : this.players) { // Paper - replace for i with for each for thread safety
+            if (entityhuman != null && !entityplayer.getBukkitEntity().canSee(entityhuman.getBukkitEntity())) {
+                continue;
+            }
+            ((ServerPlayer) entityplayer).connection.send(packet); // Paper - replace for i with for each for thread safety
+        }
+    }
+
+    public void broadcastAll(Packet packet, Level world) {
+        for (int i = 0; i < world.players().size(); ++i) {
+            ((ServerPlayer) world.players().get(i)).connection.send(packet);
+        }
+
+    }
+    // CraftBukkit end
+
     public void broadcastAll(Packet<?> packet) {
         for (ServerPlayer serverPlayer : this.players) {
             serverPlayer.connection.send(packet);
@@ -558,6 +_,12 @@
     }
 
     private void sendPlayerPermissionLevel(ServerPlayer player, int permLevel) {
+        // Paper start - Add sendOpLevel API
+        this.sendPlayerPermissionLevel(player, permLevel, true);
+    }
+
+    public void sendPlayerPermissionLevel(ServerPlayer player, int permLevel, boolean recalculatePermissions) {
+        // Paper end - Add sendOpLevel API
         if (player.connection != null) {
             byte b;
             if (permLevel <= 0) {
@@ -571,9 +_,48 @@
             player.connection.send(new ClientboundEntityEventPacket(player, b));
         }
 
+        if (recalculatePermissions) { // Paper - Add sendOpLevel API
+        player.getBukkitEntity().recalculatePermissions(); // CraftBukkit
         this.server.getCommands().sendCommands(player);
-    }
-
+        } // Paper - Add sendOpLevel API
+    }
+
+    // Paper start - whitelist verify event / login event
+    public LoginResult canBypassFullServerLogin(final NameAndId nameAndId, final LoginResult currentResult) {
+        final boolean shouldKick = this.players.size() >= this.getMaxPlayers() && !this.canBypassPlayerLimit(nameAndId);
+        final io.papermc.paper.event.player.PlayerServerFullCheckEvent fullCheckEvent = new io.papermc.paper.event.player.PlayerServerFullCheckEvent(
+            new com.destroystokyo.paper.profile.CraftPlayerProfile(nameAndId),
+            io.papermc.paper.adventure.PaperAdventure.asAdventure(currentResult.message),
+            shouldKick
+        );
+
+        fullCheckEvent.callEvent();
+        if (fullCheckEvent.isAllowed()) {
+            return net.minecraft.server.players.PlayerList.LoginResult.ALLOW;
+        } else {
+            return new net.minecraft.server.players.PlayerList.LoginResult(
+                io.papermc.paper.adventure.PaperAdventure.asVanilla(fullCheckEvent.kickMessage()), currentResult.result
+            );
+        }
+    }
+
+    public LoginResult isWhiteListedLogin(NameAndId nameAndId) {
+        boolean isOp = this.ops.contains(nameAndId);
+        boolean isWhitelisted = !this.isUsingWhitelist() || isOp || this.whitelist.contains(nameAndId);
+
+        final net.kyori.adventure.text.Component configuredMessage = net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.whitelistMessage);
+        final com.destroystokyo.paper.event.profile.ProfileWhitelistVerifyEvent event
+            = new com.destroystokyo.paper.event.profile.ProfileWhitelistVerifyEvent(new com.destroystokyo.paper.profile.CraftPlayerProfile(nameAndId), this.isUsingWhitelist(), isWhitelisted, isOp, configuredMessage);
+        event.callEvent();
+        if (!event.isWhitelisted()) {
+            return new net.minecraft.server.players.PlayerList.LoginResult(io.papermc.paper.adventure.PaperAdventure.asVanilla(event.kickMessage() == null ? configuredMessage : event.kickMessage()), org.bukkit.event.player.PlayerLoginEvent.Result.KICK_WHITELIST);
+        }
+
+        return net.minecraft.server.players.PlayerList.LoginResult.ALLOW;
+    }
+    // Paper end
+
+    @io.papermc.paper.annotation.DoNotUse // Paper
     public boolean isWhiteListed(NameAndId nameAndId) {
         return !this.isUsingWhitelist() || this.ops.contains(nameAndId) || this.whitelist.contains(nameAndId);
     }
@@ -586,21 +_,17 @@
 
     @Nullable
     public ServerPlayer getPlayerByName(String username) {
-        int size = this.players.size();
-
-        for (int i = 0; i < size; i++) {
-            ServerPlayer serverPlayer = this.players.get(i);
-            if (serverPlayer.getGameProfile().name().equalsIgnoreCase(username)) {
-                return serverPlayer;
-            }
-        }
-
-        return null;
+        return this.playersByName.get(username.toLowerCase(java.util.Locale.ROOT)); // Spigot
     }
 
     public void broadcast(@Nullable Player except, double x, double y, double z, double radius, ResourceKey<Level> dimension, Packet<?> packet) {
         for (int i = 0; i < this.players.size(); i++) {
             ServerPlayer serverPlayer = this.players.get(i);
+            // CraftBukkit start - Test if player receiving packet can see the source of the packet
+            if (except != null && !serverPlayer.getBukkitEntity().canSee(except.getBukkitEntity())) {
+               continue;
+            }
+            // CraftBukkit end
             if (serverPlayer != except && serverPlayer.level().dimension() == dimension) {
                 double d = x - serverPlayer.getX();
                 double d1 = y - serverPlayer.getY();
@@ -613,9 +_,11 @@
     }
 
     public void saveAll() {
+        io.papermc.paper.util.MCUtil.ensureMain("Save Players" , () -> { // Paper - Ensure main
         for (int i = 0; i < this.players.size(); i++) {
             this.save(this.players.get(i));
         }
+        return null; }); // Paper - ensure main
     }
 
     public UserWhiteList getWhiteList() {
@@ -642,10 +_,18 @@
         player.connection.send(new ClientboundInitializeBorderPacket(worldBorder));
         player.connection.send(new ClientboundSetTimePacket(level.getGameTime(), level.getDayTime(), level.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)));
         player.connection.send(new ClientboundSetDefaultSpawnPositionPacket(level.getRespawnData()));
+        // Paper start
+        player.connection.send(new ClientboundSetChunkCacheRadiusPacket(level.spigotConfig.viewDistance));
+        player.connection.send(new ClientboundSetSimulationDistancePacket(level.spigotConfig.simulationDistance));
+        // Paper end
         if (level.isRaining()) {
-            player.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.START_RAINING, 0.0F));
-            player.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.RAIN_LEVEL_CHANGE, level.getRainLevel(1.0F)));
-            player.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.THUNDER_LEVEL_CHANGE, level.getThunderLevel(1.0F)));
+            // CraftBukkit start - handle player weather
+            // player.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.START_RAINING, 0.0F));
+            // player.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.RAIN_LEVEL_CHANGE, level.getRainLevel(1.0F)));
+            // player.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.THUNDER_LEVEL_CHANGE, level.getThunderLevel(1.0F)));
+            player.setPlayerWeather(org.bukkit.WeatherType.DOWNFALL, false);
+            player.updateWeather(-level.rainLevel, level.rainLevel, -level.thunderLevel, level.thunderLevel);
+            // CraftBukkit end
         }
 
         player.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.LEVEL_CHUNKS_LOAD_START, 0.0F));
@@ -654,8 +_,21 @@
 
     public void sendAllPlayerInfo(ServerPlayer player) {
         player.inventoryMenu.sendAllDataToRemote();
-        player.resetSentInfo();
+        // entityplayer.resetSentInfo();
+        // Paper start - send all attributes
+        // needs to be done because the ServerPlayer instance is being reused on respawn instead of getting replaced like on vanilla
+        java.util.Collection<net.minecraft.world.entity.ai.attributes.AttributeInstance> syncableAttributes = player.getAttributes().getSyncableAttributes();
+        player.getBukkitEntity().injectScaledMaxHealth(syncableAttributes, true);
+        player.connection.send(new net.minecraft.network.protocol.game.ClientboundUpdateAttributesPacket(player.getId(), syncableAttributes));
+        // Paper end - send all attributes
+        player.refreshEntityData(player); // CraftBukkit - SPIGOT-7218: sync metadata
         player.connection.send(new ClientboundSetHeldSlotPacket(player.getInventory().getSelectedSlot()));
+        // CraftBukkit start - from GameRules
+        int i = player.level().getGameRules().getBoolean(GameRules.RULE_REDUCEDDEBUGINFO) ? 22 : 23;
+        player.connection.send(new ClientboundEntityEventPacket(player, (byte) i));
+        float immediateRespawn = player.level().getGameRules().getBoolean(GameRules.RULE_DO_IMMEDIATE_RESPAWN) ? 1.0F: 0.0F;
+        player.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.IMMEDIATE_RESPAWN, immediateRespawn));
+        // CraftBukkit end
     }
 
     public int getPlayerCount() {
@@ -704,9 +_,26 @@
     }
 
     public void removeAll() {
-        for (int i = 0; i < this.players.size(); i++) {
-            this.players.get(i).connection.disconnect(Component.translatable("multiplayer.disconnect.server_shutdown"));
-        }
+        // Paper start - Extract method to allow for restarting flag
+        this.removeAll(false);
+    }
+
+    public void removeAll(boolean isRestarting) {
+        // Paper end
+        // CraftBukkit start - disconnect safely
+        for (ServerPlayer player : this.players) {
+            if (isRestarting) player.connection.disconnect(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.restartMessage), org.bukkit.event.player.PlayerKickEvent.Cause.UNKNOWN); else // Paper - kick event cause (cause is never used here)
+            player.connection.disconnect(java.util.Objects.requireNonNullElseGet(this.server.server.shutdownMessage(), net.kyori.adventure.text.Component::empty)); // CraftBukkit - add custom shutdown message // Paper - Adventure
+        }
+        // CraftBukkit end
+
+        // Paper start - Configurable player collision; Remove collideRule team if it exists
+        if (this.collideRuleTeamName != null) {
+            final net.minecraft.world.scores.Scoreboard scoreboard = this.getServer().getLevel(Level.OVERWORLD).getScoreboard();
+            final PlayerTeam team = scoreboard.getPlayersTeam(this.collideRuleTeamName);
+            if (team != null) scoreboard.removePlayerTeam(team);
+        }
+        // Paper end - Configurable player collision
     }
 
     public void broadcastSystemMessage(Component message, boolean overlay) {
@@ -729,20 +_,39 @@
     }
 
     public void broadcastChatMessage(PlayerChatMessage message, ServerPlayer sender, ChatType.Bound boundChatType) {
-        this.broadcastChatMessage(message, sender::shouldFilterMessageTo, sender, boundChatType);
+        // Paper start
+        this.broadcastChatMessage(message, sender, boundChatType, null);
+    }
+    public void broadcastChatMessage(PlayerChatMessage message, ServerPlayer sender, ChatType.Bound boundChatType, @Nullable Function<net.kyori.adventure.audience.Audience, Component> unsignedFunction) {
+        // Paper end
+        this.broadcastChatMessage(message, sender::shouldFilterMessageTo, sender, boundChatType, unsignedFunction); // Paper
     }
 
     private void broadcastChatMessage(
         PlayerChatMessage message, Predicate<ServerPlayer> shouldFilterMessageTo, @Nullable ServerPlayer sender, ChatType.Bound boundChatType
     ) {
+        // Paper start
+        this.broadcastChatMessage(message, shouldFilterMessageTo, sender, boundChatType, null);
+    }
+    public void broadcastChatMessage(PlayerChatMessage message, Predicate<ServerPlayer> shouldFilterMessageTo, @Nullable ServerPlayer sender, ChatType.Bound boundChatType, @Nullable Function<net.kyori.adventure.audience.Audience, Component> unsignedFunction) {
+        // Paper end
         boolean flag = this.verifyChatTrusted(message);
-        this.server.logChatMessage(message.decoratedContent(), boundChatType, flag ? null : "Not Secure");
+        this.server.logChatMessage((unsignedFunction == null ? message.decoratedContent() : unsignedFunction.apply(this.server.console)), boundChatType, flag ? null : "Not Secure"); // Paper
         OutgoingChatMessage outgoingChatMessage = OutgoingChatMessage.create(message);
         boolean flag1 = false;
 
+        Packet<?> disguised = sender != null && unsignedFunction == null ? new net.minecraft.network.protocol.game.ClientboundDisguisedChatPacket(outgoingChatMessage.content(), boundChatType) : null; // Paper - don't send player chat packets from vanished players
         for (ServerPlayer serverPlayer : this.players) {
             boolean flag2 = shouldFilterMessageTo.test(serverPlayer);
-            serverPlayer.sendChatMessage(outgoingChatMessage, flag2, boundChatType);
+            // Paper start - don't send player chat packets from vanished players
+            if (sender != null && !serverPlayer.getBukkitEntity().canSee(sender.getBukkitEntity())) {
+                serverPlayer.connection.send(unsignedFunction != null
+                    ? new net.minecraft.network.protocol.game.ClientboundDisguisedChatPacket(unsignedFunction.apply(serverPlayer.getBukkitEntity()), boundChatType)
+                    : disguised);
+                continue;
+            }
+            serverPlayer.sendChatMessage(outgoingChatMessage, flag2, boundChatType, unsignedFunction == null ? null : unsignedFunction.apply(serverPlayer.getBukkitEntity()));
+            // Paper end
             flag1 |= flag2 && message.isFullyFiltered();
         }
 
@@ -755,15 +_,21 @@
         return message.hasSignature() && !message.hasExpiredServer(Instant.now());
     }
 
-    public ServerStatsCounter getPlayerStats(Player player) {
-        GameProfile gameProfile = player.getGameProfile();
-        UUID uuid = gameProfile.id();
-        ServerStatsCounter serverStatsCounter = this.stats.get(uuid);
+    // CraftBukkit start
+    public ServerStatsCounter getPlayerStats(ServerPlayer player) {
+        ServerStatsCounter serverstatisticmanager = player.getStats();
+        return serverstatisticmanager == null ? this.getPlayerStats(player.getUUID(), player.getGameProfile().name()) : serverstatisticmanager; // Paper - use username and not display name
+    }
+
+    public ServerStatsCounter getPlayerStats(UUID uuid, String displayName) {
+        ServerPlayer player = this.getPlayer(uuid);
+        ServerStatsCounter serverStatsCounter = player == null ? null : player.getStats();
+        // CraftBukkit end
         if (serverStatsCounter == null) {
             File file = this.server.getWorldPath(LevelResource.PLAYER_STATS_DIR).toFile();
             File file1 = new File(file, uuid + ".json");
             if (!file1.exists()) {
-                File file2 = new File(file, gameProfile.name() + ".json");
+                File file2 = new File(file, displayName + ".json"); // CraftBukkit
                 Path path = file2.toPath();
                 if (FileUtil.isPathNormalized(path) && FileUtil.isPathPortable(path) && path.startsWith(file.getPath()) && file2.isFile()) {
                     file2.renameTo(file1);
@@ -771,7 +_,7 @@
             }
 
             serverStatsCounter = new ServerStatsCounter(this.server, file1);
-            this.stats.put(uuid, serverStatsCounter);
+            // this.stats.put(uuid, serverStatsCounter); // CraftBukkit
         }
 
         return serverStatsCounter;
@@ -779,11 +_,11 @@
 
     public PlayerAdvancements getPlayerAdvancements(ServerPlayer player) {
         UUID uuid = player.getUUID();
-        PlayerAdvancements playerAdvancements = this.advancements.get(uuid);
+        PlayerAdvancements playerAdvancements = player.getAdvancements(); // CraftBukkit
         if (playerAdvancements == null) {
             Path path = this.server.getWorldPath(LevelResource.PLAYER_ADVANCEMENTS_DIR).resolve(uuid + ".json");
             playerAdvancements = new PlayerAdvancements(this.server.getFixerUpper(), this, this.server.getAdvancements(), path, player);
-            this.advancements.put(uuid, playerAdvancements);
+            // this.advancements.put(uuid, playerAdvancements); // CraftBukkit
         }
 
         playerAdvancements.setPlayer(player);
@@ -837,11 +_,34 @@
     }
 
     public void reloadResources() {
-        for (PlayerAdvancements playerAdvancements : this.advancements.values()) {
-            playerAdvancements.reload(this.server.getAdvancements());
+        // Paper start - API for updating recipes on clients
+        this.reloadAdvancementData();
+        this.reloadTagData();
+        this.reloadRecipes();
+    }
+    public void reloadAdvancementData() {
+        // Paper end - API for updating recipes on clients
+        // CraftBukkit start
+        // for (PlayerAdvancements playerAdvancements : this.advancements.values()) {
+        //     playerAdvancements.reload(this.server.getAdvancements());
+        // }
+        for (ServerPlayer player : this.players) {
+            player.getAdvancements().reload(this.server.getAdvancements());
+            player.getAdvancements().flushDirty(player, false); // CraftBukkit - trigger immediate flush of advancements
         }
+        // CraftBukkit end
 
+        // Paper start - API for updating recipes on clients
+    }
+    public void reloadTagData() {
         this.broadcastAll(new ClientboundUpdateTagsPacket(TagNetworkSerialization.serializeTagsToNetwork(this.registries)));
+        // CraftBukkit start
+        // this.reloadRecipes(); // Paper - do not reload recipes just because tag data was reloaded
+        // Paper end - API for updating recipes on clients
+    }
+
+    public void reloadRecipes() {
+        // CraftBukkit end
         RecipeManager recipeManager = this.server.getRecipeManager();
         ClientboundUpdateRecipesPacket clientboundUpdateRecipesPacket = new ClientboundUpdateRecipesPacket(
             recipeManager.getSynchronizedItemProperties(), recipeManager.getSynchronizedStonecutterRecipes()

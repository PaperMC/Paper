From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Newwind <support@newwindserver.com>
Date: Mon, 16 Feb 2026 23:35:37 +0200
Subject: [PATCH] Speculative portal chunk loading

Nether portals loading chunks on the main thread is a big cause of lag, freezing the server upwards of 1-2 seconds.
Since there isn't an easy way to load these chunks async, we can instead preload them, as it takes some time for survival players to travel through a portal.
This shouldn't break any vanilla behaviour as the chunk ticket does not simulate.

diff --git a/net/minecraft/world/entity/PortalProcessor.java b/net/minecraft/world/entity/PortalProcessor.java
index 4e69e32..5b41a8a 100644
--- a/net/minecraft/world/entity/PortalProcessor.java
+++ b/net/minecraft/world/entity/PortalProcessor.java
@@ -6,6 +6,8 @@ import net.minecraft.world.level.block.Portal;
 import net.minecraft.world.level.portal.TeleportTransition;
 import org.jspecify.annotations.Nullable;
 
+import static net.minecraft.server.level.TicketType.SPECULATIVE_PORTAL;
+
 public class PortalProcessor {
     private final Portal portal;
     private BlockPos entryPosition;
@@ -24,9 +26,50 @@ public class PortalProcessor {
             return false;
         } else {
             this.insidePortalThisTick = false;
-            return canChangeDimensions && this.portalTime++ >= this.portal.getPortalTransitionTime(level, entity);
+
+            // Paper start - Portal speculator
+            int transitionTime = this.portal.getPortalTransitionTime(level, entity);
+
+            if (level.paperConfig().environment.netherPortalPreloadingTicksBefore.enabled()) {
+                int ticksBefore = level.paperConfig().environment.netherPortalPreloadingTicksBefore.intValue();
+                if (canChangeDimensions && this.portalTime == transitionTime - ticksBefore && portal instanceof net.minecraft.world.level.block.NetherPortalBlock) {
+                    preloadPortalDestinationChunks(level, entity);
+                }
+            }
+
+            return canChangeDimensions && this.portalTime++ >= transitionTime;
+            // Paper end
+        }
+    }
+
+    // Paper start - Portal speculator, copying from NetherPortalBlock.getPortalDestination()
+    private void preloadPortalDestinationChunks(ServerLevel sourceLevel, Entity entity) {
+        net.minecraft.resources.ResourceKey<net.minecraft.world.level.Level> resourceKey = sourceLevel.getTypeKey() == net.minecraft.world.level.dimension.LevelStem.NETHER ? net.minecraft.world.level.Level.OVERWORLD : net.minecraft.world.level.Level.NETHER;
+        ServerLevel destinationLevel = sourceLevel.getServer().getLevel(resourceKey);
+
+        boolean flag = destinationLevel.getTypeKey() == net.minecraft.world.level.dimension.LevelStem.NETHER;
+        net.minecraft.world.level.border.WorldBorder worldBorder = destinationLevel.getWorldBorder();
+        double teleportationScale = net.minecraft.world.level.dimension.DimensionType.getTeleportationScale(sourceLevel.dimensionType(), destinationLevel.dimensionType());
+        BlockPos blockPos = worldBorder.clampToBounds(entity.getX() * teleportationScale, entity.getY(), entity.getZ() * teleportationScale);
+
+        int portalSearchRadius = destinationLevel.paperConfig().environment.portalSearchRadius;
+        if (entity.level().paperConfig().environment.portalSearchVanillaDimensionScaling && flag) { // flag = is going to nether
+            portalSearchRadius = (int) (portalSearchRadius / destinationLevel.dimensionType().coordinateScale());
         }
+
+        addLoadingTicketToChunks(destinationLevel, blockPos, portalSearchRadius);
+    }
+
+    private void addLoadingTicketToChunks(ServerLevel level, BlockPos center, int portalSearchRadius) {
+        net.minecraft.server.level.ServerChunkCache chunkSource = level.getChunkSource();
+
+        int chunkRadius = (portalSearchRadius + 15) >> 4;
+
+        chunkSource.addTicketAndLoadWithRadius(SPECULATIVE_PORTAL, new net.minecraft.world.level.ChunkPos(center), chunkRadius,
+            ca.spottedleaf.concurrentutil.util.Priority.HIGHEST
+        );
     }
+    // Paper end
 
     public @Nullable TeleportTransition getPortalDestination(ServerLevel level, Entity entity) {
         return this.portal.getPortalDestination(level, entity, this.entryPosition);

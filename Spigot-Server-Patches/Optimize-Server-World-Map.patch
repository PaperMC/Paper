From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Mon, 17 Sep 2018 23:37:31 -0400
Subject: [PATCH] Optimize Server World Map

Minecraft moved worlds to a hashmap in 1.13.1.
This creates inconsistent order for iteration of the map.

This patch restores World management to be back as an Array.

.values() will allow us to iterate as it was pre 1.13.1 by
ArrayList, giving consistent ordering and effecient iteration performance.

KeySet and EntrySet iteration is proxied to the List iterator,
and should retain manipulation behavior but nothing should be doing that.

Getting a World by dimension ID is now back a constant time operation.

Hopefully no other plugins try to mess with this map, as we are only handling
known NMS used methods, but we can add more if naughty plugins are found later.

diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldMap.java b/src/main/java/com/destroystokyo/paper/PaperWorldMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..0000000000000000000000000000000000000000
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldMap.java
@@ -0,0 +0,0 @@
+package com.destroystokyo.paper;
+
+import net.minecraft.server.DimensionManager;
+import net.minecraft.server.ResourceKey;
+import net.minecraft.server.World;
+import net.minecraft.server.WorldServer;
+
+import javax.annotation.Nonnull;
+import java.util.AbstractSet;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+public class PaperWorldMap extends HashMap<ResourceKey<World>, WorldServer> {
+    private final List<WorldServer> worlds = new ArrayList<>();
+    private final List<WorldServer> worldsIterable = new ArrayList<WorldServer>() {
+        @Override
+        public Iterator<WorldServer> iterator() {
+            Iterator<WorldServer> iterator = super.iterator();
+            return new Iterator<WorldServer>() {
+                private WorldServer last;
+
+                @Override
+                public boolean hasNext() {
+                    return iterator.hasNext();
+                }
+
+                @Override
+                public WorldServer next() {
+                    this.last = iterator.next();
+                    return last;
+                }
+
+                @Override
+                public void remove() {
+                    worlds.set(last.worldProvider.getDimensionManager().getDimensionID() + 1, null);
+                }
+            };
+        }
+    };
+    @Override
+    public int size() {
+        return worldsIterable.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return worldsIterable.isEmpty();
+    }
+
+    @Override
+    public WorldServer get(Object key) {
+        // Will hit the below method
+        return key instanceof ResourceKey ? get((ResourceKey<World>) key) : null;
+    }
+    // TODO figure out what to do with dimension ids
+    public WorldServer get(ResourceKey<World> key) {
+        int id = key.getDimensionID()+1;
+        return worlds.size() > id ? worlds.get(id) : null;
+    }
+
+    @Override
+    public boolean containsKey(Object key) {
+        // will hit below method
+        return key instanceof DimensionManager && containsKey((DimensionManager) key);
+    }
+    public boolean containsKey(DimensionManager key) {
+        return get(key) != null;
+    }
+
+    @Override
+    public WorldServer put(ResourceKey<World> key, WorldServer value) {
+        while (worlds.size() <= key.getDimensionID()+1) {
+            worlds.add(null);
+        }
+        WorldServer old = worlds.set(key.getDimensionID()+1, value);
+        if (old != null) {
+            worldsIterable.remove(old);
+        }
+        worldsIterable.add(value);
+        return old;
+    }
+
+    @Override
+    public void putAll(Map<? extends ResourceKey<World>, ? extends WorldServer> m) {
+        for (Entry<? extends ResourceKey<World>, ? extends WorldServer> e : m.entrySet()) {
+            put(e.getKey(), e.getValue());
+        }
+    }
+
+    @Override
+    public WorldServer remove(Object key) {
+        return key instanceof DimensionManager ? remove((DimensionManager) key) : null;
+    }
+
+    public WorldServer remove(DimensionManager key) {
+        WorldServer old;
+        if (key.getDimensionID()+1 == worlds.size() - 1) {
+            old = worlds.remove(key.getDimensionID()+1);
+        } else {
+            old = worlds.set(key.getDimensionID() + 1, null);
+        }
+        if (old != null) {
+            worldsIterable.remove(old);
+        }
+        return old;
+    }
+
+    @Override
+    public void clear() {
+        throw new RuntimeException("What the hell are you doing?");
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return value instanceof WorldServer && get(((WorldServer) value).getDimensionKey()) != null;
+    }
+
+    @Nonnull
+    @Override
+    public Set<ResourceKey<World>> keySet() {
+        return new AbstractSet<ResourceKey<World>>() {
+            @Override
+            public Iterator<ResourceKey<World>> iterator() {
+                Iterator<WorldServer> iterator = worldsIterable.iterator();
+                return new Iterator<ResourceKey<World>>() {
+
+                    @Override
+                    public boolean hasNext() {
+                        return iterator.hasNext();
+                    }
+
+                    @Override
+                    public ResourceKey<World> next() {
+                        return iterator.next().getDimensionKey();
+                    }
+
+                    @Override
+                    public void remove() {
+                        iterator.remove();
+                    }
+                };
+            }
+
+            @Override
+            public int size() {
+                return worlds.size();
+            }
+        };
+    }
+
+    @Override
+    public Collection<WorldServer> values() {
+        return worldsIterable;
+    }
+
+    @Override
+    public Set<Entry<ResourceKey<World>, WorldServer>> entrySet() {
+        return new AbstractSet<Entry<ResourceKey<World>, WorldServer>>() {
+            @Override
+            public Iterator<Entry<ResourceKey<World>, WorldServer>> iterator() {
+                Iterator<WorldServer> iterator = worldsIterable.iterator();
+                return new Iterator<Entry<ResourceKey<World>, WorldServer>>() {
+
+                    @Override
+                    public boolean hasNext() {
+                        return iterator.hasNext();
+                    }
+
+                    @Override
+                    public Entry<ResourceKey<World>, WorldServer> next() {
+                        WorldServer entry = iterator.next();
+                        return new SimpleEntry<>(entry.getDimensionKey(), entry);
+                    }
+
+                    @Override
+                    public void remove() {
+                        iterator.remove();
+                    }
+                };
+            }
+
+            @Override
+            public int size() {
+                return worldsIterable.size();
+            }
+        };
+    }
+}
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 0000000000000000000000000000000000000000..0000000000000000000000000000000000000000 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -0,0 +0,0 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
     private String serverIp;
     private int serverPort;
     public final IRegistryCustom.Dimension f;
-    public final Map<ResourceKey<World>, WorldServer> worldServer;
+    public final Map<ResourceKey<World>, WorldServer> worldServer = new com.destroystokyo.paper.PaperWorldMap(); // Paper;
     private PlayerList playerList;
     private volatile boolean isRunning;
     private volatile boolean isRestarting = false; // Paper - flag to signify we're attempting to restart
@@ -0,0 +0,0 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
             }
         }
         this.updateWorldSettings();
-        for (WorldServer worldserver : this.getWorlds()) {
+        for (WorldServer worldserver : com.google.common.collect.Lists.newArrayList(this.getWorlds())) { // Paper - avoid como if 1 world triggers another world
             this.loadSpawn(worldserver.getChunkProvider().playerChunkMap.worldLoadListener, worldserver);
             this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldLoadEvent(worldserver.getWorld()));
         }

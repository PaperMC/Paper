From 065e7c9f13c0749ea89c4928db3512550d365b01 Mon Sep 17 00:00:00 2001
From: Techcable <Techcable@outlook.com>
Date: Wed, 30 Nov 2016 20:56:58 -0600
Subject: [PATCH] Speedup BlockPos by fixing inlining

Normally the JVM can inline virtual getters by having two sets of code, one is the 'optimized' code and the other is the 'deoptimized' code.
If a single type is used 99% of the time, then its worth it to inline, and to revert to 'deoptimized' the 1% of the time we encounter other types.
But if two types are encountered commonly, then the JVM can't inline them both, and the call overhead remains.

This scenario also occurs with BlockPos and MutableBlockPos.
The variables in BlockPos are final, so MutableBlockPos can't modify them.
MutableBlockPos fixes this by adding custom mutable variables, and overriding the getters to access them.

This approach with utility methods that operate on MutableBlockPos and BlockPos.
Specific examples are BlockPosition.up(), and World.isValidLocation().
It makes these simple methods much slower than they need to be.

This should result in an across the board speedup in anything that accesses blocks or does logic with positions.

This is based upon conclusions drawn from inspecting the assenmbly generated bythe JIT compiler on my mircorbenchmarks.
They had 'callq' (invoke) instead of 'mov' (get from memory) instructions.

diff --git a/src/main/java/net/minecraft/server/BaseBlockPosition.java b/src/main/java/net/minecraft/server/BaseBlockPosition.java
index 680764b342..25334377a2 100644
--- a/src/main/java/net/minecraft/server/BaseBlockPosition.java
+++ b/src/main/java/net/minecraft/server/BaseBlockPosition.java
@@ -6,22 +6,22 @@ import javax.annotation.concurrent.Immutable;
 @Immutable
 public class BaseBlockPosition implements Comparable<BaseBlockPosition> {
     public static final BaseBlockPosition ZERO = new BaseBlockPosition(0, 0, 0);
-    private final int a;
-    private final int b;
-    private final int c;
     // Paper start
+    protected int x;
+    protected int y;
+    protected int z;
     public boolean isValidLocation() {
-        return a >= -30000000 && c >= -30000000 && a < 30000000 && c < 30000000 && b >= 0 && b < 256;
+        return x >= -30000000 && z >= -30000000 && x < 30000000 && z < 30000000 && y >= 0 && y < 256;
     }
     public boolean isInvalidYLocation() {
-        return b < 0 || b >= 256;
+        return y < 0 || y >= 256;
     }
     // Paper end
 
     public BaseBlockPosition(int i, int j, int k) {
-        this.a = i;
-        this.b = j;
-        this.c = k;
+        this.x = i;
+        this.y = j;
+        this.z = k;
     }
 
     public BaseBlockPosition(double d0, double d1, double d2) {
@@ -57,17 +57,19 @@ public class BaseBlockPosition implements Comparable<BaseBlockPosition> {
         }
     }
 
-    public int getX() {
-        return this.a;
+    // Paper start
+    public final int getX() {
+        return this.x;
     }
 
     public int getY() {
-        return this.b;
+        return this.y;
     }
 
     public int getZ() {
-        return this.c;
+        return this.z;
     }
+    // Paper end
 
     public BaseBlockPosition d(BaseBlockPosition baseblockposition1) {
         return new BaseBlockPosition(this.getY() * baseblockposition1.getZ() - this.getZ() * baseblockposition1.getY(), this.getZ() * baseblockposition1.getX() - this.getX() * baseblockposition1.getZ(), this.getX() * baseblockposition1.getY() - this.getY() * baseblockposition1.getX());
diff --git a/src/main/java/net/minecraft/server/BlockPosition.java b/src/main/java/net/minecraft/server/BlockPosition.java
index 1dfd71df0a..986b1e13a5 100644
--- a/src/main/java/net/minecraft/server/BlockPosition.java
+++ b/src/main/java/net/minecraft/server/BlockPosition.java
@@ -204,18 +204,20 @@ public class BlockPosition extends BaseBlockPosition {
                     if (this.g == null) {
                         this.g = new BlockPosition.MutableBlockPosition(ix, jx, kx);
                         return this.g;
-                    } else if (this.g.b == l && this.g.c == i1 && this.g.d == j1) {
+                    } else if (this.g.x == l && this.g.y == i1 && this.g.z == j1) { // Paper - use x/y/z
                         return (BlockPosition.MutableBlockPosition)this.endOfData();
                     } else {
-                        if (this.g.b < l) {
-                            ++this.g.b;
-                        } else if (this.g.c < i1) {
-                            this.g.b = ix; // Paper - decompile fix Readd line removed by the decompiler
-                            ++this.g.c;
-                        } else if (this.g.d < j1) {
-                            this.g.b = ix; // Paper - decompile fix Readd line removed by the decompiler
-                            this.g.c = jx; // Paper - decompile fix Readd line removed by the decompiler
-                            ++this.g.d;
+                        // Paper start - use xyz
+                        if (this.g.x < l) {
+                            ++this.g.x;
+                        } else if (this.g.y < i1) {
+                            this.g.x = ix; // Paper - decompile fix Readd line removed by the decompiler
+                            ++this.g.y;
+                        } else if (this.g.z < j1) {
+                            this.g.x = ix; // Paper - decompile fix Readd line removed by the decompiler
+                            this.g.y = jx; // Paper - decompile fix Readd line removed by the decompiler
+                            ++this.g.z;
+                            // Paper end
                         }
 
                         return this.g;
@@ -236,10 +238,12 @@ public class BlockPosition extends BaseBlockPosition {
     }
 
     public static class MutableBlockPosition extends BlockPosition {
+        // Paper start - comment out
+        /*
         protected int b;
         protected int c;
         protected int d;
-        // Paper start
+
         @Override
         public boolean isValidLocation() {
             return b >= -30000000 && d >= -30000000 && b < 30000000 && d < 30000000 && c >= 0 && c < 256;
@@ -248,6 +252,7 @@ public class BlockPosition extends BaseBlockPosition {
         public boolean isInvalidYLocation() {
             return c < 0 || c >= 256;
         }
+        */
         // Paper end
 
         public MutableBlockPosition() {
@@ -259,10 +264,13 @@ public class BlockPosition extends BaseBlockPosition {
         }
 
         public MutableBlockPosition(int i, int j, int k) {
-            super(0, 0, 0);
+            // Paper start
+            super(i, j, k);
+            /*
             this.b = i;
             this.c = j;
-            this.d = k;
+            this.d = k;*/
+            // Paper end
         }
 
         public BlockPosition a(double d0, double d1, double d2) {
@@ -281,6 +289,8 @@ public class BlockPosition extends BaseBlockPosition {
             return super.a(enumblockrotation).h();
         }
 
+        /*
+        // Paper start - use parent getters
         public int getX() {
             return this.b;
         }
@@ -291,13 +301,16 @@ public class BlockPosition extends BaseBlockPosition {
 
         public int getZ() {
             return this.d;
-        }
+        }*/
+        // Paper end
 
         public BlockPosition.MutableBlockPosition setValues(int i, int j, int k) { return c(i, j, k);} // Paper - OBFHELPER
         public BlockPosition.MutableBlockPosition c(int i, int j, int k) {
-            this.b = i;
-            this.c = j;
-            this.d = k;
+            // Paper start - use xyz
+            this.x = i;
+            this.y = j;
+            this.z = k;
+            // Paper end
             return this;
         }
 
@@ -315,15 +328,15 @@ public class BlockPosition extends BaseBlockPosition {
         }
 
         public BlockPosition.MutableBlockPosition c(EnumDirection enumdirection, int i) {
-            return this.c(this.b + enumdirection.getAdjacentX() * i, this.c + enumdirection.getAdjacentY() * i, this.d + enumdirection.getAdjacentZ() * i);
+            return this.c(x + enumdirection.getAdjacentX() * i, y + enumdirection.getAdjacentY() * i, z + enumdirection.getAdjacentZ() * i); // Paper - use xyz
         }
 
         public BlockPosition.MutableBlockPosition d(int i, int j, int k) {
-            return this.c(this.b + i, this.c + j, this.d + k);
+            return this.c(x + i, y + j, z + k); // Paper - use xyz
         }
 
         public void p(int i) {
-            this.c = i;
+            this.y = i; // Paper change to y
         }
 
         public BlockPosition toBlockPosition() { return h(); } // Paper - OBFHELPER
-- 
2.19.0


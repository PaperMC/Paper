From 89d13915b1039ffd557247d45a056339d20d149b Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Wed, 17 Oct 2018 21:58:27 -0400
Subject: [PATCH] Backport Timings improvements from 1.13


diff --git a/src/main/java/co/aikar/timings/TimingHistory.java b/src/main/java/co/aikar/timings/TimingHistory.java
index c2c2fb838..28d0954a3 100644
--- a/src/main/java/co/aikar/timings/TimingHistory.java
+++ b/src/main/java/co/aikar/timings/TimingHistory.java
@@ -201,11 +201,11 @@ public class TimingHistory {
 
         @SuppressWarnings("unchecked")
         final Map<EntityType, Counter> entityCounts = MRUMapCache.of(LoadingMap.of(
-                new EnumMap<EntityType, Counter>(EntityType.class), Counter.LOADER
+                new EnumMap<EntityType, Counter>(EntityType.class), k -> new Counter()
         ));
         @SuppressWarnings("unchecked")
         final Map<Material, Counter> tileEntityCounts = MRUMapCache.of(LoadingMap.of(
-                new EnumMap<Material, Counter>(Material.class), Counter.LOADER
+                new EnumMap<Material, Counter>(Material.class), k -> new Counter()
         ));
 
         static class RegionId {
@@ -335,13 +335,6 @@ public class TimingHistory {
 
     private static class Counter {
         private int count = 0;
-        @SuppressWarnings({"rawtypes", "SuppressionAnnotation", "Guava"})
-        static Function LOADER = new LoadingMap.Feeder<Counter>() {
-            @Override
-            public Counter apply() {
-                return new Counter();
-            }
-        };
         public int increment() {
             return ++count;
         }
diff --git a/src/main/java/co/aikar/timings/TimingIdentifier.java b/src/main/java/co/aikar/timings/TimingIdentifier.java
index 623dda49c..636c7119a 100644
--- a/src/main/java/co/aikar/timings/TimingIdentifier.java
+++ b/src/main/java/co/aikar/timings/TimingIdentifier.java
@@ -23,12 +23,13 @@
  */
 package co.aikar.timings;
 
-import com.google.common.base.Function;
 import co.aikar.util.LoadingMap;
-import co.aikar.util.MRUMapCache;
 
 import java.util.ArrayDeque;
 import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * <p>Used as a basis for fast HashMap key comparisons for the Timing Map.</p>
@@ -39,15 +40,8 @@ final class TimingIdentifier {
     /**
      * Holds all groups. Autoloads on request for a group by name.
      */
-    static final Map<String, TimingGroup> GROUP_MAP = MRUMapCache.of(
-        LoadingMap.newIdentityHashMap(new Function<String, TimingGroup>() {
-            @Override
-            public TimingGroup apply(String group) {
-                return new TimingGroup(group);
-            }
-        }, 64)
-    );
-    static final TimingGroup DEFAULT_GROUP = getGroup("Minecraft");
+    static final Map<String, TimingGroup> GROUP_MAP = LoadingMap.of(new ConcurrentHashMap<>(64, .5F), TimingGroup::new);
+    private static final TimingGroup DEFAULT_GROUP = getGroup("Minecraft");
     final String group;
     final String name;
     final TimingHandler groupHandler;
@@ -55,8 +49,8 @@ final class TimingIdentifier {
     private final int hashCode;
 
     TimingIdentifier(String group, String name, Timing groupHandler, boolean protect) {
-        this.group = group != null ? group.intern() : DEFAULT_GROUP.name;
-        this.name = name.intern();
+        this.group = group != null ? group: DEFAULT_GROUP.name;
+        this.name = name;
         this.groupHandler = groupHandler != null ? groupHandler.getTimingHandler() : null;
         this.protect = protect;
         this.hashCode = (31 * this.group.hashCode()) + this.name.hashCode();
@@ -67,11 +61,9 @@ final class TimingIdentifier {
             return DEFAULT_GROUP;
         }
 
-        return GROUP_MAP.get(groupName.intern());
+        return GROUP_MAP.get(groupName);
     }
 
-    // We are using .intern() on the strings so it is guaranteed to be an identity comparison.
-    @SuppressWarnings("StringEquality")
     @Override
     public boolean equals(Object o) {
         if (o == null) {
@@ -79,7 +71,7 @@ final class TimingIdentifier {
         }
 
         TimingIdentifier that = (TimingIdentifier) o;
-        return group == that.group && name == that.name;
+        return Objects.equals(group, that.group) && Objects.equals(name, that.name);
     }
 
     @Override
@@ -89,8 +81,8 @@ final class TimingIdentifier {
 
     static class TimingGroup {
 
-        private static int idPool = 1;
-        final int id = idPool++;
+        private static AtomicInteger idPool = new AtomicInteger(1);
+        final int id = idPool.getAndIncrement();
 
         final String name;
         ArrayDeque<TimingHandler> handlers = new ArrayDeque<TimingHandler>(64);
@@ -98,5 +90,18 @@ final class TimingIdentifier {
         private TimingGroup(String name) {
             this.name = name;
         }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            TimingGroup that = (TimingGroup) o;
+            return id == that.id;
+        }
+
+        @Override
+        public int hashCode() {
+            return id;
+        }
     }
 }
diff --git a/src/main/java/co/aikar/timings/TimingsManager.java b/src/main/java/co/aikar/timings/TimingsManager.java
index 58ed35e00..3b4401900 100644
--- a/src/main/java/co/aikar/timings/TimingsManager.java
+++ b/src/main/java/co/aikar/timings/TimingsManager.java
@@ -23,45 +23,35 @@
  */
 package co.aikar.timings;
 
-import com.google.common.base.Function;
+import co.aikar.util.LoadingMap;
 import com.google.common.collect.EvictingQueue;
 import org.bukkit.Bukkit;
 import org.bukkit.Server;
 import org.bukkit.command.Command;
 import org.bukkit.plugin.Plugin;
 import org.bukkit.plugin.java.PluginClassLoader;
-import co.aikar.util.LoadingMap;
 
-import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.logging.Level;
 
 public final class TimingsManager {
-    static final Map<TimingIdentifier, TimingHandler> TIMING_MAP =
-        Collections.synchronizedMap(LoadingMap.newHashMap(
-            new Function<TimingIdentifier, TimingHandler>() {
-                @Override
-                public TimingHandler apply(TimingIdentifier id) {
-                    return (id.protect ?
-                        new UnsafeTimingHandler(id) :
-                        new TimingHandler(id)
-                    );
-                }
-            },
-            256, .5F
-        ));
+    static final Map<TimingIdentifier, TimingHandler> TIMING_MAP = LoadingMap.of(
+        new ConcurrentHashMap<>(4096, .5F), id -> (id.protect ?
+            new UnsafeTimingHandler(id) :
+            new TimingHandler(id)
+        )
+    );
     public static final FullServerTickHandler FULL_SERVER_TICK = new FullServerTickHandler();
     public static final TimingHandler TIMINGS_TICK = Timings.ofSafe("Timings Tick", FULL_SERVER_TICK);
     public static final Timing PLUGIN_GROUP_HANDLER = Timings.ofSafe("Plugins");
     public static List<String> hiddenConfigs = new ArrayList<String>();
     public static boolean privacy = false;
 
-    static final Collection<TimingHandler> HANDLERS = new ArrayDeque<TimingHandler>();
-    static final ArrayDeque<TimingHistory.MinuteReport> MINUTE_REPORTS = new ArrayDeque<TimingHistory.MinuteReport>();
+    static final List<TimingHandler> HANDLERS = new ArrayList<>(1024);
+    static final List<TimingHistory.MinuteReport> MINUTE_REPORTS = new ArrayList<>(64);
 
     static EvictingQueue<TimingHistory> HISTORY = EvictingQueue.create(12);
     static TimingHandler CURRENT;
diff --git a/src/main/java/co/aikar/util/LoadingMap.java b/src/main/java/co/aikar/util/LoadingMap.java
index 1474384e8..9a4f9dca8 100644
--- a/src/main/java/co/aikar/util/LoadingMap.java
+++ b/src/main/java/co/aikar/util/LoadingMap.java
@@ -23,20 +23,14 @@
  */
 package co.aikar.util;
 
-
-import com.google.common.base.Function;
-import org.bukkit.Material;
-import co.aikar.timings.TimingHistory;
-import org.w3c.dom.css.Counter;
-
 import java.lang.reflect.Constructor;
 import java.util.AbstractMap;
 import java.util.Collection;
-import java.util.EnumMap;
 import java.util.HashMap;
 import java.util.IdentityHashMap;
 import java.util.Map;
 import java.util.Set;
+import java.util.function.Function;
 
 /**
  * Allows you to pass a Loader function that when a key is accessed that doesn't exists,
@@ -53,16 +47,16 @@ import java.util.Set;
  * @param <K> Key
  * @param <V> Value
  */
-public class LoadingMap <K,V> extends AbstractMap<K, V> {
+public class LoadingMap <K, V> extends AbstractMap<K, V> {
     private final Map<K, V> backingMap;
-    private final Function<K, V> loader;
+    private final java.util.function.Function<K, V> loader;
 
     /**
      * Initializes an auto loading map using specified loader and backing map
      * @param backingMap Map to wrap
      * @param loader Loader
      */
-    public LoadingMap(Map<K, V> backingMap, Function<K, V> loader) {
+    public LoadingMap(Map<K, V> backingMap, java.util.function.Function<K, V> loader) {
         this.backingMap = backingMap;
         this.loader = loader;
     }
@@ -77,7 +71,7 @@ public class LoadingMap <K,V> extends AbstractMap<K, V> {
      * @return Map
      */
     public static <K, V> Map<K, V> of(Map<K, V> backingMap, Function<K, V> loader) {
-        return new LoadingMap<K, V>(backingMap, loader);
+        return new LoadingMap<>(backingMap, loader);
     }
 
     /**
@@ -97,7 +91,7 @@ public class LoadingMap <K,V> extends AbstractMap<K, V> {
      */
     public static <K, V> Map<K, V> newAutoMap(Map<K, V> backingMap, final Class<? extends K> keyClass,
                                               final Class<? extends V> valueClass) {
-        return new LoadingMap<K, V>(backingMap, new AutoInstantiatingLoader<K, V>(keyClass, valueClass));
+        return new LoadingMap<>(backingMap, new AutoInstantiatingLoader<>(keyClass, valueClass));
     }
     /**
      * Creates a LoadingMap with an auto instantiating loader.
@@ -130,7 +124,7 @@ public class LoadingMap <K,V> extends AbstractMap<K, V> {
      * @return Map that auto instantiates on .get()
      */
     public static <K, V> Map<K, V> newHashAutoMap(final Class<? extends K> keyClass, final Class<? extends V> valueClass) {
-        return newAutoMap(new HashMap<K, V>(), keyClass, valueClass);
+        return newAutoMap(new HashMap<>(), keyClass, valueClass);
     }
 
     /**
@@ -161,7 +155,7 @@ public class LoadingMap <K,V> extends AbstractMap<K, V> {
      * @return Map that auto instantiates on .get()
      */
     public static <K, V> Map<K, V> newHashAutoMap(final Class<? extends K> keyClass, final Class<? extends V> valueClass, int initialCapacity, float loadFactor) {
-        return newAutoMap(new HashMap<K, V>(initialCapacity, loadFactor), keyClass, valueClass);
+        return newAutoMap(new HashMap<>(initialCapacity, loadFactor), keyClass, valueClass);
     }
 
     /**
@@ -189,9 +183,21 @@ public class LoadingMap <K,V> extends AbstractMap<K, V> {
      * @return Map
      */
     public static <K, V> Map<K, V> newHashMap(Function<K, V> loader) {
-        return new LoadingMap<K, V>(new HashMap<K, V>(), loader);
+        return new LoadingMap<>(new HashMap<>(), loader);
     }
 
+    /**
+     * Initializes an auto loading map using a HashMap
+     *
+     * @param loader Loader to use
+     * @param initialCapacity Initial capacity to use
+     * @param <K> Key Type of the Map
+     * @param <V> Value Type of the Map
+     * @return Map
+     */
+    public static <K, V> Map<K, V> newHashMap(Function<K, V> loader, int initialCapacity) {
+        return new LoadingMap<>(new HashMap<>(initialCapacity), loader);
+    }
     /**
      * Initializes an auto loading map using a HashMap
      *
@@ -203,7 +209,7 @@ public class LoadingMap <K,V> extends AbstractMap<K, V> {
      * @return Map
      */
     public static <K, V> Map<K, V> newHashMap(Function<K, V> loader, int initialCapacity, float loadFactor) {
-        return new LoadingMap<K, V>(new HashMap<K, V>(initialCapacity, loadFactor), loader);
+        return new LoadingMap<>(new HashMap<>(initialCapacity, loadFactor), loader);
     }
 
     /**
@@ -215,7 +221,7 @@ public class LoadingMap <K,V> extends AbstractMap<K, V> {
      * @return Map
      */
     public static <K, V> Map<K, V> newIdentityHashMap(Function<K, V> loader) {
-        return new LoadingMap<K, V>(new IdentityHashMap<K, V>(), loader);
+        return new LoadingMap<>(new IdentityHashMap<>(), loader);
     }
 
     /**
@@ -228,7 +234,7 @@ public class LoadingMap <K,V> extends AbstractMap<K, V> {
      * @return Map
      */
     public static <K, V> Map<K, V> newIdentityHashMap(Function<K, V> loader, int initialCapacity) {
-        return new LoadingMap<K, V>(new IdentityHashMap<K, V>(initialCapacity), loader);
+        return new LoadingMap<>(new IdentityHashMap<>(initialCapacity), loader);
     }
 
     @Override
@@ -245,14 +251,7 @@ public class LoadingMap <K,V> extends AbstractMap<K, V> {
 
     @Override
     public V get(Object key) {
-        V res =  backingMap.get(key);
-        if (res == null && key != null) {
-            res = loader.apply((K) key);
-            if (res != null) {
-                backingMap.put((K) key, res);
-            }
-        }
-        return res;
+        return backingMap.computeIfAbsent((K) key, loader);
     }
 
     public V put(K key, V value) {return backingMap.put(key, value);}
@@ -283,7 +282,7 @@ public class LoadingMap <K,V> extends AbstractMap<K, V> {
     }
 
     public LoadingMap<K, V> clone() {
-        return new LoadingMap<K, V>(backingMap, loader);
+        return new LoadingMap<>(backingMap, loader);
     }
 
     private static class AutoInstantiatingLoader<K, V> implements Function<K, V> {
-- 
2.19.1


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: 2277 <38501234+2277@users.noreply.github.com>
Date: Tue, 31 Mar 2020 10:33:55 +0100
Subject: [PATCH] Fix world loading behavior in Player#loadData()

Fixes the issue where Player#loadData() does not load world data properly, ensuring consistency with upstream behavior.

diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 5390ce62ec8afd24d2e028ea04d2ef3029a125f9..6f587c4bb4704d93552ba61335d87b1852fc169c 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -197,6 +197,7 @@ public abstract class PlayerList {
         }
 
         Optional<CompoundTag> optional = this.load(player); // CraftBukkit - decompile error
+        ResourceKey<Level> resourcekey = null; // Paper
         // CraftBukkit start - Better rename detection
         if (optional.isPresent()) {
             CompoundTag nbttagcompound = optional.get();
@@ -206,19 +207,47 @@ public abstract class PlayerList {
             }
         }
         // CraftBukkit end
-        ResourceKey<Level> resourcekey = (ResourceKey) optional.flatMap((nbttagcompound) -> {
+        // Paper start - Fix: Ensure world loading logic is properly aligned
+        boolean[] invalidPlayerWorld = {false};
+        bukkitData: if (optional.isPresent()) {
+            // Paper - Load world from Bukkit data (WorldUUID or world name)
+            final org.bukkit.World bWorld;
+            if (optional.get().contains("WorldUUIDMost") && optional.get().contains("WorldUUIDLeast")) {
+                bWorld = org.bukkit.Bukkit.getServer().getWorld(new UUID(optional.get().getLong("WorldUUIDMost"), optional.get().getLong("WorldUUIDLeast")));
+            } else if (optional.get().contains("world", net.minecraft.nbt.Tag.TAG_STRING)) { // Paper - legacy world name
+                bWorld = org.bukkit.Bukkit.getServer().getWorld(optional.get().getString("world"));
+            } else {
+                break bukkitData; // Proceed to vanilla logic if world data not found
+            }
+            if (bWorld != null) {
+                resourcekey = ((CraftWorld) bWorld).getHandle().dimension();
+            } else {
+                resourcekey = Level.OVERWORLD;
+                invalidPlayerWorld[0] = true;  // Mark as invalid if world is null
+            }
+        }
+        if (resourcekey == null) { // Only fallback to vanilla logic if world data wasn't found
+            // Vanilla logic to handle world loading, fallback to Overworld if invalid
             DataResult<ResourceKey<Level>> dataresult = DimensionType.parseLegacy(new Dynamic(NbtOps.INSTANCE, nbttagcompound.get("Dimension"))); // CraftBukkit - decompile error
             Logger logger = PlayerList.LOGGER;
 
             Objects.requireNonNull(logger);
-            return dataresult.resultOrPartial(logger::error);
-        }).orElse(player.serverLevel().dimension()); // CraftBukkit - SPIGOT-7507: If no dimension, fall back to existing dimension loaded from "WorldUUID", which in turn defaults to World.OVERWORLD
+            final Optional<ResourceKey<Level>> result = dataresult.resultOrPartial(logger::error);
+            invalidPlayerWorld[0] = result.isEmpty();
+            return result;
+        }).orElse(Level.OVERWORLD); // Paper - Fallback to Overworld if no valid world found
+        }
+        // Paper end
         ServerLevel worldserver = this.server.getLevel(resourcekey);
         ServerLevel worldserver1;
 
         if (worldserver == null) {
             PlayerList.LOGGER.warn("Unknown respawn dimension {}, defaulting to overworld", resourcekey);
             worldserver1 = this.server.overworld();
+            invalidPlayerWorld[0] = true; // Mark invalid if no world found
         } else {
             worldserver1 = worldserver;
         }
@@ -226,6 +255,10 @@ public abstract class PlayerList {
         if (optional.isEmpty()) {
             player.spawnReason = org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT; // set Player SpawnReason to DEFAULT on first login
+        }
+        if (optional.isEmpty() || invalidPlayerWorld[0]) {
+            // Paper - Ensure player spawns at the correct spawn point if invalid world or first login
             player.moveTo(player.adjustSpawnLocation(worldserver1, worldserver1.getSharedSpawnPos()).getBottomCenter(), 0.0F, 0.0F);
         }
         // Paper end - Entity#getEntitySpawnReason
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 94242c19740ae6ab2c86e3949bab6cee631b938f..d80fd4e2f41583f83c9527ccf4ce80afe851276a 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -2385,27 +2385,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             }
             // CraftBukkit end
-            // CraftBukkit start - Reset world
-            if (this instanceof ServerPlayer) {
-                Server server = Bukkit.getServer();
-                org.bukkit.World bworld = null;
-
-                // TODO: Remove World related checks, replaced with WorldUID
-                String worldName = nbt.getString("world");
-
-                if (nbt.contains("WorldUUIDMost") && nbt.contains("WorldUUIDLeast")) {
-                    UUID uid = new UUID(nbt.getLong("WorldUUIDMost"), nbt.getLong("WorldUUIDLeast"));
-                    bworld = server.getWorld(uid);
-                } else {
-                    bworld = server.getWorld(worldName);
-                }
-
-                if (bworld == null) {
-                    bworld = ((org.bukkit.craftbukkit.CraftServer) server).getServer().getLevel(Level.OVERWORLD).getWorld();
-                }
-
-                ((ServerPlayer) this).setLevel(bworld == null ? null : ((CraftWorld) bworld).getHandle());
-            }
+            // Paper - Move world parsing to PlayerList#placeNewPlayer()
             this.getBukkitEntity().readBukkitValues(nbt);
             if (nbt.contains("Bukkit.invisible")) {
                 boolean bukkitInvisible = nbt.getBoolean("Bukkit.invisible");

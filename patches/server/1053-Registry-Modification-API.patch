From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Potrebic <jake.m.potrebic@gmail.com>
Date: Mon, 27 Feb 2023 18:28:39 -0800
Subject: [PATCH] Registry Modification API

== AT ==
public net.minecraft.server.RegistryLayer STATIC_ACCESS
public net.minecraft.core.MappedRegistry validateWrite(Lnet/minecraft/resources/ResourceKey;)V

diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventRunner.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventRunner.java
index 6c072e44a8144de6658b4eb818c996f0eac5805b..618e9c5e48062840e623cccc7ace4e5c3c118e78 100644
--- a/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventRunner.java
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventRunner.java
@@ -59,8 +59,8 @@ public class LifecycleEventRunner {
     }
 
     public <O extends LifecycleEventOwner, E extends PaperLifecycleEvent> void callEvent(final LifecycleEventType<O, ? super E, ?> eventType, final E event, final Predicate<? super O> ownerPredicate) {
-        final AbstractLifecycleEventType<O, ? super E, ?, ?> lifecycleEventType = (AbstractLifecycleEventType<O, ? super E, ?, ?>) eventType;
-        lifecycleEventType.forEachHandler(registeredHandler -> {
+        final AbstractLifecycleEventType<O, ? super E, ?> lifecycleEventType = (AbstractLifecycleEventType<O, ? super E, ?>) eventType;
+        lifecycleEventType.forEachHandler(event, registeredHandler -> {
             try {
                 if (event instanceof final OwnerAwareLifecycleEvent<?> ownerAwareEvent) {
                     ownerAwareGenericHelper(ownerAwareEvent, registeredHandler.owner());
@@ -93,7 +93,7 @@ public class LifecycleEventRunner {
     }
 
     private <O extends LifecycleEventOwner> void removeEventHandlersOwnedBy(final LifecycleEventType<O, ?, ?> eventType, final Plugin possibleOwner) {
-        final AbstractLifecycleEventType<O, ?, ?, ?> lifecycleEventType = (AbstractLifecycleEventType<O, ?, ?, ?>) eventType;
+        final AbstractLifecycleEventType<O, ?, ?> lifecycleEventType = (AbstractLifecycleEventType<O, ?, ?>) eventType;
         lifecycleEventType.removeMatching(registeredHandler -> registeredHandler.owner().getPluginMeta().getName().equals(possibleOwner.getPluginMeta().getName()));
     }
 
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/PaperLifecycleEventManager.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/PaperLifecycleEventManager.java
index f1be5b9a29435bae0afd2bd951bfe88d1669e7eb..d05334016bd01201c755dea04c0cea56b6dfcb50 100644
--- a/src/main/java/io/papermc/paper/plugin/lifecycle/event/PaperLifecycleEventManager.java
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/PaperLifecycleEventManager.java
@@ -21,6 +21,6 @@ public final class PaperLifecycleEventManager<O extends LifecycleEventOwner> imp
     @Override
     public void registerEventHandler(final LifecycleEventHandlerConfiguration<? super O> handlerConfiguration) {
         Preconditions.checkState(this.registrationCheck.getAsBoolean(), "Cannot register lifecycle event handlers");
-        ((AbstractLifecycleEventHandlerConfiguration<? super O, ?, ?>) handlerConfiguration).registerFrom(this.owner);
+        ((AbstractLifecycleEventHandlerConfiguration<? super O, ?>) handlerConfiguration).registerFrom(this.owner);
     }
 }
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/AbstractLifecycleEventHandlerConfiguration.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/AbstractLifecycleEventHandlerConfiguration.java
index 6a85a4f581612efff04c1a955493aa2e32476277..fa216e6fd804859293385ed43c53dfca057f317f 100644
--- a/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/AbstractLifecycleEventHandlerConfiguration.java
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/AbstractLifecycleEventHandlerConfiguration.java
@@ -8,19 +8,21 @@ import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.framework.qual.DefaultQualifier;
 
 @DefaultQualifier(NonNull.class)
-public abstract class AbstractLifecycleEventHandlerConfiguration<O extends LifecycleEventOwner, E extends LifecycleEvent, CI extends AbstractLifecycleEventHandlerConfiguration<O, E, CI>> implements LifecycleEventHandlerConfiguration<O> {
+public abstract class AbstractLifecycleEventHandlerConfiguration<O extends LifecycleEventOwner, E extends LifecycleEvent> implements LifecycleEventHandlerConfiguration<O> {
 
     private final LifecycleEventHandler<? super E> handler;
-    private final AbstractLifecycleEventType<O, E, ?, CI> type;
+    private final AbstractLifecycleEventType<O, E, ?> type;
 
-    protected AbstractLifecycleEventHandlerConfiguration(final LifecycleEventHandler<? super E> handler, final AbstractLifecycleEventType<O, E, ?, CI> type) {
+    protected AbstractLifecycleEventHandlerConfiguration(final LifecycleEventHandler<? super E> handler, final AbstractLifecycleEventType<O, E, ?> type) {
         this.handler = handler;
         this.type = type;
     }
 
-    public abstract CI config();
-
     public final void registerFrom(final O owner) {
-        this.type.tryRegister(owner, this.handler, this.config());
+        this.type.tryRegister(owner, this);
+    }
+
+    public LifecycleEventHandler<? super E> handler() {
+        return this.handler;
     }
 }
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/MonitorLifecycleEventHandlerConfigurationImpl.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/MonitorLifecycleEventHandlerConfigurationImpl.java
index e0699fcd0a098abc5e1206e7c0fa80b96eca7884..ab444d60d72bd692843052df5d7b24fbb5621cf7 100644
--- a/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/MonitorLifecycleEventHandlerConfigurationImpl.java
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/MonitorLifecycleEventHandlerConfigurationImpl.java
@@ -8,19 +8,14 @@ import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.framework.qual.DefaultQualifier;
 
 @DefaultQualifier(NonNull.class)
-public class MonitorLifecycleEventHandlerConfigurationImpl<O extends LifecycleEventOwner, E extends LifecycleEvent> extends AbstractLifecycleEventHandlerConfiguration<O, E, MonitorLifecycleEventHandlerConfigurationImpl<O, E>> implements MonitorLifecycleEventHandlerConfiguration<O> {
+public class MonitorLifecycleEventHandlerConfigurationImpl<O extends LifecycleEventOwner, E extends LifecycleEvent> extends AbstractLifecycleEventHandlerConfiguration<O, E> implements MonitorLifecycleEventHandlerConfiguration<O> {
 
     private boolean monitor = false;
 
-    public MonitorLifecycleEventHandlerConfigurationImpl(final LifecycleEventHandler<? super E> handler, final AbstractLifecycleEventType<O, E, ?, MonitorLifecycleEventHandlerConfigurationImpl<O, E>> eventType) {
+    public MonitorLifecycleEventHandlerConfigurationImpl(final LifecycleEventHandler<? super E> handler, final AbstractLifecycleEventType<O, E, ?> eventType) {
         super(handler, eventType);
     }
 
-    @Override
-    public MonitorLifecycleEventHandlerConfigurationImpl<O, E> config() {
-        return this;
-    }
-
     public boolean isMonitor() {
         return this.monitor;
     }
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/PrioritizedLifecycleEventHandlerConfigurationImpl.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/PrioritizedLifecycleEventHandlerConfigurationImpl.java
index c1d0070fc1594f7a7c29d7dc679da7b347a7140b..ccdad31717bf12b844cbeaf11a49247485ec77f1 100644
--- a/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/PrioritizedLifecycleEventHandlerConfigurationImpl.java
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/PrioritizedLifecycleEventHandlerConfigurationImpl.java
@@ -9,22 +9,19 @@ import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.framework.qual.DefaultQualifier;
 
 @DefaultQualifier(NonNull.class)
-public class PrioritizedLifecycleEventHandlerConfigurationImpl<O extends LifecycleEventOwner, E extends LifecycleEvent> extends AbstractLifecycleEventHandlerConfiguration<O, E, PrioritizedLifecycleEventHandlerConfigurationImpl<O, E>> implements PrioritizedLifecycleEventHandlerConfiguration<O> {
+public class PrioritizedLifecycleEventHandlerConfigurationImpl<O extends LifecycleEventOwner, E extends LifecycleEvent>
+    extends AbstractLifecycleEventHandlerConfiguration<O, E>
+    implements PrioritizedLifecycleEventHandlerConfiguration<O> {
 
     private static final OptionalInt DEFAULT_PRIORITY = OptionalInt.of(0);
     private static final OptionalInt MONITOR_PRIORITY = OptionalInt.empty();
 
     private OptionalInt priority = DEFAULT_PRIORITY;
 
-    public PrioritizedLifecycleEventHandlerConfigurationImpl(final LifecycleEventHandler<? super E> handler, final AbstractLifecycleEventType<O, E, ?, PrioritizedLifecycleEventHandlerConfigurationImpl<O, E>> eventType) {
+    public PrioritizedLifecycleEventHandlerConfigurationImpl(final LifecycleEventHandler<? super E> handler, final AbstractLifecycleEventType<O, E, ?> eventType) {
         super(handler, eventType);
     }
 
-    @Override
-    public PrioritizedLifecycleEventHandlerConfigurationImpl<O, E> config() {
-        return this;
-    }
-
     public OptionalInt priority() {
         return this.priority;
     }
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/AbstractLifecycleEventType.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/AbstractLifecycleEventType.java
index a65fb37f4a729e2fe9fb81af822db626ec7e6d7b..9359a36d26970742da3a7abb0050158cd6c64e8e 100644
--- a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/AbstractLifecycleEventType.java
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/AbstractLifecycleEventType.java
@@ -12,7 +12,7 @@ import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.framework.qual.DefaultQualifier;
 
 @DefaultQualifier(NonNull.class)
-public abstract class AbstractLifecycleEventType<O extends LifecycleEventOwner, E extends LifecycleEvent, C extends LifecycleEventHandlerConfiguration<O>, CI extends AbstractLifecycleEventHandlerConfiguration<O, E, CI>> implements LifecycleEventType<O, E, C> {
+public abstract class AbstractLifecycleEventType<O extends LifecycleEventOwner, E extends LifecycleEvent, C extends LifecycleEventHandlerConfiguration<O>> implements LifecycleEventType<O, E, C> {
 
     private final String name;
     private final Class<? extends O> ownerType;
@@ -33,18 +33,22 @@ public abstract class AbstractLifecycleEventType<O extends LifecycleEventOwner,
         }
     }
 
-    public abstract void forEachHandler(Consumer<? super RegisteredHandler<O, E>> consumer, Predicate<? super RegisteredHandler<O, E>> predicate);
+    public abstract void forEachHandler(E event, Consumer<RegisteredHandler<O, E>> consumer, Predicate<RegisteredHandler<O, E>> predicate);
 
-    public abstract void removeMatching(Predicate<? super RegisteredHandler<O, E>> predicate);
+    public abstract void removeMatching(Predicate<RegisteredHandler<O, E>> predicate);
 
-    protected abstract void register(O owner, LifecycleEventHandler<? super E> handler, CI config);
+    protected abstract void register(O owner, AbstractLifecycleEventHandlerConfiguration<O, E> config);
 
-    public final void tryRegister(final O owner, final LifecycleEventHandler<? super E> handler, final CI config) {
+    public final void tryRegister(final O owner, final AbstractLifecycleEventHandlerConfiguration<O, E> config) {
         this.verifyOwner(owner);
         LifecycleEventRunner.INSTANCE.checkRegisteredHandler(owner, this);
-        this.register(owner, handler, config);
+        this.register(owner, config);
     }
 
-    public record RegisteredHandler<O, E extends LifecycleEvent>(O owner, LifecycleEventHandler<? super E> lifecycleEventHandler) {
+    public record RegisteredHandler<O extends LifecycleEventOwner, E extends LifecycleEvent>(O owner, AbstractLifecycleEventHandlerConfiguration<O, E> config) {
+
+        public LifecycleEventHandler<? super E> lifecycleEventHandler() {
+            return this.config().handler();
+        }
     }
 }
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEventTypeProviderImpl.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEventTypeProviderImpl.java
index 0886edad92b40276f268bd745b31bac359fd28af..af0cb3298d9c737417c6e54b360f8dc50a5caf04 100644
--- a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEventTypeProviderImpl.java
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEventTypeProviderImpl.java
@@ -20,6 +20,6 @@ public final class LifecycleEventTypeProviderImpl implements LifecycleEventTypeP
 
     @Override
     public <O extends LifecycleEventOwner, E extends LifecycleEvent> LifecycleEventType.Prioritizable<O, E> prioritized(final String name, final Class<? extends O> ownerType) {
-        return LifecycleEventRunner.INSTANCE.addEventType(new PrioritizableLifecycleEventType<>(name, ownerType));
+        return LifecycleEventRunner.INSTANCE.addEventType(new PrioritizableLifecycleEventType.Simple<>(name, ownerType));
     }
 }
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/MonitorableLifecycleEventType.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/MonitorableLifecycleEventType.java
index 6d92c1d3adf220154dfe7cba3a3f8158356c3e3c..c71912f0050ce0cc6e416948a354c8a66da606a8 100644
--- a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/MonitorableLifecycleEventType.java
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/MonitorableLifecycleEventType.java
@@ -3,6 +3,7 @@ package io.papermc.paper.plugin.lifecycle.event.types;
 import io.papermc.paper.plugin.lifecycle.event.LifecycleEvent;
 import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
 import io.papermc.paper.plugin.lifecycle.event.handler.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.AbstractLifecycleEventHandlerConfiguration;
 import io.papermc.paper.plugin.lifecycle.event.handler.configuration.MonitorLifecycleEventHandlerConfiguration;
 import io.papermc.paper.plugin.lifecycle.event.handler.configuration.MonitorLifecycleEventHandlerConfigurationImpl;
 import java.util.ArrayList;
@@ -13,7 +14,7 @@ import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.framework.qual.DefaultQualifier;
 
 @DefaultQualifier(NonNull.class)
-public class MonitorableLifecycleEventType<O extends LifecycleEventOwner, E extends LifecycleEvent> extends AbstractLifecycleEventType<O, E, MonitorLifecycleEventHandlerConfiguration<O>, MonitorLifecycleEventHandlerConfigurationImpl<O, E>> implements LifecycleEventType.Monitorable<O, E> {
+public class MonitorableLifecycleEventType<O extends LifecycleEventOwner, E extends LifecycleEvent> extends AbstractLifecycleEventType<O, E, MonitorLifecycleEventHandlerConfiguration<O>> implements LifecycleEventType.Monitorable<O, E> {
 
     final List<RegisteredHandler<O, E>> handlers = new ArrayList<>();
     int nonMonitorIdx = 0;
@@ -28,9 +29,12 @@ public class MonitorableLifecycleEventType<O extends LifecycleEventOwner, E exte
     }
 
     @Override
-    protected void register(final O owner, final LifecycleEventHandler<? super E> handler, final MonitorLifecycleEventHandlerConfigurationImpl<O, E> config) {
-        final RegisteredHandler<O, E> registeredHandler = new RegisteredHandler<>(owner, handler);
-        if (!config.isMonitor()) {
+    protected void register(final O owner, final AbstractLifecycleEventHandlerConfiguration<O, E> config) {
+        if (!(config instanceof final MonitorLifecycleEventHandlerConfigurationImpl<?,?> monitor)) {
+            throw new IllegalArgumentException("Configuration must be a MonitorLifecycleEventHandlerConfiguration");
+        }
+        final RegisteredHandler<O, E> registeredHandler = new RegisteredHandler<>(owner, config);
+        if (!monitor.isMonitor()) {
             this.handlers.add(this.nonMonitorIdx, registeredHandler);
             this.nonMonitorIdx++;
         } else {
@@ -39,7 +43,7 @@ public class MonitorableLifecycleEventType<O extends LifecycleEventOwner, E exte
     }
 
     @Override
-    public void forEachHandler(final Consumer<? super RegisteredHandler<O, E>> consumer, final Predicate<? super RegisteredHandler<O, E>> predicate) {
+    public void forEachHandler(final E event, final Consumer<RegisteredHandler<O, E>> consumer, final Predicate<RegisteredHandler<O, E>> predicate) {
         for (final RegisteredHandler<O, E> handler : this.handlers) {
             if (predicate.test(handler)) {
                 consumer.accept(handler);
@@ -48,7 +52,7 @@ public class MonitorableLifecycleEventType<O extends LifecycleEventOwner, E exte
     }
 
     @Override
-    public void removeMatching(final Predicate<? super RegisteredHandler<O, E>> predicate) {
+    public void removeMatching(final Predicate<RegisteredHandler<O, E>> predicate) {
         this.handlers.removeIf(predicate);
     }
 }
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizableLifecycleEventType.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizableLifecycleEventType.java
index 6629f7fabf66ce761024268043cc30076ba8a3f1..76f92a6fc84c0315f3973dc4e92649b66babc3d5 100644
--- a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizableLifecycleEventType.java
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizableLifecycleEventType.java
@@ -1,23 +1,28 @@
 package io.papermc.paper.plugin.lifecycle.event.types;
 
+import com.google.common.base.Preconditions;
 import io.papermc.paper.plugin.lifecycle.event.LifecycleEvent;
 import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
 import io.papermc.paper.plugin.lifecycle.event.handler.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.AbstractLifecycleEventHandlerConfiguration;
 import io.papermc.paper.plugin.lifecycle.event.handler.configuration.PrioritizedLifecycleEventHandlerConfiguration;
 import io.papermc.paper.plugin.lifecycle.event.handler.configuration.PrioritizedLifecycleEventHandlerConfigurationImpl;
 import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.List;
-import java.util.OptionalInt;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.framework.qual.DefaultQualifier;
 
 @DefaultQualifier(NonNull.class)
-public class PrioritizableLifecycleEventType<O extends LifecycleEventOwner, E extends LifecycleEvent> extends AbstractLifecycleEventType<O, E, PrioritizedLifecycleEventHandlerConfiguration<O>, PrioritizedLifecycleEventHandlerConfigurationImpl<O, E>> implements LifecycleEventType.Prioritizable<O, E> {
+public abstract class PrioritizableLifecycleEventType<
+    O extends LifecycleEventOwner,
+    E extends LifecycleEvent,
+    C extends PrioritizedLifecycleEventHandlerConfiguration<O>
+> extends AbstractLifecycleEventType<O, E, C> {
 
-    private static final Comparator<PrioritizedHandler<?, ?>> COMPARATOR = Comparator.comparing(PrioritizedHandler::priority, (o1, o2) -> {
+    private static final Comparator<RegisteredHandler<?, ?>> COMPARATOR = Comparator.comparing(handler -> ((PrioritizedLifecycleEventHandlerConfigurationImpl<?, ?>) handler.config()).priority(), (o1, o2) -> {
         if (o1.equals(o2)) {
             return 0;
         } else if (o1.isEmpty()) {
@@ -29,36 +34,41 @@ public class PrioritizableLifecycleEventType<O extends LifecycleEventOwner, E ex
         }
     });
 
-    private final List<PrioritizedHandler<O, E>> handlers = new ArrayList<>();
+    private final List<RegisteredHandler<O, E>> handlers = new ArrayList<>();
 
     public PrioritizableLifecycleEventType(final String name, final Class<? extends O> ownerType) {
         super(name, ownerType);
     }
 
     @Override
-    public PrioritizedLifecycleEventHandlerConfiguration<O> newHandler(final LifecycleEventHandler<? super E> handler) {
-        return new PrioritizedLifecycleEventHandlerConfigurationImpl<>(handler, this);
-    }
-
-    @Override
-    protected void register(final O owner, final LifecycleEventHandler<? super E> handler, final PrioritizedLifecycleEventHandlerConfigurationImpl<O, E> config) {
-        this.handlers.add(new PrioritizedHandler<>(new RegisteredHandler<>(owner, handler), config.priority()));
+    protected void register(final O owner, final AbstractLifecycleEventHandlerConfiguration<O, E> config) {
+        Preconditions.checkArgument(config instanceof PrioritizedLifecycleEventHandlerConfigurationImpl<?, ?>, "Configuration must be a PrioritizedLifecycleEventHandlerConfiguration");
+        this.handlers.add(new RegisteredHandler<>(owner, config));
         this.handlers.sort(COMPARATOR);
     }
 
     @Override
-    public void forEachHandler(final Consumer<? super RegisteredHandler<O, E>> consumer, final Predicate<? super RegisteredHandler<O, E>> predicate) {
-        for (final PrioritizedHandler<O, E> handler : this.handlers) {
-            if (predicate.test(handler.handler())) {
-                consumer.accept(handler.handler());
+    public void forEachHandler(final E event, final Consumer<RegisteredHandler<O, E>> consumer, final Predicate<RegisteredHandler<O, E>> predicate) {
+        for (final RegisteredHandler<O, E> handler : this.handlers) {
+            if (predicate.test(handler)) {
+                consumer.accept(handler);
             }
         }
     }
 
     @Override
-    public void removeMatching(final Predicate<? super RegisteredHandler<O, E>> predicate) {
-        this.handlers.removeIf(prioritizedHandler -> predicate.test(prioritizedHandler.handler()));
+    public void removeMatching(final Predicate<RegisteredHandler<O, E>> predicate) {
+        this.handlers.removeIf(predicate);
     }
 
-    private record PrioritizedHandler<O extends LifecycleEventOwner, E extends LifecycleEvent>(RegisteredHandler<O, E> handler, OptionalInt priority) {}
+    public static class Simple<O extends LifecycleEventOwner, E extends LifecycleEvent> extends PrioritizableLifecycleEventType<O, E, PrioritizedLifecycleEventHandlerConfiguration<O>> implements LifecycleEventType.Prioritizable<O, E> {
+        public Simple(final String name, final Class<? extends O> ownerType) {
+            super(name, ownerType);
+        }
+
+        @Override
+        public PrioritizedLifecycleEventHandlerConfiguration<O> newHandler(final LifecycleEventHandler<? super E> handler) {
+            return new PrioritizedLifecycleEventHandlerConfigurationImpl<>(handler, this);
+        }
+    }
 }
diff --git a/src/main/java/io/papermc/paper/registry/PaperRegistries.java b/src/main/java/io/papermc/paper/registry/PaperRegistries.java
index e68ac2a9710c9e0ac248ce65b6e0d21fa7033fec..9342f034ef590594db046cd9b0810bd4075d8e6b 100644
--- a/src/main/java/io/papermc/paper/registry/PaperRegistries.java
+++ b/src/main/java/io/papermc/paper/registry/PaperRegistries.java
@@ -42,6 +42,7 @@ import org.checkerframework.framework.qual.DefaultQualifier;
 
 import static io.papermc.paper.registry.entry.RegistryEntry.apiOnly;
 import static io.papermc.paper.registry.entry.RegistryEntry.entry;
+import static io.papermc.paper.registry.entry.RegistryEntry.writable;
 
 @DefaultQualifier(NonNull.class)
 public final class PaperRegistries {
diff --git a/src/main/java/io/papermc/paper/registry/PaperRegistryAccess.java b/src/main/java/io/papermc/paper/registry/PaperRegistryAccess.java
index c34cffd369ead2b3e43464a02d4f8fb98ca969c1..a70d1d8b2aef96c2dff7e20670afa8b82027ebf3 100644
--- a/src/main/java/io/papermc/paper/registry/PaperRegistryAccess.java
+++ b/src/main/java/io/papermc/paper/registry/PaperRegistryAccess.java
@@ -85,6 +85,14 @@ public class PaperRegistryAccess implements RegistryAccess {
         return possiblyUnwrap(registryHolder.get());
     }
 
+    public <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> WritableCraftRegistry<M, T, B> getWritableRegistry(final RegistryKey<T> key) {
+        final Registry<T> registry = this.getRegistry(key);
+        if (registry instanceof WritableCraftRegistry<?, T, ?>) {
+            return (WritableCraftRegistry<M, T, B>) registry;
+        }
+        throw new IllegalArgumentException(key + " does not point to a writable registry");
+    }
+
     private static <T extends Keyed> Registry<T> possiblyUnwrap(final Registry<T> registry) {
         if (registry instanceof final DelayedRegistry<T, ?> delayedRegistry) { // if not coming from legacy, unwrap the delayed registry
             return delayedRegistry.delegate();
diff --git a/src/main/java/io/papermc/paper/registry/PaperRegistryBuilder.java b/src/main/java/io/papermc/paper/registry/PaperRegistryBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..4cf32102a134ebef67d3893cfd24bf0add321eb9
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/PaperRegistryBuilder.java
@@ -0,0 +1,24 @@
+package io.papermc.paper.registry;
+
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+public interface PaperRegistryBuilder<M, T> extends RegistryBuilder<T> {
+
+    M build();
+
+    @FunctionalInterface
+    interface Filler<M, T, B extends PaperRegistryBuilder<M, T>> {
+
+        B fill(final TypedKey<T> key, final @Nullable M nms);
+
+        default Factory<M, T, B> asFactory() {
+            return key -> this.fill(key, null);
+        }
+    }
+
+    @FunctionalInterface
+    interface Factory<M, T, B extends PaperRegistryBuilder<M, T>> {
+
+        B create(final TypedKey<T> key);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/PaperRegistryListenerManager.java b/src/main/java/io/papermc/paper/registry/PaperRegistryListenerManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..d4c4ca9297ae3e481a5aba516e7d2c1729618d4b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/PaperRegistryListenerManager.java
@@ -0,0 +1,167 @@
+package io.papermc.paper.registry;
+
+import com.google.common.base.Preconditions;
+import io.papermc.paper.plugin.bootstrap.BootstrapContext;
+import io.papermc.paper.plugin.entrypoint.Entrypoint;
+import io.papermc.paper.plugin.entrypoint.LaunchEntryPointHandler;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventRunner;
+import io.papermc.paper.plugin.lifecycle.event.types.LifecycleEventType;
+import io.papermc.paper.registry.entry.RegistryEntry;
+import io.papermc.paper.registry.entry.RegistryEntryInfo;
+import io.papermc.paper.registry.event.RegistryEntryAddEventImpl;
+import io.papermc.paper.registry.event.RegistryEventMap;
+import io.papermc.paper.registry.event.RegistryEventProvider;
+import io.papermc.paper.registry.event.RegistryFreezeEvent;
+import io.papermc.paper.registry.event.RegistryFreezeEventImpl;
+import io.papermc.paper.registry.event.type.RegistryEntryAddEventType;
+import io.papermc.paper.registry.event.type.RegistryEntryAddEventTypeImpl;
+import io.papermc.paper.registry.event.type.RegistryLifecycleEventType;
+import net.kyori.adventure.key.Key;
+import net.minecraft.core.Holder;
+import net.minecraft.core.MappedRegistry;
+import net.minecraft.core.RegistrationInfo;
+import net.minecraft.core.Registry;
+import net.minecraft.core.WritableRegistry;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.resources.ResourceLocation;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.intellij.lang.annotations.Subst;
+
+public final class PaperRegistryListenerManager {
+
+    public static final PaperRegistryListenerManager INSTANCE = new PaperRegistryListenerManager();
+
+    public final RegistryEventMap valueAddHooks = new RegistryEventMap("value add");
+    public final RegistryEventMap freezeHooks = new RegistryEventMap("freeze");
+
+    private PaperRegistryListenerManager() {
+    }
+
+    /**
+     * For {@link Registry#register(Registry, String, Object)}
+     */
+    public <M> M registerWithListeners(final Registry<M> registry, final String id, final M nms) {
+        return this.registerWithListeners(registry, new ResourceLocation(id), nms);
+    }
+
+    /**
+     * For {@link Registry#register(Registry, ResourceLocation, Object)}
+     */
+    public <M> M registerWithListeners(final Registry<M> registry, final ResourceLocation loc, final M nms) {
+        return this.registerWithListeners(registry, ResourceKey.create(registry.key(), loc), nms);
+    }
+
+    /**
+     * For {@link Registry#register(Registry, ResourceKey, Object)}
+     */
+    public <M> M registerWithListeners(final Registry<M> registry, final ResourceKey<M> key, final M nms) {
+        return this.registerWithListeners(registry, key, nms, RegistrationInfo.BUILT_IN, PaperRegistryListenerManager::registerWithInstance);
+    }
+
+    /**
+     * For {@link Registry#registerForHolder(Registry, ResourceLocation, Object)}
+     */
+    public <M> Holder.Reference<M> registerForHolderWithListeners(final Registry<M> registry, final ResourceLocation loc, final M nms) {
+        return this.registerForHolderWithListeners(registry, ResourceKey.create(registry.key(), loc), nms);
+    }
+
+    /**
+     * For {@link Registry#registerForHolder(Registry, ResourceKey, Object)}
+     */
+    public <M> Holder.Reference<M> registerForHolderWithListeners(final Registry<M> registry, final ResourceKey<M> key, final M nms) {
+        return this.registerWithListeners(registry, key, nms, RegistrationInfo.BUILT_IN, WritableRegistry::register);
+    }
+
+    public <M, T extends org.bukkit.Keyed, B extends PaperRegistryBuilder<M, T>> void registerWithListeners(
+        final Registry<M> registry,
+        final ResourceKey<M> key,
+        final M nms,
+        final RegistrationInfo registrationInfo
+    ) {
+        this.registerWithListeners(registry, key, nms, registrationInfo, WritableRegistry::register);
+    }
+
+    public <M, T extends org.bukkit.Keyed, B extends PaperRegistryBuilder<M, T>, R> R registerWithListeners(
+        final Registry<M> registry,
+        final ResourceKey<M> key,
+        final M nms,
+        final RegistrationInfo registrationInfo,
+        final RegisterMethod<M, R> registerMethod
+    ) {
+        Preconditions.checkState(LaunchEntryPointHandler.INSTANCE.hasEntered(Entrypoint.BOOTSTRAPPER), registry.key() + " tried to run modification listeners before bootstrappers have been called"); // verify that bootstrappers have been called
+        final @Nullable RegistryEntryInfo<M, T> entry = PaperRegistries.getEntry(registry.key());
+        if (!(entry instanceof RegistryEntry.Modifiable<?, ?, ?>) || !this.valueAddHooks.hasHooks(entry.apiKey())) {
+            return registerMethod.register((WritableRegistry<M>) registry, key, nms, registrationInfo);
+        }
+        final RegistryEntry.Modifiable<M, T, B> modifiableEntry = (RegistryEntry.Modifiable<M, T, B>) entry;
+        @SuppressWarnings("PatternValidation") final TypedKey<T> typedKey = TypedKey.create(entry.apiKey(), Key.key(key.location().getNamespace(), key.location().getPath()));
+        final B builder = modifiableEntry.fillBuilder(typedKey, nms);
+        return this.registerWithListeners(registry, modifiableEntry, key, nms, builder, registrationInfo, registerMethod);
+    }
+
+    public <M, T extends org.bukkit.Keyed, B extends PaperRegistryBuilder<M, T>> void registerWithListeners(
+        final Registry<M> registry,
+        final RegistryEntry.Modifiable<M, T, B> entry,
+        final ResourceKey<M> key,
+        final @Nullable M oldNms,
+        final B builder,
+        final RegistrationInfo registrationInfo
+    ) {
+        this.registerWithListeners(registry, entry, key, oldNms, builder, registrationInfo, WritableRegistry::register);
+    }
+
+    public <M, T extends org.bukkit.Keyed, B extends PaperRegistryBuilder<M, T>, R> R registerWithListeners(
+        final Registry<M> registry,
+        final RegistryEntry.Modifiable<M, T, B> entry,
+        final ResourceKey<M> key,
+        final @Nullable M oldNms,
+        final B builder,
+        final RegistrationInfo registrationInfo,
+        final RegisterMethod<M, R> registerMethod
+    ) {
+        @Subst("namespace:key") final ResourceLocation beingAdded = key.location();
+        @SuppressWarnings("PatternValidation") final TypedKey<T> typedKey = TypedKey.create(entry.apiKey(), Key.key(beingAdded.getNamespace(), beingAdded.getPath()));
+        final RegistryEntryAddEventImpl<T, B> event = entry.createAdditionEvent(typedKey, builder);
+        LifecycleEventRunner.INSTANCE.callEvent(this.valueAddHooks.getHook(entry.apiKey()), event);
+        if (oldNms != null) {
+            ((MappedRegistry<M>) registry).clearIntrusiveHolder(oldNms);
+        }
+        final M newNms = event.builder().build();
+        return registerMethod.register((WritableRegistry<M>) registry, key, newNms, registrationInfo);
+    }
+
+    private static <M> M registerWithInstance(final WritableRegistry<M> writableRegistry, final ResourceKey<M> key, final M value, final RegistrationInfo registrationInfo) {
+        writableRegistry.register(key, value, registrationInfo);
+        return value;
+    }
+
+    @FunctionalInterface
+    public interface RegisterMethod<M, R> {
+
+        R register(WritableRegistry<M> writableRegistry, ResourceKey<M> key, M value, RegistrationInfo registrationInfo);
+    }
+
+    public <M, T extends org.bukkit.Keyed, B extends PaperRegistryBuilder<M, T>> void runFreezeListeners(final ResourceKey<? extends Registry<M>> resourceKey) {
+        final @Nullable RegistryEntryInfo<M, T> entry = PaperRegistries.getEntry(resourceKey);
+        if (!(entry instanceof RegistryEntry.Writable<?, ?, ?>) || !this.freezeHooks.hasHooks(entry.apiKey())) {
+            return;
+        }
+        final RegistryEntry.Writable<M, T, B> writableEntry = (RegistryEntry.Writable<M, T, B>) entry;
+        final RegistryFreezeEventImpl<T, B> event = writableEntry.createPreFreezeEvent(PaperRegistryAccess.instance().getWritableRegistry(entry.apiKey()));
+        LifecycleEventRunner.INSTANCE.callEvent(this.freezeHooks.getHook(entry.apiKey()), event);
+    }
+
+    public <T, B extends RegistryBuilder<T>> RegistryEntryAddEventType<T, B> getRegistryAdditionEventType(final RegistryEventProvider<T, B> type) {
+        if (!(PaperRegistries.getEntry(type.registryKey()) instanceof RegistryEntry.Modifiable)) {
+            throw new IllegalArgumentException(type.registryKey() + " does not support RegistryAdditionEvent");
+        }
+        return this.valueAddHooks.getOrCreate(type, RegistryEntryAddEventTypeImpl::new);
+    }
+
+    public <T, B extends RegistryBuilder<T>> LifecycleEventType.Prioritizable<BootstrapContext, RegistryFreezeEvent<T, B>> getRegistryPreFreezeEventType(final RegistryEventProvider<T, B> type) {
+        if (!(PaperRegistries.getEntry(type.registryKey()) instanceof RegistryEntry.Writable)) {
+            throw new IllegalArgumentException(type.registryKey() + " does not support RegistryPreFreezeEvent");
+        }
+        return this.freezeHooks.getOrCreate(type, RegistryLifecycleEventType::new);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/WritableCraftRegistry.java b/src/main/java/io/papermc/paper/registry/WritableCraftRegistry.java
new file mode 100644
index 0000000000000000000000000000000000000000..8cc21936a97d0f3716722da357d95f1b5049f692
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/WritableCraftRegistry.java
@@ -0,0 +1,85 @@
+package io.papermc.paper.registry;
+
+import com.mojang.serialization.Lifecycle;
+import io.papermc.paper.adventure.PaperAdventure;
+import io.papermc.paper.registry.entry.RegistryEntry;
+import io.papermc.paper.registry.event.WritableRegistry;
+import java.util.Optional;
+import java.util.function.BiFunction;
+import java.util.function.Consumer;
+import net.minecraft.core.MappedRegistry;
+import net.minecraft.core.RegistrationInfo;
+import net.minecraft.resources.ResourceKey;
+import org.bukkit.Keyed;
+import org.bukkit.NamespacedKey;
+import org.bukkit.craftbukkit.CraftRegistry;
+import org.bukkit.craftbukkit.util.ApiVersion;
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+public class WritableCraftRegistry<M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> extends CraftRegistry<T, M> {
+
+    private static final RegistrationInfo FROM_PLUGIN = new RegistrationInfo(Optional.empty(), Lifecycle.experimental());
+
+    private final RegistryEntry.BuilderHolder<M, T, B> entry;
+    private final MappedRegistry<M> registry;
+    public final WritableRegistry<T, B> writableRegistry = new PaperWritableRegistry();
+    private final PaperRegistryBuilder.Factory<M, T, ? extends B> builderFactory;
+    private final BiFunction<? super NamespacedKey, M, T> minecraftToBukkit;
+
+    public WritableCraftRegistry(
+        final RegistryEntry.BuilderHolder<M, T, B> entry,
+        final Class<?> classToPreload,
+        final MappedRegistry<M> registry,
+        final BiFunction<NamespacedKey, ApiVersion, NamespacedKey> serializationUpdater,
+        final PaperRegistryBuilder.Factory<M, T, ? extends B> builderFactory,
+        final BiFunction<? super NamespacedKey, M, T> minecraftToBukkit
+    ) {
+        super(classToPreload, registry, null, serializationUpdater);
+        this.entry = entry;
+        this.registry = registry;
+        this.builderFactory = builderFactory;
+        this.minecraftToBukkit = minecraftToBukkit;
+    }
+
+    public void register(final TypedKey<T> key, final Consumer<? super B> value) {
+        final ResourceKey<M> resourceKey = ResourceKey.create(this.registry.key(), PaperAdventure.asVanilla(key.key()));
+        this.registry.validateWrite(resourceKey);
+        final B builder = this.newBuilder(key);
+        value.accept(builder);
+        if (this.entry instanceof final RegistryEntry.Modifiable<M, T, B> modifiable && PaperRegistryListenerManager.INSTANCE.valueAddHooks.hasHooks(this.entry.apiKey())) {
+            PaperRegistryListenerManager.INSTANCE.registerWithListeners(
+                this.registry,
+                modifiable,
+                resourceKey,
+                null,
+                builder,
+                FROM_PLUGIN
+            );
+        } else {
+            this.registry.register(resourceKey, builder.build(), FROM_PLUGIN);
+        }
+    }
+
+    @Override
+    public final @Nullable T createBukkit(final NamespacedKey namespacedKey, final @Nullable M minecraft) {
+        if (minecraft == null) {
+            return null;
+        }
+        return this.minecraftToBukkit(namespacedKey, minecraft);
+    }
+
+    public T minecraftToBukkit(final NamespacedKey namespacedKey, final M minecraft) {
+        return this.minecraftToBukkit.apply(namespacedKey, minecraft);
+    }
+
+    protected B newBuilder(final TypedKey<T> key) {
+        return this.builderFactory.create(key);
+    }
+
+    public class PaperWritableRegistry implements WritableRegistry<T, B> {
+        @Override
+        public void register(final TypedKey<T> key, final Consumer<? super B> value) {
+            WritableCraftRegistry.this.register(key, value);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/entry/AddableRegistryEntry.java b/src/main/java/io/papermc/paper/registry/entry/AddableRegistryEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..a0f24d396e3a258be1978b2baa3f8e07ff54538f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/entry/AddableRegistryEntry.java
@@ -0,0 +1,43 @@
+package io.papermc.paper.registry.entry;
+
+import io.papermc.paper.registry.PaperRegistryBuilder;
+import io.papermc.paper.registry.RegistryHolder;
+import io.papermc.paper.registry.RegistryKey;
+import io.papermc.paper.registry.TypedKey;
+import io.papermc.paper.registry.WritableCraftRegistry;
+import java.util.function.BiFunction;
+import net.minecraft.core.MappedRegistry;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceKey;
+import org.bukkit.Keyed;
+import org.bukkit.NamespacedKey;
+
+public class AddableRegistryEntry<M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> extends CraftRegistryEntry<M, T> implements RegistryEntry.Addable<M, T, B> {
+
+    private final PaperRegistryBuilder.Filler<M, T, B> builderFiller;
+
+    protected AddableRegistryEntry(
+        final ResourceKey<? extends Registry<M>> mcKey,
+        final RegistryKey<T> apiKey,
+        final Class<?> classToPreload,
+        final BiFunction<NamespacedKey, M, T> minecraftToBukkit,
+        final PaperRegistryBuilder.Filler<M, T, B> builderFiller
+    ) {
+        super(mcKey, apiKey, classToPreload, minecraftToBukkit);
+        this.builderFiller = builderFiller;
+    }
+
+    private WritableCraftRegistry<M, T, B> createRegistry(final Registry<M> registry) {
+        return new WritableCraftRegistry<>(this, this.classToPreload, (MappedRegistry<M>) registry, this.updater, this.builderFiller.asFactory(), this.minecraftToBukkit);
+    }
+
+    @Override
+    public RegistryHolder<T> createRegistryHolder(final Registry<M> nmsRegistry) {
+        return new RegistryHolder.Memoized<>(() -> this.createRegistry(nmsRegistry));
+    }
+
+    @Override
+    public B fillBuilder(final TypedKey<T> key, final M nms) {
+        return this.builderFiller.fill(key, nms);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/entry/CraftRegistryEntry.java b/src/main/java/io/papermc/paper/registry/entry/CraftRegistryEntry.java
index 1194084313a5e77652af691289b50837ad39aab1..568984894a5463ccfa68bb6944b409ab0a2d7ad7 100644
--- a/src/main/java/io/papermc/paper/registry/entry/CraftRegistryEntry.java
+++ b/src/main/java/io/papermc/paper/registry/entry/CraftRegistryEntry.java
@@ -19,7 +19,7 @@ public class CraftRegistryEntry<M, B extends Keyed> extends BaseRegistryEntry<M,
 
     protected final Class<?> classToPreload;
     protected final BiFunction<NamespacedKey, M, B> minecraftToBukkit;
-    private BiFunction<NamespacedKey, ApiVersion, NamespacedKey> updater = EMPTY;
+    protected BiFunction<NamespacedKey, ApiVersion, NamespacedKey> updater = EMPTY;
 
     protected CraftRegistryEntry(
         final ResourceKey<? extends Registry<M>> mcKey,
@@ -33,7 +33,7 @@ public class CraftRegistryEntry<M, B extends Keyed> extends BaseRegistryEntry<M,
     }
 
     @Override
-    public RegistryEntry<M, B, CraftRegistry<B, M>> withSerializationUpdater(final BiFunction<NamespacedKey, ApiVersion, NamespacedKey> updater) {
+    public RegistryEntry<M, B> withSerializationUpdater(final BiFunction<NamespacedKey, ApiVersion, NamespacedKey> updater) {
         this.updater = updater;
         return this;
     }
diff --git a/src/main/java/io/papermc/paper/registry/entry/ModifiableRegistryEntry.java b/src/main/java/io/papermc/paper/registry/entry/ModifiableRegistryEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..df10008f6bde1047c8a13523c0a8fc01222a4e62
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/entry/ModifiableRegistryEntry.java
@@ -0,0 +1,31 @@
+package io.papermc.paper.registry.entry;
+
+import io.papermc.paper.registry.PaperRegistryBuilder;
+import io.papermc.paper.registry.RegistryKey;
+import io.papermc.paper.registry.TypedKey;
+import java.util.function.BiFunction;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceKey;
+import org.bukkit.Keyed;
+import org.bukkit.NamespacedKey;
+
+public class ModifiableRegistryEntry<M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> extends CraftRegistryEntry<M, T> implements RegistryEntry.Modifiable<M, T, B> {
+
+    protected final PaperRegistryBuilder.Filler<M, T, B> builderFiller;
+
+    protected ModifiableRegistryEntry(
+        final ResourceKey<? extends Registry<M>> mcKey,
+        final RegistryKey<T> apiKey,
+        final Class<?> toPreload,
+        final BiFunction<NamespacedKey, M, T> minecraftToBukkit,
+        final PaperRegistryBuilder.Filler<M, T, B> builderFiller
+    ) {
+        super(mcKey, apiKey, toPreload, minecraftToBukkit);
+        this.builderFiller = builderFiller;
+    }
+
+    @Override
+    public B fillBuilder(final TypedKey<T> key, final M nms) {
+        return this.builderFiller.fill(key, nms);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/entry/RegistryEntry.java b/src/main/java/io/papermc/paper/registry/entry/RegistryEntry.java
index dbf4684633e089e5e6a5c61c214eaa324e9272bb..644e0fb87ba859bf6d98d01a368a4329582e05d2 100644
--- a/src/main/java/io/papermc/paper/registry/entry/RegistryEntry.java
+++ b/src/main/java/io/papermc/paper/registry/entry/RegistryEntry.java
@@ -1,7 +1,12 @@
 package io.papermc.paper.registry.entry;
 
+import io.papermc.paper.registry.PaperRegistryBuilder;
 import io.papermc.paper.registry.RegistryHolder;
 import io.papermc.paper.registry.RegistryKey;
+import io.papermc.paper.registry.TypedKey;
+import io.papermc.paper.registry.WritableCraftRegistry;
+import io.papermc.paper.registry.event.RegistryEntryAddEventImpl;
+import io.papermc.paper.registry.event.RegistryFreezeEventImpl;
 import io.papermc.paper.registry.legacy.DelayedRegistryEntry;
 import java.util.function.BiFunction;
 import java.util.function.Supplier;
@@ -9,7 +14,6 @@ import net.minecraft.core.Registry;
 import net.minecraft.resources.ResourceKey;
 import org.bukkit.Keyed;
 import org.bukkit.NamespacedKey;
-import org.bukkit.craftbukkit.CraftRegistry;
 import org.bukkit.craftbukkit.util.ApiVersion;
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.framework.qual.DefaultQualifier;
@@ -19,7 +23,7 @@ public interface RegistryEntry<M, B extends Keyed> extends RegistryEntryInfo<M,
 
     RegistryHolder<B> createRegistryHolder(Registry<M> nmsRegistry);
 
-    default RegistryEntry<M, B, R> withSerializationUpdater(final BiFunction<NamespacedKey, ApiVersion, NamespacedKey> updater) {
+    default RegistryEntry<M, B> withSerializationUpdater(final BiFunction<NamespacedKey, ApiVersion, NamespacedKey> updater) {
         return this;
     }
 
@@ -33,6 +37,37 @@ public interface RegistryEntry<M, B extends Keyed> extends RegistryEntryInfo<M,
         return new DelayedRegistryEntry<>(this);
     }
 
+    interface BuilderHolder<M, T, B extends PaperRegistryBuilder<M, T>> extends RegistryEntryInfo<M, T> {
+
+        B fillBuilder(TypedKey<T> key, M nms);
+    }
+
+    /**
+     * Can mutate values being added to the registry
+     */
+    interface Modifiable<M, T, B extends PaperRegistryBuilder<M, T>> extends BuilderHolder<M, T, B> {
+
+        default RegistryEntryAddEventImpl<T, B> createAdditionEvent(final TypedKey<T> key, final B initialBuilder) {
+            return new RegistryEntryAddEventImpl<>(key, initialBuilder, this.apiKey());
+        }
+    }
+
+    /**
+     * Can only add new values to the registry, not modify any values.
+     */
+    interface Addable<M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> extends BuilderHolder<M, T, B> { // TODO remove Keyed
+
+        default RegistryFreezeEventImpl<T, B> createPreFreezeEvent(final WritableCraftRegistry<M, T, B> writableRegistry) {
+            return new RegistryFreezeEventImpl<>(this.apiKey(), writableRegistry.writableRegistry);
+        }
+    }
+
+    /**
+     * Can mutate values and add new values.
+     */
+    interface Writable<M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> extends Modifiable<M, T, B>, Addable<M, T, B> { // TODO remove Keyed
+    }
+
     static <M, B extends Keyed> RegistryEntry<M, B> entry(
         final ResourceKey<? extends Registry<M>> mcKey,
         final RegistryKey<B> apiKey,
@@ -49,4 +84,24 @@ public interface RegistryEntry<M, B extends Keyed> extends RegistryEntryInfo<M,
     ) {
         return new ApiRegistryEntry<>(mcKey, apiKey, apiRegistrySupplier);
     }
+
+    static <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> RegistryEntry<M, T> modifiable(
+        final ResourceKey<? extends Registry<M>> mcKey,
+        final RegistryKey<T> apiKey,
+        final Class<?> toPreload,
+        final BiFunction<NamespacedKey, M, T> minecraftToBukkit,
+        final PaperRegistryBuilder.Filler<M, T, B> filler
+    ) {
+        return new ModifiableRegistryEntry<>(mcKey, apiKey, toPreload, minecraftToBukkit, filler);
+    }
+
+    static <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> RegistryEntry<M, T> writable(
+        final ResourceKey<? extends Registry<M>> mcKey,
+        final RegistryKey<T> apiKey,
+        final Class<?> toPreload,
+        final BiFunction<NamespacedKey, M, T> minecraftToBukkit,
+        final PaperRegistryBuilder.Filler<M, T, B> filler
+    ) {
+        return new WritableRegistryEntry<>(mcKey, apiKey, toPreload, minecraftToBukkit, filler);
+    }
 }
diff --git a/src/main/java/io/papermc/paper/registry/entry/WritableRegistryEntry.java b/src/main/java/io/papermc/paper/registry/entry/WritableRegistryEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..562accce731630327d116afd1c9d559df7e386bd
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/entry/WritableRegistryEntry.java
@@ -0,0 +1,22 @@
+package io.papermc.paper.registry.entry;
+
+import io.papermc.paper.registry.PaperRegistryBuilder;
+import io.papermc.paper.registry.RegistryKey;
+import java.util.function.BiFunction;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceKey;
+import org.bukkit.Keyed;
+import org.bukkit.NamespacedKey;
+
+public class WritableRegistryEntry<M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> extends AddableRegistryEntry<M, T, B> implements RegistryEntry.Writable<M, T, B> { // TODO remove Keyed
+
+    protected WritableRegistryEntry(
+        final ResourceKey<? extends Registry<M>> mcKey,
+        final RegistryKey<T> apiKey,
+        final Class<?> classToPreload,
+        final BiFunction<NamespacedKey, M, T> minecraftToBukkit,
+        final PaperRegistryBuilder.Filler<M, T, B> builderFiller
+    ) {
+        super(mcKey, apiKey, classToPreload, minecraftToBukkit, builderFiller);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/event/RegistryEntryAddEventImpl.java b/src/main/java/io/papermc/paper/registry/event/RegistryEntryAddEventImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..a1d747c1a46d3aa8bcdef82bebb48f1fd760e61f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/event/RegistryEntryAddEventImpl.java
@@ -0,0 +1,13 @@
+package io.papermc.paper.registry.event;
+
+import io.papermc.paper.plugin.lifecycle.event.PaperLifecycleEvent;
+import io.papermc.paper.registry.RegistryBuilder;
+import io.papermc.paper.registry.RegistryKey;
+import io.papermc.paper.registry.TypedKey;
+
+public record RegistryEntryAddEventImpl<T, B extends RegistryBuilder<T>>(
+    TypedKey<T> key,
+    B builder,
+    RegistryKey<T> registryKey
+) implements RegistryEntryAddEvent<T, B>, PaperLifecycleEvent {
+}
diff --git a/src/main/java/io/papermc/paper/registry/event/RegistryEventMap.java b/src/main/java/io/papermc/paper/registry/event/RegistryEventMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..f5ea23173dcbe491742c3dd051c147ef397307a0
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/event/RegistryEventMap.java
@@ -0,0 +1,44 @@
+package io.papermc.paper.registry.event;
+
+import io.papermc.paper.plugin.bootstrap.BootstrapContext;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventRunner;
+import io.papermc.paper.plugin.lifecycle.event.types.LifecycleEventType;
+import io.papermc.paper.registry.RegistryBuilder;
+import io.papermc.paper.registry.RegistryKey;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+import java.util.function.BiFunction;
+
+public final class RegistryEventMap {
+
+    private final Map<RegistryKey<?>, LifecycleEventType<BootstrapContext, ? extends RegistryEvent<?>, ?>> hooks = new HashMap<>();
+    private final String name;
+
+    public RegistryEventMap(final String name) {
+        this.name = name;
+    }
+
+    @SuppressWarnings("unchecked")
+    public <T, B extends RegistryBuilder<T>, E extends RegistryEvent<T>, ET extends LifecycleEventType<BootstrapContext, E, ?>> ET getOrCreate(final RegistryEventProvider<T, B> type, final BiFunction<? super RegistryEventProvider<T, B>, ? super String, ET> eventTypeCreator) {
+        final ET registerHook;
+        if (this.hooks.containsKey(type.registryKey())) {
+            registerHook = (ET) this.hooks.get(type.registryKey());
+        } else {
+            registerHook = eventTypeCreator.apply(type, this.name);
+            LifecycleEventRunner.INSTANCE.addEventType(registerHook);
+            this.hooks.put(type.registryKey(), registerHook);
+        }
+        return registerHook;
+    }
+
+    @SuppressWarnings("unchecked")
+    public <T, E extends RegistryEvent<T>> LifecycleEventType<BootstrapContext, E, ?> getHook(final RegistryKey<T> registryKey) {
+        return (LifecycleEventType<BootstrapContext, E, ?>) Objects.requireNonNull(this.hooks.get(registryKey), "No hook for " + registryKey);
+    }
+
+    public boolean hasHooks(final RegistryKey<?> registryKey) {
+        return this.hooks.containsKey(registryKey);
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/registry/event/RegistryEventTypeProviderImpl.java b/src/main/java/io/papermc/paper/registry/event/RegistryEventTypeProviderImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..a4c3f981673c4202d06149996db7997f6670a07c
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/event/RegistryEventTypeProviderImpl.java
@@ -0,0 +1,24 @@
+package io.papermc.paper.registry.event;
+
+import io.papermc.paper.plugin.bootstrap.BootstrapContext;
+import io.papermc.paper.plugin.lifecycle.event.types.LifecycleEventType;
+import io.papermc.paper.registry.PaperRegistryListenerManager;
+import io.papermc.paper.registry.RegistryBuilder;
+import io.papermc.paper.registry.event.type.RegistryEntryAddEventType;
+
+public class RegistryEventTypeProviderImpl implements RegistryEventTypeProvider {
+
+    public static RegistryEventTypeProviderImpl instance() {
+        return (RegistryEventTypeProviderImpl) RegistryEventTypeProvider.provider();
+    }
+
+    @Override
+    public <T, B extends RegistryBuilder<T>> RegistryEntryAddEventType<T, B> registryAddition(final RegistryEventProvider<T, B> type) {
+        return PaperRegistryListenerManager.INSTANCE.getRegistryAdditionEventType(type);
+    }
+
+    @Override
+    public <T, B extends RegistryBuilder<T>> LifecycleEventType.Prioritizable<BootstrapContext, RegistryFreezeEvent<T, B>> registryPreFreeze(final RegistryEventProvider<T, B> type) {
+        return PaperRegistryListenerManager.INSTANCE.getRegistryPreFreezeEventType(type);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/event/RegistryFreezeEventImpl.java b/src/main/java/io/papermc/paper/registry/event/RegistryFreezeEventImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..2db5d33d0b72ec3c9ff1c3042d9246dfa4344346
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/event/RegistryFreezeEventImpl.java
@@ -0,0 +1,11 @@
+package io.papermc.paper.registry.event;
+
+import io.papermc.paper.plugin.lifecycle.event.PaperLifecycleEvent;
+import io.papermc.paper.registry.RegistryBuilder;
+import io.papermc.paper.registry.RegistryKey;
+
+public record RegistryFreezeEventImpl<T, B extends RegistryBuilder<T>>(
+    RegistryKey<T> registryKey,
+    WritableRegistry<T, B> registry
+) implements RegistryFreezeEvent<T, B>, PaperLifecycleEvent {
+}
diff --git a/src/main/java/io/papermc/paper/registry/event/package-info.java b/src/main/java/io/papermc/paper/registry/event/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..14d2d9766b8dee763f220c397aba3ad432d02aaa
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/event/package-info.java
@@ -0,0 +1,5 @@
+@DefaultQualifier(NonNull.class)
+package io.papermc.paper.registry.event;
+
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
diff --git a/src/main/java/io/papermc/paper/registry/event/type/RegistryEntryAddEventTypeImpl.java b/src/main/java/io/papermc/paper/registry/event/type/RegistryEntryAddEventTypeImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..32303ea9b3da736cbe26d06e57f5dcc3aa32a99b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/event/type/RegistryEntryAddEventTypeImpl.java
@@ -0,0 +1,32 @@
+package io.papermc.paper.registry.event.type;
+
+import io.papermc.paper.plugin.bootstrap.BootstrapContext;
+import io.papermc.paper.plugin.lifecycle.event.handler.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.types.PrioritizableLifecycleEventType;
+import io.papermc.paper.registry.RegistryBuilder;
+import io.papermc.paper.registry.event.RegistryEntryAddEvent;
+import io.papermc.paper.registry.event.RegistryEventProvider;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+
+public class RegistryEntryAddEventTypeImpl<T, B extends RegistryBuilder<T>> extends PrioritizableLifecycleEventType<BootstrapContext, RegistryEntryAddEvent<T, B>, RegistryEntryAddConfiguration<T>> implements RegistryEntryAddEventType<T, B> {
+
+    public RegistryEntryAddEventTypeImpl(final RegistryEventProvider<T, B> type, final String eventName) {
+        super(type.registryKey() + " / " + eventName, BootstrapContext.class);
+    }
+
+    @Override
+    public RegistryEntryAddConfiguration<T> newHandler(final LifecycleEventHandler<? super RegistryEntryAddEvent<T, B>> handler) {
+        return new RegistryEntryAddHandlerConfiguration<>(handler, this);
+    }
+
+    @Override
+    public void forEachHandler(final RegistryEntryAddEvent<T, B> event, final Consumer<RegisteredHandler<BootstrapContext, RegistryEntryAddEvent<T, B>>> consumer, final Predicate<RegisteredHandler<BootstrapContext, RegistryEntryAddEvent<T, B>>> predicate) {
+        super.forEachHandler(event, consumer, predicate.and(handler -> this.matchesTarget(event, handler)));
+    }
+
+    private boolean matchesTarget(final RegistryEntryAddEvent<T, B> event, final RegisteredHandler<BootstrapContext, RegistryEntryAddEvent<T, B>> handler) {
+        final RegistryEntryAddHandlerConfiguration<T, B> config = (RegistryEntryAddHandlerConfiguration<T, B>) handler.config();
+        return config.target() == null || event.key().equals(config.target());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/event/type/RegistryEntryAddHandlerConfiguration.java b/src/main/java/io/papermc/paper/registry/event/type/RegistryEntryAddHandlerConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..53df2dd1a9e1cef90bd8504c717b1cc6374b6f4e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/event/type/RegistryEntryAddHandlerConfiguration.java
@@ -0,0 +1,39 @@
+package io.papermc.paper.registry.event.type;
+
+import io.papermc.paper.plugin.bootstrap.BootstrapContext;
+import io.papermc.paper.plugin.lifecycle.event.handler.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.PrioritizedLifecycleEventHandlerConfigurationImpl;
+import io.papermc.paper.plugin.lifecycle.event.types.AbstractLifecycleEventType;
+import io.papermc.paper.registry.RegistryBuilder;
+import io.papermc.paper.registry.TypedKey;
+import io.papermc.paper.registry.event.RegistryEntryAddEvent;
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+public class RegistryEntryAddHandlerConfiguration<T, B extends RegistryBuilder<T>> extends PrioritizedLifecycleEventHandlerConfigurationImpl<BootstrapContext, RegistryEntryAddEvent<T, B>> implements RegistryEntryAddConfiguration<T> {
+
+    private @Nullable TypedKey<T> target;
+
+    public RegistryEntryAddHandlerConfiguration(final LifecycleEventHandler<? super RegistryEntryAddEvent<T, B>> handler, final AbstractLifecycleEventType<BootstrapContext, RegistryEntryAddEvent<T, B>, ?> eventType) {
+        super(handler, eventType);
+    }
+
+    public @Nullable TypedKey<T> target() {
+        return this.target;
+    }
+
+    @Override
+    public RegistryEntryAddConfiguration<T> onlyFor(final TypedKey<T> key) {
+        this.target = key;
+        return this;
+    }
+
+    @Override
+    public RegistryEntryAddConfiguration<T> priority(final int priority) {
+        return (RegistryEntryAddConfiguration<T>) super.priority(priority);
+    }
+
+    @Override
+    public RegistryEntryAddConfiguration<T> monitor() {
+        return (RegistryEntryAddConfiguration<T>) super.monitor();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/event/type/RegistryLifecycleEventType.java b/src/main/java/io/papermc/paper/registry/event/type/RegistryLifecycleEventType.java
new file mode 100644
index 0000000000000000000000000000000000000000..dcc0f6b337840a78d38abdf2eb3f4bbd1676f58f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/event/type/RegistryLifecycleEventType.java
@@ -0,0 +1,14 @@
+package io.papermc.paper.registry.event.type;
+
+import io.papermc.paper.plugin.bootstrap.BootstrapContext;
+import io.papermc.paper.plugin.lifecycle.event.types.PrioritizableLifecycleEventType;
+import io.papermc.paper.registry.RegistryBuilder;
+import io.papermc.paper.registry.event.RegistryEvent;
+import io.papermc.paper.registry.event.RegistryEventProvider;
+
+public final class RegistryLifecycleEventType<T, B extends RegistryBuilder<T>, E extends RegistryEvent<T>> extends PrioritizableLifecycleEventType.Simple<BootstrapContext, E> {
+
+    public RegistryLifecycleEventType(final RegistryEventProvider<T, B> type, final String eventName) {
+        super(type.registryKey() + " / " + eventName, BootstrapContext.class);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/package-info.java b/src/main/java/io/papermc/paper/registry/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..0b80179ff90e085568d7ceafd9b17511789dc99b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/package-info.java
@@ -0,0 +1,5 @@
+@DefaultQualifier(NonNull.class)
+package io.papermc.paper.registry;
+
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
diff --git a/src/main/java/net/minecraft/core/MappedRegistry.java b/src/main/java/net/minecraft/core/MappedRegistry.java
index 72c0c4a12aea39fa1c1967fa0277ed117471107e..7af48c1cb6985769cea840a01f8290b73380be29 100644
--- a/src/main/java/net/minecraft/core/MappedRegistry.java
+++ b/src/main/java/net/minecraft/core/MappedRegistry.java
@@ -77,6 +77,14 @@ public class MappedRegistry<T> implements WritableRegistry<T> {
         }
     };
     private final Object tagAdditionLock = new Object();
+    // Paper start
+    @Nullable
+    private Map<ResourceLocation, T> beforeFrozen = new HashMap<>(2048);
+    public Map<ResourceLocation, T> beforeFrozenView() {
+        com.google.common.base.Preconditions.checkState(this.beforeFrozen != null, "Cannot get this after the registry is frozen");
+        return Collections.unmodifiableMap(this.beforeFrozen);
+    }
+    // Paper end
 
     public MappedRegistry(ResourceKey<? extends Registry<T>> key, Lifecycle lifecycle) {
         this(key, lifecycle, false);
@@ -144,6 +152,7 @@ public class MappedRegistry<T> implements WritableRegistry<T> {
         this.byId.add(reference);
         this.toId.put(value, i);
         this.registrationInfos.put(key, info);
+        Objects.requireNonNull(this.beforeFrozen).put(key.location(), value); // Paper
         this.registryLifecycle = this.registryLifecycle.add(info.lifecycle());
         return reference;
     }
@@ -323,6 +332,7 @@ public class MappedRegistry<T> implements WritableRegistry<T> {
         } else {
             this.frozen = true;
             this.byValue.forEach((value, entry) -> entry.bindValue((T)value));
+            this.beforeFrozen = null; // Paper
             List<ResourceLocation> list = this.byKey
                 .entrySet()
                 .stream()
@@ -436,4 +446,12 @@ public class MappedRegistry<T> implements WritableRegistry<T> {
     public HolderLookup.RegistryLookup<T> asLookup() {
         return this.lookup;
     }
+    // Paper start
+    // used to clear intrusive holders from GameEvent, Item, Block, EntityType, and Fluid from unused instances of those types
+    public void clearIntrusiveHolder(final T instance) {
+        if (this.unregisteredIntrusiveHolders != null) {
+            this.unregisteredIntrusiveHolders.remove(instance);
+        }
+    }
+    // Paper end
 }
diff --git a/src/main/java/net/minecraft/core/registries/BuiltInRegistries.java b/src/main/java/net/minecraft/core/registries/BuiltInRegistries.java
index 8daee5a7935e3253834c4cbe81d5e8886f776dad..d7da62360d48d8c12c489296b4ee2ee44c0c2d93 100644
--- a/src/main/java/net/minecraft/core/registries/BuiltInRegistries.java
+++ b/src/main/java/net/minecraft/core/registries/BuiltInRegistries.java
@@ -310,6 +310,7 @@ public class BuiltInRegistries {
     }
     public static void bootStrap(Runnable runnable) {
         // Paper end
+        REGISTRY.freeze(); // Paper - freeze main registry early
         createContents();
         runnable.run(); // Paper
         freeze();
@@ -328,6 +329,7 @@ public class BuiltInRegistries {
         REGISTRY.freeze();
 
         for (Registry<?> registry : REGISTRY) {
+            io.papermc.paper.registry.PaperRegistryListenerManager.INSTANCE.runFreezeListeners(registry.key()); // Paper
             registry.freeze();
         }
     }
diff --git a/src/main/java/net/minecraft/resources/RegistryDataLoader.java b/src/main/java/net/minecraft/resources/RegistryDataLoader.java
index d59356df2d98de873fc5accc749f87fa3d685267..9414cadb2766c3b8f50bf811d3408402e9f57670 100644
--- a/src/main/java/net/minecraft/resources/RegistryDataLoader.java
+++ b/src/main/java/net/minecraft/resources/RegistryDataLoader.java
@@ -125,6 +125,7 @@ public class RegistryDataLoader {
         list.forEach(loader -> loadable.apply((RegistryDataLoader.Loader<?>)loader, registryInfoLookup));
         list.forEach(loader -> {
             Registry<?> registry = loader.registry();
+            io.papermc.paper.registry.PaperRegistryListenerManager.INSTANCE.runFreezeListeners(loader.registry.key()); // Paper - run pre-freeze listeners
 
             try {
                 registry.freeze();
@@ -188,7 +189,7 @@ public class RegistryDataLoader {
             JsonElement jsonElement = JsonParser.parseReader(reader);
             DataResult<E> dataResult = decoder.parse(ops, jsonElement);
             E object = dataResult.getOrThrow();
-            registry.register(key, object, entryInfo);
+            io.papermc.paper.registry.PaperRegistryListenerManager.INSTANCE.registerWithListeners(registry, key, object, entryInfo); // Paper
         }
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java b/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java
index d41b502eb451ec11dade2b987aee621511312ac6..7bd6ef81f1e1313d4542d417c6cc08c9cb3c22e2 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java
@@ -156,11 +156,11 @@ public class CraftRegistry<B extends Keyed, M> implements Registry<B> {
     private final Map<NamespacedKey, B> cache = new HashMap<>();
     private final Map<B, NamespacedKey> byValue = new java.util.IdentityHashMap<>(); // Paper - improve Registry
     private final net.minecraft.core.Registry<M> minecraftRegistry;
-    private final BiFunction<NamespacedKey, M, B> minecraftToBukkit;
+    private final BiFunction<? super NamespacedKey, M, B> minecraftToBukkit; // Paper
     private final BiFunction<NamespacedKey, ApiVersion, NamespacedKey> serializationUpdater; // Paper - rename to make it *clear* what it is *only* for
     private boolean init;
 
-    public CraftRegistry(Class<?> bukkitClass, net.minecraft.core.Registry<M> minecraftRegistry, BiFunction<NamespacedKey, M, B> minecraftToBukkit, BiFunction<NamespacedKey, ApiVersion, NamespacedKey> serializationUpdater) { // Paper - relax preload class
+    public CraftRegistry(Class<?> bukkitClass, net.minecraft.core.Registry<M> minecraftRegistry, BiFunction<? super NamespacedKey, M, B> minecraftToBukkit, BiFunction<NamespacedKey, ApiVersion, NamespacedKey> serializationUpdater) { // Paper - relax preload class
         this.bukkitClass = bukkitClass;
         this.minecraftRegistry = minecraftRegistry;
         this.minecraftToBukkit = minecraftToBukkit;
diff --git a/src/main/resources/META-INF/services/io.papermc.paper.registry.event.RegistryEventTypeProvider b/src/main/resources/META-INF/services/io.papermc.paper.registry.event.RegistryEventTypeProvider
new file mode 100644
index 0000000000000000000000000000000000000000..8bee1a5ed877a04e4d027593df1f42cefdd824e7
--- /dev/null
+++ b/src/main/resources/META-INF/services/io.papermc.paper.registry.event.RegistryEventTypeProvider
@@ -0,0 +1 @@
+io.papermc.paper.registry.event.RegistryEventTypeProviderImpl

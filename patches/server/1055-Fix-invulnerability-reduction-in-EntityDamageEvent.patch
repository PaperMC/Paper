From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Bjarne Koll <lynxplay101@gmail.com>
Date: Mon, 28 Oct 2024 15:59:44 +0100
Subject: [PATCH] Fix invulnerability reduction in EntityDamageEvent


diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 0831d69d6ac1aa112dfe8243b01adcf5e8eba6a0..437ef50ca9505e8c62cea659ddffbd8594b947f6 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -1505,12 +1505,12 @@ public abstract class LivingEntity extends Entity implements Attackable {
                 }
 
                 // Paper start - only call damage event when actuallyHurt will be called - move call logic down
-                event = this.handleEntityDamage(source, amount);
+                event = this.handleEntityDamage(source, amount, this.lastHurt); // Paper - fix invulnerability reduction in EntityDamageEvent
                 amount = computeAmountFromEntityDamageEvent(event);
                 // Paper end - only call damage event when actuallyHurt will be called - move call logic down
 
                 // CraftBukkit start
-                if (!this.actuallyHurt(world, source, (float) event.getFinalDamage() - this.lastHurt, event)) {
+                if (!this.actuallyHurt(world, source, (float) event.getFinalDamage(), event)) {
                     return false;
                 }
                 if (this instanceof ServerPlayer && event.getDamage() == 0 && originalAmount == 0) return false; // Paper - revert to vanilla damage - players are not affected by damage that is 0 - skip damage if the vanilla damage is 0 and was not modified by plugins in the event.
@@ -1519,7 +1519,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
                 flag1 = false;
             } else {
                 // Paper start - only call damage event when actuallyHurt will be called - move call logic down
-                event = this.handleEntityDamage(source, amount);
+                event = this.handleEntityDamage(source, amount, 0); // Paper - fix invulnerability reduction in EntityDamageEvent
                 amount = computeAmountFromEntityDamageEvent(event);
                 // Paper end - only call damage event when actuallyHurt will be called - move call logic down
                 // CraftBukkit start
@@ -2322,8 +2322,19 @@ public abstract class LivingEntity extends Entity implements Attackable {
     }
 
     // CraftBukkit start
-    private EntityDamageEvent handleEntityDamage(final DamageSource damagesource, float f) {
+    private EntityDamageEvent handleEntityDamage(final DamageSource damagesource, float f, final float invulnerabilityRelatedLastDamage) { // Paper - fix invulnerability reduction in EntityDamageEvent
         float originalDamage = f;
+        // Paper start - fix invulnerability reduction in EntityDamageEvent
+        final com.google.common.base.Function<Double, Double> invulnerabilityReductionFormular = d -> {
+            if (invulnerabilityRelatedLastDamage == 0) return 0D; // no last damage, no reduction
+            // last damage existed, this means the reduction *technically* is (new damage - last damage).
+            // If the event damage was changed to something less than invul damage, hard lock it at 0.
+            if (d < invulnerabilityRelatedLastDamage) return 0D;
+            return (double) -invulnerabilityRelatedLastDamage;
+        };
+        final float originalInvulnerabilityReduction = invulnerabilityReductionFormular.apply((double) f).floatValue();
+        f += originalInvulnerabilityReduction;
+        // Paper end - fix invulnerability reduction in EntityDamageEvent
 
         com.google.common.base.Function<Double, Double> freezing = new com.google.common.base.Function<Double, Double>() {
             @Override
@@ -2399,7 +2410,12 @@ public abstract class LivingEntity extends Entity implements Attackable {
         };
         float absorptionModifier = absorption.apply((double) f).floatValue();
 
-        return CraftEventFactory.handleLivingEntityDamageEvent(this, damagesource, originalDamage, freezingModifier, hardHatModifier, blockingModifier, armorModifier, resistanceModifier, magicModifier, absorptionModifier, freezing, hardHat, blocking, armor, resistance, magic, absorption);
+        // Paper start - fix invulnerability reduction in EntityDamageEvent
+        return CraftEventFactory.handleLivingEntityDamageEvent(this, damagesource, originalDamage, freezingModifier, hardHatModifier, blockingModifier, armorModifier, resistanceModifier, magicModifier, absorptionModifier, freezing, hardHat, blocking, armor, resistance, magic, absorption, (damageModifierDoubleMap, damageModifierFunctionMap) -> {
+            damageModifierFunctionMap.put(DamageModifier.INVULNERABILITY_REDUCTION, invulnerabilityReductionFormular);
+            damageModifierDoubleMap.put(DamageModifier.INVULNERABILITY_REDUCTION, (double) originalInvulnerabilityReduction);
+        });
+        // Paper end - fix invulnerability reduction in EntityDamageEvent
     }
 
     protected boolean actuallyHurt(ServerLevel worldserver, final DamageSource damagesource, float f, final EntityDamageEvent event) { // void -> boolean, add final
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index 1e98f68e51618606f1178c12be77c1a945362630..b47fc19d779e08e2416df58257c8684ef459d50a 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -1218,6 +1218,11 @@ public class CraftEventFactory {
     private static final Function<? super Double, Double> ZERO = Functions.constant(-0.0);
 
     public static EntityDamageEvent handleLivingEntityDamageEvent(Entity damagee, DamageSource source, double rawDamage, double freezingModifier, double hardHatModifier, double blockingModifier, double armorModifier, double resistanceModifier, double magicModifier, double absorptionModifier, Function<Double, Double> freezing, Function<Double, Double> hardHat, Function<Double, Double> blocking, Function<Double, Double> armor, Function<Double, Double> resistance, Function<Double, Double> magic, Function<Double, Double> absorption) {
+    // Paper start - fix invulnerability reduction in EntityDamageEvent
+        return handleLivingEntityDamageEvent(damagee, source, rawDamage, freezingModifier, hardHatModifier, blockingModifier, armorModifier, resistanceModifier, magicModifier, absorptionModifier, freezing, hardHat, blocking, armor, resistance, magic, absorption, null);
+    }
+    public static EntityDamageEvent handleLivingEntityDamageEvent(Entity damagee, DamageSource source, double rawDamage, double freezingModifier, double hardHatModifier, double blockingModifier, double armorModifier, double resistanceModifier, double magicModifier, double absorptionModifier, Function<Double, Double> freezing, Function<Double, Double> hardHat, Function<Double, Double> blocking, Function<Double, Double> armor, Function<Double, Double> resistance, Function<Double, Double> magic, Function<Double, Double> absorption, java.util.function.BiConsumer<Map<DamageModifier, Double>, Map<DamageModifier, Function<? super Double, Double>>> callback) {
+    // Paper end - fix invulnerability reduction in EntityDamageEvent
         Map<DamageModifier, Double> modifiers = new EnumMap<>(DamageModifier.class);
         Map<DamageModifier, Function<? super Double, Double>> modifierFunctions = new EnumMap<>(DamageModifier.class);
         modifiers.put(DamageModifier.BASE, rawDamage);
@@ -1242,6 +1247,7 @@ public class CraftEventFactory {
         modifierFunctions.put(DamageModifier.MAGIC, magic);
         modifiers.put(DamageModifier.ABSORPTION, absorptionModifier);
         modifierFunctions.put(DamageModifier.ABSORPTION, absorption);
+        if (callback != null) callback.accept(modifiers, modifierFunctions); // Paper - fix invulnerability reduction in EntityDamageEvent
         return CraftEventFactory.handleEntityDamageEvent(damagee, source, modifiers, modifierFunctions);
     }
 

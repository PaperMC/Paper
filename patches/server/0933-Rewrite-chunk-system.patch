From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Sun, 23 Jan 2022 22:58:11 -0800
Subject: [PATCH] Rewrite chunk system


diff --git a/src/main/java/ca/spottedleaf/concurrentutil/collection/MultiThreadedQueue.java b/src/main/java/ca/spottedleaf/concurrentutil/collection/MultiThreadedQueue.java
new file mode 100644
index 0000000000000000000000000000000000000000..f4415f782b32fed25da98e44b172f717c4d46e34
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concurrentutil/collection/MultiThreadedQueue.java
@@ -0,0 +1,1402 @@
+package ca.spottedleaf.concurrentutil.collection;
+
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import ca.spottedleaf.concurrentutil.util.Validate;
+import java.lang.invoke.VarHandle;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.Queue;
+import java.util.Spliterator;
+import java.util.Spliterators;
+import java.util.function.Consumer;
+import java.util.function.IntFunction;
+import java.util.function.Predicate;
+
+/**
+ * MT-Safe linked first in first out ordered queue.
+ *
+ * This queue should out-perform {@link java.util.concurrent.ConcurrentLinkedQueue} in high-contention reads/writes, and is
+ * not any slower in lower contention reads/writes.
+ * <p>
+ * Note that this queue breaks the specification laid out by {@link Collection}, see {@link #preventAdds()} and {@link Collection#add(Object)}.
+ * </p>
+ * <p><b>
+ * This queue will only unlink linked nodes through the {@link #peek()} and {@link #poll()} methods, and this is only if
+ * they are at the head of the queue.
+ * </b></p>
+ * @param <E> Type of element in this queue.
+ */
+public class MultiThreadedQueue<E> implements Queue<E> {
+
+    protected volatile LinkedNode<E> head; /* Always non-null, high chance of being the actual head */
+
+    protected volatile LinkedNode<E> tail; /* Always non-null, high chance of being the actual tail */
+
+    /* Note that it is possible to reach head from tail. */
+
+    /* IMPL NOTE: Leave hashCode and equals to their defaults */
+
+    protected static final VarHandle HEAD_HANDLE = ConcurrentUtil.getVarHandle(MultiThreadedQueue.class, "head", LinkedNode.class);
+    protected static final VarHandle TAIL_HANDLE = ConcurrentUtil.getVarHandle(MultiThreadedQueue.class, "tail", LinkedNode.class);
+
+    /* head */
+
+    protected final void setHeadPlain(final LinkedNode<E> newHead) {
+        HEAD_HANDLE.set(this, newHead);
+    }
+
+    protected final void setHeadOpaque(final LinkedNode<E> newHead) {
+        HEAD_HANDLE.setOpaque(this, newHead);
+    }
+
+    @SuppressWarnings("unchecked")
+    protected final LinkedNode<E> getHeadPlain() {
+        return (LinkedNode<E>)HEAD_HANDLE.get(this);
+    }
+
+    @SuppressWarnings("unchecked")
+    protected final LinkedNode<E> getHeadOpaque() {
+        return (LinkedNode<E>)HEAD_HANDLE.getOpaque(this);
+    }
+
+    @SuppressWarnings("unchecked")
+    protected final LinkedNode<E> getHeadAcquire() {
+        return (LinkedNode<E>)HEAD_HANDLE.getAcquire(this);
+    }
+
+    /* tail */
+
+    protected final void setTailPlain(final LinkedNode<E> newTail) {
+        TAIL_HANDLE.set(this, newTail);
+    }
+
+    protected final void setTailOpaque(final LinkedNode<E> newTail) {
+        TAIL_HANDLE.setOpaque(this, newTail);
+    }
+
+    @SuppressWarnings("unchecked")
+    protected final LinkedNode<E> getTailPlain() {
+        return (LinkedNode<E>)TAIL_HANDLE.get(this);
+    }
+
+    @SuppressWarnings("unchecked")
+    protected final LinkedNode<E> getTailOpaque() {
+        return (LinkedNode<E>)TAIL_HANDLE.getOpaque(this);
+    }
+
+    /**
+     * Constructs a {@code MultiThreadedQueue}, initially empty.
+     * <p>
+     * The returned object may not be published without synchronization.
+     * </p>
+     */
+    public MultiThreadedQueue() {
+        final LinkedNode<E> value = new LinkedNode<>(null, null);
+        this.setHeadPlain(value);
+        this.setTailPlain(value);
+    }
+
+    /**
+     * Constructs a {@code MultiThreadedQueue}, initially containing all elements in the specified {@code collection}.
+     * <p>
+     * The returned object may not be published without synchronization.
+     * </p>
+     * @param collection The specified collection.
+     * @throws NullPointerException If {@code collection} is {@code null} or contains {@code null} elements.
+     */
+    public MultiThreadedQueue(final Iterable<? extends E> collection) {
+        final Iterator<? extends E> elements = collection.iterator();
+
+        if (!elements.hasNext()) {
+            final LinkedNode<E> value = new LinkedNode<>(null, null);
+            this.setHeadPlain(value);
+            this.setTailPlain(value);
+            return;
+        }
+
+        final LinkedNode<E> head = new LinkedNode<>(Validate.notNull(elements.next(), "Null element"), null);
+        LinkedNode<E> tail = head;
+
+        while (elements.hasNext()) {
+            final LinkedNode<E> next = new LinkedNode<>(Validate.notNull(elements.next(), "Null element"), null);
+            tail.setNextPlain(next);
+            tail = next;
+        }
+
+        this.setHeadPlain(head);
+        this.setTailPlain(tail);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E remove() throws NoSuchElementException {
+        final E ret = this.poll();
+
+        if (ret == null) {
+            throw new NoSuchElementException();
+        }
+
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * Contrary to the specification of {@link Collection#add}, this method will fail to add the element to this queue
+     * and return {@code false} if this queue is add-blocked.
+     * </p>
+     */
+    @Override
+    public boolean add(final E element) {
+        return this.offer(element);
+    }
+
+    /**
+     * Adds the specified element to the tail of this queue. If this queue is currently add-locked, then the queue is
+     * released from that lock and this element is added. The unlock operation and addition of the specified
+     * element is atomic.
+     * @param element The specified element.
+     * @return {@code true} if this queue previously allowed additions
+     */
+    public boolean forceAdd(final E element) {
+        final LinkedNode<E> node = new LinkedNode<>(element, null);
+
+        return !this.forceAppendList(node, node);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E element() throws NoSuchElementException {
+        final E ret = this.peek();
+
+        if (ret == null) {
+            throw new NoSuchElementException();
+        }
+
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * This method may also return {@code false} to indicate an element was not added if this queue is add-blocked.
+     * </p>
+     */
+    @Override
+    public boolean offer(final E element) {
+        Validate.notNull(element, "Null element");
+
+        final LinkedNode<E> node = new LinkedNode<>(element, null);
+
+        return this.appendList(node, node);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E peek() {
+        for (LinkedNode<E> head = this.getHeadOpaque(), curr = head;;) {
+            final LinkedNode<E> next = curr.getNextVolatile();
+            final E element = curr.getElementPlain(); /* Likely in sync */
+
+            if (element != null) {
+                if (this.getHeadOpaque() == head && curr != head) {
+                    this.setHeadOpaque(curr);
+                }
+                return element;
+            }
+
+            if (next == null || curr == next) {
+                return null;
+            }
+            curr = next;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E poll() {
+        return this.removeHead();
+    }
+
+    /**
+     * Retrieves and removes the head of this queue if it matches the specified predicate. If this queue is empty
+     * or the head does not match the predicate, this function returns {@code null}.
+     * <p>
+     * The predicate may be invoked multiple or no times in this call.
+     * </p>
+     * @param predicate The specified predicate.
+     * @return The head if it matches the predicate, or {@code null} if it did not or this queue is empty.
+     */
+    public E pollIf(final Predicate<E> predicate) {
+        return this.removeHead(Validate.notNull(predicate, "Null predicate"));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void clear() {
+        //noinspection StatementWithEmptyBody
+        while (this.poll() != null);
+    }
+
+    /**
+     * Prevents elements from being added to this queue. Once this is called, any attempt to add to this queue will fail.
+     * <p>
+     * This function is MT-Safe.
+     * </p>
+     * @return {@code true} if the queue was modified to prevent additions, {@code false} if it already prevented additions.
+     */
+    public boolean preventAdds() {
+        final LinkedNode<E> deadEnd = new LinkedNode<>(null, null);
+        deadEnd.setNextPlain(deadEnd);
+
+        if (!this.appendList(deadEnd, deadEnd)) {
+            return false;
+        }
+
+        this.setTailPlain(deadEnd); /* (try to) Ensure tail is set for the following #allowAdds call */
+        return true;
+    }
+
+    /**
+     * Allows elements to be added to this queue once again. Note that this function has undefined behaviour if
+     * {@link #preventAdds()} is not called beforehand. The benefit of this function over {@link #tryAllowAdds()}
+     * is that this function might perform better.
+     * <p>
+     * This function is not MT-Safe.
+     * </p>
+     */
+    public void allowAdds() {
+        LinkedNode<E> tail = this.getTailPlain();
+
+        /* We need to find the tail given the cas on tail isn't atomic (nor volatile) in this.appendList */
+        /* Thus it is possible for an outdated tail to be set */
+        while (tail != (tail = tail.getNextPlain())) {}
+
+        tail.setNextVolatile(null);
+    }
+
+    /**
+     * Tries to allow elements to be added to this queue. Returns {@code true} if the queue was previous add-locked,
+     * {@code false} otherwise.
+     * <p>
+     * This function is MT-Safe, however it should not be used with {@link #allowAdds()}.
+     * </p>
+     * @return {@code true} if the queue was previously add-locked, {@code false} otherwise.
+     */
+    public boolean tryAllowAdds() {
+        LinkedNode<E> tail = this.getTailPlain();
+
+        for (int failures = 0;;) {
+            /* We need to find the tail given the cas on tail isn't atomic (nor volatile) in this.appendList */
+            /* Thus it is possible for an outdated tail to be set */
+            while (tail != (tail = tail.getNextAcquire())) {
+                if (tail == null) {
+                    return false;
+                }
+            }
+
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (tail == (tail = tail.compareExchangeNextVolatile(tail, null))) {
+                return true;
+            }
+
+            if (tail == null) {
+                return false;
+            }
+            ++failures;
+        }
+    }
+
+    /**
+     * Atomically adds the specified element to this queue or allows additions to the queue. If additions
+     * are not allowed, the element is not added.
+     * <p>
+     * This function is MT-Safe.
+     * </p>
+     * @param element The specified element.
+     * @return {@code true} if the queue now allows additions, {@code false} if the element was added.
+     */
+    public boolean addOrAllowAdds(final E element) {
+        Validate.notNull(element, "Null element");
+        int failures = 0;
+
+        final LinkedNode<E> append = new LinkedNode<>(element, null);
+
+        for (LinkedNode<E> currTail = this.getTailOpaque(), curr = currTail;;) {
+            /* It has been experimentally shown that placing the read before the backoff results in significantly greater performance */
+            /* It is likely due to a cache miss caused by another write to the next field */
+            final LinkedNode<E> next = curr.getNextVolatile();
+
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (next == null) {
+                final LinkedNode<E> compared = curr.compareExchangeNextVolatile(null, append);
+
+                if (compared == null) {
+                    /* Added */
+                    /* Avoid CASing on tail more than we need to */
+                    /* CAS to avoid setting an out-of-date tail */
+                    if (this.getTailOpaque() == currTail) {
+                        this.setTailOpaque(append);
+                    }
+                    return false; // we added
+                }
+
+                ++failures;
+                curr = compared;
+                continue;
+            } else if (next == curr) {
+                final LinkedNode<E> compared = curr.compareExchangeNextVolatile(curr, null);
+
+                if (compared == curr) {
+                    return true; // we let additions through
+                }
+
+                ++failures;
+
+                if (compared != null) {
+                    curr = compared;
+                }
+                continue;
+            }
+
+            if (curr == currTail) {
+                /* Tail is likely not up-to-date */
+                curr = next;
+            } else {
+                /* Try to update to tail */
+                if (currTail == (currTail = this.getTailOpaque())) {
+                    curr = next;
+                } else {
+                    curr = currTail;
+                }
+            }
+        }
+    }
+
+    /**
+     * Atomically removes the head from this queue if it exists, otherwise prevents additions to this queue if no
+     * head is removed.
+     * <p>
+     * This function is MT-Safe.
+     * </p>
+     * If the queue is already add-blocked and empty then no operation is performed.
+     * @return {@code null} if the queue is now add-blocked or was previously add-blocked, else returns
+     * an non-null value which was the previous head of queue.
+     */
+    public E pollOrBlockAdds() {
+        int failures = 0;
+        for (LinkedNode<E> head = this.getHeadOpaque(), curr = head;;) {
+            final E currentVal = curr.getElementVolatile();
+            final LinkedNode<E> next = curr.getNextOpaque();
+
+            if (next == curr) {
+                return null; /* Additions are already blocked */
+            }
+
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (currentVal != null) {
+                if (curr.getAndSetElementVolatile(null) == null) {
+                    ++failures;
+                    continue;
+                }
+
+                /* "CAS" to avoid setting an out-of-date head */
+                if (this.getHeadOpaque() == head) {
+                    this.setHeadOpaque(next != null ? next : curr);
+                }
+
+                return currentVal;
+            }
+
+            if (next == null) {
+                /* Try to update stale head */
+                if (curr != head && this.getHeadOpaque() == head) {
+                    this.setHeadOpaque(curr);
+                }
+
+                final LinkedNode<E> compared = curr.compareExchangeNextVolatile(null, curr);
+
+                if (compared != null) {
+                    // failed to block additions
+                    curr = compared;
+                    ++failures;
+                    continue;
+                }
+
+                return null; /* We blocked additions */
+            }
+
+            if (head == curr) {
+                /* head is likely not up-to-date */
+                curr = next;
+            } else {
+                /* Try to update to head */
+                if (head == (head = this.getHeadOpaque())) {
+                    curr = next;
+                } else {
+                    curr = head;
+                }
+            }
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean remove(final Object object) {
+        Validate.notNull(object, "Null object to remove");
+
+        for (LinkedNode<E> curr = this.getHeadOpaque();;) {
+            final LinkedNode<E> next = curr.getNextVolatile();
+            final E element = curr.getElementPlain(); /* Likely in sync */
+
+            if (element != null) {
+                if ((element == object || element.equals(object)) && curr.getAndSetElementVolatile(null) == element) {
+                    return true;
+                }
+            }
+
+            if (next == curr || next == null) {
+                break;
+            }
+            curr = next;
+        }
+
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean removeIf(final Predicate<? super E> filter) {
+        Validate.notNull(filter, "Null filter");
+
+        boolean ret = false;
+
+        for (LinkedNode<E> curr = this.getHeadOpaque();;) {
+            final LinkedNode<E> next = curr.getNextVolatile();
+            final E element = curr.getElementPlain(); /* Likely in sync */
+
+            if (element != null) {
+                ret |= filter.test(element) && curr.getAndSetElementVolatile(null) == element;
+            }
+
+            if (next == null || next == curr) {
+                break;
+            }
+            curr = next;
+        }
+
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean removeAll(final Collection<?> collection) {
+        Validate.notNull(collection, "Null collection");
+
+        boolean ret = false;
+
+        /* Volatile is required to synchronize with the write to the first element */
+        for (LinkedNode<E> curr = this.getHeadOpaque();;) {
+            final LinkedNode<E> next = curr.getNextVolatile();
+            final E element = curr.getElementPlain(); /* Likely in sync */
+
+            if (element != null) {
+                ret |= collection.contains(element) && curr.getAndSetElementVolatile(null) == element;
+            }
+
+            if (next == null || next == curr) {
+                break;
+            }
+            curr = next;
+        }
+
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean retainAll(final Collection<?> collection) {
+        Validate.notNull(collection, "Null collection");
+
+        boolean ret = false;
+
+        for (LinkedNode<E> curr = this.getHeadOpaque();;) {
+            final LinkedNode<E> next = curr.getNextVolatile();
+            final E element = curr.getElementPlain(); /* Likely in sync */
+
+            if (element != null) {
+                ret |= !collection.contains(element) && curr.getAndSetElementVolatile(null) == element;
+            }
+
+            if (next == null || next == curr) {
+                break;
+            }
+            curr = next;
+        }
+
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Object[] toArray() {
+        final List<E> ret = new ArrayList<>();
+
+        for (LinkedNode<E> curr = this.getHeadOpaque();;) {
+            final LinkedNode<E> next = curr.getNextVolatile();
+            final E element = curr.getElementPlain(); /* Likely in sync */
+
+            if (element != null) {
+                ret.add(element);
+            }
+
+            if (next == null || next == curr) {
+                break;
+            }
+            curr = next;
+        }
+
+        return ret.toArray();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public <T> T[] toArray(final T[] array) {
+        final List<T> ret = new ArrayList<>();
+
+        for (LinkedNode<E> curr = this.getHeadOpaque();;) {
+            final LinkedNode<E> next = curr.getNextVolatile();
+            final E element = curr.getElementPlain(); /* Likely in sync */
+
+            if (element != null) {
+                //noinspection unchecked
+                ret.add((T)element);
+            }
+
+            if (next == null || next == curr) {
+                break;
+            }
+            curr = next;
+        }
+
+        return ret.toArray(array);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public <T> T[] toArray(final IntFunction<T[]> generator) {
+        Validate.notNull(generator, "Null generator");
+
+        final List<T> ret = new ArrayList<>();
+
+        for (LinkedNode<E> curr = this.getHeadOpaque();;) {
+            final LinkedNode<E> next = curr.getNextVolatile();
+            final E element = curr.getElementPlain(); /* Likely in sync */
+
+            if (element != null) {
+                //noinspection unchecked
+                ret.add((T)element);
+            }
+
+            if (next == null || next == curr) {
+                break;
+            }
+            curr = next;
+        }
+
+        return ret.toArray(generator);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String toString() {
+        final StringBuilder builder = new StringBuilder();
+
+        builder.append("MultiThreadedQueue: {elements: {");
+
+        int deadEntries = 0;
+        int totalEntries = 0;
+        int aliveEntries = 0;
+
+        boolean addLocked = false;
+
+        for (LinkedNode<E> curr = this.getHeadOpaque();; ++totalEntries) {
+            final LinkedNode<E> next = curr.getNextVolatile();
+            final E element = curr.getElementPlain(); /* Likely in sync */
+
+            if (element == null) {
+                ++deadEntries;
+            } else {
+                ++aliveEntries;
+            }
+
+            if (totalEntries != 0) {
+                builder.append(", ");
+            }
+
+            builder.append(totalEntries).append(": \"").append(element).append('"');
+
+            if (next == null) {
+                break;
+            }
+            if (curr == next) {
+                addLocked = true;
+                break;
+            }
+            curr = next;
+        }
+
+        builder.append("}, total_entries: \"").append(totalEntries).append("\", alive_entries: \"").append(aliveEntries)
+            .append("\", dead_entries:").append(deadEntries).append("\", add_locked: \"").append(addLocked)
+            .append("\"}");
+
+        return builder.toString();
+    }
+
+    /**
+     * Adds all elements from the specified collection to this queue. The addition is atomic.
+     * @param collection The specified collection.
+     * @return {@code true} if all elements were added successfully, or {@code false} if this queue is add-blocked, or
+     * {@code false} if the specified collection contains no elements.
+     */
+    @Override
+    public boolean addAll(final Collection<? extends E> collection) {
+        return this.addAll((Iterable<? extends E>)collection);
+    }
+
+    /**
+     * Adds all elements from the specified iterable object to this queue. The addition is atomic.
+     * @param iterable The specified iterable object.
+     * @return {@code true} if all elements were added successfully, or {@code false} if this queue is add-blocked, or
+     * {@code false} if the specified iterable contains no elements.
+     */
+    public boolean addAll(final Iterable<? extends E> iterable) {
+        Validate.notNull(iterable, "Null iterable");
+
+        final Iterator<? extends E> elements = iterable.iterator();
+        if (!elements.hasNext()) {
+            return false;
+        }
+
+        /* Build a list of nodes to append */
+        /* This is an much faster due to the fact that zero additional synchronization is performed */
+
+        final LinkedNode<E> head = new LinkedNode<>(Validate.notNull(elements.next(), "Null element"), null);
+        LinkedNode<E> tail = head;
+
+        while (elements.hasNext()) {
+            final LinkedNode<E> next = new LinkedNode<>(Validate.notNull(elements.next(), "Null element"), null);
+            tail.setNextPlain(next);
+            tail = next;
+        }
+
+        return this.appendList(head, tail);
+    }
+
+    /**
+     * Adds all of the elements from the specified array to this queue.
+     * @param items The specified array.
+     * @return {@code true} if all elements were added successfully, or {@code false} if this queue is add-blocked, or
+     * {@code false} if the specified array has a length of 0.
+     */
+    public boolean addAll(final E[] items) {
+        return this.addAll(items, 0, items.length);
+    }
+
+    /**
+     * Adds all of the elements from the specified array to this queue.
+     * @param items The specified array.
+     * @param off The offset in the array.
+     * @param len The number of items.
+     * @return {@code true} if all elements were added successfully, or {@code false} if this queue is add-blocked, or
+     * {@code false} if the specified array has a length of 0.
+     */
+    public boolean addAll(final E[] items, final int off, final int len) {
+        Validate.notNull(items, "Items may not be null");
+        Validate.arrayBounds(off, len, items.length, "Items array indices out of bounds");
+
+        if (len == 0) {
+            return false;
+        }
+
+        final LinkedNode<E> head = new LinkedNode<>(Validate.notNull(items[off], "Null element"), null);
+        LinkedNode<E> tail = head;
+
+        for (int i = 1; i < len; ++i) {
+            final LinkedNode<E> next = new LinkedNode<>(Validate.notNull(items[off + i], "Null element"), null);
+            tail.setNextPlain(next);
+            tail = next;
+        }
+
+        return this.appendList(head, tail);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean containsAll(final Collection<?> collection) {
+        Validate.notNull(collection, "Null collection");
+
+        for (final Object element : collection) {
+            if (!this.contains(element)) {
+                return false;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Iterator<E> iterator() {
+        return new LinkedIterator<>(this.getHeadOpaque());
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * Note that this function is computed non-atomically and in O(n) time. The value returned may not be representative of
+     * the queue in its current state.
+     * </p>
+     */
+    @Override
+    public int size() {
+        int size = 0;
+
+        /* Volatile is required to synchronize with the write to the first element */
+        for (LinkedNode<E> curr = this.getHeadOpaque();;) {
+            final LinkedNode<E> next = curr.getNextVolatile();
+            final E element = curr.getElementPlain(); /* Likely in sync */
+
+            if (element != null) {
+                ++size;
+            }
+
+            if (next == null || next == curr) {
+                break;
+            }
+            curr = next;
+        }
+
+        return size;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isEmpty() {
+        return this.peek() == null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean contains(final Object object) {
+        Validate.notNull(object, "Null object");
+
+        for (LinkedNode<E> curr = this.getHeadOpaque();;) {
+            final LinkedNode<E> next = curr.getNextVolatile();
+            final E element = curr.getElementPlain(); /* Likely in sync */
+
+            if (element != null && (element == object || element.equals(object))) {
+                return true;
+            }
+
+            if (next == null || next == curr) {
+                break;
+            }
+            curr = next;
+        }
+
+        return false;
+    }
+
+    /**
+     * Finds the first element in this queue that matches the predicate.
+     * @param predicate The predicate to test elements against.
+     * @return The first element that matched the predicate, {@code null} if none matched.
+     */
+    public E find(final Predicate<E> predicate) {
+        Validate.notNull(predicate, "Null predicate");
+
+        for (LinkedNode<E> curr = this.getHeadOpaque();;) {
+            final LinkedNode<E> next = curr.getNextVolatile();
+            final E element = curr.getElementPlain(); /* Likely in sync */
+
+            if (element != null && predicate.test(element)) {
+                return element;
+            }
+
+            if (next == null || next == curr) {
+                break;
+            }
+            curr = next;
+        }
+
+        return null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void forEach(final Consumer<? super E> action) {
+        Validate.notNull(action, "Null action");
+
+        for (LinkedNode<E> curr = this.getHeadOpaque();;) {
+            final LinkedNode<E> next = curr.getNextVolatile();
+            final E element = curr.getElementPlain(); /* Likely in sync */
+
+            if (element != null) {
+                action.accept(element);
+            }
+
+            if (next == null || next == curr) {
+                break;
+            }
+            curr = next;
+        }
+    }
+
+    // return true if normal addition, false if the queue previously disallowed additions
+    protected final boolean forceAppendList(final LinkedNode<E> head, final LinkedNode<E> tail) {
+        int failures = 0;
+
+        for (LinkedNode<E> currTail = this.getTailOpaque(), curr = currTail;;) {
+            /* It has been experimentally shown that placing the read before the backoff results in significantly greater performance */
+            /* It is likely due to a cache miss caused by another write to the next field */
+            final LinkedNode<E> next = curr.getNextVolatile();
+
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (next == null || next == curr) {
+                final LinkedNode<E> compared = curr.compareExchangeNextVolatile(next, head);
+
+                if (compared == next) {
+                    /* Added */
+                    /* Avoid CASing on tail more than we need to */
+                    /* "CAS" to avoid setting an out-of-date tail */
+                    if (this.getTailOpaque() == currTail) {
+                        this.setTailOpaque(tail);
+                    }
+                    return next != curr;
+                }
+
+                ++failures;
+                curr = compared;
+                continue;
+            }
+
+            if (curr == currTail) {
+                /* Tail is likely not up-to-date */
+                curr = next;
+            } else {
+                /* Try to update to tail */
+                if (currTail == (currTail = this.getTailOpaque())) {
+                    curr = next;
+                } else {
+                    curr = currTail;
+                }
+            }
+        }
+    }
+
+    // return true if successful, false otherwise
+    protected final boolean appendList(final LinkedNode<E> head, final LinkedNode<E> tail) {
+        int failures = 0;
+
+        for (LinkedNode<E> currTail = this.getTailOpaque(), curr = currTail;;) {
+            /* It has been experimentally shown that placing the read before the backoff results in significantly greater performance */
+            /* It is likely due to a cache miss caused by another write to the next field */
+            final LinkedNode<E> next = curr.getNextVolatile();
+
+            if (next == curr) {
+                /* Additions are stopped */
+                return false;
+            }
+
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (next == null) {
+                final LinkedNode<E> compared = curr.compareExchangeNextVolatile(null, head);
+
+                if (compared == null) {
+                    /* Added */
+                    /* Avoid CASing on tail more than we need to */
+                    /* CAS to avoid setting an out-of-date tail */
+                    if (this.getTailOpaque() == currTail) {
+                        this.setTailOpaque(tail);
+                    }
+                    return true;
+                }
+
+                ++failures;
+                curr = compared;
+                continue;
+            }
+
+            if (curr == currTail) {
+                /* Tail is likely not up-to-date */
+                curr = next;
+            } else {
+                /* Try to update to tail */
+                if (currTail == (currTail = this.getTailOpaque())) {
+                    curr = next;
+                } else {
+                    curr = currTail;
+                }
+            }
+        }
+    }
+
+    protected final E removeHead(final Predicate<E> predicate) {
+        int failures = 0;
+        for (LinkedNode<E> head = this.getHeadOpaque(), curr = head;;) {
+            // volatile here synchronizes-with writes to element
+            final LinkedNode<E> next = curr.getNextVolatile();
+            final E currentVal = curr.getElementPlain();
+
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (currentVal != null) {
+                if (!predicate.test(currentVal)) {
+                    /* Try to update stale head */
+                    if (curr != head && this.getHeadOpaque() == head) {
+                        this.setHeadOpaque(curr);
+                    }
+                    return null;
+                }
+                if (curr.getAndSetElementVolatile(null) == null) {
+                    /* Failed to get head */
+                    if (curr == (curr = next) || next == null) {
+                        return null;
+                    }
+                    ++failures;
+                    continue;
+                }
+
+                /* "CAS" to avoid setting an out-of-date head */
+                if (this.getHeadOpaque() == head) {
+                    this.setHeadOpaque(next != null ? next : curr);
+                }
+
+                return currentVal;
+            }
+
+            if (curr == next || next == null) {
+                /* Try to update stale head */
+                if (curr != head && this.getHeadOpaque() == head) {
+                    this.setHeadOpaque(curr);
+                }
+                return null; /* End of queue */
+            }
+
+            if (head == curr) {
+                /* head is likely not up-to-date */
+                curr = next;
+            } else {
+                /* Try to update to head */
+                if (head == (head = this.getHeadOpaque())) {
+                    curr = next;
+                } else {
+                    curr = head;
+                }
+            }
+        }
+    }
+
+    protected final E removeHead() {
+        int failures = 0;
+        for (LinkedNode<E> head = this.getHeadOpaque(), curr = head;;) {
+            final LinkedNode<E> next = curr.getNextVolatile();
+            final E currentVal = curr.getElementPlain();
+
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (currentVal != null) {
+                if (curr.getAndSetElementVolatile(null) == null) {
+                    /* Failed to get head */
+                    if (curr == (curr = next) || next == null) {
+                        return null;
+                    }
+                    ++failures;
+                    continue;
+                }
+
+                /* "CAS" to avoid setting an out-of-date head */
+                if (this.getHeadOpaque() == head) {
+                    this.setHeadOpaque(next != null ? next : curr);
+                }
+
+                return currentVal;
+            }
+
+            if (curr == next || next == null) {
+                /* Try to update stale head */
+                if (curr != head && this.getHeadOpaque() == head) {
+                    this.setHeadOpaque(curr);
+                }
+                return null; /* End of queue */
+            }
+
+            if (head == curr) {
+                /* head is likely not up-to-date */
+                curr = next;
+            } else {
+                /* Try to update to head */
+                if (head == (head = this.getHeadOpaque())) {
+                    curr = next;
+                } else {
+                    curr = head;
+                }
+            }
+        }
+    }
+
+    /**
+     * Empties the queue into the specified consumer. This function is optimized for single-threaded reads, and should
+     * be faster than a loop on {@link #poll()}.
+     * <p>
+     * This function is not MT-Safe. This function cannot be called with other read operations ({@link #peek()}, {@link #poll()},
+     * {@link #clear()}, etc).
+     * Write operations are safe to be called concurrently.
+     * </p>
+     * @param consumer The consumer to accept the elements.
+     * @return The total number of elements drained.
+     */
+    public int drain(final Consumer<E> consumer) {
+        return this.drain(consumer, false, ConcurrentUtil::rethrow);
+    }
+
+    /**
+     * Empties the queue into the specified consumer. This function is optimized for single-threaded reads, and should
+     * be faster than a loop on {@link #poll()}.
+     * <p>
+     * If {@code preventAdds} is {@code true}, then after this function returns the queue is guaranteed to be empty and
+     * additions to the queue will fail.
+     * </p>
+     * <p>
+     * This function is not MT-Safe. This function cannot be called with other read operations ({@link #peek()}, {@link #poll()},
+     * {@link #clear()}, etc).
+     * Write operations are safe to be called concurrently.
+     * </p>
+     * @param consumer The consumer to accept the elements.
+     * @param preventAdds Whether to prevent additions to this queue after draining.
+     * @return The total number of elements drained.
+     */
+    public int drain(final Consumer<E> consumer, final boolean preventAdds) {
+        return this.drain(consumer, preventAdds, ConcurrentUtil::rethrow);
+    }
+
+    /**
+     * Empties the queue into the specified consumer. This function is optimized for single-threaded reads, and should
+     * be faster than a loop on {@link #poll()}.
+     * <p>
+     * If {@code preventAdds} is {@code true}, then after this function returns the queue is guaranteed to be empty and
+     * additions to the queue will fail.
+     * </p>
+     * <p>
+     * This function is not MT-Safe. This function cannot be called with other read operations ({@link #peek()}, {@link #poll()},
+     * {@link #clear()}, {@link #remove(Object)} etc).
+     * Only write operations are safe to be called concurrently.
+     * </p>
+     * @param consumer The consumer to accept the elements.
+     * @param preventAdds Whether to prevent additions to this queue after draining.
+     * @param exceptionHandler Invoked when the consumer raises an exception.
+     * @return The total number of elements drained.
+     */
+    public int drain(final Consumer<E> consumer, final boolean preventAdds, final Consumer<Throwable> exceptionHandler) {
+        Validate.notNull(consumer, "Null consumer");
+        Validate.notNull(exceptionHandler, "Null exception handler");
+
+        /* This function assumes proper synchronization is made to ensure drain and no other read function are called concurrently */
+        /* This allows plain write usages instead of opaque or higher */
+        int total = 0;
+
+        final LinkedNode<E> head = this.getHeadAcquire(); /* Required to synchronize with the write to the first element field */
+        LinkedNode<E> curr = head;
+
+        for (;;) {
+            /* Volatile acquires with the write to the element field */
+            final E currentVal = curr.getElementPlain();
+            LinkedNode<E> next = curr.getNextVolatile();
+
+            if (next == curr) {
+                /* Add-locked nodes always have a null value */
+                break;
+            }
+
+            if (currentVal == null) {
+                if (next == null) {
+                    if (preventAdds && (next = curr.compareExchangeNextVolatile(null, curr)) != null) {
+                        // failed to prevent adds, continue
+                        curr = next;
+                        continue;
+                    } else {
+                        // we're done here
+                        break;
+                    }
+                }
+                curr = next;
+                continue;
+            }
+
+            try {
+                consumer.accept(currentVal);
+            } catch (final Exception ex) {
+                this.setHeadOpaque(next != null ? next : curr); /* Avoid perf penalty (of reiterating) if the exception handler decides to re-throw */
+                curr.setElementOpaque(null); /* set here, we might re-throw */
+
+                exceptionHandler.accept(ex);
+            }
+
+            curr.setElementOpaque(null);
+
+            ++total;
+
+            if (next == null) {
+                if (preventAdds && (next = curr.compareExchangeNextVolatile(null, curr)) != null) {
+                    /* Retry with next value */
+                    curr = next;
+                    continue;
+                }
+                break;
+            }
+
+            curr = next;
+        }
+        if (curr != head) {
+            this.setHeadOpaque(curr); /* While this may be a plain write, eventually publish it for methods such as find. */
+        }
+        return total;
+    }
+
+    @Override
+    public Spliterator<E> spliterator() { // TODO implement
+        return Spliterators.spliterator(this, Spliterator.CONCURRENT |
+            Spliterator.NONNULL | Spliterator.ORDERED);
+    }
+
+    protected static final class LinkedNode<E> {
+
+        protected volatile Object element;
+        protected volatile LinkedNode<E> next;
+
+        protected static final VarHandle ELEMENT_HANDLE = ConcurrentUtil.getVarHandle(LinkedNode.class, "element", Object.class);
+        protected static final VarHandle NEXT_HANDLE = ConcurrentUtil.getVarHandle(LinkedNode.class, "next", LinkedNode.class);
+
+        protected LinkedNode(final Object element, final LinkedNode<E> next) {
+            ELEMENT_HANDLE.set(this, element);
+            NEXT_HANDLE.set(this, next);
+        }
+
+        /* element */
+
+        @SuppressWarnings("unchecked")
+        protected final E getElementPlain() {
+            return (E)ELEMENT_HANDLE.get(this);
+        }
+
+        @SuppressWarnings("unchecked")
+        protected final E getElementVolatile() {
+            return (E)ELEMENT_HANDLE.getVolatile(this);
+        }
+
+        protected final void setElementPlain(final E update) {
+            ELEMENT_HANDLE.set(this, (Object)update);
+        }
+
+        protected final void setElementOpaque(final E update) {
+            ELEMENT_HANDLE.setOpaque(this, (Object)update);
+        }
+
+        protected final void setElementVolatile(final E update) {
+            ELEMENT_HANDLE.setVolatile(this, (Object)update);
+        }
+
+        @SuppressWarnings("unchecked")
+        protected final E getAndSetElementVolatile(final E update) {
+            return (E)ELEMENT_HANDLE.getAndSet(this, update);
+        }
+
+        @SuppressWarnings("unchecked")
+        protected final E compareExchangeElementVolatile(final E expect, final E update) {
+            return (E)ELEMENT_HANDLE.compareAndExchange(this, expect, update);
+        }
+
+        /* next */
+
+        @SuppressWarnings("unchecked")
+        protected final LinkedNode<E> getNextPlain() {
+            return (LinkedNode<E>)NEXT_HANDLE.get(this);
+        }
+
+        @SuppressWarnings("unchecked")
+        protected final LinkedNode<E> getNextOpaque() {
+            return (LinkedNode<E>)NEXT_HANDLE.getOpaque(this);
+        }
+
+        @SuppressWarnings("unchecked")
+        protected final LinkedNode<E> getNextAcquire() {
+            return (LinkedNode<E>)NEXT_HANDLE.getAcquire(this);
+        }
+
+        @SuppressWarnings("unchecked")
+        protected final LinkedNode<E> getNextVolatile() {
+            return (LinkedNode<E>)NEXT_HANDLE.getVolatile(this);
+        }
+
+        protected final void setNextPlain(final LinkedNode<E> next) {
+            NEXT_HANDLE.set(this, next);
+        }
+
+        protected final void setNextVolatile(final LinkedNode<E> next) {
+            NEXT_HANDLE.setVolatile(this, next);
+        }
+
+        @SuppressWarnings("unchecked")
+        protected final LinkedNode<E> compareExchangeNextVolatile(final LinkedNode<E> expect, final LinkedNode<E> set) {
+            return (LinkedNode<E>)NEXT_HANDLE.compareAndExchange(this, expect, set);
+        }
+    }
+
+    protected static final class LinkedIterator<E> implements Iterator<E> {
+
+        protected LinkedNode<E> curr; /* last returned by next() */
+        protected LinkedNode<E> next; /* next to return from next() */
+        protected E nextElement; /* cached to avoid a race condition with removing or polling */
+
+        protected LinkedIterator(final LinkedNode<E> start) {
+            /* setup nextElement and next */
+            for (LinkedNode<E> curr = start;;) {
+                final LinkedNode<E> next = curr.getNextVolatile();
+
+                final E element = curr.getElementPlain();
+
+                if (element != null) {
+                    this.nextElement = element;
+                    this.next = curr;
+                    break;
+                }
+
+                if (next == null || next == curr) {
+                    break;
+                }
+                curr = next;
+            }
+        }
+
+        protected final void findNext() {
+            /* only called if this.nextElement != null, which means this.next != null */
+            for (LinkedNode<E> curr = this.next;;) {
+                final LinkedNode<E> next = curr.getNextVolatile();
+
+                if (next == null || next == curr) {
+                    break;
+                }
+
+                final E element = next.getElementPlain();
+
+                if (element != null) {
+                    this.nextElement = element;
+                    this.curr = this.next; /* this.next will be the value returned from next(), set this.curr for remove() */
+                    this.next = next;
+                    return;
+                }
+                curr = next;
+            }
+
+            /* out of nodes to iterate */
+            /* keep curr for remove() calls */
+            this.next = null;
+            this.nextElement = null;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public boolean hasNext() {
+            return this.nextElement != null;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public E next() {
+            final E element = this.nextElement;
+
+            if (element == null) {
+                throw new NoSuchElementException();
+            }
+
+            this.findNext();
+
+            return element;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void remove() {
+            if (this.curr == null) {
+                throw new IllegalStateException();
+            }
+
+            this.curr.setElementVolatile(null);
+            this.curr = null;
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concurrentutil/completable/Completable.java b/src/main/java/ca/spottedleaf/concurrentutil/completable/Completable.java
new file mode 100644
index 0000000000000000000000000000000000000000..a1ad3308f9c3545a604b635896259a1cd3382b2a
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concurrentutil/completable/Completable.java
@@ -0,0 +1,98 @@
+package ca.spottedleaf.concurrentutil.completable;
+
+import ca.spottedleaf.concurrentutil.collection.MultiThreadedQueue;
+import ca.spottedleaf.concurrentutil.executor.Cancellable;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import com.mojang.logging.LogUtils;
+import org.slf4j.Logger;
+import java.util.function.BiConsumer;
+
+public final class Completable<T> {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    private final MultiThreadedQueue<BiConsumer<T, Throwable>> waiters = new MultiThreadedQueue<>();
+    private T result;
+    private Throwable throwable;
+    private volatile boolean completed;
+
+    public boolean isCompleted() {
+        return this.completed;
+    }
+
+    /**
+     * Note: Can only use after calling {@link #addAsynchronousWaiter(BiConsumer)}, as this function performs zero
+     * synchronisation
+     */
+    public T getResult() {
+        return this.result;
+    }
+
+    /**
+     * Note: Can only use after calling {@link #addAsynchronousWaiter(BiConsumer)}, as this function performs zero
+     * synchronisation
+     */
+    public Throwable getThrowable() {
+        return this.throwable;
+    }
+
+    public Cancellable addAsynchronousWaiter(final BiConsumer<T, Throwable> consumer) {
+        if (this.waiters.add(consumer)) {
+            return new CancellableImpl(consumer);
+        }
+        return null;
+    }
+
+    private void completeAllWaiters(final T result, final Throwable throwable) {
+        this.completed = true;
+        BiConsumer<T, Throwable> waiter;
+        while ((waiter = this.waiters.pollOrBlockAdds()) != null) {
+            this.completeWaiter(waiter, result, throwable);
+        }
+    }
+
+    private void completeWaiter(final BiConsumer<T, Throwable> consumer, final T result, final Throwable throwable) {
+        try {
+            consumer.accept(result, throwable);
+        } catch (final ThreadDeath death) {
+            throw death;
+        } catch (final Throwable throwable2) {
+            LOGGER.error("Failed to complete callback " + ConcurrentUtil.genericToString(consumer), throwable2);
+        }
+    }
+
+    public Cancellable addWaiter(final BiConsumer<T, Throwable> consumer) {
+        if (this.waiters.add(consumer)) {
+            return new CancellableImpl(consumer);
+        }
+        this.completeWaiter(consumer, this.result, this.throwable);
+        return new CancellableImpl(consumer);
+    }
+
+    public void complete(final T result) {
+        this.result = result;
+        this.completeAllWaiters(result, null);
+    }
+
+    public void completeWithThrowable(final Throwable throwable) {
+        if (throwable == null) {
+            throw new NullPointerException("Throwable cannot be null");
+        }
+        this.throwable = throwable;
+        this.completeAllWaiters(null, throwable);
+    }
+
+    private final class CancellableImpl implements Cancellable {
+
+        private final BiConsumer<T, Throwable> waiter;
+
+        private CancellableImpl(final BiConsumer<T, Throwable> waiter) {
+            this.waiter = waiter;
+        }
+
+        @Override
+        public boolean cancel() {
+            return Completable.this.waiters.remove(this.waiter);
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concurrentutil/executor/BaseExecutor.java b/src/main/java/ca/spottedleaf/concurrentutil/executor/BaseExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..716a0fd3f558df748e355069746272facb91de22
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concurrentutil/executor/BaseExecutor.java
@@ -0,0 +1,198 @@
+package ca.spottedleaf.concurrentutil.executor;
+
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import java.util.function.BooleanSupplier;
+
+public interface BaseExecutor {
+
+    /**
+     * Returns whether every task scheduled to this queue has been removed and executed or cancelled. If no tasks have been queued,
+     * returns {@code true}.
+     *
+     * @return {@code true} if all tasks that have been queued have finished executing or no tasks have been queued, {@code false} otherwise.
+     */
+    public default boolean haveAllTasksExecuted() {
+        // order is important
+        // if new tasks are scheduled between the reading of these variables, scheduled is guaranteed to be higher -
+        // so our check fails, and we try again
+        final long completed = this.getTotalTasksExecuted();
+        final long scheduled = this.getTotalTasksScheduled();
+
+        return completed == scheduled;
+    }
+
+    /**
+     * Returns the number of tasks that have been scheduled or execute or are pending to be scheduled.
+     */
+    public long getTotalTasksScheduled();
+
+    /**
+     * Returns the number of tasks that have fully been executed.
+     */
+    public long getTotalTasksExecuted();
+
+
+    /**
+     * Waits until this queue has had all of its tasks executed (NOT removed). See {@link #haveAllTasksExecuted()}
+     * <p>
+     *     This call is most effective after a {@link #shutdown()} call, as the shutdown call guarantees no tasks can
+     *     be executed and the waitUntilAllExecuted call makes sure the queue is empty. Effectively, using shutdown then using
+     *     waitUntilAllExecuted ensures this queue is empty - and most importantly, will remain empty.
+     * </p>
+     * <p>
+     *     This method is not guaranteed to be immediately responsive to queue state, so calls may take significantly more
+     *     time than expected. Effectively, do not rely on this call being fast - even if there are few tasks scheduled.
+     * </p>
+     * <p>
+     *     Note: Interruptions to the the current thread have no effect. Interrupt status is also not affected by this cal.
+     * </p>
+     *
+     * @throws IllegalStateException If the current thread is not allowed to wait
+     */
+    public default void waitUntilAllExecuted() throws IllegalStateException {
+        long failures = 9L; // start out at 1ms
+
+        while (!this.haveAllTasksExecuted()) {
+            Thread.yield();
+            failures = ConcurrentUtil.linearLongBackoff(failures, 500_000L, 5_000_000L); // 500us, 5ms
+        }
+    }
+
+    /**
+     * Executes the next available task.
+     * <p>
+     *     If there is a task with priority {@link PrioritisedExecutor.Priority#BLOCKING} available, then that such task is executed.
+     * </p>
+     * <p>
+     *     If there is a task with priority {@link PrioritisedExecutor.Priority#IDLE} available then that task is only executed
+     *     when there are no other tasks available with a higher priority.
+     * </p>
+     * <p>
+     *     If there are no tasks that have priority {@link PrioritisedExecutor.Priority#BLOCKING} or {@link PrioritisedExecutor.Priority#IDLE}, then
+     *     this function will be biased to execute tasks that have higher priorities.
+     * </p>
+     *
+     * @return {@code true} if a task was executed, {@code false} otherwise
+     * @throws IllegalStateException If the current thread is not allowed to execute a task
+     */
+    public boolean executeTask() throws IllegalStateException;
+
+    /**
+     * Executes all queued tasks.
+     *
+     * @return {@code true} if a task was executed, {@code false} otherwise
+     * @throws IllegalStateException If the current thread is not allowed to execute a task
+     */
+    public default boolean executeAll() {
+        if (!this.executeTask()) {
+            return false;
+        }
+
+        while (this.executeTask());
+
+        return true;
+    }
+
+    /**
+     * Waits and executes tasks until the condition returns {@code true}.
+     * <p>
+     *     WARNING: This function is <i>not</i> suitable for waiting until a deadline!
+     *     Use {@link #executeUntil(long)} or {@link #executeConditionally(BooleanSupplier, long)} instead.
+     * </p>
+     */
+    public default void executeConditionally(final BooleanSupplier condition) {
+        long failures = 0;
+        while (!condition.getAsBoolean()) {
+            if (this.executeTask()) {
+                failures = failures >>> 2;
+            } else {
+                failures = ConcurrentUtil.linearLongBackoff(failures, 100_000L, 10_000_000L); // 100us, 10ms
+            }
+        }
+    }
+
+    /**
+     * Waits and executes tasks until the condition returns {@code true} or {@code System.nanoTime() >= deadline}.
+     */
+    public default void executeConditionally(final BooleanSupplier condition, final long deadline) {
+        long failures = 0;
+        // double check deadline; we don't know how expensive the condition is
+        while ((System.nanoTime() < deadline) && !condition.getAsBoolean() && (System.nanoTime() < deadline)) {
+            if (this.executeTask()) {
+                failures = failures >>> 2;
+            } else {
+                failures = ConcurrentUtil.linearLongBackoffDeadline(failures, 100_000L, 10_000_000L, deadline); // 100us, 10ms
+            }
+        }
+    }
+
+    /**
+     * Waits and executes tasks until {@code System.nanoTime() >= deadline}.
+     */
+    public default void executeUntil(final long deadline) {
+        long failures = 0;
+        while (System.nanoTime() < deadline) {
+            if (this.executeTask()) {
+                failures = failures >>> 2;
+            } else {
+                failures = ConcurrentUtil.linearLongBackoffDeadline(failures, 100_000L, 10_000_000L, deadline); // 100us, 10ms
+            }
+        }
+    }
+
+    /**
+     * Prevent further additions to this queue. Attempts to add after this call has completed (potentially during) will
+     * result in {@link IllegalStateException} being thrown.
+     * <p>
+     *     This operation is atomic with respect to other shutdown calls
+     * </p>
+     * <p>
+     *     After this call has completed, regardless of return value, this queue will be shutdown.
+     * </p>
+     *
+     * @return {@code true} if the queue was shutdown, {@code false} if it has shut down already
+     * @throws UnsupportedOperationException If this queue does not support shutdown
+     */
+    public default boolean shutdown() throws UnsupportedOperationException {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Returns whether this queue has shut down. Effectively, whether new tasks will be rejected - this method
+     * does not indicate whether all of the tasks scheduled have been executed.
+     * @return Returns whether this queue has shut down.
+     */
+    public default boolean isShutdown() {
+        return false;
+    }
+
+    public static interface BaseTask extends Cancellable {
+
+        /**
+         * Causes a lazily queued task to become queued or executed
+         *
+         * @throws IllegalStateException If the backing queue has shutdown
+         * @return {@code true} If the task was queued, {@code false} if the task was already queued/cancelled/executed
+         */
+        public boolean queue();
+
+        /**
+         * Forces this task to be marked as completed.
+         *
+         * @return {@code true} if the task was cancelled, {@code false} if the task has already completed or is being completed.
+         */
+        @Override
+        public boolean cancel();
+
+        /**
+         * Executes this task. This will also mark the task as completing.
+         * <p>
+         *     Exceptions thrown from the runnable will be rethrown.
+         * </p>
+         *
+         * @return {@code true} if this task was executed, {@code false} if it was already marked as completed.
+         */
+        public boolean execute();
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concurrentutil/executor/Cancellable.java b/src/main/java/ca/spottedleaf/concurrentutil/executor/Cancellable.java
new file mode 100644
index 0000000000000000000000000000000000000000..11449056361bb6c5a055f543cdd135c4113757c6
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concurrentutil/executor/Cancellable.java
@@ -0,0 +1,14 @@
+package ca.spottedleaf.concurrentutil.executor;
+
+/**
+ * Interface specifying that something can be cancelled.
+ */
+public interface Cancellable {
+
+    /**
+     * Tries to cancel this task. If the task is in a stage that is too late to be cancelled, then this function
+     * will return {@code false}. If the task is already cancelled, then this function returns {@code false}. Only
+     * when this function successfully stops this task from being completed will it return {@code true}.
+     */
+    public boolean cancel();
+}
diff --git a/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/DelayedPrioritisedTask.java b/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/DelayedPrioritisedTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..3ce10053d4ec51855ad7012abb5d97df1c0e557a
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/DelayedPrioritisedTask.java
@@ -0,0 +1,170 @@
+package ca.spottedleaf.concurrentutil.executor.standard;
+
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import java.lang.invoke.VarHandle;
+
+public class DelayedPrioritisedTask {
+
+    protected volatile int priority;
+    protected static final VarHandle PRIORITY_HANDLE = ConcurrentUtil.getVarHandle(DelayedPrioritisedTask.class, "priority", int.class);
+
+    protected static final int PRIORITY_SET = Integer.MIN_VALUE >>> 0;
+
+    protected final int getPriorityVolatile() {
+        return (int)PRIORITY_HANDLE.getVolatile((DelayedPrioritisedTask)this);
+    }
+
+    protected final int compareAndExchangePriorityVolatile(final int expect, final int update) {
+        return (int)PRIORITY_HANDLE.compareAndExchange((DelayedPrioritisedTask)this, (int)expect, (int)update);
+    }
+
+    protected final int getAndOrPriorityVolatile(final int val) {
+        return (int)PRIORITY_HANDLE.getAndBitwiseOr((DelayedPrioritisedTask)this, (int)val);
+    }
+
+    protected final void setPriorityPlain(final int val) {
+        PRIORITY_HANDLE.set((DelayedPrioritisedTask)this, (int)val);
+    }
+
+    protected volatile PrioritisedExecutor.PrioritisedTask task;
+    protected static final VarHandle TASK_HANDLE = ConcurrentUtil.getVarHandle(DelayedPrioritisedTask.class, "task", PrioritisedExecutor.PrioritisedTask.class);
+
+    protected PrioritisedExecutor.PrioritisedTask getTaskPlain() {
+        return (PrioritisedExecutor.PrioritisedTask)TASK_HANDLE.get((DelayedPrioritisedTask)this);
+    }
+
+    protected PrioritisedExecutor.PrioritisedTask getTaskVolatile() {
+        return (PrioritisedExecutor.PrioritisedTask)TASK_HANDLE.getVolatile((DelayedPrioritisedTask)this);
+    }
+
+    protected final PrioritisedExecutor.PrioritisedTask compareAndExchangeTaskVolatile(final PrioritisedExecutor.PrioritisedTask expect, final PrioritisedExecutor.PrioritisedTask update) {
+        return (PrioritisedExecutor.PrioritisedTask)TASK_HANDLE.compareAndExchange((DelayedPrioritisedTask)this, (PrioritisedExecutor.PrioritisedTask)expect, (PrioritisedExecutor.PrioritisedTask)update);
+    }
+
+    public DelayedPrioritisedTask(final PrioritisedExecutor.Priority priority) {
+        this.setPriorityPlain(priority.priority);
+    }
+
+    // only public for debugging
+    public int getPriorityInternal() {
+        return this.getPriorityVolatile();
+    }
+
+    public PrioritisedExecutor.PrioritisedTask getTask() {
+        return this.getTaskVolatile();
+    }
+
+    public void setTask(final PrioritisedExecutor.PrioritisedTask task) {
+        int priority = this.getPriorityVolatile();
+
+        if (this.compareAndExchangeTaskVolatile(null, task) != null) {
+            throw new IllegalStateException("setTask() called twice");
+        }
+
+        int failures = 0;
+        for (;;) {
+            task.setPriority(PrioritisedExecutor.Priority.getPriority(priority));
+
+            if (priority == (priority = this.compareAndExchangePriorityVolatile(priority, priority | PRIORITY_SET))) {
+                return;
+            }
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    public PrioritisedExecutor.Priority getPriority() {
+        final int priority = this.getPriorityVolatile();
+        if ((priority & PRIORITY_SET) != 0) {
+            return this.task.getPriority();
+        }
+
+        return PrioritisedExecutor.Priority.getPriority(priority);
+    }
+
+    public void raisePriority(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+
+        int failures = 0;
+        for (int curr = this.getPriorityVolatile();;) {
+            if ((curr & PRIORITY_SET) != 0) {
+                this.getTaskPlain().raisePriority(priority);
+                return;
+            }
+
+            if (!priority.isLowerPriority(curr)) {
+                return;
+            }
+
+            if (curr == (curr = this.compareAndExchangePriorityVolatile(curr, priority.priority))) {
+                return;
+            }
+
+            // failed, retry
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    public void setPriority(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+
+        int failures = 0;
+        for (int curr = this.getPriorityVolatile();;) {
+            if ((curr & PRIORITY_SET) != 0) {
+                this.getTaskPlain().setPriority(priority);
+                return;
+            }
+
+            if (curr == (curr = this.compareAndExchangePriorityVolatile(curr, priority.priority))) {
+                return;
+            }
+
+            // failed, retry
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    public void lowerPriority(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+
+        int failures = 0;
+        for (int curr = this.getPriorityVolatile();;) {
+            if ((curr & PRIORITY_SET) != 0) {
+                this.getTaskPlain().lowerPriority(priority);
+                return;
+            }
+
+            if (!priority.isHigherPriority(curr)) {
+                return;
+            }
+
+            if (curr == (curr = this.compareAndExchangePriorityVolatile(curr, priority.priority))) {
+                return;
+            }
+
+            // failed, retry
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/PrioritisedExecutor.java b/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/PrioritisedExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..e5d8ff730ba9d83efc2d80782de313a718bf55b3
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/PrioritisedExecutor.java
@@ -0,0 +1,246 @@
+package ca.spottedleaf.concurrentutil.executor.standard;
+
+import ca.spottedleaf.concurrentutil.executor.BaseExecutor;
+
+public interface PrioritisedExecutor extends BaseExecutor {
+
+    public static enum Priority {
+
+        /**
+         * Priority value indicating the task has completed or is being completed.
+         * This priority cannot be used to schedule tasks.
+         */
+        COMPLETING(-1),
+
+        /**
+         * Absolute highest priority, should only be used for when a task is blocking a time-critical thread.
+         */
+        BLOCKING(),
+
+        /**
+         * Should only be used for urgent but not time-critical tasks.
+         */
+        HIGHEST(),
+
+        /**
+         * Two priorities above normal.
+         */
+        HIGHER(),
+
+        /**
+         * One priority above normal.
+         */
+        HIGH(),
+
+        /**
+         * Default priority.
+         */
+        NORMAL(),
+
+        /**
+         * One priority below normal.
+         */
+        LOW(),
+
+        /**
+         * Two priorities below normal.
+         */
+        LOWER(),
+
+        /**
+         * Use for tasks that should eventually execute, but are not needed to.
+         */
+        LOWEST(),
+
+        /**
+         * Use for tasks that can be delayed indefinitely.
+         */
+        IDLE();
+
+        // returns whether the priority can be scheduled
+        public static boolean isValidPriority(final Priority priority) {
+            return priority != null && priority != Priority.COMPLETING;
+        }
+
+        // returns the higher priority of the two
+        public static PrioritisedExecutor.Priority max(final Priority p1, final Priority p2) {
+            return p1.isHigherOrEqualPriority(p2) ? p1 : p2;
+        }
+
+        // returns the lower priroity of the two
+        public static PrioritisedExecutor.Priority min(final Priority p1, final Priority p2) {
+            return p1.isLowerOrEqualPriority(p2) ? p1 : p2;
+        }
+
+        public boolean isHigherOrEqualPriority(final Priority than) {
+            return this.priority <= than.priority;
+        }
+
+        public boolean isHigherPriority(final Priority than) {
+            return this.priority < than.priority;
+        }
+
+        public boolean isLowerOrEqualPriority(final Priority than) {
+            return this.priority >= than.priority;
+        }
+
+        public boolean isLowerPriority(final Priority than) {
+            return this.priority > than.priority;
+        }
+
+        public boolean isHigherOrEqualPriority(final int than) {
+            return this.priority <= than;
+        }
+
+        public boolean isHigherPriority(final int than) {
+            return this.priority < than;
+        }
+
+        public boolean isLowerOrEqualPriority(final int than) {
+            return this.priority >= than;
+        }
+
+        public boolean isLowerPriority(final int than) {
+            return this.priority > than;
+        }
+
+        public static boolean isHigherOrEqualPriority(final int priority, final int than) {
+            return priority <= than;
+        }
+
+        public static boolean isHigherPriority(final int priority, final int than) {
+            return priority < than;
+        }
+
+        public static boolean isLowerOrEqualPriority(final int priority, final int than) {
+            return priority >= than;
+        }
+
+        public static boolean isLowerPriority(final int priority, final int than) {
+            return priority > than;
+        }
+
+        static final PrioritisedExecutor.Priority[] PRIORITIES = PrioritisedExecutor.Priority.values();
+
+        /** includes special priorities */
+        public static final int TOTAL_PRIORITIES = PRIORITIES.length;
+
+        public static final int TOTAL_SCHEDULABLE_PRIORITIES = TOTAL_PRIORITIES - 1;
+
+        public static PrioritisedExecutor.Priority getPriority(final int priority) {
+            return PRIORITIES[priority + 1];
+        }
+
+        private static int priorityCounter;
+
+        private static int nextCounter() {
+            return priorityCounter++;
+        }
+
+        public final int priority;
+
+        Priority() {
+            this(nextCounter());
+        }
+
+        Priority(final int priority) {
+            this.priority = priority;
+        }
+    }
+
+    /**
+     * Queues or executes a task at {@link Priority#NORMAL} priority.
+     * @param task The task to run.
+     *
+     * @throws IllegalStateException If this queue has shutdown.
+     * @throws NullPointerException If the task is null
+     * @return {@code null} if the current thread immediately executed the task, else returns the prioritised task
+     * associated with the parameter
+     */
+    public default PrioritisedTask queueRunnable(final Runnable task) {
+        return this.queueRunnable(task, PrioritisedExecutor.Priority.NORMAL);
+    }
+
+    /**
+     * Queues or executes a task.
+     *
+     * @param task The task to run.
+     * @param priority The priority for the task.
+     *
+     * @throws IllegalStateException If this queue has shutdown.
+     * @throws NullPointerException If the task is null
+     * @throws IllegalArgumentException If the priority is invalid.
+     * @return {@code null} if the current thread immediately executed the task, else returns the prioritised task
+     * associated with the parameter
+     */
+    public PrioritisedTask queueRunnable(final Runnable task, final PrioritisedExecutor.Priority priority);
+
+    /**
+     * Creates, but does not execute or queue the task. The task must later be queued via {@link BaseExecutor.BaseTask#queue()}.
+     *
+     * @param task The task to run.
+     *
+     * @throws IllegalStateException If this queue has shutdown.
+     * @throws NullPointerException If the task is null
+     * @throws IllegalArgumentException If the priority is invalid.
+     * @throws UnsupportedOperationException If this executor does not support lazily queueing tasks
+     * @return The prioritised task associated with the parameters
+     */
+    public default PrioritisedExecutor.PrioritisedTask createTask(final Runnable task) {
+        return this.createTask(task, PrioritisedExecutor.Priority.NORMAL);
+    }
+
+    /**
+     * Creates, but does not execute or queue the task. The task must later be queued via {@link BaseExecutor.BaseTask#queue()}.
+     *
+     * @param task The task to run.
+     * @param priority The priority for the task.
+     *
+     * @throws IllegalStateException If this queue has shutdown.
+     * @throws NullPointerException If the task is null
+     * @throws IllegalArgumentException If the priority is invalid.
+     * @throws UnsupportedOperationException If this executor does not support lazily queueing tasks
+     * @return The prioritised task associated with the parameters
+     */
+    public PrioritisedExecutor.PrioritisedTask createTask(final Runnable task, final PrioritisedExecutor.Priority priority);
+
+    public static interface PrioritisedTask extends BaseTask {
+
+        /**
+         * Returns the current priority. Note that {@link PrioritisedExecutor.Priority#COMPLETING} will be returned
+         * if this task is completing or has completed.
+         */
+        public PrioritisedExecutor.Priority getPriority();
+
+        /**
+         * Attempts to set this task's priority level to the level specified.
+         *
+         * @param priority Specified priority level.
+         *
+         * @throws IllegalArgumentException If the priority is invalid
+         * @return {@code true} if successful, {@code false} if this task is completing or has completed or the queue
+         * this task was scheduled on was shutdown, or if the priority was already at the specified level.
+         */
+        public boolean setPriority(final PrioritisedExecutor.Priority priority);
+
+        /**
+         * Attempts to raise the priority to the priority level specified.
+         *
+         * @param priority Priority specified
+         *
+         * @throws IllegalArgumentException If the priority is invalid
+         * @return {@code false} if the current task is completing, {@code true} if the priority was raised to the specified level or was already at the specified level or higher.
+         */
+        public boolean raisePriority(final PrioritisedExecutor.Priority priority);
+
+        /**
+         * Attempts to lower the priority to the priority level specified.
+         *
+         * @param priority Priority specified
+         *
+         * @throws IllegalArgumentException If the priority is invalid
+         * @return {@code false} if the current task is completing, {@code true} if the priority was lowered to the specified level or was already at the specified level or lower.
+         */
+        public boolean lowerPriority(final PrioritisedExecutor.Priority priority);
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/PrioritisedQueueExecutorThread.java b/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/PrioritisedQueueExecutorThread.java
new file mode 100644
index 0000000000000000000000000000000000000000..91fe0f7049122f62f05ba09c24cba5d758340cff
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/PrioritisedQueueExecutorThread.java
@@ -0,0 +1,297 @@
+package ca.spottedleaf.concurrentutil.executor.standard;
+
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import com.mojang.logging.LogUtils;
+import org.slf4j.Logger;
+import java.lang.invoke.VarHandle;
+import java.util.concurrent.locks.LockSupport;
+
+/**
+ * Thread which will continuously drain from a specified queue.
+ * <p>
+ *     Note: When using this thread, queue additions to the underlying {@link #queue} are not sufficient to get this thread
+ *     to execute the task. The function {@link #notifyTasks()} must be used after scheduling a task. For expected behaviour
+ *     of task scheduling (thread wakes up after tasks are scheduled), use the methods provided on {@link PrioritisedExecutor}
+ *     methods.
+ * </p>
+ */
+public class PrioritisedQueueExecutorThread extends Thread implements PrioritisedExecutor {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    protected final PrioritisedExecutor queue;
+
+    protected volatile boolean threadShutdown;
+
+    protected static final VarHandle THREAD_PARKED_HANDLE = ConcurrentUtil.getVarHandle(PrioritisedQueueExecutorThread.class, "threadParked", boolean.class);
+    protected volatile boolean threadParked;
+
+    protected volatile boolean halted;
+
+    protected final long spinWaitTime;
+
+    static final long DEFAULT_SPINWAIT_TIME = (long)(0.1e6);// 0.1ms
+
+    public PrioritisedQueueExecutorThread(final PrioritisedExecutor queue) {
+        this(queue, DEFAULT_SPINWAIT_TIME); // 0.1ms
+    }
+
+    public PrioritisedQueueExecutorThread(final PrioritisedExecutor queue, final long spinWaitTime) { // in ns
+        this.queue = queue;
+        this.spinWaitTime = spinWaitTime;
+    }
+
+    @Override
+    public void run() {
+        final long spinWaitTime = this.spinWaitTime;
+
+        main_loop:
+        for (;;) {
+            this.pollTasks();
+
+            // spinwait
+
+            final long start = System.nanoTime();
+
+            for (;;) {
+                // If we are interrupted for any reason, park() will always return immediately. Clear so that we don't needlessly use cpu in such an event.
+                Thread.interrupted();
+                Thread.yield();
+                LockSupport.parkNanos("Spinwaiting on tasks", 10_000L); // 10us
+
+                if (this.pollTasks()) {
+                    // restart loop, found tasks
+                    continue main_loop;
+                }
+
+                if (this.handleClose()) {
+                    return; // we're done
+                }
+
+                if ((System.nanoTime() - start) >= spinWaitTime) {
+                    break;
+                }
+            }
+
+            if (this.handleClose()) {
+                return;
+            }
+
+            this.setThreadParkedVolatile(true);
+
+            // We need to parse here to avoid a race condition where a thread queues a task before we set parked to true
+            // (i.e it will not notify us)
+            if (this.pollTasks()) {
+                this.setThreadParkedVolatile(false);
+                continue;
+            }
+
+            if (this.handleClose()) {
+                return;
+            }
+
+            // we don't need to check parked before sleeping, but we do need to check parked in a do-while loop
+            // LockSupport.park() can fail for any reason
+            while (this.getThreadParkedVolatile()) {
+                Thread.interrupted();
+                LockSupport.park("Waiting on tasks");
+            }
+        }
+    }
+
+    protected boolean pollTasks() {
+        boolean ret = false;
+
+        for (;;) {
+            if (this.halted) {
+                break;
+            }
+            try {
+                if (!this.queue.executeTask()) {
+                    break;
+                }
+                ret = true;
+            } catch (final ThreadDeath death) {
+                throw death; // goodbye world...
+            } catch (final Throwable throwable) {
+                LOGGER.error("Exception thrown from prioritized runnable task in thread '" + this.getName() + "'", throwable);
+            }
+        }
+
+        return ret;
+    }
+
+    protected boolean handleClose() {
+        if (this.threadShutdown) {
+            this.pollTasks(); // this ensures we've emptied the queue
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Notify this thread that a task has been added to its queue
+     * @return {@code true} if this thread was waiting for tasks, {@code false} if it is executing tasks
+     */
+    public boolean notifyTasks() {
+        if (this.getThreadParkedVolatile() && this.exchangeThreadParkedVolatile(false)) {
+            LockSupport.unpark(this);
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public PrioritisedTask createTask(final Runnable task, final Priority priority) {
+        final PrioritisedExecutor.PrioritisedTask queueTask = this.queue.createTask(task, priority);
+
+        // need to override queue() to notify us of tasks
+        return new PrioritisedTask() {
+            @Override
+            public Priority getPriority() {
+                return queueTask.getPriority();
+            }
+
+            @Override
+            public boolean setPriority(final Priority priority) {
+                return queueTask.setPriority(priority);
+            }
+
+            @Override
+            public boolean raisePriority(final Priority priority) {
+                return queueTask.raisePriority(priority);
+            }
+
+            @Override
+            public boolean lowerPriority(final Priority priority) {
+                return queueTask.lowerPriority(priority);
+            }
+
+            @Override
+            public boolean queue() {
+                final boolean ret = queueTask.queue();
+                if (ret) {
+                    PrioritisedQueueExecutorThread.this.notifyTasks();
+                }
+                return ret;
+            }
+
+            @Override
+            public boolean cancel() {
+                return queueTask.cancel();
+            }
+
+            @Override
+            public boolean execute() {
+                return queueTask.execute();
+            }
+        };
+    }
+
+    @Override
+    public PrioritisedExecutor.PrioritisedTask queueRunnable(final Runnable task, final PrioritisedExecutor.Priority priority) {
+        final PrioritisedExecutor.PrioritisedTask ret = this.queue.queueRunnable(task, priority);
+
+        this.notifyTasks();
+
+        return ret;
+    }
+
+    @Override
+    public boolean haveAllTasksExecuted() {
+        return this.queue.haveAllTasksExecuted();
+    }
+
+    @Override
+    public long getTotalTasksExecuted() {
+        return this.queue.getTotalTasksExecuted();
+    }
+
+    @Override
+    public long getTotalTasksScheduled() {
+        return this.queue.getTotalTasksScheduled();
+    }
+
+    /**
+     * {@inheritDoc}
+     * @throws IllegalStateException If the current thread is {@code this} thread, or the underlying queue throws this exception.
+     */
+    @Override
+    public void waitUntilAllExecuted() throws IllegalStateException {
+        if (Thread.currentThread() == this) {
+            throw new IllegalStateException("Cannot block on our own queue");
+        }
+        this.queue.waitUntilAllExecuted();
+    }
+
+    /**
+     * {@inheritDoc}
+     * @throws IllegalStateException Always
+     */
+    @Override
+    public boolean executeTask() throws IllegalStateException {
+        throw new IllegalStateException();
+    }
+
+    /**
+     * Closes this queue executor's queue. Optionally waits for all tasks in queue to be executed if {@code wait} is true.
+     * <p>
+     *     This function is MT-Safe.
+     * </p>
+     * @param wait If this call is to wait until the queue is empty and there are no tasks executing in the queue.
+     * @param killQueue Whether to shutdown this thread's queue
+     * @return whether this thread shut down the queue
+     * @see #halt(boolean)
+     */
+    public boolean close(final boolean wait, final boolean killQueue) {
+        final boolean ret = killQueue && this.queue.shutdown();
+        this.threadShutdown = true;
+
+        // force thread to respond to the shutdown
+        this.setThreadParkedVolatile(false);
+        LockSupport.unpark(this);
+
+        if (wait) {
+            this.waitUntilAllExecuted();
+        }
+
+        return ret;
+    }
+
+
+    /**
+     * Causes this thread to exit without draining the queue. To ensure tasks are completed, use {@link #close(boolean, boolean)}.
+     * <p>
+     *     This is not safe to call with {@link #close(boolean, boolean)} if <code>wait = true</code>, in which case
+     *     the waiting thread may block indefinitely.
+     * </p>
+     * <p>
+     *     This function is MT-Safe.
+     * </p>
+     * @param killQueue Whether to shutdown this thread's queue
+     * @see #close(boolean, boolean)
+     */
+    public void halt(final boolean killQueue) {
+        if (killQueue) {
+            this.queue.shutdown();
+        }
+        this.threadShutdown = true;
+        this.halted = true;
+
+        // force thread to respond to the shutdown
+        this.setThreadParkedVolatile(false);
+        LockSupport.unpark(this);
+    }
+
+    protected final boolean getThreadParkedVolatile() {
+        return (boolean)THREAD_PARKED_HANDLE.getVolatile(this);
+    }
+
+    protected final boolean exchangeThreadParkedVolatile(final boolean value) {
+        return (boolean)THREAD_PARKED_HANDLE.getAndSet(this, value);
+    }
+
+    protected final void setThreadParkedVolatile(final boolean value) {
+        THREAD_PARKED_HANDLE.setVolatile(this, value);
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/PrioritisedThreadPool.java b/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/PrioritisedThreadPool.java
new file mode 100644
index 0000000000000000000000000000000000000000..26fa2caa18a9194e57574a4a7fa9f7a4265740e0
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/PrioritisedThreadPool.java
@@ -0,0 +1,579 @@
+package ca.spottedleaf.concurrentutil.executor.standard;
+
+import com.mojang.logging.LogUtils;
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
+import org.slf4j.Logger;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.TreeSet;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.BiConsumer;
+
+public final class PrioritisedThreadPool {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    protected final PrioritisedThread[] threads;
+    protected final TreeSet<PrioritisedPoolExecutorImpl> queues = new TreeSet<>(PrioritisedPoolExecutorImpl.comparator());
+    protected final String name;
+    protected final long queueMaxHoldTime;
+
+    protected final ReferenceOpenHashSet<PrioritisedPoolExecutorImpl> nonShutdownQueues = new ReferenceOpenHashSet<>();
+    protected final ReferenceOpenHashSet<PrioritisedPoolExecutorImpl> activeQueues = new ReferenceOpenHashSet<>();
+
+    protected boolean shutdown;
+
+    protected long schedulingIdGenerator;
+
+    protected static final long DEFAULT_QUEUE_HOLD_TIME = (long)(5.0e6);
+
+    public PrioritisedThreadPool(final String name, final int threads) {
+        this(name, threads, null);
+    }
+
+    public PrioritisedThreadPool(final String name, final int threads, final BiConsumer<Thread, Integer> threadModifier) {
+        this(name, threads, threadModifier, DEFAULT_QUEUE_HOLD_TIME); // 5ms
+    }
+
+    public PrioritisedThreadPool(final String name, final int threads, final BiConsumer<Thread, Integer> threadModifier,
+                                 final long queueHoldTime) { // in ns
+        if (threads <= 0) {
+            throw new IllegalArgumentException("Thread count must be > 0, not " + threads);
+        }
+        if (name == null) {
+            throw new IllegalArgumentException("Name cannot be null");
+        }
+        this.name = name;
+        this.queueMaxHoldTime = queueHoldTime;
+
+        this.threads = new PrioritisedThread[threads];
+        for (int i = 0; i < threads; ++i) {
+            this.threads[i] = new PrioritisedThread(this);
+
+            // set default attributes
+            this.threads[i].setName("Prioritised thread for pool '" + name + "' #" + i);
+            this.threads[i].setUncaughtExceptionHandler((final Thread thread, final Throwable throwable) -> {
+                LOGGER.error("Uncaught exception in thread " + thread.getName(), throwable);
+            });
+
+            // let thread modifier override defaults
+            if (threadModifier != null) {
+                threadModifier.accept(this.threads[i], Integer.valueOf(i));
+            }
+
+            // now the thread can start
+            this.threads[i].start();
+        }
+    }
+
+    public Thread[] getThreads() {
+        return Arrays.copyOf(this.threads, this.threads.length, Thread[].class);
+    }
+
+    public PrioritisedPoolExecutor createExecutor(final String name, final int parallelism) {
+        synchronized (this.nonShutdownQueues) {
+            if (this.shutdown) {
+                throw new IllegalStateException("Queue is shutdown: " + this.toString());
+            }
+            final PrioritisedPoolExecutorImpl ret = new PrioritisedPoolExecutorImpl(this, name, Math.min(Math.max(1, parallelism), this.threads.length));
+
+            this.nonShutdownQueues.add(ret);
+
+            synchronized (this.activeQueues) {
+                this.activeQueues.add(ret);
+            }
+
+            return ret;
+        }
+    }
+
+    /**
+     * Prevents creation of new queues, shutdowns all non-shutdown queues if specified
+     */
+    public void halt(final boolean shutdownQueues) {
+        synchronized (this.nonShutdownQueues) {
+            this.shutdown = true;
+        }
+        if (shutdownQueues) {
+            final ArrayList<PrioritisedPoolExecutorImpl> queuesToShutdown;
+            synchronized (this.nonShutdownQueues) {
+                this.shutdown = true;
+                queuesToShutdown = new ArrayList<>(this.nonShutdownQueues);
+            }
+
+            for (final PrioritisedPoolExecutorImpl queue : queuesToShutdown) {
+                queue.shutdown();
+            }
+        }
+
+
+        for (final PrioritisedThread thread : this.threads) {
+            // can't kill queue, queue is null
+            thread.halt(false);
+        }
+    }
+
+    /**
+     * Waits until all threads in this pool have shutdown, or until the specified time has passed.
+     * @param msToWait Maximum time to wait.
+     * @return {@code false} if the maximum time passed, {@code true} otherwise.
+     */
+    public boolean join(final long msToWait) {
+        try {
+            return this.join(msToWait, false);
+        } catch (final InterruptedException ex) {
+            throw new IllegalStateException(ex);
+        }
+    }
+
+    /**
+     * Waits until all threads in this pool have shutdown, or until the specified time has passed.
+     * @param msToWait Maximum time to wait.
+     * @return {@code false} if the maximum time passed, {@code true} otherwise.
+     * @throws InterruptedException If this thread is interrupted.
+     */
+    public boolean joinInterruptable(final long msToWait) throws InterruptedException {
+        return this.join(msToWait, true);
+    }
+
+    protected final boolean join(final long msToWait, final boolean interruptable) throws InterruptedException {
+        final long nsToWait = msToWait * (1000 * 1000);
+        final long start = System.nanoTime();
+        final long deadline = start + nsToWait;
+        boolean interrupted = false;
+        try {
+            for (final PrioritisedThread thread : this.threads) {
+                for (;;) {
+                    if (!thread.isAlive()) {
+                        break;
+                    }
+                    final long current = System.nanoTime();
+                    if (current >= deadline) {
+                        return false;
+                    }
+
+                    try {
+                        thread.join(Math.max(1L, (deadline - current) / (1000 * 1000)));
+                    } catch (final InterruptedException ex) {
+                        if (interruptable) {
+                            throw ex;
+                        }
+                        interrupted = true;
+                    }
+                }
+            }
+
+            return true;
+        } finally {
+            if (interrupted) {
+                Thread.currentThread().interrupt();
+            }
+        }
+    }
+
+    public void shutdown(final boolean wait) {
+        final ArrayList<PrioritisedPoolExecutorImpl> queuesToShutdown;
+        synchronized (this.nonShutdownQueues) {
+            this.shutdown = true;
+            queuesToShutdown = new ArrayList<>(this.nonShutdownQueues);
+        }
+
+        for (final PrioritisedPoolExecutorImpl queue : queuesToShutdown) {
+            queue.shutdown();
+        }
+
+        for (final PrioritisedThread thread : this.threads) {
+            // none of these can be true or else NPE
+            thread.close(false, false);
+        }
+
+        if (wait) {
+            final ArrayList<PrioritisedPoolExecutorImpl> queues;
+            synchronized (this.activeQueues) {
+                queues = new ArrayList<>(this.activeQueues);
+            }
+            for (final PrioritisedPoolExecutorImpl queue : queues) {
+                queue.waitUntilAllExecuted();
+            }
+        }
+    }
+
+    protected static final class PrioritisedThread extends PrioritisedQueueExecutorThread {
+
+        protected final PrioritisedThreadPool pool;
+        protected final AtomicBoolean alertedHighPriority = new AtomicBoolean();
+
+        public PrioritisedThread(final PrioritisedThreadPool pool) {
+            super(null);
+            this.pool = pool;
+        }
+
+        public boolean alertHighPriorityExecutor() {
+            if (!this.notifyTasks()) {
+                if (!this.alertedHighPriority.get()) {
+                    this.alertedHighPriority.set(true);
+                }
+                return false;
+            }
+
+            return true;
+        }
+
+        private boolean isAlertedHighPriority() {
+            return this.alertedHighPriority.get() && this.alertedHighPriority.getAndSet(false);
+        }
+
+        @Override
+        protected boolean pollTasks() {
+            final PrioritisedThreadPool pool = this.pool;
+            final TreeSet<PrioritisedPoolExecutorImpl> queues = this.pool.queues;
+
+            boolean ret = false;
+            for (;;) {
+                if (this.halted) {
+                    break;
+                }
+                // try to find a queue
+                // note that if and ONLY IF the queues set is empty, this means there are no tasks for us to execute.
+                // so we can only break when it's empty
+                final PrioritisedPoolExecutorImpl queue;
+                // select queue
+                synchronized (queues) {
+                    queue = queues.pollFirst();
+                    if (queue == null) {
+                        // no tasks to execute
+                        break;
+                    }
+
+                    queue.schedulingId = ++pool.schedulingIdGenerator;
+                    // we own this queue now, so increment the executor count
+                    // do we also need to push this queue up for grabs for another executor?
+                    if (++queue.concurrentExecutors < queue.maximumExecutors) {
+                        // re-add to queues
+                        // it's very important this is done in the same synchronised block for polling, as this prevents
+                        // us from possibly later adding a queue that should not exist in the set
+                        queues.add(queue);
+                        queue.isQueued = true;
+                    } else {
+                        queue.isQueued = false;
+                    }
+                    // note: we cannot drain entries from the queue while holding this lock, as it will cause deadlock
+                    // the queue addition holds the per-queue lock first then acquires the lock we have now, but if we
+                    // try to poll now we don't hold the per queue lock but we do hold the global lock...
+                }
+
+                // parse tasks as long as we are allowed
+                final long start = System.nanoTime();
+                final long deadline = start + pool.queueMaxHoldTime;
+                do {
+                    try {
+                        if (this.halted) {
+                            break;
+                        }
+                        if (!queue.executeTask()) {
+                            // no more tasks, try next queue
+                            break;
+                        }
+                        ret = true;
+                    } catch (final ThreadDeath death) {
+                        throw death; // goodbye world...
+                    } catch (final Throwable throwable) {
+                        LOGGER.error("Exception thrown from thread '" + this.getName() + "' in queue '" + queue.toString() + "'", throwable);
+                    }
+                } while (!this.isAlertedHighPriority() && System.nanoTime() <= deadline);
+
+                synchronized (queues) {
+                    // decrement executors, we are no longer executing
+                    if (queue.isQueued) {
+                        queues.remove(queue);
+                        queue.isQueued = false;
+                    }
+                    if (--queue.concurrentExecutors == 0 && queue.scheduledPriority == null) {
+                        // reset scheduling id once the queue is empty again
+                        // this will ensure empty queues are not prioritised suddenly over active queues once tasks are
+                        // queued
+                        queue.schedulingId = 0L;
+                    }
+
+                    // ensure the executor is queued for execution again
+                    if (!queue.isHalted && queue.scheduledPriority != null) { // make sure it actually has tasks
+                        queues.add(queue);
+                        queue.isQueued = true;
+                    }
+                }
+            }
+
+            return ret;
+        }
+    }
+
+    public interface PrioritisedPoolExecutor extends PrioritisedExecutor {
+
+        /**
+         * Removes this queue from the thread pool without shutting the queue down or waiting for queued tasks to be executed
+         */
+        public void halt();
+
+        /**
+         * Returns whether this executor is scheduled to run tasks or is running tasks, otherwise it returns whether
+         * this queue is not halted and not shutdown.
+         */
+        public boolean isActive();
+    }
+
+    protected static final class PrioritisedPoolExecutorImpl extends PrioritisedThreadedTaskQueue implements PrioritisedPoolExecutor {
+
+        protected final PrioritisedThreadPool pool;
+        protected final long[] priorityCounts = new long[Priority.TOTAL_SCHEDULABLE_PRIORITIES];
+        protected long schedulingId;
+        protected int concurrentExecutors;
+        protected Priority scheduledPriority;
+
+        protected final String name;
+        protected final int maximumExecutors;
+        protected boolean isQueued;
+
+        public PrioritisedPoolExecutorImpl(final PrioritisedThreadPool pool, final String name, final int maximumExecutors) {
+            this.pool = pool;
+            this.name = name;
+            this.maximumExecutors = maximumExecutors;
+        }
+
+        public static Comparator<PrioritisedPoolExecutorImpl> comparator() {
+            return (final PrioritisedPoolExecutorImpl p1, final PrioritisedPoolExecutorImpl p2) -> {
+                if (p1 == p2) {
+                    return 0;
+                }
+
+                // prefer higher priority
+                final int priorityCompare = p1.scheduledPriority.ordinal() - p2.scheduledPriority.ordinal();
+                if (priorityCompare != 0) {
+                    return priorityCompare;
+                }
+
+                // try to spread out the executors so that each can have threads executing
+                final int executorCompare = p1.concurrentExecutors - p2.concurrentExecutors;
+                if (executorCompare != 0) {
+                    return executorCompare;
+                }
+
+                // if all else fails here we just choose whichever executor was queued first
+                return Long.compare(p1.schedulingId, p2.schedulingId);
+            };
+        }
+
+        private boolean isHalted;
+
+        @Override
+        public void halt() {
+            final PrioritisedThreadPool pool = this.pool;
+            final TreeSet<PrioritisedPoolExecutorImpl> queues = pool.queues;
+            synchronized (queues) {
+                if (this.isHalted) {
+                    return;
+                }
+                this.isHalted = true;
+                if (this.isQueued) {
+                    queues.remove(this);
+                    this.isQueued = false;
+                }
+            }
+            synchronized (pool.nonShutdownQueues) {
+                pool.nonShutdownQueues.remove(this);
+            }
+            synchronized (pool.activeQueues) {
+                pool.activeQueues.remove(this);
+            }
+        }
+
+        @Override
+        public boolean isActive() {
+            final PrioritisedThreadPool pool = this.pool;
+            final TreeSet<PrioritisedPoolExecutorImpl> queues = pool.queues;
+
+            synchronized (queues) {
+                if (this.concurrentExecutors != 0) {
+                    return true;
+                }
+                synchronized (pool.activeQueues) {
+                    if (pool.activeQueues.contains(this)) {
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+
+        private long totalQueuedTasks = 0L;
+
+        @Override
+        protected void priorityChange(final PrioritisedThreadedTaskQueue.PrioritisedTask task, final Priority from, final Priority to) {
+            // Note: The superclass' queue lock is ALWAYS held when inside this method. So we do NOT need to do any additional synchronisation
+            // for accessing this queue's state.
+            final long[] priorityCounts = this.priorityCounts;
+            final boolean shutdown = this.isShutdown();
+
+            if (from == null && to == Priority.COMPLETING) {
+                throw new IllegalStateException("Cannot complete task without queueing it first");
+            }
+
+            // we should only notify for queueing of tasks, not changing priorities
+            final boolean shouldNotifyTasks = from == null;
+
+            final Priority scheduledPriority = this.scheduledPriority;
+            if (from != null) {
+                --priorityCounts[from.priority];
+            }
+            if (to != Priority.COMPLETING) {
+                ++priorityCounts[to.priority];
+            }
+            final long totalQueuedTasks;
+            if (to == Priority.COMPLETING) {
+                totalQueuedTasks = --this.totalQueuedTasks;
+            } else if (from == null) {
+                totalQueuedTasks = ++this.totalQueuedTasks;
+            } else {
+                totalQueuedTasks = this.totalQueuedTasks;
+            }
+
+            // find new highest priority
+            int highest = Math.min(to == Priority.COMPLETING ? Priority.IDLE.priority : to.priority, scheduledPriority == null ? Priority.IDLE.priority : scheduledPriority.priority);
+            int lowestPriority = priorityCounts.length; // exclusive
+            for (;highest < lowestPriority; ++highest) {
+                final long count = priorityCounts[highest];
+                if (count < 0) {
+                    throw new IllegalStateException("Priority " + highest + " has " + count + " scheduled tasks");
+                }
+
+                if (count != 0) {
+                    break;
+                }
+            }
+
+            final Priority newPriority;
+            if (highest == lowestPriority) {
+                // no tasks left
+                newPriority = null;
+            } else if (shutdown) {
+                // whichever is lower, the actual greatest priority or simply HIGHEST
+                // this is so shutdown automatically gets priority
+                newPriority = Priority.getPriority(Math.min(highest, Priority.HIGHEST.priority));
+            } else {
+                newPriority = Priority.getPriority(highest);
+            }
+
+            final int executorsWanted;
+            boolean shouldNotifyHighPriority = false;
+
+            final PrioritisedThreadPool pool = this.pool;
+            final TreeSet<PrioritisedPoolExecutorImpl> queues = pool.queues;
+
+            synchronized (queues) {
+                if (!this.isQueued) {
+                    // see if we need to be queued
+                    if (newPriority != null) {
+                        if (this.schedulingId == 0L) {
+                            this.schedulingId = ++pool.schedulingIdGenerator;
+                        }
+                        this.scheduledPriority = newPriority; // must be updated before queue add
+                        if (!this.isHalted && this.concurrentExecutors < this.maximumExecutors) {
+                            shouldNotifyHighPriority = newPriority.isHigherOrEqualPriority(Priority.HIGH);
+                            queues.add(this);
+                            this.isQueued = true;
+                        }
+                    } else {
+                        // do not queue
+                        this.scheduledPriority = null;
+                    }
+                } else {
+                    // see if we need to NOT be queued
+                    if (newPriority == null) {
+                        queues.remove(this);
+                        this.scheduledPriority = null;
+                        this.isQueued = false;
+                    } else if (scheduledPriority != newPriority) {
+                        // if our priority changed, we need to update it - which means removing and re-adding into the queue
+                        queues.remove(this);
+                        // only now can we update scheduledPriority, since we are no longer in queue
+                        this.scheduledPriority = newPriority;
+                        queues.add(this);
+                        shouldNotifyHighPriority = (scheduledPriority == null || scheduledPriority.isLowerPriority(Priority.HIGH)) && newPriority.isHigherOrEqualPriority(Priority.HIGH);
+                    }
+                }
+
+                if (this.isQueued) {
+                    executorsWanted = Math.min(this.maximumExecutors - this.concurrentExecutors, (int)totalQueuedTasks);
+                } else {
+                    executorsWanted = 0;
+                }
+            }
+
+            if (newPriority == null && shutdown) {
+                synchronized (pool.activeQueues) {
+                    pool.activeQueues.remove(this);
+                }
+            }
+
+            // Wake up the number of executors we want
+            if (executorsWanted > 0 || (shouldNotifyTasks | shouldNotifyHighPriority)) {
+                int notified = 0;
+                for (final PrioritisedThread thread : pool.threads) {
+                    if ((shouldNotifyHighPriority ? thread.alertHighPriorityExecutor() : thread.notifyTasks())
+                            && (++notified >= executorsWanted)) {
+                        break;
+                    }
+                }
+            }
+        }
+
+        @Override
+        public boolean shutdown() {
+            final boolean ret = super.shutdown();
+            if (!ret) {
+                return ret;
+            }
+
+            final PrioritisedThreadPool pool = this.pool;
+
+            // remove from active queues
+            synchronized (pool.nonShutdownQueues) {
+                pool.nonShutdownQueues.remove(this);
+            }
+
+            final TreeSet<PrioritisedPoolExecutorImpl> queues = pool.queues;
+
+            // try and shift around our priority
+            synchronized (queues) {
+                if (this.scheduledPriority == null) {
+                    // no tasks are queued, ensure we aren't in activeQueues
+                    synchronized (pool.activeQueues) {
+                        pool.activeQueues.remove(this);
+                    }
+
+                    return ret;
+                }
+
+                // try to set scheduled priority to HIGHEST so it drains faster
+
+                if (this.scheduledPriority.isHigherOrEqualPriority(Priority.HIGHEST)) {
+                    // already at target priority (highest or above)
+                    return ret;
+                }
+
+                // shift priority to HIGHEST
+
+                if (this.isQueued) {
+                    queues.remove(this);
+                    this.scheduledPriority = Priority.HIGHEST;
+                    queues.add(this);
+                } else {
+                    this.scheduledPriority = Priority.HIGHEST;
+                }
+            }
+
+            return ret;
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/PrioritisedThreadedTaskQueue.java b/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/PrioritisedThreadedTaskQueue.java
new file mode 100644
index 0000000000000000000000000000000000000000..b71404be2c82f7db35272b367af861e94d6c73d3
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/PrioritisedThreadedTaskQueue.java
@@ -0,0 +1,378 @@
+package ca.spottedleaf.concurrentutil.executor.standard;
+
+import java.util.ArrayDeque;
+import java.util.concurrent.atomic.AtomicLong;
+
+public class PrioritisedThreadedTaskQueue implements PrioritisedExecutor {
+
+    protected final ArrayDeque<PrioritisedTask>[] queues = new ArrayDeque[Priority.TOTAL_SCHEDULABLE_PRIORITIES]; {
+        for (int i = 0; i < Priority.TOTAL_SCHEDULABLE_PRIORITIES; ++i) {
+            this.queues[i] = new ArrayDeque<>();
+        }
+    }
+
+    // Use AtomicLong to separate from the queue field, we don't want false sharing here.
+    protected final AtomicLong totalScheduledTasks = new AtomicLong();
+    protected final AtomicLong totalCompletedTasks = new AtomicLong();
+
+    // this is here to prevent failures to queue stalling flush() calls (as the schedule calls would increment totalScheduledTasks without this check)
+    protected volatile boolean hasShutdown;
+
+    protected long taskIdGenerator = 0;
+
+    @Override
+    public PrioritisedExecutor.PrioritisedTask queueRunnable(final Runnable task, final PrioritisedExecutor.Priority priority) throws IllegalStateException, IllegalArgumentException {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Priority " + priority + " is invalid");
+        }
+        if (task == null) {
+            throw new NullPointerException("Task cannot be null");
+        }
+
+        if (this.hasShutdown) {
+            // prevent us from stalling flush() calls by incrementing scheduled tasks when we really didn't schedule something
+            throw new IllegalStateException("Queue has shutdown");
+        }
+
+        final PrioritisedTask ret;
+
+        synchronized (this.queues) {
+            if (this.hasShutdown) {
+                throw new IllegalStateException("Queue has shutdown");
+            }
+            this.getAndAddTotalScheduledTasksVolatile(1L);
+
+            ret = new PrioritisedTask(this.taskIdGenerator++, task, priority, this);
+
+            this.queues[ret.priority.priority].add(ret);
+
+            // call priority change callback (note: only after we successfully queue!)
+            this.priorityChange(ret, null, priority);
+        }
+
+        return ret;
+    }
+
+    @Override
+    public PrioritisedExecutor.PrioritisedTask createTask(final Runnable task, final Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Priority " + priority + " is invalid");
+        }
+        if (task == null) {
+            throw new NullPointerException("Task cannot be null");
+        }
+
+        return new PrioritisedTask(task, priority, this);
+    }
+
+    @Override
+    public long getTotalTasksScheduled() {
+        return this.totalScheduledTasks.get();
+    }
+
+    @Override
+    public long getTotalTasksExecuted() {
+        return this.totalCompletedTasks.get();
+    }
+
+    // callback method for subclasses to override
+    // from is null when a task is immediately created
+    protected void priorityChange(final PrioritisedTask task, final Priority from, final Priority to) {}
+
+    /**
+     * Polls the highest priority task currently available. {@code null} if none. This will mark the
+     * returned task as completed.
+     */
+    protected PrioritisedTask poll() {
+        return this.poll(Priority.IDLE);
+    }
+
+    protected PrioritisedTask poll(final PrioritisedExecutor.Priority minPriority) {
+        final ArrayDeque<PrioritisedTask>[] queues = this.queues;
+        synchronized (queues) {
+            final int max = minPriority.priority;
+            for (int i = 0; i <= max; ++i) {
+                final ArrayDeque<PrioritisedTask> queue = queues[i];
+                PrioritisedTask task;
+                while ((task = queue.pollFirst()) != null) {
+                    if (task.trySetCompleting(i)) {
+                        return task;
+                    }
+                }
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Polls and executes the highest priority task currently available. Exceptions thrown during task execution will
+     * be rethrown.
+     * @return {@code true} if a task was executed, {@code false} otherwise.
+     */
+    @Override
+    public boolean executeTask() {
+        final PrioritisedTask task = this.poll();
+
+        if (task != null) {
+            task.executeInternal();
+            return true;
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean shutdown() {
+        synchronized (this.queues) {
+            if (this.hasShutdown) {
+                return false;
+            }
+            this.hasShutdown = true;
+        }
+        return true;
+    }
+
+    @Override
+    public boolean isShutdown() {
+        return this.hasShutdown;
+    }
+
+    /* totalScheduledTasks */
+
+    protected final long getTotalScheduledTasksVolatile() {
+        return this.totalScheduledTasks.get();
+    }
+
+    protected final long getAndAddTotalScheduledTasksVolatile(final long value) {
+        return this.totalScheduledTasks.getAndAdd(value);
+    }
+
+    /* totalCompletedTasks */
+
+    protected final long getTotalCompletedTasksVolatile() {
+        return this.totalCompletedTasks.get();
+    }
+
+    protected final long getAndAddTotalCompletedTasksVolatile(final long value) {
+        return this.totalCompletedTasks.getAndAdd(value);
+    }
+
+    protected static final class PrioritisedTask implements PrioritisedExecutor.PrioritisedTask {
+        protected final PrioritisedThreadedTaskQueue queue;
+        protected long id;
+        protected static final long NOT_SCHEDULED_ID = -1L;
+
+        protected Runnable runnable;
+        protected volatile PrioritisedExecutor.Priority priority;
+
+        protected PrioritisedTask(final long id, final Runnable runnable, final PrioritisedExecutor.Priority priority, final PrioritisedThreadedTaskQueue queue) {
+            if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+                throw new IllegalArgumentException("Invalid priority " + priority);
+            }
+
+            this.priority = priority;
+            this.runnable = runnable;
+            this.queue = queue;
+            this.id = id;
+        }
+
+        protected PrioritisedTask(final Runnable runnable, final PrioritisedExecutor.Priority priority, final PrioritisedThreadedTaskQueue queue) {
+            if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+                throw new IllegalArgumentException("Invalid priority " + priority);
+            }
+
+            this.priority = priority;
+            this.runnable = runnable;
+            this.queue = queue;
+            this.id = NOT_SCHEDULED_ID;
+        }
+
+        @Override
+        public boolean queue() {
+            if (this.queue.hasShutdown) {
+                throw new IllegalStateException("Queue has shutdown");
+            }
+
+            synchronized (this.queue.queues) {
+                if (this.queue.hasShutdown) {
+                    throw new IllegalStateException("Queue has shutdown");
+                }
+
+                final PrioritisedExecutor.Priority priority = this.priority;
+                if (priority == PrioritisedExecutor.Priority.COMPLETING) {
+                    return false;
+                }
+
+                if (this.id != NOT_SCHEDULED_ID) {
+                    return false;
+                }
+
+                this.queue.getAndAddTotalScheduledTasksVolatile(1L);
+                this.id = this.queue.taskIdGenerator++;
+                this.queue.queues[priority.priority].add(this);
+
+                this.queue.priorityChange(this, null, priority);
+
+                return true;
+            }
+        }
+
+        protected boolean trySetCompleting(final int minPriority) {
+            final PrioritisedExecutor.Priority oldPriority = this.priority;
+            if (oldPriority != PrioritisedExecutor.Priority.COMPLETING && oldPriority.isHigherOrEqualPriority(minPriority)) {
+                this.priority = PrioritisedExecutor.Priority.COMPLETING;
+                if (this.id != NOT_SCHEDULED_ID) {
+                    this.queue.priorityChange(this, oldPriority, PrioritisedExecutor.Priority.COMPLETING);
+                }
+                return true;
+            }
+
+            return false;
+        }
+
+        @Override
+        public PrioritisedExecutor.Priority getPriority() {
+            return this.priority;
+        }
+
+        @Override
+        public boolean setPriority(final PrioritisedExecutor.Priority priority) {
+            if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+                throw new IllegalArgumentException("Invalid priority " + priority);
+            }
+            synchronized (this.queue.queues) {
+                final PrioritisedExecutor.Priority curr = this.priority;
+
+                if (curr == PrioritisedExecutor.Priority.COMPLETING) {
+                    return false;
+                }
+
+                if (curr == priority) {
+                    return true;
+                }
+
+                this.priority = priority;
+                if (this.id != NOT_SCHEDULED_ID) {
+                    this.queue.queues[priority.priority].add(this);
+
+                    // call priority change callback
+                    this.queue.priorityChange(this, curr, priority);
+                }
+            }
+
+            return true;
+        }
+
+        @Override
+        public boolean raisePriority(final PrioritisedExecutor.Priority priority) {
+            if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+                throw new IllegalArgumentException("Invalid priority " + priority);
+            }
+
+            synchronized (this.queue.queues) {
+                final PrioritisedExecutor.Priority curr = this.priority;
+
+                if (curr == PrioritisedExecutor.Priority.COMPLETING) {
+                    return false;
+                }
+
+                if (curr.isHigherOrEqualPriority(priority)) {
+                    return true;
+                }
+
+                this.priority = priority;
+                if (this.id != NOT_SCHEDULED_ID) {
+                    this.queue.queues[priority.priority].add(this);
+
+                    // call priority change callback
+                    this.queue.priorityChange(this, curr, priority);
+                }
+            }
+
+            return true;
+        }
+
+        @Override
+        public boolean lowerPriority(final PrioritisedExecutor.Priority priority) {
+            if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+                throw new IllegalArgumentException("Invalid priority " + priority);
+            }
+
+            synchronized (this.queue.queues) {
+                final PrioritisedExecutor.Priority curr = this.priority;
+
+                if (curr == PrioritisedExecutor.Priority.COMPLETING) {
+                    return false;
+                }
+
+                if (curr.isLowerOrEqualPriority(priority)) {
+                    return true;
+                }
+
+                this.priority = priority;
+                if (this.id != NOT_SCHEDULED_ID) {
+                    this.queue.queues[priority.priority].add(this);
+
+                    // call priority change callback
+                    this.queue.priorityChange(this, curr, priority);
+                }
+            }
+
+            return true;
+        }
+
+        @Override
+        public boolean cancel() {
+            final long id;
+            synchronized (this.queue.queues) {
+                final Priority oldPriority = this.priority;
+                if (oldPriority == PrioritisedExecutor.Priority.COMPLETING) {
+                    return false;
+                }
+
+                this.priority = PrioritisedExecutor.Priority.COMPLETING;
+                // call priority change callback
+                if ((id = this.id) != NOT_SCHEDULED_ID) {
+                    this.queue.priorityChange(this, oldPriority, PrioritisedExecutor.Priority.COMPLETING);
+                }
+            }
+            this.runnable = null;
+            if (id != NOT_SCHEDULED_ID) {
+                this.queue.getAndAddTotalCompletedTasksVolatile(1L);
+            }
+            return true;
+        }
+
+        protected void executeInternal() {
+            try {
+                final Runnable execute = this.runnable;
+                this.runnable = null;
+                execute.run();
+            } finally {
+                if (this.id != NOT_SCHEDULED_ID) {
+                    this.queue.getAndAddTotalCompletedTasksVolatile(1L);
+                }
+            }
+        }
+
+        @Override
+        public boolean execute() {
+            synchronized (this.queue.queues) {
+                final Priority oldPriority = this.priority;
+                if (oldPriority == PrioritisedExecutor.Priority.COMPLETING) {
+                    return false;
+                }
+
+                this.priority = PrioritisedExecutor.Priority.COMPLETING;
+                // call priority change callback
+                if (this.id != NOT_SCHEDULED_ID) {
+                    this.queue.priorityChange(this, oldPriority, PrioritisedExecutor.Priority.COMPLETING);
+                }
+            }
+
+            this.executeInternal();
+            return true;
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concurrentutil/map/SWMRHashTable.java b/src/main/java/ca/spottedleaf/concurrentutil/map/SWMRHashTable.java
new file mode 100644
index 0000000000000000000000000000000000000000..a037bb57bedc0cde6b979f5c1f9669678fa7bd16
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concurrentutil/map/SWMRHashTable.java
@@ -0,0 +1,1673 @@
+package ca.spottedleaf.concurrentutil.map;
+
+import ca.spottedleaf.concurrentutil.util.ArrayUtil;
+import ca.spottedleaf.concurrentutil.util.CollectionUtil;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import ca.spottedleaf.concurrentutil.util.Validate;
+import io.papermc.paper.util.IntegerUtil;
+import java.lang.invoke.VarHandle;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Set;
+import java.util.Spliterator;
+import java.util.Spliterators;
+import java.util.function.BiConsumer;
+import java.util.function.BiFunction;
+import java.util.function.BiPredicate;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.IntFunction;
+import java.util.function.Predicate;
+
+/**
+ * <p>
+ * Note: Not really tested, use at your own risk.
+ * </p>
+ * This map is safe for reading from multiple threads, however it is only safe to write from a single thread.
+ * {@code null} keys or values are not permitted. Writes to values in this map are guaranteed to be ordered by release semantics,
+ * however immediate visibility to other threads is not guaranteed. However, writes are guaranteed to be made visible eventually.
+ * Reads are ordered by acquire semantics.
+ * <p>
+ * Iterators cannot be modified concurrently, and its backing map cannot be modified concurrently. There is no
+ * fast-fail attempt made by iterators, thus modifying the iterator's backing map while iterating will have undefined
+ * behaviour.
+ * </p>
+ * <p>
+ * Subclasses should override {@link #clone()} to return correct instances of this class.
+ * </p>
+ * @param <K> {@inheritDoc}
+ * @param <V> {@inheritDoc}
+ */
+public class SWMRHashTable<K, V> implements Map<K, V>, Iterable<Map.Entry<K, V>> {
+
+    protected int size;
+
+    protected TableEntry<K, V>[] table;
+
+    protected final float loadFactor;
+
+    protected static final VarHandle SIZE_HANDLE = ConcurrentUtil.getVarHandle(SWMRHashTable.class, "size", int.class);
+    protected static final VarHandle TABLE_HANDLE = ConcurrentUtil.getVarHandle(SWMRHashTable.class, "table", TableEntry[].class);
+
+    /* size */
+
+    protected final int getSizePlain() {
+        return (int)SIZE_HANDLE.get(this);
+    }
+
+    protected final int getSizeOpaque() {
+        return (int)SIZE_HANDLE.getOpaque(this);
+    }
+
+    protected final int getSizeAcquire() {
+        return (int)SIZE_HANDLE.getAcquire(this);
+    }
+
+    protected final void setSizePlain(final int value) {
+        SIZE_HANDLE.set(this, value);
+    }
+
+    protected final void setSizeOpaque(final int value) {
+        SIZE_HANDLE.setOpaque(this, value);
+    }
+
+    protected final void setSizeRelease(final int value) {
+        SIZE_HANDLE.setRelease(this, value);
+    }
+
+    /* table */
+
+    protected final TableEntry<K, V>[] getTablePlain() {
+        //noinspection unchecked
+        return (TableEntry<K, V>[])TABLE_HANDLE.get(this);
+    }
+
+    protected final TableEntry<K, V>[] getTableAcquire() {
+        //noinspection unchecked
+        return (TableEntry<K, V>[])TABLE_HANDLE.getAcquire(this);
+    }
+
+    protected final void setTablePlain(final TableEntry<K, V>[] table) {
+        TABLE_HANDLE.set(this, table);
+    }
+
+    protected final void setTableRelease(final TableEntry<K, V>[] table) {
+        TABLE_HANDLE.setRelease(this, table);
+    }
+
+    protected static final int DEFAULT_CAPACITY = 16;
+    protected static final float DEFAULT_LOAD_FACTOR = 0.75f;
+    protected static final int MAXIMUM_CAPACITY = Integer.MIN_VALUE >>> 1;
+
+    /**
+     * Constructs this map with a capacity of {@code 16} and load factor of {@code 0.75f}.
+     */
+    public SWMRHashTable() {
+        this(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);
+    }
+
+    /**
+     * Constructs this map with the specified capacity and load factor of {@code 0.75f}.
+     * @param capacity specified initial capacity, > 0
+     */
+    public SWMRHashTable(final int capacity) {
+        this(capacity, DEFAULT_LOAD_FACTOR);
+    }
+
+    /**
+     * Constructs this map with the specified capacity and load factor.
+     * @param capacity specified capacity, > 0
+     * @param loadFactor specified load factor, > 0 && finite
+     */
+    public SWMRHashTable(final int capacity, final float loadFactor) {
+        final int tableSize = getCapacityFor(capacity);
+
+        if (loadFactor <= 0.0 || !Float.isFinite(loadFactor)) {
+            throw new IllegalArgumentException("Invalid load factor: " + loadFactor);
+        }
+
+        //noinspection unchecked
+        final TableEntry<K, V>[] table = new TableEntry[tableSize];
+        this.setTablePlain(table);
+
+        if (tableSize == MAXIMUM_CAPACITY) {
+            this.threshold = -1;
+        } else {
+            this.threshold = getTargetCapacity(tableSize, loadFactor);
+        }
+
+        this.loadFactor = loadFactor;
+    }
+
+    /**
+     * Constructs this map with a capacity of {@code 16} or the specified map's size, whichever is larger, and
+     * with a load factor of {@code 0.75f}.
+     * All of the specified map's entries are copied into this map.
+     * @param other The specified map.
+     */
+    public SWMRHashTable(final Map<K, V> other) {
+        this(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, other);
+    }
+
+    /**
+     * Constructs this map with a minimum capacity of the specified capacity or the specified map's size, whichever is larger, and
+     * with a load factor of {@code 0.75f}.
+     * All of the specified map's entries are copied into this map.
+     * @param capacity specified capacity, > 0
+     * @param other The specified map.
+     */
+    public SWMRHashTable(final int capacity, final Map<K, V> other) {
+        this(capacity, DEFAULT_LOAD_FACTOR, other);
+    }
+
+    /**
+     * Constructs this map with a min capacity of the specified capacity or the specified map's size, whichever is larger, and
+     * with the specified load factor.
+     * All of the specified map's entries are copied into this map.
+     * @param capacity specified capacity, > 0
+     * @param loadFactor specified load factor, > 0 && finite
+     * @param other The specified map.
+     */
+    public SWMRHashTable(final int capacity, final float loadFactor, final Map<K, V> other) {
+        this(Math.max(Validate.notNull(other, "Null map").size(), capacity), loadFactor);
+        this.putAll(other);
+    }
+
+    public final float getLoadFactor() {
+        return this.loadFactor;
+    }
+
+    protected static int getCapacityFor(final int capacity) {
+        if (capacity <= 0) {
+            throw new IllegalArgumentException("Invalid capacity: " + capacity);
+        }
+        if (capacity >= MAXIMUM_CAPACITY) {
+            return MAXIMUM_CAPACITY;
+        }
+        return IntegerUtil.roundCeilLog2(capacity);
+    }
+
+    /** Callers must still use acquire when reading the value of the entry. */
+    protected final TableEntry<K, V> getEntryForOpaque(final K key) {
+        final int hash = SWMRHashTable.getHash(key);
+        final TableEntry<K, V>[] table = this.getTableAcquire();
+
+        for (TableEntry<K, V> curr = ArrayUtil.getOpaque(table, hash & (table.length - 1)); curr != null; curr = curr.getNextOpaque()) {
+            if (hash == curr.hash && (key == curr.key || curr.key.equals(key))) {
+                return curr;
+            }
+        }
+
+        return null;
+    }
+
+    protected final TableEntry<K, V> getEntryForPlain(final K key) {
+        final int hash = SWMRHashTable.getHash(key);
+        final TableEntry<K, V>[] table = this.getTablePlain();
+
+        for (TableEntry<K, V> curr = table[hash & (table.length - 1)]; curr != null; curr = curr.getNextPlain()) {
+            if (hash == curr.hash && (key == curr.key || curr.key.equals(key))) {
+                return curr;
+            }
+        }
+
+        return null;
+    }
+
+    /* MT-Safe */
+
+    /** must be deterministic given a key */
+    private static int getHash(final Object key) {
+        int hash = key == null ? 0 : key.hashCode();
+        // inlined IntegerUtil#hash0
+        hash *= 0x36935555;
+        hash ^= hash >>> 16;
+        return hash;
+    }
+
+    static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash
+    static final int spread(int h) {
+        return (h ^ (h >>> 16)) & HASH_BITS;
+    }
+
+    // rets -1 if capacity*loadFactor is too large
+    protected static int getTargetCapacity(final int capacity, final float loadFactor) {
+        final double ret = (double)capacity * (double)loadFactor;
+        if (Double.isInfinite(ret) || ret >= ((double)Integer.MAX_VALUE)) {
+            return -1;
+        }
+
+        return (int)ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean equals(final Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        /* Make no attempt to deal with concurrent modifications */
+        if (!(obj instanceof Map)) {
+            return false;
+        }
+        final Map<?, ?> other = (Map<?, ?>)obj;
+
+        if (this.size() != other.size()) {
+            return false;
+        }
+
+        final TableEntry<K, V>[] table = this.getTableAcquire();
+
+        for (int i = 0, len = table.length; i < len; ++i) {
+            for (TableEntry<K, V> curr = ArrayUtil.getOpaque(table, i); curr != null; curr = curr.getNextOpaque()) {
+                final V value = curr.getValueAcquire();
+
+                final Object otherValue = other.get(curr.key);
+                if (otherValue == null || (value != otherValue && value.equals(otherValue))) {
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int hashCode() {
+        /* Make no attempt to deal with concurrent modifications */
+        int hash = 0;
+        final TableEntry<K, V>[] table = this.getTableAcquire();
+
+        for (int i = 0, len = table.length; i < len; ++i) {
+            for (TableEntry<K, V> curr = ArrayUtil.getOpaque(table, i); curr != null; curr = curr.getNextOpaque()) {
+                hash += curr.hashCode();
+            }
+        }
+
+        return hash;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String toString() {
+        final StringBuilder builder = new StringBuilder(64);
+        builder.append("SingleWriterMultiReaderHashMap:{");
+
+        this.forEach((final K key, final V value) -> {
+            builder.append("{key: \"").append(key).append("\", value: \"").append(value).append("\"}");
+        });
+
+        return builder.append('}').toString();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public SWMRHashTable<K, V> clone() {
+        return new SWMRHashTable<>(this.getTableAcquire().length, this.loadFactor, this);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Iterator<Entry<K, V>> iterator() {
+        return new EntryIterator<>(this.getTableAcquire(), this);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void forEach(final Consumer<? super Entry<K, V>> action) {
+        Validate.notNull(action, "Null action");
+
+        final TableEntry<K, V>[] table = this.getTableAcquire();
+        for (int i = 0, len = table.length; i < len; ++i) {
+            for (TableEntry<K, V> curr = ArrayUtil.getOpaque(table, i); curr != null; curr = curr.getNextOpaque()) {
+                action.accept(curr);
+            }
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void forEach(final BiConsumer<? super K, ? super V> action) {
+        Validate.notNull(action, "Null action");
+
+        final TableEntry<K, V>[] table = this.getTableAcquire();
+        for (int i = 0, len = table.length; i < len; ++i) {
+            for (TableEntry<K, V> curr = ArrayUtil.getOpaque(table, i); curr != null; curr = curr.getNextOpaque()) {
+                final V value = curr.getValueAcquire();
+
+                action.accept(curr.key, value);
+            }
+        }
+    }
+
+    /**
+     * Provides the specified consumer with all keys contained within this map.
+     * @param action The specified consumer.
+     */
+    public void forEachKey(final Consumer<? super K> action) {
+        Validate.notNull(action, "Null action");
+
+        final TableEntry<K, V>[] table = this.getTableAcquire();
+        for (int i = 0, len = table.length; i < len; ++i) {
+            for (TableEntry<K, V> curr = ArrayUtil.getOpaque(table, i); curr != null; curr = curr.getNextOpaque()) {
+                action.accept(curr.key);
+            }
+        }
+    }
+
+    /**
+     * Provides the specified consumer with all values contained within this map. Equivalent to {@code map.values().forEach(Consumer)}.
+     * @param action The specified consumer.
+     */
+    public void forEachValue(final Consumer<? super V> action) {
+        Validate.notNull(action, "Null action");
+
+        final TableEntry<K, V>[] table = this.getTableAcquire();
+        for (int i = 0, len = table.length; i < len; ++i) {
+            for (TableEntry<K, V> curr = ArrayUtil.getOpaque(table, i); curr != null; curr = curr.getNextOpaque()) {
+                final V value = curr.getValueAcquire();
+
+                action.accept(value);
+            }
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public V get(final Object key) {
+        Validate.notNull(key, "Null key");
+
+        //noinspection unchecked
+        final TableEntry<K, V> entry = this.getEntryForOpaque((K)key);
+        return entry == null ? null : entry.getValueAcquire();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean containsKey(final Object key) {
+        Validate.notNull(key, "Null key");
+
+        // note: we need to use getValueAcquire, so that the reads from this map are ordered by acquire semantics
+        return this.get(key) != null;
+    }
+
+    /**
+     * Returns {@code true} if this map contains an entry with the specified key and value at some point during this call.
+     * @param key The specified key.
+     * @param value The specified value.
+     * @return {@code true} if this map contains an entry with the specified key and value.
+     */
+    public boolean contains(final Object key, final Object value) {
+        Validate.notNull(key, "Null key");
+
+        //noinspection unchecked
+        final TableEntry<K, V> entry = this.getEntryForOpaque((K)key);
+
+        if (entry == null) {
+            return false;
+        }
+
+        final V entryVal = entry.getValueAcquire();
+        return entryVal == value || entryVal.equals(value);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean containsValue(final Object value) {
+        Validate.notNull(value, "Null value");
+
+        final TableEntry<K, V>[] table = this.getTableAcquire();
+        for (int i = 0, len = table.length; i < len; ++i) {
+            for (TableEntry<K, V> curr = ArrayUtil.getOpaque(table, i); curr != null; curr = curr.getNextOpaque()) {
+                final V currVal = curr.getValueAcquire();
+                if (currVal == value || currVal.equals(value)) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public V getOrDefault(final Object key, final V defaultValue) {
+        Validate.notNull(key, "Null key");
+
+        //noinspection unchecked
+        final TableEntry<K, V> entry = this.getEntryForOpaque((K)key);
+
+        return entry == null ? defaultValue : entry.getValueAcquire();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int size() {
+        return this.getSizeAcquire();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isEmpty() {
+        return this.getSizeAcquire() == 0;
+    }
+
+    protected Set<K> keyset;
+    protected Collection<V> values;
+    protected Set<Map.Entry<K, V>> entrySet;
+
+    @Override
+    public Set<K> keySet() {
+        return this.keyset == null ? this.keyset = new KeySet<>(this) : this.keyset;
+    }
+
+    @Override
+    public Collection<V> values() {
+        return this.values == null ? this.values = new ValueCollection<>(this) : this.values;
+    }
+
+    @Override
+    public Set<Map.Entry<K, V>> entrySet() {
+        return this.entrySet == null ? this.entrySet = new EntrySet<>(this) : this.entrySet;
+    }
+
+    /* Non-MT-Safe */
+
+    protected int threshold;
+
+    protected final void checkResize(final int minCapacity) {
+        if (minCapacity <= this.threshold || this.threshold < 0) {
+            return;
+        }
+
+        final TableEntry<K, V>[] table = this.getTablePlain();
+        int newCapacity = minCapacity >= MAXIMUM_CAPACITY ? MAXIMUM_CAPACITY : IntegerUtil.roundCeilLog2(minCapacity);
+        if (newCapacity < 0) {
+            newCapacity = MAXIMUM_CAPACITY;
+        }
+        if (newCapacity <= table.length) {
+            if (newCapacity == MAXIMUM_CAPACITY) {
+                return;
+            }
+            newCapacity = table.length << 1;
+        }
+
+        //noinspection unchecked
+        final TableEntry<K, V>[] newTable = new TableEntry[newCapacity];
+        final int indexMask = newCapacity - 1;
+
+        for (int i = 0, len = table.length; i < len; ++i) {
+            for (TableEntry<K, V> entry = table[i]; entry != null; entry = entry.getNextPlain()) {
+                final int hash = entry.hash;
+                final int index = hash & indexMask;
+
+                /* we need to create a new entry since there could be reading threads */
+                final TableEntry<K, V> insert = new TableEntry<>(hash, entry.key, entry.getValuePlain());
+
+                final TableEntry<K, V> prev = newTable[index];
+
+                newTable[index] = insert;
+                insert.setNextPlain(prev);
+            }
+        }
+
+        if (newCapacity == MAXIMUM_CAPACITY) {
+            this.threshold = -1; /* No more resizing */
+        } else {
+            this.threshold = getTargetCapacity(newCapacity, this.loadFactor);
+        }
+        this.setTableRelease(newTable); /* use release to publish entries in table */
+    }
+
+    protected final int addToSize(final int num) {
+        final int newSize = this.getSizePlain() + num;
+
+        this.setSizeOpaque(newSize);
+        this.checkResize(newSize);
+
+        return newSize;
+    }
+
+    protected final int removeFromSize(final int num) {
+        final int newSize = this.getSizePlain() - num;
+
+        this.setSizeOpaque(newSize);
+
+        return newSize;
+    }
+
+    /* Cannot be used to perform downsizing */
+    protected final int removeFromSizePlain(final int num) {
+        final int newSize = this.getSizePlain() - num;
+
+        this.setSizePlain(newSize);
+
+        return newSize;
+    }
+
+    protected final V put(final K key, final V value, final boolean onlyIfAbsent) {
+        final TableEntry<K, V>[] table = this.getTablePlain();
+        final int hash = SWMRHashTable.getHash(key);
+        final int index = hash & (table.length - 1);
+
+        final TableEntry<K, V> head = table[index];
+        if (head == null) {
+            final TableEntry<K, V> insert = new TableEntry<>(hash, key, value);
+            ArrayUtil.setRelease(table, index, insert);
+            this.addToSize(1);
+            return null;
+        }
+
+        for (TableEntry<K, V> curr = head;;) {
+            if (curr.hash == hash && (key == curr.key || curr.key.equals(key))) {
+                if (onlyIfAbsent) {
+                    return curr.getValuePlain();
+                }
+
+                final V currVal = curr.getValuePlain();
+                curr.setValueRelease(value);
+                return currVal;
+            }
+
+            final TableEntry<K, V> next = curr.getNextPlain();
+            if (next != null) {
+                curr = next;
+                continue;
+            }
+
+            final TableEntry<K, V> insert = new TableEntry<>(hash, key, value);
+
+            curr.setNextRelease(insert);
+            this.addToSize(1);
+            return null;
+        }
+    }
+
+    /**
+     * Removes a key-value pair from this map if the specified predicate returns true. The specified predicate is
+     * tested with every entry in this map. Returns the number of key-value pairs removed.
+     * @param predicate The predicate to test key-value pairs against.
+     * @return The total number of key-value pairs removed from this map.
+     */
+    public int removeIf(final BiPredicate<K, V> predicate) {
+        Validate.notNull(predicate, "Null predicate");
+
+        int removed = 0;
+
+        final TableEntry<K, V>[] table = this.getTablePlain();
+
+        bin_iteration_loop:
+        for (int i = 0, len = table.length; i < len; ++i) {
+            TableEntry<K, V> curr = table[i];
+            if (curr == null) {
+                continue;
+            }
+
+            /* Handle bin nodes first */
+            while (predicate.test(curr.key, curr.getValuePlain())) {
+                ++removed;
+                this.removeFromSizePlain(1); /* required in case predicate throws an exception */
+
+                ArrayUtil.setRelease(table, i, curr = curr.getNextPlain());
+
+                if (curr == null) {
+                    continue bin_iteration_loop;
+                }
+            }
+
+            TableEntry<K, V> prev;
+
+            /* curr at this point is the bin node */
+
+            for (prev = curr, curr = curr.getNextPlain(); curr != null;) {
+                /* If we want to remove, then we should hold prev, as it will be a valid entry to link on */
+                if (predicate.test(curr.key, curr.getValuePlain())) {
+                    ++removed;
+                    this.removeFromSizePlain(1); /* required in case predicate throws an exception */
+
+                    prev.setNextRelease(curr = curr.getNextPlain());
+                } else {
+                    prev = curr;
+                    curr = curr.getNextPlain();
+                }
+            }
+        }
+
+        return removed;
+    }
+
+    /**
+     * Removes a key-value pair from this map if the specified predicate returns true. The specified predicate is
+     * tested with every entry in this map. Returns the number of key-value pairs removed.
+     * @param predicate The predicate to test key-value pairs against.
+     * @return The total number of key-value pairs removed from this map.
+     */
+    public int removeEntryIf(final Predicate<? super Entry<K, V>> predicate) {
+        Validate.notNull(predicate, "Null predicate");
+
+        int removed = 0;
+
+        final TableEntry<K, V>[] table = this.getTablePlain();
+
+        bin_iteration_loop:
+        for (int i = 0, len = table.length; i < len; ++i) {
+            TableEntry<K, V> curr = table[i];
+            if (curr == null) {
+                continue;
+            }
+
+            /* Handle bin nodes first */
+            while (predicate.test(curr)) {
+                ++removed;
+                this.removeFromSizePlain(1); /* required in case predicate throws an exception */
+
+                ArrayUtil.setRelease(table, i, curr = curr.getNextPlain());
+
+                if (curr == null) {
+                    continue bin_iteration_loop;
+                }
+            }
+
+            TableEntry<K, V> prev;
+
+            /* curr at this point is the bin node */
+
+            for (prev = curr, curr = curr.getNextPlain(); curr != null;) {
+                /* If we want to remove, then we should hold prev, as it will be a valid entry to link on */
+                if (predicate.test(curr)) {
+                    ++removed;
+                    this.removeFromSizePlain(1); /* required in case predicate throws an exception */
+
+                    prev.setNextRelease(curr = curr.getNextPlain());
+                } else {
+                    prev = curr;
+                    curr = curr.getNextPlain();
+                }
+            }
+        }
+
+        return removed;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public V put(final K key, final V value) {
+        Validate.notNull(key, "Null key");
+        Validate.notNull(value, "Null value");
+
+        return this.put(key, value, false);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public V putIfAbsent(final K key, final V value) {
+        Validate.notNull(key, "Null key");
+        Validate.notNull(value, "Null value");
+
+        return this.put(key, value, true);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean remove(final Object key, final Object value) {
+        Validate.notNull(key, "Null key");
+        Validate.notNull(value, "Null value");
+
+        final TableEntry<K, V>[] table = this.getTablePlain();
+        final int hash = SWMRHashTable.getHash(key);
+        final int index = hash & (table.length - 1);
+
+        final TableEntry<K, V> head = table[index];
+        if (head == null) {
+            return false;
+        }
+
+        if (head.hash == hash && (head.key == key || head.key.equals(key))) {
+            final V currVal = head.getValuePlain();
+
+            if (currVal != value && !currVal.equals(value)) {
+                return false;
+            }
+
+            ArrayUtil.setRelease(table, index, head.getNextPlain());
+            this.removeFromSize(1);
+
+            return true;
+        }
+
+        for (TableEntry<K, V> curr = head.getNextPlain(), prev = head; curr != null; prev = curr, curr = curr.getNextPlain()) {
+            if (curr.hash == hash && (curr.key == key || curr.key.equals(key))) {
+                final V currVal = curr.getValuePlain();
+
+                if (currVal != value && !currVal.equals(value)) {
+                    return false;
+                }
+
+                prev.setNextRelease(curr.getNextPlain());
+                this.removeFromSize(1);
+
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    protected final V remove(final Object key, final int hash) {
+        final TableEntry<K, V>[] table = this.getTablePlain();
+        final int index = (table.length - 1) & hash;
+
+        final TableEntry<K, V> head = table[index];
+        if (head == null) {
+            return null;
+        }
+
+        if (hash == head.hash && (head.key == key || head.key.equals(key))) {
+            ArrayUtil.setRelease(table, index, head.getNextPlain());
+            this.removeFromSize(1);
+
+            return head.getValuePlain();
+        }
+
+        for (TableEntry<K, V> curr = head.getNextPlain(), prev = head; curr != null; prev = curr, curr = curr.getNextPlain()) {
+            if (curr.hash == hash && (key == curr.key || curr.key.equals(key))) {
+                prev.setNextRelease(curr.getNextPlain());
+                this.removeFromSize(1);
+
+                return curr.getValuePlain();
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public V remove(final Object key) {
+        Validate.notNull(key, "Null key");
+
+        return this.remove(key, SWMRHashTable.getHash(key));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean replace(final K key, final V oldValue, final V newValue) {
+        Validate.notNull(key, "Null key");
+        Validate.notNull(oldValue, "Null oldValue");
+        Validate.notNull(newValue, "Null newValue");
+
+        final TableEntry<K, V> entry = this.getEntryForPlain(key);
+        if (entry == null) {
+            return false;
+        }
+
+        final V currValue = entry.getValuePlain();
+        if (currValue == oldValue || currValue.equals(oldValue)) {
+            entry.setValueRelease(newValue);
+            return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public V replace(final K key, final V value) {
+        Validate.notNull(key, "Null key");
+        Validate.notNull(value, "Null value");
+
+        final TableEntry<K, V> entry = this.getEntryForPlain(key);
+        if (entry == null) {
+            return null;
+        }
+
+        final V prev = entry.getValuePlain();
+        entry.setValueRelease(value);
+        return prev;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void replaceAll(final BiFunction<? super K, ? super V, ? extends V> function) {
+        Validate.notNull(function, "Null function");
+
+        final TableEntry<K, V>[] table = this.getTablePlain();
+        for (int i = 0, len = table.length; i < len; ++i) {
+            for (TableEntry<K, V> curr = table[i]; curr != null; curr = curr.getNextPlain()) {
+                final V value = curr.getValuePlain();
+
+                final V newValue = function.apply(curr.key, value);
+                if (newValue == null) {
+                    throw new NullPointerException();
+                }
+
+                curr.setValueRelease(newValue);
+            }
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void putAll(final Map<? extends K, ? extends V> map) {
+        Validate.notNull(map, "Null map");
+
+        final int size = map.size();
+        this.checkResize(Math.max(this.getSizePlain() + size/2, size)); /* preemptively resize */
+        map.forEach(this::put);
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * This call is non-atomic and the order that which entries are removed is undefined. The clear operation itself
+     * is release ordered, that is, after the clear operation is performed a release fence is performed.
+     * </p>
+     */
+    @Override
+    public void clear() {
+        Arrays.fill(this.getTablePlain(), null);
+        this.setSizeRelease(0);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public V compute(final K key, final BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
+        Validate.notNull(key, "Null key");
+        Validate.notNull(remappingFunction, "Null remappingFunction");
+
+        final int hash = SWMRHashTable.getHash(key);
+        final TableEntry<K, V>[] table = this.getTablePlain();
+        final int index = hash & (table.length - 1);
+
+        for (TableEntry<K, V> curr = table[index], prev = null;;prev = curr, curr = curr.getNextPlain()) {
+            if (curr == null) {
+                final V newVal = remappingFunction.apply(key ,null);
+
+                if (newVal == null) {
+                    return null;
+                }
+
+                final TableEntry<K, V> insert = new TableEntry<>(hash, key, newVal);
+                if (prev == null) {
+                    ArrayUtil.setRelease(table, index, insert);
+                } else {
+                    prev.setNextRelease(insert);
+                }
+
+                this.addToSize(1);
+
+                return newVal;
+            }
+
+            if (curr.hash == hash && (curr.key == key || curr.key.equals(key))) {
+                final V newVal = remappingFunction.apply(key, curr.getValuePlain());
+
+                if (newVal != null) {
+                    curr.setValueRelease(newVal);
+                    return newVal;
+                }
+
+                if (prev == null) {
+                    ArrayUtil.setRelease(table, index, curr.getNextPlain());
+                } else {
+                    prev.setNextRelease(curr.getNextPlain());
+                }
+
+                this.removeFromSize(1);
+
+                return null;
+            }
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public V computeIfPresent(final K key, final BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
+        Validate.notNull(key, "Null key");
+        Validate.notNull(remappingFunction, "Null remappingFunction");
+
+        final int hash = SWMRHashTable.getHash(key);
+        final TableEntry<K, V>[] table = this.getTablePlain();
+        final int index = hash & (table.length - 1);
+
+        for (TableEntry<K, V> curr = table[index], prev = null; curr != null; prev = curr, curr = curr.getNextPlain()) {
+            if (curr.hash != hash || (curr.key != key && !curr.key.equals(key))) {
+                continue;
+            }
+
+            final V newVal = remappingFunction.apply(key, curr.getValuePlain());
+            if (newVal != null) {
+                curr.setValueRelease(newVal);
+                return newVal;
+            }
+
+            if (prev == null) {
+                ArrayUtil.setRelease(table, index, curr.getNextPlain());
+            } else {
+                prev.setNextRelease(curr.getNextPlain());
+            }
+
+            this.removeFromSize(1);
+
+            return null;
+        }
+
+        return null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public V computeIfAbsent(final K key, final Function<? super K, ? extends V> mappingFunction) {
+        Validate.notNull(key, "Null key");
+        Validate.notNull(mappingFunction, "Null mappingFunction");
+
+        final int hash = SWMRHashTable.getHash(key);
+        final TableEntry<K, V>[] table = this.getTablePlain();
+        final int index = hash & (table.length - 1);
+
+        for (TableEntry<K, V> curr = table[index], prev = null;;prev = curr, curr = curr.getNextPlain()) {
+            if (curr != null) {
+                if (curr.hash == hash && (curr.key == key || curr.key.equals(key))) {
+                    return curr.getValuePlain();
+                }
+                continue;
+            }
+
+            final V newVal = mappingFunction.apply(key);
+
+            if (newVal == null) {
+                return null;
+            }
+
+            final TableEntry<K, V> insert = new TableEntry<>(hash, key, newVal);
+            if (prev == null) {
+                ArrayUtil.setRelease(table, index, insert);
+            } else {
+                prev.setNextRelease(insert);
+            }
+
+            this.addToSize(1);
+
+            return newVal;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public V merge(final K key, final V value, final BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
+        Validate.notNull(key, "Null key");
+        Validate.notNull(value, "Null value");
+        Validate.notNull(remappingFunction, "Null remappingFunction");
+
+        final int hash = SWMRHashTable.getHash(key);
+        final TableEntry<K, V>[] table = this.getTablePlain();
+        final int index = hash & (table.length - 1);
+
+        for (TableEntry<K, V> curr = table[index], prev = null;;prev = curr, curr = curr.getNextPlain()) {
+            if (curr == null) {
+                final TableEntry<K, V> insert = new TableEntry<>(hash, key, value);
+                if (prev == null) {
+                    ArrayUtil.setRelease(table, index, insert);
+                } else {
+                    prev.setNextRelease(insert);
+                }
+
+                this.addToSize(1);
+
+                return value;
+            }
+
+            if (curr.hash == hash && (curr.key == key || curr.key.equals(key))) {
+                final V newVal = remappingFunction.apply(curr.getValuePlain(), value);
+
+                if (newVal != null) {
+                    curr.setValueRelease(newVal);
+                    return newVal;
+                }
+
+                if (prev == null) {
+                    ArrayUtil.setRelease(table, index, curr.getNextPlain());
+                } else {
+                    prev.setNextRelease(curr.getNextPlain());
+                }
+
+                this.removeFromSize(1);
+
+                return null;
+            }
+        }
+    }
+
+    protected static final class TableEntry<K, V> implements Map.Entry<K, V> {
+
+        protected final int hash;
+        protected final K key;
+        protected V value;
+
+        protected TableEntry<K, V> next;
+
+        protected static final VarHandle VALUE_HANDLE = ConcurrentUtil.getVarHandle(TableEntry.class, "value", Object.class);
+        protected static final VarHandle NEXT_HANDLE = ConcurrentUtil.getVarHandle(TableEntry.class, "next", TableEntry.class);
+
+        /* value */
+
+        protected final V getValuePlain() {
+            //noinspection unchecked
+            return (V)VALUE_HANDLE.get(this);
+        }
+
+        protected final V getValueAcquire() {
+            //noinspection unchecked
+            return (V)VALUE_HANDLE.getAcquire(this);
+        }
+
+        protected final void setValueRelease(final V to) {
+            VALUE_HANDLE.setRelease(this, to);
+        }
+
+        /* next */
+
+        protected final TableEntry<K, V> getNextPlain() {
+            //noinspection unchecked
+            return (TableEntry<K, V>)NEXT_HANDLE.get(this);
+        }
+
+        protected final TableEntry<K, V> getNextOpaque() {
+            //noinspection unchecked
+            return (TableEntry<K, V>)NEXT_HANDLE.getOpaque(this);
+        }
+
+        protected final void setNextPlain(final TableEntry<K, V> next) {
+            NEXT_HANDLE.set(this, next);
+        }
+
+        protected final void setNextRelease(final TableEntry<K, V> next) {
+            NEXT_HANDLE.setRelease(this, next);
+        }
+
+        protected TableEntry(final int hash, final K key, final V value) {
+            this.hash = hash;
+            this.key = key;
+            this.value = value;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public K getKey() {
+            return this.key;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public V getValue() {
+            return this.getValueAcquire();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public V setValue(final V value) {
+            if (value == null) {
+                throw new NullPointerException();
+            }
+
+            final V curr = this.getValuePlain();
+
+            this.setValueRelease(value);
+            return curr;
+        }
+
+        protected static int hash(final Object key, final Object value) {
+            return key.hashCode() ^ (value == null ? 0 : value.hashCode());
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int hashCode() {
+            return hash(this.key, this.getValueAcquire());
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public boolean equals(final Object obj) {
+            if (this == obj) {
+                return true;
+            }
+
+            if (!(obj instanceof Map.Entry)) {
+                return false;
+            }
+            final Map.Entry<?, ?> other = (Map.Entry<?, ?>)obj;
+            final Object otherKey = other.getKey();
+            final Object otherValue = other.getValue();
+
+            final K thisKey = this.getKey();
+            final V thisVal = this.getValueAcquire();
+            return (thisKey == otherKey || thisKey.equals(otherKey)) &&
+                (thisVal == otherValue || thisVal.equals(otherValue));
+        }
+    }
+
+
+    protected static abstract class TableEntryIterator<K, V, T> implements Iterator<T> {
+
+        protected final TableEntry<K, V>[] table;
+        protected final SWMRHashTable<K, V> map;
+
+        /* bin which our current element resides on */
+        protected int tableIndex;
+
+        protected TableEntry<K, V> currEntry; /* curr entry, null if no more to iterate or if curr was removed or if we've just init'd */
+        protected TableEntry<K, V> nextEntry; /* may not be on the same bin as currEntry */
+
+        protected TableEntryIterator(final TableEntry<K, V>[] table, final SWMRHashTable<K, V> map) {
+            this.table = table;
+            this.map = map;
+            int tableIndex = 0;
+            for (int len = table.length; tableIndex < len; ++tableIndex) {
+                final TableEntry<K, V> entry = ArrayUtil.getOpaque(table, tableIndex);
+                if (entry != null) {
+                    this.nextEntry = entry;
+                    this.tableIndex = tableIndex + 1;
+                    return;
+                }
+            }
+            this.tableIndex = tableIndex;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return this.nextEntry != null;
+        }
+
+        protected final TableEntry<K, V> advanceEntry() {
+            final TableEntry<K, V>[] table = this.table;
+            final int tableLength = table.length;
+            int tableIndex = this.tableIndex;
+            final TableEntry<K, V> curr = this.nextEntry;
+            if (curr == null) {
+                return null;
+            }
+
+            this.currEntry = curr;
+
+            // set up nextEntry
+
+            // find next in chain
+            TableEntry<K, V> next = curr.getNextOpaque();
+
+            if (next != null) {
+                this.nextEntry = next;
+                return curr;
+            }
+
+            // nothing in chain, so find next available bin
+            for (;tableIndex < tableLength; ++tableIndex) {
+                next = ArrayUtil.getOpaque(table, tableIndex);
+                if (next != null) {
+                    this.nextEntry = next;
+                    this.tableIndex = tableIndex + 1;
+                    return curr;
+                }
+            }
+
+            this.nextEntry = null;
+            this.tableIndex = tableIndex;
+            return curr;
+        }
+
+        @Override
+        public void remove() {
+            final TableEntry<K, V> curr = this.currEntry;
+            if (curr == null) {
+                throw new IllegalStateException();
+            }
+
+            this.map.remove(curr.key, curr.hash);
+
+            this.currEntry = null;
+        }
+    }
+
+    protected static final class ValueIterator<K, V> extends TableEntryIterator<K, V, V> {
+
+        protected ValueIterator(final TableEntry<K, V>[] table, final SWMRHashTable<K, V> map) {
+            super(table, map);
+        }
+
+        @Override
+        public V next() {
+            final TableEntry<K, V> entry = this.advanceEntry();
+
+            if (entry == null) {
+                throw new NoSuchElementException();
+            }
+
+            return entry.getValueAcquire();
+        }
+    }
+
+    protected static final class KeyIterator<K, V> extends TableEntryIterator<K, V, K> {
+
+        protected KeyIterator(final TableEntry<K, V>[] table, final SWMRHashTable<K, V> map) {
+            super(table, map);
+        }
+
+        @Override
+        public K next() {
+            final TableEntry<K, V> curr = this.advanceEntry();
+
+            if (curr == null) {
+                throw new NoSuchElementException();
+            }
+
+            return curr.key;
+        }
+    }
+
+    protected static final class EntryIterator<K, V> extends TableEntryIterator<K, V, Map.Entry<K, V>> {
+
+        protected EntryIterator(final TableEntry<K, V>[] table, final SWMRHashTable<K, V> map) {
+            super(table, map);
+        }
+
+        @Override
+        public Map.Entry<K, V> next() {
+            final TableEntry<K, V> curr = this.advanceEntry();
+
+            if (curr == null) {
+                throw new NoSuchElementException();
+            }
+
+            return curr;
+        }
+    }
+
+    protected static abstract class ViewCollection<K, V, T> implements Collection<T> {
+
+        protected final SWMRHashTable<K, V> map;
+
+        protected ViewCollection(final SWMRHashTable<K, V> map) {
+            this.map = map;
+        }
+
+        @Override
+        public boolean add(final T element) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean addAll(final Collection<? extends T> collections) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean removeAll(final Collection<?> collection) {
+            Validate.notNull(collection, "Null collection");
+
+            boolean modified = false;
+            for (final Object element : collection) {
+                modified |= this.remove(element);
+            }
+            return modified;
+        }
+
+        @Override
+        public int size() {
+            return this.map.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return this.size() == 0;
+        }
+
+        @Override
+        public void clear() {
+            this.map.clear();
+        }
+
+        @Override
+        public boolean containsAll(final Collection<?> collection) {
+            Validate.notNull(collection, "Null collection");
+
+            for (final Object element : collection) {
+                if (!this.contains(element)) {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
+        @Override
+        public Object[] toArray() {
+            final List<T> list = new ArrayList<>(this.size());
+
+            this.forEach(list::add);
+
+            return list.toArray();
+        }
+
+        @Override
+        public <E> E[] toArray(final E[] array) {
+            final List<T> list = new ArrayList<>(this.size());
+
+            this.forEach(list::add);
+
+            return list.toArray(array);
+        }
+
+        @Override
+        public <E> E[] toArray(final IntFunction<E[]> generator) {
+            final List<T> list = new ArrayList<>(this.size());
+
+            this.forEach(list::add);
+
+            return list.toArray(generator);
+        }
+
+        @Override
+        public int hashCode() {
+            int hash = 0;
+            for (final T element : this) {
+                hash += element == null ? 0 : element.hashCode();
+            }
+            return hash;
+        }
+
+        @Override
+        public Spliterator<T> spliterator() { // TODO implement
+            return Spliterators.spliterator(this, Spliterator.NONNULL);
+        }
+    }
+
+    protected static abstract class ViewSet<K, V, T> extends ViewCollection<K, V, T> implements Set<T> {
+
+        protected ViewSet(final SWMRHashTable<K, V> map) {
+            super(map);
+        }
+
+        @Override
+        public boolean equals(final Object obj) {
+            if (this == obj) {
+                return true;
+            }
+
+            if (!(obj instanceof Set)) {
+                return false;
+            }
+
+            final Set<?> other = (Set<?>)obj;
+            if (other.size() != this.size()) {
+                return false;
+            }
+
+            return this.containsAll(other);
+        }
+    }
+
+    protected static final class EntrySet<K, V> extends ViewSet<K, V, Map.Entry<K, V>> implements Set<Map.Entry<K, V>> {
+
+        protected EntrySet(final SWMRHashTable<K, V> map) {
+            super(map);
+        }
+
+        @Override
+        public boolean remove(final Object object) {
+            if (!(object instanceof Map.Entry<?, ?>)) {
+                return false;
+            }
+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>)object;
+
+            final Object key;
+            final Object value;
+
+            try {
+                key = entry.getKey();
+                value = entry.getValue();
+            } catch (final IllegalStateException ex) {
+                return false;
+            }
+
+            return this.map.remove(key, value);
+        }
+
+        @Override
+        public boolean removeIf(final Predicate<? super Map.Entry<K, V>> filter) {
+            Validate.notNull(filter, "Null filter");
+
+            return this.map.removeEntryIf(filter) != 0;
+        }
+
+        @Override
+        public boolean retainAll(final Collection<?> collection) {
+            Validate.notNull(collection, "Null collection");
+
+            return this.map.removeEntryIf((final Map.Entry<K, V> entry) -> {
+                return !collection.contains(entry);
+            }) != 0;
+        }
+
+        @Override
+        public Iterator<Entry<K, V>> iterator() {
+            return new EntryIterator<>(this.map.getTableAcquire(), this.map);
+        }
+
+        @Override
+        public void forEach(final Consumer<? super Entry<K, V>> action) {
+            this.map.forEach(action);
+        }
+
+        @Override
+        public boolean contains(final Object object) {
+            if (!(object instanceof Map.Entry)) {
+                return false;
+            }
+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>)object;
+
+            final Object key;
+            final Object value;
+
+            try {
+                key = entry.getKey();
+                value = entry.getValue();
+            } catch (final IllegalStateException ex) {
+                return false;
+            }
+
+            return this.map.contains(key, value);
+        }
+
+        @Override
+        public String toString() {
+            return CollectionUtil.toString(this, "SWMRHashTableEntrySet");
+        }
+    }
+
+    protected static final class KeySet<K, V> extends ViewSet<K, V, K> {
+
+        protected KeySet(final SWMRHashTable<K, V> map) {
+            super(map);
+        }
+
+        @Override
+        public Iterator<K> iterator() {
+            return new KeyIterator<>(this.map.getTableAcquire(), this.map);
+        }
+
+        @Override
+        public void forEach(final Consumer<? super K> action) {
+            Validate.notNull(action, "Null action");
+
+            this.map.forEachKey(action);
+        }
+
+        @Override
+        public boolean contains(final Object key) {
+            Validate.notNull(key, "Null key");
+
+            return this.map.containsKey(key);
+        }
+
+        @Override
+        public boolean remove(final Object key) {
+            Validate.notNull(key, "Null key");
+
+            return this.map.remove(key) != null;
+        }
+
+        @Override
+        public boolean retainAll(final Collection<?> collection) {
+            Validate.notNull(collection, "Null collection");
+
+            return this.map.removeIf((final K key, final V value) -> {
+                return !collection.contains(key);
+            }) != 0;
+        }
+
+        @Override
+        public boolean removeIf(final Predicate<? super K> filter) {
+            Validate.notNull(filter, "Null filter");
+
+            return this.map.removeIf((final K key, final V value) -> {
+                return filter.test(key);
+            }) != 0;
+        }
+
+        @Override
+        public String toString() {
+            return CollectionUtil.toString(this, "SWMRHashTableKeySet");
+        }
+    }
+
+    protected static final class ValueCollection<K, V> extends ViewSet<K, V, V> implements Collection<V> {
+
+        protected ValueCollection(final SWMRHashTable<K, V> map) {
+            super(map);
+        }
+
+        @Override
+        public Iterator<V> iterator() {
+            return new ValueIterator<>(this.map.getTableAcquire(), this.map);
+        }
+
+        @Override
+        public void forEach(final Consumer<? super V> action) {
+            Validate.notNull(action, "Null action");
+
+            this.map.forEachValue(action);
+        }
+
+        @Override
+        public boolean contains(final Object object) {
+            Validate.notNull(object, "Null object");
+
+            return this.map.containsValue(object);
+        }
+
+        @Override
+        public boolean remove(final Object object) {
+            Validate.notNull(object, "Null object");
+
+            final Iterator<V> itr = this.iterator();
+            while (itr.hasNext()) {
+                final V val = itr.next();
+                if (val == object || val.equals(object)) {
+                    itr.remove();
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        @Override
+        public boolean removeIf(final Predicate<? super V> filter) {
+            Validate.notNull(filter, "Null filter");
+
+            return this.map.removeIf((final K key, final V value) -> {
+                return filter.test(value);
+            }) != 0;
+        }
+
+        @Override
+        public boolean retainAll(final Collection<?> collection) {
+            Validate.notNull(collection, "Null collection");
+
+            return this.map.removeIf((final K key, final V value) -> {
+                return !collection.contains(value);
+            }) != 0;
+        }
+
+        @Override
+        public String toString() {
+            return CollectionUtil.toString(this, "SWMRHashTableValues");
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concurrentutil/map/SWMRLong2ObjectHashTable.java b/src/main/java/ca/spottedleaf/concurrentutil/map/SWMRLong2ObjectHashTable.java
new file mode 100644
index 0000000000000000000000000000000000000000..1e98f778ffa0a7bb00ebccaaa8bde075183e41f0
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concurrentutil/map/SWMRLong2ObjectHashTable.java
@@ -0,0 +1,672 @@
+package ca.spottedleaf.concurrentutil.map;
+
+import ca.spottedleaf.concurrentutil.util.ArrayUtil;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import ca.spottedleaf.concurrentutil.util.Validate;
+import io.papermc.paper.util.IntegerUtil;
+import java.lang.invoke.VarHandle;
+import java.util.Arrays;
+import java.util.function.Consumer;
+import java.util.function.LongConsumer;
+
+// trimmed down version of SWMRHashTable
+public class SWMRLong2ObjectHashTable<V> {
+
+    protected int size;
+
+    protected TableEntry<V>[] table;
+
+    protected final float loadFactor;
+
+    protected static final VarHandle SIZE_HANDLE = ConcurrentUtil.getVarHandle(SWMRLong2ObjectHashTable.class, "size", int.class);
+    protected static final VarHandle TABLE_HANDLE = ConcurrentUtil.getVarHandle(SWMRLong2ObjectHashTable.class, "table", TableEntry[].class);
+
+    /* size */
+
+    protected final int getSizePlain() {
+        return (int)SIZE_HANDLE.get(this);
+    }
+
+    protected final int getSizeOpaque() {
+        return (int)SIZE_HANDLE.getOpaque(this);
+    }
+
+    protected final int getSizeAcquire() {
+        return (int)SIZE_HANDLE.getAcquire(this);
+    }
+
+    protected final void setSizePlain(final int value) {
+        SIZE_HANDLE.set(this, value);
+    }
+
+    protected final void setSizeOpaque(final int value) {
+        SIZE_HANDLE.setOpaque(this, value);
+    }
+
+    protected final void setSizeRelease(final int value) {
+        SIZE_HANDLE.setRelease(this, value);
+    }
+
+    /* table */
+
+    protected final TableEntry<V>[] getTablePlain() {
+        //noinspection unchecked
+        return (TableEntry<V>[])TABLE_HANDLE.get(this);
+    }
+
+    protected final TableEntry<V>[] getTableAcquire() {
+        //noinspection unchecked
+        return (TableEntry<V>[])TABLE_HANDLE.getAcquire(this);
+    }
+
+    protected final void setTablePlain(final TableEntry<V>[] table) {
+        TABLE_HANDLE.set(this, table);
+    }
+
+    protected final void setTableRelease(final TableEntry<V>[] table) {
+        TABLE_HANDLE.setRelease(this, table);
+    }
+
+    protected static final int DEFAULT_CAPACITY = 16;
+    protected static final float DEFAULT_LOAD_FACTOR = 0.75f;
+    protected static final int MAXIMUM_CAPACITY = Integer.MIN_VALUE >>> 1;
+
+    /**
+     * Constructs this map with a capacity of {@code 16} and load factor of {@code 0.75f}.
+     */
+    public SWMRLong2ObjectHashTable() {
+        this(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);
+    }
+
+    /**
+     * Constructs this map with the specified capacity and load factor of {@code 0.75f}.
+     * @param capacity specified initial capacity, > 0
+     */
+    public SWMRLong2ObjectHashTable(final int capacity) {
+        this(capacity, DEFAULT_LOAD_FACTOR);
+    }
+
+    /**
+     * Constructs this map with the specified capacity and load factor.
+     * @param capacity specified capacity, > 0
+     * @param loadFactor specified load factor, > 0 && finite
+     */
+    public SWMRLong2ObjectHashTable(final int capacity, final float loadFactor) {
+        final int tableSize = getCapacityFor(capacity);
+
+        if (loadFactor <= 0.0 || !Float.isFinite(loadFactor)) {
+            throw new IllegalArgumentException("Invalid load factor: " + loadFactor);
+        }
+
+        //noinspection unchecked
+        final TableEntry<V>[] table = new TableEntry[tableSize];
+        this.setTablePlain(table);
+
+        if (tableSize == MAXIMUM_CAPACITY) {
+            this.threshold = -1;
+        } else {
+            this.threshold = getTargetCapacity(tableSize, loadFactor);
+        }
+
+        this.loadFactor = loadFactor;
+    }
+
+    /**
+     * Constructs this map with a capacity of {@code 16} or the specified map's size, whichever is larger, and
+     * with a load factor of {@code 0.75f}.
+     * All of the specified map's entries are copied into this map.
+     * @param other The specified map.
+     */
+    public SWMRLong2ObjectHashTable(final SWMRLong2ObjectHashTable<V> other) {
+        this(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, other);
+    }
+
+    /**
+     * Constructs this map with a minimum capacity of the specified capacity or the specified map's size, whichever is larger, and
+     * with a load factor of {@code 0.75f}.
+     * All of the specified map's entries are copied into this map.
+     * @param capacity specified capacity, > 0
+     * @param other The specified map.
+     */
+    public SWMRLong2ObjectHashTable(final int capacity, final SWMRLong2ObjectHashTable<V> other) {
+        this(capacity, DEFAULT_LOAD_FACTOR, other);
+    }
+
+    /**
+     * Constructs this map with a min capacity of the specified capacity or the specified map's size, whichever is larger, and
+     * with the specified load factor.
+     * All of the specified map's entries are copied into this map.
+     * @param capacity specified capacity, > 0
+     * @param loadFactor specified load factor, > 0 && finite
+     * @param other The specified map.
+     */
+    public SWMRLong2ObjectHashTable(final int capacity, final float loadFactor, final SWMRLong2ObjectHashTable<V> other) {
+        this(Math.max(Validate.notNull(other, "Null map").size(), capacity), loadFactor);
+        this.putAll(other);
+    }
+
+    public final float getLoadFactor() {
+        return this.loadFactor;
+    }
+
+    protected static int getCapacityFor(final int capacity) {
+        if (capacity <= 0) {
+            throw new IllegalArgumentException("Invalid capacity: " + capacity);
+        }
+        if (capacity >= MAXIMUM_CAPACITY) {
+            return MAXIMUM_CAPACITY;
+        }
+        return IntegerUtil.roundCeilLog2(capacity);
+    }
+
+    /** Callers must still use acquire when reading the value of the entry. */
+    protected final TableEntry<V> getEntryForOpaque(final long key) {
+        final int hash = SWMRLong2ObjectHashTable.getHash(key);
+        final TableEntry<V>[] table = this.getTableAcquire();
+
+        for (TableEntry<V> curr = ArrayUtil.getOpaque(table, hash & (table.length - 1)); curr != null; curr = curr.getNextOpaque()) {
+            if (key == curr.key) {
+                return curr;
+            }
+        }
+
+        return null;
+    }
+
+    protected final TableEntry<V> getEntryForPlain(final long key) {
+        final int hash = SWMRLong2ObjectHashTable.getHash(key);
+        final TableEntry<V>[] table = this.getTablePlain();
+
+        for (TableEntry<V> curr = table[hash & (table.length - 1)]; curr != null; curr = curr.getNextPlain()) {
+            if (key == curr.key) {
+                return curr;
+            }
+        }
+
+        return null;
+    }
+
+    /* MT-Safe */
+
+    /** must be deterministic given a key */
+    protected static int getHash(final long key) {
+        return (int)it.unimi.dsi.fastutil.HashCommon.mix(key);
+    }
+
+    // rets -1 if capacity*loadFactor is too large
+    protected static int getTargetCapacity(final int capacity, final float loadFactor) {
+        final double ret = (double)capacity * (double)loadFactor;
+        if (Double.isInfinite(ret) || ret >= ((double)Integer.MAX_VALUE)) {
+            return -1;
+        }
+
+        return (int)ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean equals(final Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        /* Make no attempt to deal with concurrent modifications */
+        if (!(obj instanceof SWMRLong2ObjectHashTable)) {
+            return false;
+        }
+        final SWMRLong2ObjectHashTable<?> other = (SWMRLong2ObjectHashTable<?>)obj;
+
+        if (this.size() != other.size()) {
+            return false;
+        }
+
+        final TableEntry<V>[] table = this.getTableAcquire();
+
+        for (int i = 0, len = table.length; i < len; ++i) {
+            for (TableEntry<V> curr = ArrayUtil.getOpaque(table, i); curr != null; curr = curr.getNextOpaque()) {
+                final V value = curr.getValueAcquire();
+
+                final Object otherValue = other.get(curr.key);
+                if (otherValue == null || (value != otherValue && value.equals(otherValue))) {
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int hashCode() {
+        /* Make no attempt to deal with concurrent modifications */
+        int hash = 0;
+        final TableEntry<V>[] table = this.getTableAcquire();
+
+        for (int i = 0, len = table.length; i < len; ++i) {
+            for (TableEntry<V> curr = ArrayUtil.getOpaque(table, i); curr != null; curr = curr.getNextOpaque()) {
+                hash += curr.hashCode();
+            }
+        }
+
+        return hash;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String toString() {
+        final StringBuilder builder = new StringBuilder(64);
+        builder.append("SingleWriterMultiReaderHashMap:{");
+
+        this.forEach((final long key, final V value) -> {
+            builder.append("{key: \"").append(key).append("\", value: \"").append(value).append("\"}");
+        });
+
+        return builder.append('}').toString();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public SWMRLong2ObjectHashTable<V> clone() {
+        return new SWMRLong2ObjectHashTable<>(this.getTableAcquire().length, this.loadFactor, this);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void forEach(final Consumer<? super SWMRLong2ObjectHashTable.TableEntry<V>> action) {
+        Validate.notNull(action, "Null action");
+
+        final TableEntry<V>[] table = this.getTableAcquire();
+        for (int i = 0, len = table.length; i < len; ++i) {
+            for (TableEntry<V> curr = ArrayUtil.getOpaque(table, i); curr != null; curr = curr.getNextOpaque()) {
+                action.accept(curr);
+            }
+        }
+    }
+
+    @FunctionalInterface
+    public static interface BiLongObjectConsumer<V> {
+        public void accept(final long key, final V value);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void forEach(final BiLongObjectConsumer<? super V> action) {
+        Validate.notNull(action, "Null action");
+
+        final TableEntry<V>[] table = this.getTableAcquire();
+        for (int i = 0, len = table.length; i < len; ++i) {
+            for (TableEntry<V> curr = ArrayUtil.getOpaque(table, i); curr != null; curr = curr.getNextOpaque()) {
+                final V value = curr.getValueAcquire();
+
+                action.accept(curr.key, value);
+            }
+        }
+    }
+
+    /**
+     * Provides the specified consumer with all keys contained within this map.
+     * @param action The specified consumer.
+     */
+    public void forEachKey(final LongConsumer action) {
+        Validate.notNull(action, "Null action");
+
+        final TableEntry<V>[] table = this.getTableAcquire();
+        for (int i = 0, len = table.length; i < len; ++i) {
+            for (TableEntry<V> curr = ArrayUtil.getOpaque(table, i); curr != null; curr = curr.getNextOpaque()) {
+                action.accept(curr.key);
+            }
+        }
+    }
+
+    /**
+     * Provides the specified consumer with all values contained within this map. Equivalent to {@code map.values().forEach(Consumer)}.
+     * @param action The specified consumer.
+     */
+    public void forEachValue(final Consumer<? super V> action) {
+        Validate.notNull(action, "Null action");
+
+        final TableEntry<V>[] table = this.getTableAcquire();
+        for (int i = 0, len = table.length; i < len; ++i) {
+            for (TableEntry<V> curr = ArrayUtil.getOpaque(table, i); curr != null; curr = curr.getNextOpaque()) {
+                final V value = curr.getValueAcquire();
+
+                action.accept(value);
+            }
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public V get(final long key) {
+        final TableEntry<V> entry = this.getEntryForOpaque(key);
+        return entry == null ? null : entry.getValueAcquire();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean containsKey(final long key) {
+        // note: we need to use getValueAcquire, so that the reads from this map are ordered by acquire semantics
+        return this.get(key) != null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public V getOrDefault(final long key, final V defaultValue) {
+        final TableEntry<V> entry = this.getEntryForOpaque(key);
+
+        return entry == null ? defaultValue : entry.getValueAcquire();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public int size() {
+        return this.getSizeAcquire();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean isEmpty() {
+        return this.getSizeAcquire() == 0;
+    }
+
+    /* Non-MT-Safe */
+
+    protected int threshold;
+
+    protected final void checkResize(final int minCapacity) {
+        if (minCapacity <= this.threshold || this.threshold < 0) {
+            return;
+        }
+
+        final TableEntry<V>[] table = this.getTablePlain();
+        int newCapacity = minCapacity >= MAXIMUM_CAPACITY ? MAXIMUM_CAPACITY : IntegerUtil.roundCeilLog2(minCapacity);
+        if (newCapacity < 0) {
+            newCapacity = MAXIMUM_CAPACITY;
+        }
+        if (newCapacity <= table.length) {
+            if (newCapacity == MAXIMUM_CAPACITY) {
+                return;
+            }
+            newCapacity = table.length << 1;
+        }
+
+        //noinspection unchecked
+        final TableEntry<V>[] newTable = new TableEntry[newCapacity];
+        final int indexMask = newCapacity - 1;
+
+        for (int i = 0, len = table.length; i < len; ++i) {
+            for (TableEntry<V> entry = table[i]; entry != null; entry = entry.getNextPlain()) {
+                final long key = entry.key;
+                final int hash = SWMRLong2ObjectHashTable.getHash(key);
+                final int index = hash & indexMask;
+
+                /* we need to create a new entry since there could be reading threads */
+                final TableEntry<V> insert = new TableEntry<>(key, entry.getValuePlain());
+
+                final TableEntry<V> prev = newTable[index];
+
+                newTable[index] = insert;
+                insert.setNextPlain(prev);
+            }
+        }
+
+        if (newCapacity == MAXIMUM_CAPACITY) {
+            this.threshold = -1; /* No more resizing */
+        } else {
+            this.threshold = getTargetCapacity(newCapacity, this.loadFactor);
+        }
+        this.setTableRelease(newTable); /* use release to publish entries in table */
+    }
+
+    protected final int addToSize(final int num) {
+        final int newSize = this.getSizePlain() + num;
+
+        this.setSizeOpaque(newSize);
+        this.checkResize(newSize);
+
+        return newSize;
+    }
+
+    protected final int removeFromSize(final int num) {
+        final int newSize = this.getSizePlain() - num;
+
+        this.setSizeOpaque(newSize);
+
+        return newSize;
+    }
+
+    protected final V put(final long key, final V value, final boolean onlyIfAbsent) {
+        final TableEntry<V>[] table = this.getTablePlain();
+        final int hash = SWMRLong2ObjectHashTable.getHash(key);
+        final int index = hash & (table.length - 1);
+
+        final TableEntry<V> head = table[index];
+        if (head == null) {
+            final TableEntry<V> insert = new TableEntry<>(key, value);
+            ArrayUtil.setRelease(table, index, insert);
+            this.addToSize(1);
+            return null;
+        }
+
+        for (TableEntry<V> curr = head;;) {
+            if (key == curr.key) {
+                if (onlyIfAbsent) {
+                    return curr.getValuePlain();
+                }
+
+                final V currVal = curr.getValuePlain();
+                curr.setValueRelease(value);
+                return currVal;
+            }
+
+            final TableEntry<V> next = curr.getNextPlain();
+            if (next != null) {
+                curr = next;
+                continue;
+            }
+
+            final TableEntry<V> insert = new TableEntry<>(key, value);
+
+            curr.setNextRelease(insert);
+            this.addToSize(1);
+            return null;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public V put(final long key, final V value) {
+        Validate.notNull(value, "Null value");
+
+        return this.put(key, value, false);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public V putIfAbsent(final long key, final V value) {
+        Validate.notNull(value, "Null value");
+
+        return this.put(key, value, true);
+    }
+
+    protected final V remove(final long key, final int hash) {
+        final TableEntry<V>[] table = this.getTablePlain();
+        final int index = (table.length - 1) & hash;
+
+        final TableEntry<V> head = table[index];
+        if (head == null) {
+            return null;
+        }
+
+        if (head.key == key) {
+            ArrayUtil.setRelease(table, index, head.getNextPlain());
+            this.removeFromSize(1);
+
+            return head.getValuePlain();
+        }
+
+        for (TableEntry<V> curr = head.getNextPlain(), prev = head; curr != null; prev = curr, curr = curr.getNextPlain()) {
+            if (key == curr.key) {
+                prev.setNextRelease(curr.getNextPlain());
+                this.removeFromSize(1);
+
+                return curr.getValuePlain();
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public V remove(final long key) {
+        return this.remove(key, SWMRLong2ObjectHashTable.getHash(key));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void putAll(final SWMRLong2ObjectHashTable<? extends V> map) {
+        Validate.notNull(map, "Null map");
+
+        final int size = map.size();
+        this.checkResize(Math.max(this.getSizePlain() + size/2, size)); /* preemptively resize */
+        map.forEach(this::put);
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * This call is non-atomic and the order that which entries are removed is undefined. The clear operation itself
+     * is release ordered, that is, after the clear operation is performed a release fence is performed.
+     * </p>
+     */
+    public void clear() {
+        Arrays.fill(this.getTablePlain(), null);
+        this.setSizeRelease(0);
+    }
+
+    public static final class TableEntry<V> {
+
+        protected final long key;
+        protected V value;
+
+        protected TableEntry<V> next;
+
+        protected static final VarHandle VALUE_HANDLE = ConcurrentUtil.getVarHandle(TableEntry.class, "value", Object.class);
+        protected static final VarHandle NEXT_HANDLE = ConcurrentUtil.getVarHandle(TableEntry.class, "next", TableEntry.class);
+
+        /* value */
+
+        protected final V getValuePlain() {
+            //noinspection unchecked
+            return (V)VALUE_HANDLE.get(this);
+        }
+
+        protected final V getValueAcquire() {
+            //noinspection unchecked
+            return (V)VALUE_HANDLE.getAcquire(this);
+        }
+
+        protected final void setValueRelease(final V to) {
+            VALUE_HANDLE.setRelease(this, to);
+        }
+
+        /* next */
+
+        protected final TableEntry<V> getNextPlain() {
+            //noinspection unchecked
+            return (TableEntry<V>)NEXT_HANDLE.get(this);
+        }
+
+        protected final TableEntry<V> getNextOpaque() {
+            //noinspection unchecked
+            return (TableEntry<V>)NEXT_HANDLE.getOpaque(this);
+        }
+
+        protected final void setNextPlain(final TableEntry<V> next) {
+            NEXT_HANDLE.set(this, next);
+        }
+
+        protected final void setNextRelease(final TableEntry<V> next) {
+            NEXT_HANDLE.setRelease(this, next);
+        }
+
+        protected TableEntry(final long key, final V value) {
+            this.key = key;
+            this.value = value;
+        }
+
+        public long getKey() {
+            return this.key;
+        }
+
+        public V getValue() {
+            return this.getValueAcquire();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public V setValue(final V value) {
+            if (value == null) {
+                throw new NullPointerException();
+            }
+
+            final V curr = this.getValuePlain();
+
+            this.setValueRelease(value);
+            return curr;
+        }
+
+        protected static int hash(final long key, final Object value) {
+            return SWMRLong2ObjectHashTable.getHash(key) ^ (value == null ? 0 : value.hashCode());
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int hashCode() {
+            return hash(this.key, this.getValueAcquire());
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public boolean equals(final Object obj) {
+            if (this == obj) {
+                return true;
+            }
+
+            if (!(obj instanceof TableEntry<?>)) {
+                return false;
+            }
+            final TableEntry<?> other = (TableEntry<?>)obj;
+            final long otherKey = other.getKey();
+            final long thisKey = this.getKey();
+            final Object otherValue = other.getValueAcquire();
+            final V thisVal = this.getValueAcquire();
+            return (thisKey == otherKey) && (thisVal == otherValue || thisVal.equals(otherValue));
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concurrentutil/util/ArrayUtil.java b/src/main/java/ca/spottedleaf/concurrentutil/util/ArrayUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..ebb1ab06165addb173fea4d295001fe37f4e79d3
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concurrentutil/util/ArrayUtil.java
@@ -0,0 +1,816 @@
+package ca.spottedleaf.concurrentutil.util;
+
+import java.lang.invoke.VarHandle;
+
+public final class ArrayUtil {
+
+    public static final VarHandle BOOLEAN_ARRAY_HANDLE = ConcurrentUtil.getArrayHandle(boolean[].class);
+
+    public static final VarHandle BYTE_ARRAY_HANDLE = ConcurrentUtil.getArrayHandle(byte[].class);
+
+    public static final VarHandle SHORT_ARRAY_HANDLE = ConcurrentUtil.getArrayHandle(short[].class);
+
+    public static final VarHandle INT_ARRAY_HANDLE = ConcurrentUtil.getArrayHandle(int[].class);
+
+    public static final VarHandle LONG_ARRAY_HANDLE = ConcurrentUtil.getArrayHandle(long[].class);
+
+    public static final VarHandle OBJECT_ARRAY_HANDLE = ConcurrentUtil.getArrayHandle(Object[].class);
+
+    private ArrayUtil() {
+        throw new RuntimeException();
+    }
+
+    /* byte array */
+
+    public static byte getPlain(final byte[] array, final int index) {
+        return (byte)BYTE_ARRAY_HANDLE.get(array, index);
+    }
+
+    public static byte getOpaque(final byte[] array, final int index) {
+        return (byte)BYTE_ARRAY_HANDLE.getOpaque(array, index);
+    }
+
+    public static byte getAcquire(final byte[] array, final int index) {
+        return (byte)BYTE_ARRAY_HANDLE.getAcquire(array, index);
+    }
+
+    public static byte getVolatile(final byte[] array, final int index) {
+        return (byte)BYTE_ARRAY_HANDLE.getVolatile(array, index);
+    }
+
+    public static void setPlain(final byte[] array, final int index, final byte value) {
+        BYTE_ARRAY_HANDLE.set(array, index, value);
+    }
+
+    public static void setOpaque(final byte[] array, final int index, final byte value) {
+        BYTE_ARRAY_HANDLE.setOpaque(array, index, value);
+    }
+
+    public static void setRelease(final byte[] array, final int index, final byte value) {
+        BYTE_ARRAY_HANDLE.setRelease(array, index, value);
+    }
+
+    public static void setVolatile(final byte[] array, final int index, final byte value) {
+        BYTE_ARRAY_HANDLE.setVolatile(array, index, value);
+    }
+
+    public static void setVolatileContended(final byte[] array, final int index, final byte param) {
+        int failures = 0;
+
+        for (byte curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, param))) {
+                return;
+            }
+        }
+    }
+
+    public static byte compareAndExchangeVolatile(final byte[] array, final int index, final byte expect, final byte update) {
+        return (byte)BYTE_ARRAY_HANDLE.compareAndExchange(array, index, expect, update);
+    }
+
+    public static byte getAndAddVolatile(final byte[] array, final int index, final byte param) {
+        return (byte)BYTE_ARRAY_HANDLE.getAndAdd(array, index, param);
+    }
+
+    public static byte getAndAndVolatile(final byte[] array, final int index, final byte param) {
+        return (byte)BYTE_ARRAY_HANDLE.getAndBitwiseAnd(array, index, param);
+    }
+
+    public static byte getAndOrVolatile(final byte[] array, final int index, final byte param) {
+        return (byte)BYTE_ARRAY_HANDLE.getAndBitwiseOr(array, index, param);
+    }
+
+    public static byte getAndXorVolatile(final byte[] array, final int index, final byte param) {
+        return (byte)BYTE_ARRAY_HANDLE.getAndBitwiseXor(array, index, param);
+    }
+
+    public static byte getAndSetVolatile(final byte[] array, final int index, final byte param) {
+        return (byte)BYTE_ARRAY_HANDLE.getAndSet(array, index, param);
+    }
+
+    public static byte compareAndExchangeVolatileContended(final byte[] array, final int index, final byte expect, final byte update) {
+        return (byte)BYTE_ARRAY_HANDLE.compareAndExchange(array, index, expect, update);
+    }
+
+    public static byte getAndAddVolatileContended(final byte[] array, final int index, final byte param) {
+        int failures = 0;
+
+        for (byte curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, (byte) (curr + param)))) {
+                return curr;
+            }
+        }
+    }
+
+    public static byte getAndAndVolatileContended(final byte[] array, final int index, final byte param) {
+        int failures = 0;
+
+        for (byte curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, (byte) (curr & param)))) {
+                return curr;
+            }
+        }
+    }
+
+    public static byte getAndOrVolatileContended(final byte[] array, final int index, final byte param) {
+        int failures = 0;
+
+        for (byte curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, (byte) (curr | param)))) {
+                return curr;
+            }
+        }
+    }
+
+    public static byte getAndXorVolatileContended(final byte[] array, final int index, final byte param) {
+        int failures = 0;
+
+        for (byte curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, (byte) (curr ^ param)))) {
+                return curr;
+            }
+        }
+    }
+
+    public static byte getAndSetVolatileContended(final byte[] array, final int index, final byte param) {
+        int failures = 0;
+
+        for (byte curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, param))) {
+                return curr;
+            }
+        }
+    }
+
+    /* short array */
+
+    public static short getPlain(final short[] array, final int index) {
+        return (short)SHORT_ARRAY_HANDLE.get(array, index);
+    }
+
+    public static short getOpaque(final short[] array, final int index) {
+        return (short)SHORT_ARRAY_HANDLE.getOpaque(array, index);
+    }
+
+    public static short getAcquire(final short[] array, final int index) {
+        return (short)SHORT_ARRAY_HANDLE.getAcquire(array, index);
+    }
+
+    public static short getVolatile(final short[] array, final int index) {
+        return (short)SHORT_ARRAY_HANDLE.getVolatile(array, index);
+    }
+
+    public static void setPlain(final short[] array, final int index, final short value) {
+        SHORT_ARRAY_HANDLE.set(array, index, value);
+    }
+
+    public static void setOpaque(final short[] array, final int index, final short value) {
+        SHORT_ARRAY_HANDLE.setOpaque(array, index, value);
+    }
+
+    public static void setRelease(final short[] array, final int index, final short value) {
+        SHORT_ARRAY_HANDLE.setRelease(array, index, value);
+    }
+
+    public static void setVolatile(final short[] array, final int index, final short value) {
+        SHORT_ARRAY_HANDLE.setVolatile(array, index, value);
+    }
+
+    public static void setVolatileContended(final short[] array, final int index, final short param) {
+        int failures = 0;
+
+        for (short curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, param))) {
+                return;
+            }
+        }
+    }
+
+    public static short compareAndExchangeVolatile(final short[] array, final int index, final short expect, final short update) {
+        return (short)SHORT_ARRAY_HANDLE.compareAndExchange(array, index, expect, update);
+    }
+
+    public static short getAndAddVolatile(final short[] array, final int index, final short param) {
+        return (short)SHORT_ARRAY_HANDLE.getAndAdd(array, index, param);
+    }
+
+    public static short getAndAndVolatile(final short[] array, final int index, final short param) {
+        return (short)SHORT_ARRAY_HANDLE.getAndBitwiseAnd(array, index, param);
+    }
+
+    public static short getAndOrVolatile(final short[] array, final int index, final short param) {
+        return (short)SHORT_ARRAY_HANDLE.getAndBitwiseOr(array, index, param);
+    }
+
+    public static short getAndXorVolatile(final short[] array, final int index, final short param) {
+        return (short)SHORT_ARRAY_HANDLE.getAndBitwiseXor(array, index, param);
+    }
+
+    public static short getAndSetVolatile(final short[] array, final int index, final short param) {
+        return (short)SHORT_ARRAY_HANDLE.getAndSet(array, index, param);
+    }
+
+    public static short compareAndExchangeVolatileContended(final short[] array, final int index, final short expect, final short update) {
+        return (short)SHORT_ARRAY_HANDLE.compareAndExchange(array, index, expect, update);
+    }
+
+    public static short getAndAddVolatileContended(final short[] array, final int index, final short param) {
+        int failures = 0;
+
+        for (short curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, (short) (curr + param)))) {
+                return curr;
+            }
+        }
+    }
+
+    public static short getAndAndVolatileContended(final short[] array, final int index, final short param) {
+        int failures = 0;
+
+        for (short curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, (short) (curr & param)))) {
+                return curr;
+            }
+        }
+    }
+
+    public static short getAndOrVolatileContended(final short[] array, final int index, final short param) {
+        int failures = 0;
+
+        for (short curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, (short) (curr | param)))) {
+                return curr;
+            }
+        }
+    }
+
+    public static short getAndXorVolatileContended(final short[] array, final int index, final short param) {
+        int failures = 0;
+
+        for (short curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, (short) (curr ^ param)))) {
+                return curr;
+            }
+        }
+    }
+
+    public static short getAndSetVolatileContended(final short[] array, final int index, final short param) {
+        int failures = 0;
+
+        for (short curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, param))) {
+                return curr;
+            }
+        }
+    }
+
+    /* int array */
+
+    public static int getPlain(final int[] array, final int index) {
+        return (int)INT_ARRAY_HANDLE.get(array, index);
+    }
+
+    public static int getOpaque(final int[] array, final int index) {
+        return (int)INT_ARRAY_HANDLE.getOpaque(array, index);
+    }
+
+    public static int getAcquire(final int[] array, final int index) {
+        return (int)INT_ARRAY_HANDLE.getAcquire(array, index);
+    }
+
+    public static int getVolatile(final int[] array, final int index) {
+        return (int)INT_ARRAY_HANDLE.getVolatile(array, index);
+    }
+
+    public static void setPlain(final int[] array, final int index, final int value) {
+        INT_ARRAY_HANDLE.set(array, index, value);
+    }
+
+    public static void setOpaque(final int[] array, final int index, final int value) {
+        INT_ARRAY_HANDLE.setOpaque(array, index, value);
+    }
+
+    public static void setRelease(final int[] array, final int index, final int value) {
+        INT_ARRAY_HANDLE.setRelease(array, index, value);
+    }
+
+    public static void setVolatile(final int[] array, final int index, final int value) {
+        INT_ARRAY_HANDLE.setVolatile(array, index, value);
+    }
+
+    public static void setVolatileContended(final int[] array, final int index, final int param) {
+        int failures = 0;
+
+        for (int curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, param))) {
+                return;
+            }
+        }
+    }
+
+    public static int compareAndExchangeVolatile(final int[] array, final int index, final int expect, final int update) {
+        return (int)INT_ARRAY_HANDLE.compareAndExchange(array, index, expect, update);
+    }
+
+    public static int getAndAddVolatile(final int[] array, final int index, final int param) {
+        return (int)INT_ARRAY_HANDLE.getAndAdd(array, index, param);
+    }
+
+    public static int getAndAndVolatile(final int[] array, final int index, final int param) {
+        return (int)INT_ARRAY_HANDLE.getAndBitwiseAnd(array, index, param);
+    }
+
+    public static int getAndOrVolatile(final int[] array, final int index, final int param) {
+        return (int)INT_ARRAY_HANDLE.getAndBitwiseOr(array, index, param);
+    }
+
+    public static int getAndXorVolatile(final int[] array, final int index, final int param) {
+        return (int)INT_ARRAY_HANDLE.getAndBitwiseXor(array, index, param);
+    }
+
+    public static int getAndSetVolatile(final int[] array, final int index, final int param) {
+        return (int)INT_ARRAY_HANDLE.getAndSet(array, index, param);
+    }
+
+    public static int compareAndExchangeVolatileContended(final int[] array, final int index, final int expect, final int update) {
+        return (int)INT_ARRAY_HANDLE.compareAndExchange(array, index, expect, update);
+    }
+
+    public static int getAndAddVolatileContended(final int[] array, final int index, final int param) {
+        int failures = 0;
+
+        for (int curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, (int) (curr + param)))) {
+                return curr;
+            }
+        }
+    }
+
+    public static int getAndAndVolatileContended(final int[] array, final int index, final int param) {
+        int failures = 0;
+
+        for (int curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, (int) (curr & param)))) {
+                return curr;
+            }
+        }
+    }
+
+    public static int getAndOrVolatileContended(final int[] array, final int index, final int param) {
+        int failures = 0;
+
+        for (int curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, (int) (curr | param)))) {
+                return curr;
+            }
+        }
+    }
+
+    public static int getAndXorVolatileContended(final int[] array, final int index, final int param) {
+        int failures = 0;
+
+        for (int curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, (int) (curr ^ param)))) {
+                return curr;
+            }
+        }
+    }
+
+    public static int getAndSetVolatileContended(final int[] array, final int index, final int param) {
+        int failures = 0;
+
+        for (int curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, param))) {
+                return curr;
+            }
+        }
+    }
+
+    /* long array */
+
+    public static long getPlain(final long[] array, final int index) {
+        return (long)LONG_ARRAY_HANDLE.get(array, index);
+    }
+
+    public static long getOpaque(final long[] array, final int index) {
+        return (long)LONG_ARRAY_HANDLE.getOpaque(array, index);
+    }
+
+    public static long getAcquire(final long[] array, final int index) {
+        return (long)LONG_ARRAY_HANDLE.getAcquire(array, index);
+    }
+
+    public static long getVolatile(final long[] array, final int index) {
+        return (long)LONG_ARRAY_HANDLE.getVolatile(array, index);
+    }
+
+    public static void setPlain(final long[] array, final int index, final long value) {
+        LONG_ARRAY_HANDLE.set(array, index, value);
+    }
+
+    public static void setOpaque(final long[] array, final int index, final long value) {
+        LONG_ARRAY_HANDLE.setOpaque(array, index, value);
+    }
+
+    public static void setRelease(final long[] array, final int index, final long value) {
+        LONG_ARRAY_HANDLE.setRelease(array, index, value);
+    }
+
+    public static void setVolatile(final long[] array, final int index, final long value) {
+        LONG_ARRAY_HANDLE.setVolatile(array, index, value);
+    }
+
+    public static void setVolatileContended(final long[] array, final int index, final long param) {
+        int failures = 0;
+
+        for (long curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, param))) {
+                return;
+            }
+        }
+    }
+
+    public static long compareAndExchangeVolatile(final long[] array, final int index, final long expect, final long update) {
+        return (long)LONG_ARRAY_HANDLE.compareAndExchange(array, index, expect, update);
+    }
+
+    public static long getAndAddVolatile(final long[] array, final int index, final long param) {
+        return (long)LONG_ARRAY_HANDLE.getAndAdd(array, index, param);
+    }
+
+    public static long getAndAndVolatile(final long[] array, final int index, final long param) {
+        return (long)LONG_ARRAY_HANDLE.getAndBitwiseAnd(array, index, param);
+    }
+
+    public static long getAndOrVolatile(final long[] array, final int index, final long param) {
+        return (long)LONG_ARRAY_HANDLE.getAndBitwiseOr(array, index, param);
+    }
+
+    public static long getAndXorVolatile(final long[] array, final int index, final long param) {
+        return (long)LONG_ARRAY_HANDLE.getAndBitwiseXor(array, index, param);
+    }
+
+    public static long getAndSetVolatile(final long[] array, final int index, final long param) {
+        return (long)LONG_ARRAY_HANDLE.getAndSet(array, index, param);
+    }
+
+    public static long compareAndExchangeVolatileContended(final long[] array, final int index, final long expect, final long update) {
+        return (long)LONG_ARRAY_HANDLE.compareAndExchange(array, index, expect, update);
+    }
+
+    public static long getAndAddVolatileContended(final long[] array, final int index, final long param) {
+        int failures = 0;
+
+        for (long curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, (long) (curr + param)))) {
+                return curr;
+            }
+        }
+    }
+
+    public static long getAndAndVolatileContended(final long[] array, final int index, final long param) {
+        int failures = 0;
+
+        for (long curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, (long) (curr & param)))) {
+                return curr;
+            }
+        }
+    }
+
+    public static long getAndOrVolatileContended(final long[] array, final int index, final long param) {
+        int failures = 0;
+
+        for (long curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, (long) (curr | param)))) {
+                return curr;
+            }
+        }
+    }
+
+    public static long getAndXorVolatileContended(final long[] array, final int index, final long param) {
+        int failures = 0;
+
+        for (long curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, (long) (curr ^ param)))) {
+                return curr;
+            }
+        }
+    }
+
+    public static long getAndSetVolatileContended(final long[] array, final int index, final long param) {
+        int failures = 0;
+
+        for (long curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, param))) {
+                return curr;
+            }
+        }
+    }
+
+    /* boolean array */
+
+    public static boolean getPlain(final boolean[] array, final int index) {
+        return (boolean)BOOLEAN_ARRAY_HANDLE.get(array, index);
+    }
+
+    public static boolean getOpaque(final boolean[] array, final int index) {
+        return (boolean)BOOLEAN_ARRAY_HANDLE.getOpaque(array, index);
+    }
+
+    public static boolean getAcquire(final boolean[] array, final int index) {
+        return (boolean)BOOLEAN_ARRAY_HANDLE.getAcquire(array, index);
+    }
+
+    public static boolean getVolatile(final boolean[] array, final int index) {
+        return (boolean)BOOLEAN_ARRAY_HANDLE.getVolatile(array, index);
+    }
+
+    public static void setPlain(final boolean[] array, final int index, final boolean value) {
+        BOOLEAN_ARRAY_HANDLE.set(array, index, value);
+    }
+
+    public static void setOpaque(final boolean[] array, final int index, final boolean value) {
+        BOOLEAN_ARRAY_HANDLE.setOpaque(array, index, value);
+    }
+
+    public static void setRelease(final boolean[] array, final int index, final boolean value) {
+        BOOLEAN_ARRAY_HANDLE.setRelease(array, index, value);
+    }
+
+    public static void setVolatile(final boolean[] array, final int index, final boolean value) {
+        BOOLEAN_ARRAY_HANDLE.setVolatile(array, index, value);
+    }
+
+    public static void setVolatileContended(final boolean[] array, final int index, final boolean param) {
+        int failures = 0;
+
+        for (boolean curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, param))) {
+                return;
+            }
+        }
+    }
+
+    public static boolean compareAndExchangeVolatile(final boolean[] array, final int index, final boolean expect, final boolean update) {
+        return (boolean)BOOLEAN_ARRAY_HANDLE.compareAndExchange(array, index, expect, update);
+    }
+
+    public static boolean getAndOrVolatile(final boolean[] array, final int index, final boolean param) {
+        return (boolean)BOOLEAN_ARRAY_HANDLE.getAndBitwiseOr(array, index, param);
+    }
+
+    public static boolean getAndXorVolatile(final boolean[] array, final int index, final boolean param) {
+        return (boolean)BOOLEAN_ARRAY_HANDLE.getAndBitwiseXor(array, index, param);
+    }
+
+    public static boolean getAndSetVolatile(final boolean[] array, final int index, final boolean param) {
+        return (boolean)BOOLEAN_ARRAY_HANDLE.getAndSet(array, index, param);
+    }
+
+    public static boolean compareAndExchangeVolatileContended(final boolean[] array, final int index, final boolean expect, final boolean update) {
+        return (boolean)BOOLEAN_ARRAY_HANDLE.compareAndExchange(array, index, expect, update);
+    }
+
+    public static boolean getAndAndVolatileContended(final boolean[] array, final int index, final boolean param) {
+        int failures = 0;
+
+        for (boolean curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, (boolean) (curr & param)))) {
+                return curr;
+            }
+        }
+    }
+
+    public static boolean getAndOrVolatileContended(final boolean[] array, final int index, final boolean param) {
+        int failures = 0;
+
+        for (boolean curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, (boolean) (curr | param)))) {
+                return curr;
+            }
+        }
+    }
+
+    public static boolean getAndXorVolatileContended(final boolean[] array, final int index, final boolean param) {
+        int failures = 0;
+
+        for (boolean curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, (boolean) (curr ^ param)))) {
+                return curr;
+            }
+        }
+    }
+
+    public static boolean getAndSetVolatileContended(final boolean[] array, final int index, final boolean param) {
+        int failures = 0;
+
+        for (boolean curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, param))) {
+                return curr;
+            }
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <T> T getPlain(final T[] array, final int index) {
+        final Object ret = OBJECT_ARRAY_HANDLE.get((Object[])array, index);
+        return (T)ret;
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <T> T getOpaque(final T[] array, final int index) {
+        final Object ret = OBJECT_ARRAY_HANDLE.getOpaque((Object[])array, index);
+        return (T)ret;
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <T> T getAcquire(final T[] array, final int index) {
+        final Object ret = OBJECT_ARRAY_HANDLE.getAcquire((Object[])array, index);
+        return (T)ret;
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <T> T getVolatile(final T[] array, final int index) {
+        final Object ret = OBJECT_ARRAY_HANDLE.getVolatile((Object[])array, index);
+        return (T)ret;
+    }
+
+    public static <T> void setPlain(final T[] array, final int index, final T value) {
+        OBJECT_ARRAY_HANDLE.set((Object[])array, index, (Object)value);
+    }
+
+    public static <T> void setOpaque(final T[] array, final int index, final T value) {
+        OBJECT_ARRAY_HANDLE.setOpaque((Object[])array, index, (Object)value);
+    }
+
+    public static <T> void setRelease(final T[] array, final int index, final T value) {
+        OBJECT_ARRAY_HANDLE.setRelease((Object[])array, index, (Object)value);
+    }
+
+    public static <T> void setVolatile(final T[] array, final int index, final T value) {
+        OBJECT_ARRAY_HANDLE.setVolatile((Object[])array, index, (Object)value);
+    }
+
+    public static <T> void setVolatileContended(final T[] array, final int index, final T param) {
+        int failures = 0;
+
+        for (T curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, param))) {
+                return;
+            }
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <T> T compareAndExchangeVolatile(final T[] array, final int index, final T expect, final T update) {
+        final Object ret = OBJECT_ARRAY_HANDLE.compareAndExchange((Object[])array, index, (Object)expect, (Object)update);
+        return (T)ret;
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <T> T getAndSetVolatile(final T[] array, final int index, final T param) {
+        final Object ret = BYTE_ARRAY_HANDLE.getAndSet((Object[])array, index, (Object)param);
+        return (T)ret;
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <T> T compareAndExchangeVolatileContended(final T[] array, final int index, final T expect, final T update) {
+        final Object ret = OBJECT_ARRAY_HANDLE.compareAndExchange((Object[])array, index, (Object)expect, (Object)update);
+        return (T)ret;
+    }
+
+    public static <T> T getAndSetVolatileContended(final T[] array, final int index, final T param) {
+        int failures = 0;
+
+        for (T curr = getVolatile(array, index);;++failures) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+
+            if (curr == (curr = compareAndExchangeVolatileContended(array, index, curr, param))) {
+                return curr;
+            }
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concurrentutil/util/CollectionUtil.java b/src/main/java/ca/spottedleaf/concurrentutil/util/CollectionUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..9420b9822de99d3a31224642452835b0c986f7b4
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concurrentutil/util/CollectionUtil.java
@@ -0,0 +1,31 @@
+package ca.spottedleaf.concurrentutil.util;
+
+import java.util.Collection;
+
+public final class CollectionUtil {
+
+    public static String toString(final Collection<?> collection, final String name) {
+        return CollectionUtil.toString(collection, name, new StringBuilder(name.length() + 128)).toString();
+    }
+
+    public static StringBuilder toString(final Collection<?> collection, final String name, final StringBuilder builder) {
+        builder.append(name).append("{elements={");
+
+        boolean first = true;
+
+        for (final Object element : collection) {
+            if (!first) {
+                builder.append(", ");
+            }
+            first = false;
+
+            builder.append('"').append(element).append('"');
+        }
+
+        return builder.append("}}");
+    }
+
+    private CollectionUtil() {
+        throw new RuntimeException();
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concurrentutil/util/ConcurrentUtil.java b/src/main/java/ca/spottedleaf/concurrentutil/util/ConcurrentUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..23ae82e55696a7e2ff0e0f9609c0df6a48bb8d1d
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concurrentutil/util/ConcurrentUtil.java
@@ -0,0 +1,166 @@
+package ca.spottedleaf.concurrentutil.util;
+
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.VarHandle;
+import java.util.concurrent.locks.LockSupport;
+
+public final class ConcurrentUtil {
+
+    public static String genericToString(final Object object) {
+        return object == null ? "null" : object.getClass().getName() + ":" + object.hashCode() + ":" + object.toString();
+    }
+
+    public static void rethrow(Throwable exception) {
+        rethrow0(exception);
+    }
+
+    private static <T extends Throwable> void rethrow0(Throwable thr) throws T {
+        throw (T)thr;
+    }
+
+    public static VarHandle getVarHandle(final Class<?> lookIn, final String fieldName, final Class<?> fieldType) {
+        try {
+            return MethodHandles.privateLookupIn(lookIn, MethodHandles.lookup()).findVarHandle(lookIn, fieldName, fieldType);
+        } catch (final Exception ex) {
+            throw new RuntimeException(ex); // unreachable
+        }
+    }
+
+    public static VarHandle getStaticVarHandle(final Class<?> lookIn, final String fieldName, final Class<?> fieldType) {
+        try {
+            return MethodHandles.privateLookupIn(lookIn, MethodHandles.lookup()).findStaticVarHandle(lookIn, fieldName, fieldType);
+        } catch (final Exception ex) {
+            throw new RuntimeException(ex); // unreachable
+        }
+    }
+
+    /**
+     * Non-exponential backoff algorithm to use in lightly contended areas.
+     * @see ConcurrentUtil#exponentiallyBackoffSimple(long)
+     * @see ConcurrentUtil#exponentiallyBackoffComplex(long)
+     */
+    public static void backoff() {
+        Thread.onSpinWait();
+    }
+
+    /**
+     * Backoff algorithm to use for a short held lock (i.e compareAndExchange operation). Generally this should not be
+     * used when a thread can block another thread. Instead, use {@link ConcurrentUtil#exponentiallyBackoffComplex(long)}.
+     * @param counter The current counter.
+     * @return The counter plus 1.
+     * @see ConcurrentUtil#backoff()
+     * @see ConcurrentUtil#exponentiallyBackoffComplex(long)
+     */
+    public static long exponentiallyBackoffSimple(final long counter) {
+        for (long i = 0; i < counter; ++i) {
+            backoff();
+        }
+        return counter + 1L;
+    }
+
+    /**
+     * Backoff algorithm to use for a lock that can block other threads (i.e if another thread contending with this thread
+     * can be thrown off the scheduler). This lock should not be used for simple locks such as compareAndExchange.
+     * @param counter The current counter.
+     * @return The next (if any) step in the backoff logic.
+     * @see ConcurrentUtil#backoff()
+     * @see ConcurrentUtil#exponentiallyBackoffSimple(long)
+     */
+    public static long exponentiallyBackoffComplex(final long counter) {
+        // TODO experimentally determine counters
+        if (counter < 100L) {
+            return exponentiallyBackoffSimple(counter);
+        }
+        if (counter < 1_200L) {
+            Thread.yield();
+            LockSupport.parkNanos(1_000L);
+            return counter + 1L;
+        }
+        // scale 0.1ms (100us) per failure
+        Thread.yield();
+        LockSupport.parkNanos(100_000L * counter);
+        return counter + 1;
+    }
+
+    /**
+     * Simple exponential backoff that will linearly increase the time per failure, according to the scale.
+     * @param counter The current failure counter.
+     * @param scale Time per failure, in ns.
+     * @param max The maximum time to wait for, in ns.
+     * @return The next counter.
+     */
+    public static long linearLongBackoff(long counter, final long scale, long max) {
+        counter = Math.min(Long.MAX_VALUE, counter + 1); // prevent overflow
+        max = Math.max(0, max);
+
+        if (scale <= 0L) {
+            return counter;
+        }
+
+        long time = scale * counter;
+
+        if (time > max || time / scale != counter) {
+            time = max;
+        }
+
+        boolean interrupted = Thread.interrupted();
+        if (time > 1_000_000L) { // 1ms
+            Thread.yield();
+        }
+        LockSupport.parkNanos(time);
+        if (interrupted) {
+            Thread.currentThread().interrupt();
+        }
+        return counter;
+    }
+
+    /**
+     * Simple exponential backoff that will linearly increase the time per failure, according to the scale.
+     * @param counter The current failure counter.
+     * @param scale Time per failure, in ns.
+     * @param max The maximum time to wait for, in ns.
+     * @param deadline The deadline in ns. Deadline time source: {@link System#nanoTime()}.
+     * @return The next counter.
+     */
+    public static long linearLongBackoffDeadline(long counter, final long scale, long max, long deadline) {
+        counter = Math.min(Long.MAX_VALUE, counter + 1); // prevent overflow
+        max = Math.max(0, max);
+
+        if (scale <= 0L) {
+            return counter;
+        }
+
+        long time = scale * counter;
+
+        // check overflow
+        if (time / scale != counter) {
+            // overflew
+            --counter;
+            time = max;
+        } else if (time > max) {
+            time = max;
+        }
+
+        final long currTime = System.nanoTime();
+        final long diff = deadline - currTime;
+        if (diff <= 0) {
+            return counter;
+        }
+        if (diff <= 1_500_000L) { // 1.5ms
+            time = 100_000L; // 100us
+        } else if (time > 1_000_000L) { // 1ms
+            Thread.yield();
+        }
+
+        boolean interrupted = Thread.interrupted();
+        LockSupport.parkNanos(time);
+        if (interrupted) {
+            Thread.currentThread().interrupt();
+        }
+        return counter;
+    }
+
+    public static VarHandle getArrayHandle(final Class<?> type) {
+        return MethodHandles.arrayElementVarHandle(type);
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concurrentutil/util/Validate.java b/src/main/java/ca/spottedleaf/concurrentutil/util/Validate.java
new file mode 100644
index 0000000000000000000000000000000000000000..382177d0d162fa3139c9078a873ce2504a2b17b2
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concurrentutil/util/Validate.java
@@ -0,0 +1,28 @@
+package ca.spottedleaf.concurrentutil.util;
+
+public final class Validate {
+
+    public static <T> T notNull(final T obj) {
+        if (obj == null) {
+            throw new NullPointerException();
+        }
+        return obj;
+    }
+
+    public static <T> T notNull(final T obj, final String msgIfNull) {
+        if (obj == null) {
+            throw new NullPointerException(msgIfNull);
+        }
+        return obj;
+    }
+
+    public static void arrayBounds(final int off, final int len, final int arrayLength, final String msgPrefix) {
+        if (off < 0 || len < 0 || (arrayLength - off) < len) {
+            throw new ArrayIndexOutOfBoundsException(msgPrefix + ": off: " + off + ", len: " + len + ", array length: " + arrayLength);
+        }
+    }
+
+    private Validate() {
+        throw new RuntimeException();
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/starlight/common/light/StarLightInterface.java b/src/main/java/ca/spottedleaf/starlight/common/light/StarLightInterface.java
index ef8dcbb6bbc0769e9ccfdadb05e6a46c070eda98..f6dfaaa0ccd8caeb4bd4b94254aebe7e96732f12 100644
--- a/src/main/java/ca/spottedleaf/starlight/common/light/StarLightInterface.java
+++ b/src/main/java/ca/spottedleaf/starlight/common/light/StarLightInterface.java
@@ -41,14 +41,14 @@ public final class StarLightInterface {
     protected final ArrayDeque<SkyStarLightEngine> cachedSkyPropagators;
     protected final ArrayDeque<BlockStarLightEngine> cachedBlockPropagators;
 
-    protected final LightQueue lightQueue = new LightQueue(this);
+    public final io.papermc.paper.chunk.system.light.LightQueue lightQueue; // Paper - replace light queue
 
     protected final LayerLightEventListener skyReader;
     protected final LayerLightEventListener blockReader;
     protected final boolean isClientSide;
 
-    protected final int minSection;
-    protected final int maxSection;
+    public final int minSection; // Paper - public
+    public final int maxSection; // Paper - public
     protected final int minLightSection;
     protected final int maxLightSection;
 
@@ -182,6 +182,7 @@ public final class StarLightInterface {
                 StarLightInterface.this.sectionChange(pos, notReady);
             }
         };
+        this.lightQueue = new io.papermc.paper.chunk.system.light.LightQueue(this); // Paper - replace light queue
     }
 
     protected int getSkyLightValue(final BlockPos blockPos, final ChunkAccess chunk) {
@@ -325,7 +326,7 @@ public final class StarLightInterface {
         return this.lightAccess;
     }
 
-    protected final SkyStarLightEngine getSkyLightEngine() {
+    public final SkyStarLightEngine getSkyLightEngine() { // Paper - public
         if (this.cachedSkyPropagators == null) {
             return null;
         }
@@ -340,7 +341,7 @@ public final class StarLightInterface {
         return ret;
     }
 
-    protected final void releaseSkyLightEngine(final SkyStarLightEngine engine) {
+    public final void releaseSkyLightEngine(final SkyStarLightEngine engine) { // Paper - public
         if (this.cachedSkyPropagators == null) {
             return;
         }
@@ -349,7 +350,7 @@ public final class StarLightInterface {
         }
     }
 
-    protected final BlockStarLightEngine getBlockLightEngine() {
+    public final BlockStarLightEngine getBlockLightEngine() { // Paper - public
         if (this.cachedBlockPropagators == null) {
             return null;
         }
@@ -364,7 +365,7 @@ public final class StarLightInterface {
         return ret;
     }
 
-    protected final void releaseBlockLightEngine(final BlockStarLightEngine engine) {
+    public final void releaseBlockLightEngine(final BlockStarLightEngine engine) { // Paper - public
         if (this.cachedBlockPropagators == null) {
             return;
         }
@@ -511,57 +512,15 @@ public final class StarLightInterface {
     }
 
     public void scheduleChunkLight(final ChunkPos pos, final Runnable run) {
-        this.lightQueue.queueChunkLighting(pos, run);
+        throw new UnsupportedOperationException("No longer implemented, use the new lightQueue field to queue tasks"); // Paper - replace light queue
     }
 
     public void removeChunkTasks(final ChunkPos pos) {
-        this.lightQueue.removeChunk(pos);
+        throw new UnsupportedOperationException("No longer implemented, use the new lightQueue field to queue tasks"); // Paper - replace light queue
     }
 
     public void propagateChanges() {
-        if (this.lightQueue.isEmpty()) {
-            return;
-        }
-
-        final SkyStarLightEngine skyEngine = this.getSkyLightEngine();
-        final BlockStarLightEngine blockEngine = this.getBlockLightEngine();
-
-        try {
-            LightQueue.ChunkTasks task;
-            while ((task = this.lightQueue.removeFirstTask()) != null) {
-                if (task.lightTasks != null) {
-                    for (final Runnable run : task.lightTasks) {
-                        run.run();
-                    }
-                }
-
-                final long coordinate = task.chunkCoordinate;
-                final int chunkX = CoordinateUtils.getChunkX(coordinate);
-                final int chunkZ = CoordinateUtils.getChunkZ(coordinate);
-
-                final Set<BlockPos> positions = task.changedPositions;
-                final Boolean[] sectionChanges = task.changedSectionSet;
-
-                if (skyEngine != null && (!positions.isEmpty() || sectionChanges != null)) {
-                    skyEngine.blocksChangedInChunk(this.lightAccess, chunkX, chunkZ, positions, sectionChanges);
-                }
-                if (blockEngine != null && (!positions.isEmpty() || sectionChanges != null)) {
-                    blockEngine.blocksChangedInChunk(this.lightAccess, chunkX, chunkZ, positions, sectionChanges);
-                }
-
-                if (skyEngine != null && task.queuedEdgeChecksSky != null) {
-                    skyEngine.checkChunkEdges(this.lightAccess, chunkX, chunkZ, task.queuedEdgeChecksSky);
-                }
-                if (blockEngine != null && task.queuedEdgeChecksBlock != null) {
-                    blockEngine.checkChunkEdges(this.lightAccess, chunkX, chunkZ, task.queuedEdgeChecksBlock);
-                }
-
-                task.onComplete.complete(null);
-            }
-        } finally {
-            this.releaseSkyLightEngine(skyEngine);
-            this.releaseBlockLightEngine(blockEngine);
-        }
+        throw new UnsupportedOperationException("No longer implemented, task draining is now performed by the light thread"); // Paper - replace light queue
     }
 
     protected static final class LightQueue {
diff --git a/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java b/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java
index 7c89a96d54641904e2d4562fe28c59deecfb5444..7b95b599c29ddb9c249ab1f8e51b69789c63bdc4 100644
--- a/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java
+++ b/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java
@@ -45,7 +45,7 @@ public final class PaperFileIOThread extends QueueExecutorThread {
         public static final PaperFileIOThread INSTANCE = new PaperFileIOThread();
 
         static {
-            INSTANCE.start();
+             // Paper - fail hard on usage
         }
     }
 
@@ -89,39 +89,16 @@ public final class PaperFileIOThread extends QueueExecutorThread {
      * @param priority Priority level to try to bump to
      */
     public void bumpPriority(final ServerLevel world, final int chunkX, final int chunkZ, final int priority) {
-        if (!PrioritizedTaskQueue.validPriority(priority)) {
-            throw new IllegalArgumentException("Invalid priority: " + priority);
-        }
-
-        final Long key = Long.valueOf(IOUtil.getCoordinateKey(chunkX, chunkZ));
-
-        final ChunkDataTask poiTask = world.poiDataController.tasks.get(key);
-        final ChunkDataTask chunkTask = world.chunkDataController.tasks.get(key);
-
-        if (poiTask != null) {
-            poiTask.raisePriority(priority);
-        }
-        if (chunkTask != null) {
-            chunkTask.raisePriority(priority);
-        }
+        throw new IllegalStateException("Shouldn't get here, use RegionFileIOThread"); // Paper - rewrite chunk system, fail hard on usage
     }
 
     public CompoundTag getPendingWrite(final ServerLevel world, final int chunkX, final int chunkZ, final boolean poiData) {
-        final ChunkDataController taskController = poiData ? world.poiDataController : world.chunkDataController;
-
-        final ChunkDataTask dataTask = taskController.tasks.get(Long.valueOf(IOUtil.getCoordinateKey(chunkX, chunkZ)));
-
-        if (dataTask == null) {
-            return null;
-        }
-
-        final ChunkDataController.InProgressWrite write = dataTask.inProgressWrite;
-
-        if (write == null) {
-            return null;
-        }
-
-        return write.data;
+        // Paper start - rewrite chunk system
+        return io.papermc.paper.chunk.system.io.RegionFileIOThread.getPendingWrite(
+            world, chunkX, chunkZ, poiData ? io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.POI_DATA :
+                io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.CHUNK_DATA
+            );
+        // Paper end - rewrite chunk system
     }
 
     /**
@@ -132,21 +109,7 @@ public final class PaperFileIOThread extends QueueExecutorThread {
      * @param priority Priority level to set to
      */
     public void setPriority(final ServerLevel world, final int chunkX, final int chunkZ, final int priority) {
-        if (!PrioritizedTaskQueue.validPriority(priority)) {
-            throw new IllegalArgumentException("Invalid priority: " + priority);
-        }
-
-        final Long key = Long.valueOf(IOUtil.getCoordinateKey(chunkX, chunkZ));
-
-        final ChunkDataTask poiTask = world.poiDataController.tasks.get(key);
-        final ChunkDataTask chunkTask = world.chunkDataController.tasks.get(key);
-
-        if (poiTask != null) {
-            poiTask.updatePriority(priority);
-        }
-        if (chunkTask != null) {
-            chunkTask.updatePriority(priority);
-        }
+        throw new IllegalStateException("Shouldn't get here, use RegionFileIOThread"); // Paper - rewrite chunk system, fail hard on usage
     }
 
     /**
@@ -173,58 +136,12 @@ public final class PaperFileIOThread extends QueueExecutorThread {
     public void scheduleSave(final ServerLevel world, final int chunkX, final int chunkZ,
                              final CompoundTag poiData, final CompoundTag chunkData,
                              final int priority) throws IllegalArgumentException {
-        if (!PrioritizedTaskQueue.validPriority(priority)) {
-            throw new IllegalArgumentException("Invalid priority: " + priority);
-        }
-
-        final long writeCounter = this.writeCounter.getAndIncrement();
-
-        if (poiData != null) {
-            this.scheduleWrite(world.poiDataController, world, chunkX, chunkZ, poiData, priority, writeCounter);
-        }
-        if (chunkData != null) {
-            this.scheduleWrite(world.chunkDataController, world, chunkX, chunkZ, chunkData, priority, writeCounter);
-        }
+        throw new IllegalStateException("Shouldn't get here, use RegionFileIOThread"); // Paper - rewrite chunk system, fail hard on usage
     }
 
     private void scheduleWrite(final ChunkDataController dataController, final ServerLevel world,
                                final int chunkX, final int chunkZ, final CompoundTag data, final int priority, final long writeCounter) {
-        dataController.tasks.compute(Long.valueOf(IOUtil.getCoordinateKey(chunkX, chunkZ)), (final Long keyInMap, final ChunkDataTask taskRunning) -> {
-            if (taskRunning == null) {
-                // no task is scheduled
-
-                // create task
-                final ChunkDataTask newTask = new ChunkDataTask(priority, world, chunkX, chunkZ, dataController);
-                newTask.inProgressWrite = new ChunkDataController.InProgressWrite();
-                newTask.inProgressWrite.writeCounter = writeCounter;
-                newTask.inProgressWrite.data = data;
-
-                PaperFileIOThread.this.queueTask(newTask); // schedule
-                return newTask;
-            }
-
-            taskRunning.raisePriority(priority);
-
-            if (taskRunning.inProgressWrite == null) {
-                taskRunning.inProgressWrite = new ChunkDataController.InProgressWrite();
-            }
-
-            boolean reschedule = taskRunning.inProgressWrite.writeCounter == -1L;
-
-            // synchronize for readers
-            //noinspection SynchronizationOnLocalVariableOrMethodParameter
-            synchronized (taskRunning) {
-                taskRunning.inProgressWrite.data = data;
-                taskRunning.inProgressWrite.writeCounter = writeCounter;
-            }
-
-            if (reschedule) {
-                // We need to reschedule this task since the previous one is not currently scheduled since it failed
-                taskRunning.reschedule(priority);
-            }
-
-            return taskRunning;
-        });
+        throw new IllegalStateException("Shouldn't get here, use RegionFileIOThread"); // Paper - rewrite chunk system, fail hard on usage
     }
 
     /**
@@ -283,45 +200,45 @@ public final class PaperFileIOThread extends QueueExecutorThread {
         }
 
         final ChunkData complete = new ChunkData();
-        final boolean[] requireCompletion = new boolean[] { readPoiData, readChunkData };
-
+        // Paper start - rewrite chunk system
+        final java.util.List<io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType> types = new java.util.ArrayList<>();
         if (readPoiData) {
-            this.scheduleRead(world.poiDataController, world, chunkX, chunkZ, (final CompoundTag poiData) -> {
-                complete.poiData = poiData;
-
-                final boolean finished;
-
-                // avoid a race condition where the file io thread completes and we complete synchronously
-                // Note: Synchronization can be elided if both of the accesses are volatile
-                synchronized (requireCompletion) {
-                    requireCompletion[0] = false; // 0 -> poi data
-                    finished = !requireCompletion[1]; // 1 -> chunk data
-                }
-
-                if (finished) {
-                    onComplete.accept(complete);
-                }
-            }, priority, intendingToBlock);
+            types.add(io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.POI_DATA);
         }
-
         if (readChunkData) {
-            this.scheduleRead(world.chunkDataController, world, chunkX, chunkZ, (final CompoundTag chunkData) -> {
-                complete.chunkData = chunkData;
-
-                final boolean finished;
-
-                // avoid a race condition where the file io thread completes and we complete synchronously
-                // Note: Synchronization can be elided if both of the accesses are volatile
-                synchronized (requireCompletion) {
-                    requireCompletion[1] = false; // 1 -> chunk data
-                    finished = !requireCompletion[0]; // 0 -> poi data
+            types.add(io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.CHUNK_DATA);
+        }
+        final ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority newPriority;
+        switch (priority) {
+            case PrioritizedTaskQueue.HIGHEST_PRIORITY -> newPriority = ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.BLOCKING;
+            case PrioritizedTaskQueue.HIGHER_PRIORITY -> newPriority = ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.HIGHEST;
+            case PrioritizedTaskQueue.HIGH_PRIORITY -> newPriority = ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.HIGH;
+            case PrioritizedTaskQueue.NORMAL_PRIORITY -> newPriority = ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.NORMAL;
+            case PrioritizedTaskQueue.LOW_PRIORITY -> newPriority = ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.LOW;
+            case PrioritizedTaskQueue.LOWEST_PRIORITY -> newPriority = ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.IDLE;
+            default -> throw new IllegalStateException("Legacy priority " + priority + " should be valid");
+        }
+        final Consumer<io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileData> transformComplete = (io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileData data) -> {
+            if (readPoiData) {
+                if (data.getThrowable(io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.POI_DATA) != null) {
+                    complete.poiData = FAILURE_VALUE;
+                } else {
+                    complete.poiData = data.getData(io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.POI_DATA);
                 }
+            }
 
-                if (finished) {
-                    onComplete.accept(complete);
+            if (readChunkData) {
+                if (data.getThrowable(io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.CHUNK_DATA) != null) {
+                    complete.chunkData = FAILURE_VALUE;
+                } else {
+                    complete.chunkData = data.getData(io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.CHUNK_DATA);
                 }
-            }, priority, intendingToBlock);
-        }
+            }
+
+            onComplete.accept(complete);
+        };
+        io.papermc.paper.chunk.system.io.RegionFileIOThread.loadChunkData(world, chunkX, chunkZ, transformComplete, intendingToBlock, newPriority, types.toArray(new io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType[0]));
+        // Paper end - rewrite chunk system
 
     }
 
@@ -329,49 +246,7 @@ public final class PaperFileIOThread extends QueueExecutorThread {
     private void scheduleRead(final ChunkDataController dataController, final ServerLevel world,
                               final int chunkX, final int chunkZ, final Consumer<CompoundTag> onComplete, final int priority,
                               final boolean intendingToBlock) {
-
-        Function<RegionFile, Boolean> tryLoadFunction = (final RegionFile file) -> {
-            if (file == null) {
-                return Boolean.TRUE;
-            }
-            return Boolean.valueOf(file.hasChunk(new ChunkPos(chunkX, chunkZ)));
-        };
-
-        dataController.tasks.compute(Long.valueOf(IOUtil.getCoordinateKey(chunkX, chunkZ)), (final Long keyInMap, final ChunkDataTask running) -> {
-            if (running == null) {
-                // not scheduled
-
-                final Boolean shouldSchedule = intendingToBlock ? dataController.computeForRegionFile(chunkX, chunkZ, tryLoadFunction) :
-                    dataController.computeForRegionFileIfLoaded(chunkX, chunkZ, tryLoadFunction);
-
-                if (shouldSchedule == Boolean.FALSE) {
-                    // not on disk
-                    onComplete.accept(null);
-                    return null;
-                }
-
-                // set up task
-                final ChunkDataTask newTask = new ChunkDataTask(priority, world, chunkX, chunkZ, dataController);
-                newTask.inProgressRead = new ChunkDataController.InProgressRead();
-                newTask.inProgressRead.readFuture.thenAccept(onComplete);
-
-                PaperFileIOThread.this.queueTask(newTask); // schedule task
-                return newTask;
-            }
-
-            running.raisePriority(priority);
-
-            if (running.inProgressWrite == null) {
-                // chain to the read future
-                running.inProgressRead.readFuture.thenAccept(onComplete);
-                return running;
-            }
-
-            // at this stage we have to use the in progress write's data to avoid an order issue
-            // we don't synchronize since all writes to data occur in the compute() call
-            onComplete.accept(running.inProgressWrite.data);
-            return running;
-        });
+        throw new IllegalStateException("Shouldn't get here, use RegionFileIOThread"); // Paper - rewrite chunk system, fail hard on usage
     }
 
     /**
@@ -391,7 +266,7 @@ public final class PaperFileIOThread extends QueueExecutorThread {
      * </p>
      */
     public void runTask(final int priority, final Runnable runnable) {
-        this.queueTask(new GeneralTask(priority, runnable));
+        throw new IllegalStateException("Shouldn't get here, use RegionFileIOThread"); // Paper - rewrite chunk system, fail hard on usage
     }
 
     static final class GeneralTask extends PrioritizedTaskQueue.PrioritizedTask implements Runnable {
@@ -471,7 +346,7 @@ public final class PaperFileIOThread extends QueueExecutorThread {
         @Override
         public String toString() {
             return "Task for world: '" + this.world.getWorld().getName() + "' at " + this.x + "," + this.z +
-                " poi: " + (this.taskController == this.world.poiDataController) + ", hash: " + this.hashCode();
+                " poi: " + (this.taskController == null) + ", hash: " + this.hashCode(); // Paper - TODO rewrite chunk system
         }
 
         /*
@@ -501,6 +376,7 @@ public final class PaperFileIOThread extends QueueExecutorThread {
 
         @Override
         public void run() {
+            if (true) throw new IllegalStateException("Shouldn't get here, use RegionFileIOThread"); // Paper - rewrite chunk system, fail hard on usage
             ChunkDataController.InProgressRead read = this.inProgressRead;
             if (read != null) {
                 CompoundTag compound = PaperFileIOThread.FAILURE_VALUE;
diff --git a/src/main/java/com/destroystokyo/paper/io/chunk/ChunkTaskManager.java b/src/main/java/com/destroystokyo/paper/io/chunk/ChunkTaskManager.java
index 68860a3b6db2aa50373d71aec9502c18d48ab8b9..193f492ce1fb6a7ebf2c19f092c268422c7435c3 100644
--- a/src/main/java/com/destroystokyo/paper/io/chunk/ChunkTaskManager.java
+++ b/src/main/java/com/destroystokyo/paper/io/chunk/ChunkTaskManager.java
@@ -86,24 +86,7 @@ public final class ChunkTaskManager {
     }
 
     public static void dumpAllChunkLoadInfo() {
-        ChunkInfo[] chunks = getChunkInfos();
-        if (chunks.length > 0) {
-            PaperFileIOThread.LOGGER.error("Chunk wait task info below: ");
-
-            for (final ChunkInfo chunkInfo : chunks) {
-                final long key = IOUtil.getCoordinateKey(chunkInfo.chunkX, chunkInfo.chunkZ);
-                final ChunkLoadTask loadTask = chunkInfo.world.asyncChunkTaskManager.chunkLoadTasks.get(key);
-                final ChunkSaveTask saveTask = chunkInfo.world.asyncChunkTaskManager.chunkSaveTasks.get(key);
-
-                PaperFileIOThread.LOGGER.error(chunkInfo.chunkX + "," + chunkInfo.chunkZ + " in '" + chunkInfo.world.getWorld().getName() + ":");
-                PaperFileIOThread.LOGGER.error("Load Task - " + (loadTask == null ? "none" : loadTask.toString()));
-                PaperFileIOThread.LOGGER.error("Save Task - " + (saveTask == null ? "none" : saveTask.toString()));
-                // log current status of chunk to indicate whether we're waiting on generation or loading
-                ChunkHolder chunkHolder = chunkInfo.world.getChunkSource().chunkMap.getVisibleChunkIfPresent(key);
-
-                dumpChunkInfo(new HashSet<>(), chunkHolder, chunkInfo.chunkX, chunkInfo.chunkZ);
-            }
-        }
+        // Paper - rewrite chunk system
     }
 
     static void dumpChunkInfo(Set<ChunkHolder> seenChunks, ChunkHolder chunkHolder, int x, int z) {
@@ -111,49 +94,7 @@ public final class ChunkTaskManager {
     }
 
     static void dumpChunkInfo(Set<ChunkHolder> seenChunks, ChunkHolder chunkHolder, int x, int z, int indent, int maxDepth) {
-        if (seenChunks.contains(chunkHolder)) {
-            return;
-        }
-        if (indent > maxDepth) {
-            return;
-        }
-        seenChunks.add(chunkHolder);
-        String indentStr = StringUtils.repeat("  ", indent);
-        if (chunkHolder == null) {
-            PaperFileIOThread.LOGGER.error(indentStr + "Chunk Holder - null for (" + x +"," + z +")");
-        } else {
-            ChunkAccess chunk = chunkHolder.getLastAvailable();
-            ChunkStatus holderStatus = chunkHolder.getChunkHolderStatus();
-            PaperFileIOThread.LOGGER.error(indentStr + "Chunk Holder - non-null");
-            PaperFileIOThread.LOGGER.error(indentStr + "Chunk Status - " + ((chunk == null) ? "null chunk" : chunk.getStatus().toString()));
-            PaperFileIOThread.LOGGER.error(indentStr + "Chunk Ticket Status - "  + ChunkHolder.getStatus(chunkHolder.getTicketLevel()));
-            PaperFileIOThread.LOGGER.error(indentStr + "Chunk Holder Status - " + ((holderStatus == null) ? "null" : holderStatus.toString()));
-            // Paper start
-            PaperFileIOThread.LOGGER.error(indentStr + "Chunk Holder Priority - " + chunkHolder.queueLevel);
-
-            if (!chunkHolder.neighbors.isEmpty()) {
-                if (indent >= maxDepth) {
-                    PaperFileIOThread.LOGGER.error(indentStr + "Chunk Neighbors: (Can't show, too deeply nested)");
-                    return;
-                }
-                PaperFileIOThread.LOGGER.error(indentStr + "Chunk Neighbors: ");
-                for (ChunkHolder neighbor : chunkHolder.neighbors.keySet()) {
-                    ChunkStatus status = neighbor.getChunkHolderStatus();
-                    if (status != null && status.isOrAfter(ChunkHolder.getStatus(neighbor.getTicketLevel()))) {
-                        continue;
-                    }
-                    int nx = neighbor.pos.x;
-                    int nz = neighbor.pos.z;
-                    if (seenChunks.contains(neighbor)) {
-                        PaperFileIOThread.LOGGER.error(indentStr + "  " + nx + "," + nz + " in " + chunkHolder.getWorld().getWorld().getName() + " (CIRCULAR)");
-                        continue;
-                    }
-                    PaperFileIOThread.LOGGER.error(indentStr + "  " + nx + "," + nz + " in " + chunkHolder.getWorld().getWorld().getName() + ":");
-                    dumpChunkInfo(seenChunks, neighbor, nx, nz, indent + 1, maxDepth);
-                }
-            }
-            // Paper end
-        }
+        // Paper - rewrite chunk system
     }
 
     public static void processConfiguration(GlobalConfiguration.AsyncChunks config) {
diff --git a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
new file mode 100644
index 0000000000000000000000000000000000000000..25ae685b4c849a481bd7065219b2f952cc8d5e49
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
@@ -0,0 +1,712 @@
+package io.papermc.paper.chunk.system.entity;
+
+import com.google.common.collect.Iterables;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.util.CoordinateUtils;
+import io.papermc.paper.util.TickThread;
+import io.papermc.paper.util.WorldUtil;
+import io.papermc.paper.world.ChunkEntitySlices;
+import it.unimi.dsi.fastutil.ints.Int2ReferenceOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Object2ReferenceOpenHashMap;
+import net.minecraft.core.BlockPos;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.level.entity.EntityInLevelCallback;
+import net.minecraft.world.level.entity.EntityTypeTest;
+import net.minecraft.world.level.entity.LevelCallback;
+import net.minecraft.world.level.entity.LevelEntityGetter;
+import net.minecraft.world.level.entity.Visibility;
+import net.minecraft.world.phys.AABB;
+import org.jetbrains.annotations.Nullable;
+import org.slf4j.Logger;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+import java.util.concurrent.locks.StampedLock;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+
+public final class EntityLookup implements LevelEntityGetter<Entity> {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    protected static final int REGION_SHIFT = 5;
+    protected static final int REGION_MASK = (1 << REGION_SHIFT) - 1;
+    protected static final int REGION_SIZE = 1 << REGION_SHIFT;
+
+    public final ServerLevel world;
+
+    private final StampedLock stateLock = new StampedLock();
+    protected final Long2ObjectOpenHashMap<ChunkSlicesRegion> regions = new Long2ObjectOpenHashMap<>(128, 0.5f);
+
+    private final int minSection; // inclusive
+    private final int maxSection; // inclusive
+    private final LevelCallback<Entity> worldCallback;
+
+    private final StampedLock entityByLock = new StampedLock();
+    private final Int2ReferenceOpenHashMap<Entity> entityById = new Int2ReferenceOpenHashMap<>();
+    private final Object2ReferenceOpenHashMap<UUID, Entity> entityByUUID = new Object2ReferenceOpenHashMap<>();
+
+    public EntityLookup(final ServerLevel world, final LevelCallback<Entity> worldCallback) {
+        this.world = world;
+        this.minSection = WorldUtil.getMinSection(world);
+        this.maxSection = WorldUtil.getMaxSection(world);
+        this.worldCallback = worldCallback;
+    }
+
+    @Nullable
+    @Override
+    public Entity get(final int id) {
+        final long attempt = this.entityByLock.tryOptimisticRead();
+        if (attempt != 0L) {
+            try {
+                final Entity ret = this.entityById.get(id);
+
+                if (this.entityByLock.validate(attempt)) {
+                    return ret;
+                }
+            } catch (final Error error) {
+                throw error;
+            } catch (final Throwable thr) {
+                // ignore
+            }
+        }
+
+        this.entityByLock.readLock();
+        try {
+            return this.entityById.get(id);
+        } finally {
+            this.entityByLock.tryUnlockRead();
+        }
+    }
+
+    @Nullable
+    @Override
+    public Entity get(final UUID id) {
+        final long attempt = this.entityByLock.tryOptimisticRead();
+        if (attempt != 0L) {
+            try {
+                final Entity ret = this.entityByUUID.get(id);
+
+                if (this.entityByLock.validate(attempt)) {
+                    return ret;
+                }
+            } catch (final Error error) {
+                throw error;
+            } catch (final Throwable thr) {
+                // ignore
+            }
+        }
+
+        this.entityByLock.readLock();
+        try {
+            return this.entityByUUID.get(id);
+        } finally {
+            this.entityByLock.tryUnlockRead();
+        }
+    }
+
+    public boolean hasEntity(final UUID uuid) {
+        return this.get(uuid) != null;
+    }
+
+    public String getDebugInfo() {
+        return "count_id:" + this.entityById.size() + ",count_uuid:" + this.entityByUUID.size() + ",region_count:" + this.regions.size();
+    }
+
+    @Override
+    public Iterable<Entity> getAll() {
+        return Iterables.unmodifiableIterable(this.entityById.values());
+    }
+
+    @Override
+    public <U extends Entity> void get(final EntityTypeTest<Entity, U> filter, final Consumer<U> action) {
+        for (final Entity entity : this.entityById.values()) {
+            final U casted = filter.tryCast(entity);
+            if (casted != null) {
+                action.accept(casted);
+            }
+        }
+    }
+
+    @Override
+    public void get(final AABB box, final Consumer<Entity> action) {
+        List<Entity> entities = new ArrayList<>();
+        this.getEntitiesWithoutDragonParts(null, box, entities, null);
+        for (int i = 0, len = entities.size(); i < len; ++i) {
+            action.accept(entities.get(i));
+        }
+    }
+
+    @Override
+    public void get(final AABB box, final Consumer<Entity> action, final boolean isContainerSearch) {
+        this.get(box, action); // container search needs to be reworked
+    }
+
+    @Override
+    public <U extends Entity> void get(final EntityTypeTest<Entity, U> filter, final AABB box, final Consumer<U> action) {
+        List<Entity> entities = new ArrayList<>();
+        this.getEntitiesWithoutDragonParts(null, box, entities, null);
+        for (int i = 0, len = entities.size(); i < len; ++i) {
+            final U casted = filter.tryCast(entities.get(i));
+            if (casted != null) {
+                action.accept(casted);
+            }
+        }
+    }
+
+    public void chunkStatusChange(final int x, final int z, final ChunkHolder.FullChunkStatus newStatus) {
+        final ChunkEntitySlices slices = this.getChunk(x, z);
+        if (slices != null) {
+            slices.updateStatus(newStatus, this.worldCallback);
+        }
+    }
+
+    public void addLegacyChunkEntities(final List<Entity> entities) {
+        for (int i = 0, len = entities.size(); i < len; ++i) {
+            this.addEntity(entities.get(i), true);
+        }
+    }
+
+    public void addEntityChunkEntities(final List<Entity> entities) {
+        for (int i = 0, len = entities.size(); i < len; ++i) {
+            this.addEntity(entities.get(i), true);
+        }
+    }
+
+    public void addWorldGenChunkEntities(final List<Entity> entities) {
+        for (int i = 0, len = entities.size(); i < len; ++i) {
+            this.addEntity(entities.get(i), false);
+        }
+    }
+
+    public boolean addNewEntity(final Entity entity) {
+        return this.addEntity(entity, false);
+    }
+
+    public static Visibility getEntityStatus(final Entity entity) {
+        if (entity.isAlwaysTicking()) {
+            return Visibility.TICKING;
+        }
+        final ChunkHolder.FullChunkStatus entityStatus = entity.chunkStatus;
+        return Visibility.fromFullChunkStatus(entityStatus == null ? ChunkHolder.FullChunkStatus.INACCESSIBLE : entityStatus);
+    }
+
+    private boolean addEntity(final Entity entity, final boolean fromDisk) {
+        final BlockPos pos = entity.blockPosition();
+        final int sectionX = pos.getX() >> 4;
+        final int sectionY = Mth.clamp(pos.getY() >> 4, this.minSection, this.maxSection);
+        final int sectionZ = pos.getZ() >> 4;
+        TickThread.ensureTickThread(sectionX, sectionZ, "Cannot add entity off-main thread");
+        this.entityByLock.writeLock();
+        try {
+            if (entity.isRemoved()) {
+                LOGGER.warn("Refusing to add removed entity: " + entity);
+                return false;
+            }
+            // TODO duplicate entity id config
+            // TODO what about if chunk slices contains entity
+            // TODO players will force-add
+            // TODO what if they're the same entity
+            if (this.entityById.containsKey(entity.getId())) {
+                LOGGER.warn("Entity id already exists: " + entity.getId() + ", mapped to " + this.entityById.get(entity.getId()) + ", can't add " + entity, new Throwable());
+                return false;
+            }
+            if (this.entityByUUID.containsKey(entity.getUUID())) {
+                LOGGER.warn("Entity uuid already exists: " + entity.getUUID() + ", mapped to " + this.entityByUUID.get(entity.getUUID()) + ", can't add " + entity, new Throwable());
+                return false;
+            }
+            this.entityById.put(entity.getId(), entity);
+            this.entityByUUID.put(entity.getUUID(), entity);
+        } finally {
+            this.entityByLock.tryUnlockWrite();
+        }
+
+        entity.sectionX = sectionX;
+        entity.sectionY = sectionY;
+        entity.sectionZ = sectionZ;
+        final ChunkEntitySlices slices = this.getOrCreateChunk(sectionX, sectionZ);
+        slices.addEntity(entity, sectionY);
+
+        entity.setLevelCallback(new EntityCallback(entity));
+
+        if (!fromDisk) {
+            this.worldCallback.onCreated(entity);
+        }
+
+        final Visibility visibility = getEntityStatus(entity);
+
+        this.worldCallback.onTrackingStart(entity);
+
+        if (visibility.isTicking()) {
+            this.worldCallback.onTickingStart(entity);
+        }
+
+        return true;
+    }
+
+    private void removeEntity(final Entity entity) {
+        final int sectionX = entity.sectionX;
+        final int sectionY = entity.sectionY;
+        final int sectionZ = entity.sectionZ;
+        TickThread.ensureTickThread(sectionX, sectionZ, "Cannot remove entity off-main");
+        if (!entity.isRemoved()) {
+            throw new IllegalStateException("Only call Entity#setRemoved to remove an entity");
+        }
+        final ChunkEntitySlices slices = this.getChunk(sectionX, sectionZ);
+        // all entities should be in a chunk
+        if (slices == null) {
+            LOGGER.warn("Cannot remove entity " + entity + " from null entity slices (" + sectionX + "," + sectionZ + ")");
+        } else {
+            if (!slices.removeEntity(entity, sectionY)) {
+                LOGGER.warn("Failed to remove entity " + entity + " from entity slices (" + sectionX + "," + sectionZ + ")");
+            }
+        }
+        entity.sectionX = entity.sectionY = entity.sectionZ = Integer.MIN_VALUE;
+
+        this.entityByLock.writeLock();
+        try {
+            if (!this.entityById.remove(entity.getId(), entity)) {
+                LOGGER.warn("Failed to remove entity " + entity + " by id, current entity mapped: " + this.entityById.get(entity.getId()));
+            }
+            if (!this.entityByUUID.remove(entity.getUUID(), entity)) {
+                LOGGER.warn("Failed to remove entity " + entity + " by uuid, current entity mapped: " + this.entityByUUID.get(entity.getUUID()));
+            }
+        } finally {
+            this.entityByLock.tryUnlockWrite();
+        }
+    }
+
+    public void moveEntity(final Entity entity) {
+        final BlockPos newPos = entity.blockPosition();
+        final int newSectionX = newPos.getX() >> 4;
+        final int newSectionY = Mth.clamp(newPos.getY() >> 4, this.minSection, this.maxSection);
+        final int newSectionZ = newPos.getZ() >> 4;
+
+        if (newSectionX == entity.sectionX && newSectionY == entity.sectionY && newSectionZ == entity.sectionZ) {
+            return;
+        }
+
+        TickThread.ensureTickThread(newSectionX, newSectionZ, "Cannot move entity off-main");
+        TickThread.ensureTickThread(entity.sectionX, entity.sectionZ, "Cannot move entity off-main");
+
+        final ChunkEntitySlices old = this.getChunk(entity.sectionX, entity.sectionZ);
+        final ChunkEntitySlices slices = this.getOrCreateChunk(newSectionX, newSectionZ);
+
+        // are we changing chunks?
+        if (newSectionX != entity.sectionX || newSectionZ != entity.sectionZ) {
+            old.removeEntity(entity, entity.sectionY);
+
+            slices.addEntity(entity, newSectionY);
+
+            entity.sectionX = newSectionX;
+            entity.sectionY = newSectionY;
+            entity.sectionZ = newSectionZ;
+        } else {
+            // same chunk
+            slices.removeEntity(entity, entity.sectionY);
+            slices.addEntity(entity, newSectionY);
+            entity.sectionY = newSectionY;
+        }
+    }
+
+    public void getEntitiesWithoutDragonParts(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
+        final int minChunkX = (Mth.floor(box.minX) - 2) >> 4;
+        final int minChunkZ = (Mth.floor(box.minZ) - 2) >> 4;
+        final int maxChunkX = (Mth.floor(box.maxX) + 2) >> 4;
+        final int maxChunkZ = (Mth.floor(box.maxZ) + 2) >> 4;
+
+        final int minRegionX = minChunkX >> REGION_SHIFT;
+        final int minRegionZ = minChunkZ >> REGION_SHIFT;
+        final int maxRegionX = maxChunkX >> REGION_SHIFT;
+        final int maxRegionZ = maxChunkZ >> REGION_SHIFT;
+
+        for (int currRegionZ = minRegionZ; currRegionZ <= maxRegionZ; ++currRegionZ) {
+            final int minZ = currRegionZ == minRegionZ ? minChunkZ & REGION_MASK : 0;
+            final int maxZ = currRegionZ == maxRegionZ ? maxChunkZ & REGION_MASK : REGION_MASK;
+
+            for (int currRegionX = minRegionX; currRegionX <= maxRegionX; ++currRegionX) {
+                final ChunkSlicesRegion region = this.getRegion(currRegionX, currRegionZ);
+
+                if (region == null) {
+                    continue;
+                }
+
+                final int minX = currRegionX == minRegionX ? minChunkX & REGION_MASK : 0;
+                final int maxX = currRegionX == maxRegionX ? maxChunkX & REGION_MASK : REGION_MASK;
+
+                for (int currZ = minZ; currZ <= maxZ; ++currZ) {
+                    for (int currX = minX; currX <= maxX; ++currX) {
+                        final ChunkEntitySlices chunk = region.get(currX | (currZ << REGION_SHIFT));
+                        if (chunk == null || !chunk.status.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                            continue;
+                        }
+
+                        chunk.getEntitiesWithoutDragonParts(except, box, into, predicate);
+                    }
+                }
+            }
+        }
+    }
+
+    public void getEntities(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
+        final int minChunkX = (Mth.floor(box.minX) - 2) >> 4;
+        final int minChunkZ = (Mth.floor(box.minZ) - 2) >> 4;
+        final int maxChunkX = (Mth.floor(box.maxX) + 2) >> 4;
+        final int maxChunkZ = (Mth.floor(box.maxZ) + 2) >> 4;
+
+        final int minRegionX = minChunkX >> REGION_SHIFT;
+        final int minRegionZ = minChunkZ >> REGION_SHIFT;
+        final int maxRegionX = maxChunkX >> REGION_SHIFT;
+        final int maxRegionZ = maxChunkZ >> REGION_SHIFT;
+
+        for (int currRegionZ = minRegionZ; currRegionZ <= maxRegionZ; ++currRegionZ) {
+            final int minZ = currRegionZ == minRegionZ ? minChunkZ & REGION_MASK : 0;
+            final int maxZ = currRegionZ == maxRegionZ ? maxChunkZ & REGION_MASK : REGION_MASK;
+
+            for (int currRegionX = minRegionX; currRegionX <= maxRegionX; ++currRegionX) {
+                final ChunkSlicesRegion region = this.getRegion(currRegionX, currRegionZ);
+
+                if (region == null) {
+                    continue;
+                }
+
+                final int minX = currRegionX == minRegionX ? minChunkX & REGION_MASK : 0;
+                final int maxX = currRegionX == maxRegionX ? maxChunkX & REGION_MASK : REGION_MASK;
+
+                for (int currZ = minZ; currZ <= maxZ; ++currZ) {
+                    for (int currX = minX; currX <= maxX; ++currX) {
+                        final ChunkEntitySlices chunk = region.get(currX | (currZ << REGION_SHIFT));
+                        if (chunk == null || !chunk.status.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                            continue;
+                        }
+
+                        chunk.getEntities(except, box, into, predicate);
+                    }
+                }
+            }
+        }
+    }
+
+    public void getHardCollidingEntities(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
+        final int minChunkX = (Mth.floor(box.minX) - 2) >> 4;
+        final int minChunkZ = (Mth.floor(box.minZ) - 2) >> 4;
+        final int maxChunkX = (Mth.floor(box.maxX) + 2) >> 4;
+        final int maxChunkZ = (Mth.floor(box.maxZ) + 2) >> 4;
+
+        final int minRegionX = minChunkX >> REGION_SHIFT;
+        final int minRegionZ = minChunkZ >> REGION_SHIFT;
+        final int maxRegionX = maxChunkX >> REGION_SHIFT;
+        final int maxRegionZ = maxChunkZ >> REGION_SHIFT;
+
+        for (int currRegionZ = minRegionZ; currRegionZ <= maxRegionZ; ++currRegionZ) {
+            final int minZ = currRegionZ == minRegionZ ? minChunkZ & REGION_MASK : 0;
+            final int maxZ = currRegionZ == maxRegionZ ? maxChunkZ & REGION_MASK : REGION_MASK;
+
+            for (int currRegionX = minRegionX; currRegionX <= maxRegionX; ++currRegionX) {
+                final ChunkSlicesRegion region = this.getRegion(currRegionX, currRegionZ);
+
+                if (region == null) {
+                    continue;
+                }
+
+                final int minX = currRegionX == minRegionX ? minChunkX & REGION_MASK : 0;
+                final int maxX = currRegionX == maxRegionX ? maxChunkX & REGION_MASK : REGION_MASK;
+
+                for (int currZ = minZ; currZ <= maxZ; ++currZ) {
+                    for (int currX = minX; currX <= maxX; ++currX) {
+                        final ChunkEntitySlices chunk = region.get(currX | (currZ << REGION_SHIFT));
+                        if (chunk == null || !chunk.status.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                            continue;
+                        }
+
+                        chunk.getHardCollidingEntities(except, box, into, predicate);
+                    }
+                }
+            }
+        }
+    }
+
+    public <T extends Entity> void getEntities(final EntityType<?> type, final AABB box, final List<? super T> into,
+                                               final Predicate<? super T> predicate) {
+        final int minChunkX = (Mth.floor(box.minX) - 2) >> 4;
+        final int minChunkZ = (Mth.floor(box.minZ) - 2) >> 4;
+        final int maxChunkX = (Mth.floor(box.maxX) + 2) >> 4;
+        final int maxChunkZ = (Mth.floor(box.maxZ) + 2) >> 4;
+
+        final int minRegionX = minChunkX >> REGION_SHIFT;
+        final int minRegionZ = minChunkZ >> REGION_SHIFT;
+        final int maxRegionX = maxChunkX >> REGION_SHIFT;
+        final int maxRegionZ = maxChunkZ >> REGION_SHIFT;
+
+        for (int currRegionZ = minRegionZ; currRegionZ <= maxRegionZ; ++currRegionZ) {
+            final int minZ = currRegionZ == minRegionZ ? minChunkZ & REGION_MASK : 0;
+            final int maxZ = currRegionZ == maxRegionZ ? maxChunkZ & REGION_MASK : REGION_MASK;
+
+            for (int currRegionX = minRegionX; currRegionX <= maxRegionX; ++currRegionX) {
+                final ChunkSlicesRegion region = this.getRegion(currRegionX, currRegionZ);
+
+                if (region == null) {
+                    continue;
+                }
+
+                final int minX = currRegionX == minRegionX ? minChunkX & REGION_MASK : 0;
+                final int maxX = currRegionX == maxRegionX ? maxChunkX & REGION_MASK : REGION_MASK;
+
+                for (int currZ = minZ; currZ <= maxZ; ++currZ) {
+                    for (int currX = minX; currX <= maxX; ++currX) {
+                        final ChunkEntitySlices chunk = region.get(currX | (currZ << REGION_SHIFT));
+                        if (chunk == null || !chunk.status.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                            continue;
+                        }
+
+                        chunk.getEntities(type, box, (List)into, (Predicate)predicate);
+                    }
+                }
+            }
+        }
+    }
+
+    public <T extends Entity> void getEntities(final Class<? extends T> clazz, final Entity except, final AABB box, final List<? super T> into,
+                                               final Predicate<? super T> predicate) {
+        final int minChunkX = (Mth.floor(box.minX) - 2) >> 4;
+        final int minChunkZ = (Mth.floor(box.minZ) - 2) >> 4;
+        final int maxChunkX = (Mth.floor(box.maxX) + 2) >> 4;
+        final int maxChunkZ = (Mth.floor(box.maxZ) + 2) >> 4;
+
+        final int minRegionX = minChunkX >> REGION_SHIFT;
+        final int minRegionZ = minChunkZ >> REGION_SHIFT;
+        final int maxRegionX = maxChunkX >> REGION_SHIFT;
+        final int maxRegionZ = maxChunkZ >> REGION_SHIFT;
+
+        for (int currRegionZ = minRegionZ; currRegionZ <= maxRegionZ; ++currRegionZ) {
+            final int minZ = currRegionZ == minRegionZ ? minChunkZ & REGION_MASK : 0;
+            final int maxZ = currRegionZ == maxRegionZ ? maxChunkZ & REGION_MASK : REGION_MASK;
+
+            for (int currRegionX = minRegionX; currRegionX <= maxRegionX; ++currRegionX) {
+                final ChunkSlicesRegion region = this.getRegion(currRegionX, currRegionZ);
+
+                if (region == null) {
+                    continue;
+                }
+
+                final int minX = currRegionX == minRegionX ? minChunkX & REGION_MASK : 0;
+                final int maxX = currRegionX == maxRegionX ? maxChunkX & REGION_MASK : REGION_MASK;
+
+                for (int currZ = minZ; currZ <= maxZ; ++currZ) {
+                    for (int currX = minX; currX <= maxX; ++currX) {
+                        final ChunkEntitySlices chunk = region.get(currX | (currZ << REGION_SHIFT));
+                        if (chunk == null || !chunk.status.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                            continue;
+                        }
+
+                        chunk.getEntities(clazz, except, box, into, predicate);
+                    }
+                }
+            }
+        }
+    }
+
+    public void entitySectionLoad(final int chunkX, final int chunkZ, final ChunkEntitySlices slices) {
+        TickThread.ensureTickThread(chunkX, chunkZ, "Cannot load in entity section off-main");
+        synchronized (this) {
+            final ChunkEntitySlices curr = this.getChunk(chunkX, chunkZ);
+            if (curr != null) {
+                this.removeChunk(chunkX, chunkZ);
+
+                curr.mergeInto(slices);
+
+                this.addChunk(chunkX, chunkZ, slices);
+            } else {
+                this.addChunk(chunkX, chunkZ, slices);
+            }
+        }
+    }
+
+    public void entitySectionUnload(final int chunkX, final int chunkZ) {
+        TickThread.ensureTickThread(chunkX, chunkZ, "Cannot unload entity section off-main");
+        this.removeChunk(chunkX, chunkZ);
+    }
+
+    public ChunkEntitySlices getChunk(final int chunkX, final int chunkZ) {
+        final ChunkSlicesRegion region = this.getRegion(chunkX >> REGION_SHIFT, chunkZ >> REGION_SHIFT);
+        if (region == null) {
+            return null;
+        }
+
+        return region.get((chunkX & REGION_MASK) | ((chunkZ & REGION_MASK) << REGION_SHIFT));
+    }
+
+    public ChunkEntitySlices getOrCreateChunk(final int chunkX, final int chunkZ) {
+        final ChunkSlicesRegion region = this.getRegion(chunkX >> REGION_SHIFT, chunkZ >> REGION_SHIFT);
+        ChunkEntitySlices ret;
+        if (region == null || (ret = region.get((chunkX & REGION_MASK) | ((chunkZ & REGION_MASK) << REGION_SHIFT))) == null) {
+            // loadInEntityChunk will call addChunk for us
+            return this.world.chunkTaskScheduler.chunkHolderManager.getOrCreateEntityChunk(chunkX, chunkZ, true);
+        }
+
+        return ret;
+    }
+
+    public ChunkSlicesRegion getRegion(final int regionX, final int regionZ) {
+        final long key = CoordinateUtils.getChunkKey(regionX, regionZ);
+        final long attempt = this.stateLock.tryOptimisticRead();
+        if (attempt != 0L) {
+            try {
+                final ChunkSlicesRegion ret = this.regions.get(key);
+
+                if (this.stateLock.validate(attempt)) {
+                    return ret;
+                }
+            } catch (final Error error) {
+                throw error;
+            } catch (final Throwable thr) {
+                // ignore
+            }
+        }
+
+        this.stateLock.readLock();
+        try {
+            return this.regions.get(key);
+        } finally {
+            this.stateLock.tryUnlockRead();
+        }
+    }
+
+    private synchronized void removeChunk(final int chunkX, final int chunkZ) {
+        final long key = CoordinateUtils.getChunkKey(chunkX >> REGION_SHIFT, chunkZ >> REGION_SHIFT);
+        final int relIndex = (chunkX & REGION_MASK) | ((chunkZ & REGION_MASK) << REGION_SHIFT);
+
+        final ChunkSlicesRegion region = this.regions.get(key);
+        final int remaining = region.remove(relIndex);
+
+        if (remaining == 0) {
+            this.stateLock.writeLock();
+            try {
+                this.regions.remove(key);
+            } finally {
+                this.stateLock.tryUnlockWrite();
+            }
+        }
+    }
+
+    public synchronized void addChunk(final int chunkX, final int chunkZ, final ChunkEntitySlices slices) {
+        final long key = CoordinateUtils.getChunkKey(chunkX >> REGION_SHIFT, chunkZ >> REGION_SHIFT);
+        final int relIndex = (chunkX & REGION_MASK) | ((chunkZ & REGION_MASK) << REGION_SHIFT);
+
+        ChunkSlicesRegion region = this.regions.get(key);
+        if (region != null) {
+            region.add(relIndex, slices);
+        } else {
+            region = new ChunkSlicesRegion();
+            region.add(relIndex, slices);
+            this.stateLock.writeLock();
+            try {
+                this.regions.put(key, region);
+            } finally {
+                this.stateLock.tryUnlockWrite();
+            }
+        }
+    }
+
+    public static final class ChunkSlicesRegion {
+
+        protected final ChunkEntitySlices[] slices = new ChunkEntitySlices[REGION_SIZE * REGION_SIZE];
+        protected int sliceCount;
+
+        public ChunkEntitySlices get(final int index) {
+            return this.slices[index];
+        }
+
+        public int remove(final int index) {
+            final ChunkEntitySlices slices = this.slices[index];
+            if (slices == null) {
+                throw new IllegalStateException();
+            }
+
+            this.slices[index] = null;
+
+            return --this.sliceCount;
+        }
+
+        public void add(final int index, final ChunkEntitySlices slices) {
+            final ChunkEntitySlices curr = this.slices[index];
+            if (curr != null) {
+                throw new IllegalStateException();
+            }
+
+            this.slices[index] = slices;
+
+            ++this.sliceCount;
+        }
+    }
+
+    private final class EntityCallback implements EntityInLevelCallback {
+
+        public final Entity entity;
+
+        public EntityCallback(final Entity entity) {
+            this.entity = entity;
+        }
+
+        @Override
+        public void onMove() {
+            final Entity entity = this.entity;
+            final Visibility oldVisibility = getEntityStatus(entity);
+            EntityLookup.this.moveEntity(this.entity);
+            final Visibility newVisibility = getEntityStatus(entity);
+            // too late to throw and stop the movement now, it's already happened
+
+            if (oldVisibility == newVisibility) {
+                return;
+            }
+
+            if (newVisibility.ordinal() > oldVisibility.ordinal()) {
+                // status upgrade
+                if (!oldVisibility.isTicking() && newVisibility.isTicking()) {
+                    EntityLookup.this.worldCallback.onTickingStart(entity);
+                }
+            } else {
+                // status downgrade
+                if (oldVisibility.isTicking() && !newVisibility.isTicking()) {
+                    EntityLookup.this.worldCallback.onTickingEnd(entity);
+                }
+            }
+        }
+
+        @Override
+        public void onRemove(final Entity.RemovalReason reason) {
+            io.papermc.paper.util.TickThread.ensureTickThread(entity.chunkPosition().x, entity.chunkPosition().z, "Cannot remove entity off-main"); // Paper - rewrite chunk system
+            final Visibility tickingState = EntityLookup.getEntityStatus(this.entity);
+
+            EntityLookup.this.removeEntity(this.entity);
+
+            if (tickingState.isTicking()) {
+                EntityLookup.this.worldCallback.onTickingEnd(this.entity);
+            }
+
+            EntityLookup.this.worldCallback.onTrackingEnd(this.entity);
+
+            if (reason.shouldDestroy()) {
+                EntityLookup.this.worldCallback.onDestroyed(this.entity);
+            }
+
+            this.entity.setLevelCallback(NoOpCallback.INSTANCE);
+        }
+    }
+
+    private static final class NoOpCallback implements EntityInLevelCallback {
+
+        public static final NoOpCallback INSTANCE = new NoOpCallback();
+
+        @Override
+        public void onMove() {}
+
+        @Override
+        public void onRemove(final Entity.RemovalReason reason) {}
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java b/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java
new file mode 100644
index 0000000000000000000000000000000000000000..560a8663f86a2f9e505609873ffc8c02d674e579
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java
@@ -0,0 +1,1308 @@
+package io.papermc.paper.chunk.system.io;
+
+import ca.spottedleaf.concurrentutil.collection.MultiThreadedQueue;
+import ca.spottedleaf.concurrentutil.executor.Cancellable;
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedQueueExecutorThread;
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedThreadedTaskQueue;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.util.CoordinateUtils;
+import io.papermc.paper.util.TickThread;
+import it.unimi.dsi.fastutil.HashCommon;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.storage.RegionFile;
+import net.minecraft.world.level.chunk.storage.RegionFileStorage;
+import org.slf4j.Logger;
+import java.io.IOException;
+import java.lang.invoke.VarHandle;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.BiConsumer;
+import java.util.function.BiFunction;
+import java.util.function.Consumer;
+import java.util.function.Function;
+
+/**
+ * Prioritised RegionFile I/O executor, responsible for all RegionFile access.
+ * <p>
+ *     All functions provided are MT-Safe, however certain ordering constraints are recommended:
+ *     <li>
+ *         Chunk saves may not occur for unloaded chunks.
+ *     </li>
+ *     <li>
+ *         Tasks must be scheduled on the chunk scheduler thread.
+ *     </li>
+ *     By following these constraints, no chunk data loss should occur with the exception of underlying I/O problems.
+ * </p>
+ */
+public final class RegionFileIOThread extends PrioritisedQueueExecutorThread {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    /**
+     * The kinds of region files controlled by the region file thread. Add more when needed, and ensure
+     * getControllerFor is updated.
+     */
+    public static enum RegionFileType {
+        CHUNK_DATA,
+        POI_DATA,
+        ENTITY_DATA;
+    }
+
+    protected static final RegionFileType[] CACHED_REGIONFILE_TYPES = RegionFileType.values();
+
+    private ChunkDataController getControllerFor(final ServerLevel world, final RegionFileType type) {
+        switch (type) {
+            case CHUNK_DATA:
+                return world.chunkDataControllerNew;
+            case POI_DATA:
+                return world.poiDataControllerNew;
+            case ENTITY_DATA:
+                return world.entityDataControllerNew;
+            default:
+                throw new IllegalStateException("Unknown controller type " + type);
+        }
+    }
+
+    /**
+     * Collects regionfile data for a certain chunk.
+     */
+    public static final class RegionFileData {
+
+        private final boolean[] hasResult = new boolean[CACHED_REGIONFILE_TYPES.length];
+        private final CompoundTag[] data = new CompoundTag[CACHED_REGIONFILE_TYPES.length];
+        private final Throwable[] throwables = new Throwable[CACHED_REGIONFILE_TYPES.length];
+
+        /**
+         * Sets the result associated with the specified regionfile type. Note that
+         * results can only be set once per regionfile type.
+         *
+         * @param type The regionfile type.
+         * @param data The result to set.
+         */
+        public void setData(final RegionFileType type, final CompoundTag data) {
+            final int index = type.ordinal();
+
+            if (this.hasResult[index]) {
+                throw new IllegalArgumentException("Result already exists for type " + type);
+            }
+            this.hasResult[index] = true;
+            this.data[index] = data;
+        }
+
+        /**
+         * Sets the result associated with the specified regionfile type. Note that
+         * results can only be set once per regionfile type.
+         *
+         * @param type The regionfile type.
+         * @param throwable The result to set.
+         */
+        public void setThrowable(final RegionFileType type, final Throwable throwable) {
+            final int index = type.ordinal();
+
+            if (this.hasResult[index]) {
+                throw new IllegalArgumentException("Result already exists for type " + type);
+            }
+            this.hasResult[index] = true;
+            this.throwables[index] = throwable;
+        }
+
+        /**
+         * Returns whether there is a result for the specified regionfile type.
+         *
+         * @param type Specified regionfile type.
+         *
+         * @return Whether a result exists for {@code type}.
+         */
+        public boolean hasResult(final RegionFileType type) {
+            return this.hasResult[type.ordinal()];
+        }
+
+        /**
+         * Returns the data result for the regionfile type.
+         *
+         * @param type Specified regionfile type.
+         *
+         * @throws IllegalArgumentException If the result has not been set for {@code type}.
+         * @return The data result for the specified type. If the result is a {@code Throwable},
+         * then returns {@code null}.
+         */
+        public CompoundTag getData(final RegionFileType type) {
+            final int index = type.ordinal();
+
+            if (!this.hasResult[index]) {
+                throw new IllegalArgumentException("Result does not exist for type " + type);
+            }
+
+            return this.data[index];
+        }
+
+        /**
+         * Returns the throwable result for the regionfile type.
+         *
+         * @param type Specified regionfile type.
+         *
+         * @throws IllegalArgumentException If the result has not been set for {@code type}.
+         * @return The throwable result for the specified type. If the result is an {@code CompoundTag},
+         * then returns {@code null}.
+         */
+        public Throwable getThrowable(final RegionFileType type) {
+            final int index = type.ordinal();
+
+            if (!this.hasResult[index]) {
+                throw new IllegalArgumentException("Result does not exist for type " + type);
+            }
+
+            return this.throwables[index];
+        }
+    }
+
+    private static final Object INIT_LOCK = new Object();
+
+    static RegionFileIOThread[] threads;
+
+    /* needs to be consistent given a set of parameters */
+    static RegionFileIOThread selectThread(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type) {
+        if (threads == null) {
+            throw new IllegalStateException("Threads not initialised");
+        }
+
+        final int regionX = chunkX >> 5;
+        final int regionZ = chunkZ >> 5;
+        final int typeOffset = type.ordinal();
+
+        return threads[(System.identityHashCode(world) + regionX + regionZ + typeOffset) % threads.length];
+    }
+
+    /**
+     * Shuts down the I/O executor(s). Watis for all tasks to complete if specified.
+     * Tasks queued during this call might not be accepted, and tasks queued after will not be accepted.
+     *
+     * @param wait Whether to wait until all tasks have completed.
+     */
+    public static void close(final boolean wait) {
+        for (int i = 0, len = threads.length; i < len; ++i) {
+            threads[i].close(false, true);
+        }
+        if (wait) {
+            RegionFileIOThread.flush();
+        }
+    }
+
+    public static long[] getExecutedTasks() {
+        final long[] ret = new long[threads.length];
+        for (int i = 0, len = threads.length; i < len; ++i) {
+            ret[i] = threads[i].getTotalTasksExecuted();
+        }
+
+        return ret;
+    }
+
+    public static long[] getTasksScheduled() {
+        final long[] ret = new long[threads.length];
+        for (int i = 0, len = threads.length; i < len; ++i) {
+            ret[i] = threads[i].getTotalTasksScheduled();
+        }
+        return ret;
+    }
+
+    public static void flush() {
+        for (int i = 0, len = threads.length; i < len; ++i) {
+            threads[i].waitUntilAllExecuted();
+        }
+    }
+
+    /**
+     * Inits the executor with the specified number of threads.
+     *
+     * @param threads Specified number of threads.
+     */
+    public static void init(final int threads) {
+        synchronized (INIT_LOCK) {
+            if (RegionFileIOThread.threads != null) {
+                throw new IllegalStateException("Already initialised threads");
+            }
+
+            RegionFileIOThread.threads = new RegionFileIOThread[threads];
+
+            for (int i = 0; i < threads; ++i) {
+                RegionFileIOThread.threads[i] = new RegionFileIOThread(i);
+                RegionFileIOThread.threads[i].start();
+            }
+        }
+    }
+
+    private RegionFileIOThread(final int threadNumber) {
+        super(new PrioritisedThreadedTaskQueue(), (int)(1.0e6)); // 1.0ms spinwait time
+        this.setName("RegionFile I/O Thread #" + threadNumber);
+        this.setPriority(Thread.NORM_PRIORITY - 2); // we keep priority close to normal because threads can wait on us
+        this.setUncaughtExceptionHandler((final Thread thread, final Throwable thr) -> {
+            LOGGER.error("Uncaught exception thrown from I/O thread, report this! Thread: " + thread.getName(), thr);
+        });
+    }
+
+    /**
+     * Returns whether the current thread is a regionfile I/O executor.
+     * @return Whether the current thread is a regionfile I/O executor.
+     */
+    public static boolean isRegionFileThread() {
+        return Thread.currentThread() instanceof RegionFileIOThread;
+    }
+
+    /**
+     * Returns the priority associated with blocking I/O based on the current thread. The goal is to avoid
+     * dumb plugins from taking away priority from threads we consider crucial.
+     * @return The priroity to use with blocking I/O on the current thread.
+     */
+    public static PrioritisedExecutor.Priority getIOBlockingPriorityForCurrentThread() {
+        if (TickThread.isTickThread()) {
+            return PrioritisedExecutor.Priority.BLOCKING;
+        }
+        return PrioritisedExecutor.Priority.HIGHEST;
+    }
+
+    /**
+     * Returns the current {@code CompoundTag} pending for write for the specified chunk & regionfile type.
+     * Note that this does not copy the result, so do not modify the result returned.
+     *
+     * @param world Specified world.
+     * @param chunkX Specified chunk x.
+     * @param chunkZ Specified chunk z.
+     * @param type Specified regionfile type.
+     *
+     * @return The compound tag associated for the specified chunk. {@code null} if no write was pending, or if {@code null} is the write pending.
+     */
+    public static CompoundTag getPendingWrite(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type) {
+        final RegionFileIOThread thread = RegionFileIOThread.selectThread(world, chunkX, chunkZ, type);
+        return thread.getPendingWriteInternal(world, chunkX, chunkZ, type);
+    }
+
+    CompoundTag getPendingWriteInternal(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type) {
+        final ChunkDataController taskController = this.getControllerFor(world, type);
+        final ChunkDataTask task = taskController.tasks.get(Long.valueOf(CoordinateUtils.getChunkKey(chunkX, chunkZ)));
+
+        if (task == null) {
+            return null;
+        }
+
+        final CompoundTag ret = task.inProgressWrite;
+
+        return ret == ChunkDataTask.NOTHING_TO_WRITE ? null : ret;
+    }
+
+    /**
+     * Returns the priority for the specified regionfile type for the specified chunk.
+     * @param world Specified world.
+     * @param chunkX Specified chunk x.
+     * @param chunkZ Specified chunk z.
+     * @param type Specified regionfile type.
+     * @return The priority for the chunk
+     */
+    public static PrioritisedExecutor.Priority getPriority(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type) {
+        final RegionFileIOThread thread = RegionFileIOThread.selectThread(world, chunkX, chunkZ, type);
+        return thread.getPriorityInternal(world, chunkX, chunkZ, type);
+    }
+
+    PrioritisedExecutor.Priority getPriorityInternal(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type) {
+        final ChunkDataController taskController = this.getControllerFor(world, type);
+        final ChunkDataTask task = taskController.tasks.get(Long.valueOf(CoordinateUtils.getChunkKey(chunkX, chunkZ)));
+
+        if (task == null) {
+            return PrioritisedExecutor.Priority.COMPLETING;
+        }
+
+        return task.prioritisedTask.getPriority();
+    }
+
+    /**
+     * Sets the priority for all regionfile types for the specified chunk. Note that great care should
+     * be taken using this method, as there can be multiple tasks tied to the same chunk that want different
+     * priorities.
+     *
+     * @param world Specified world.
+     * @param chunkX Specified chunk x.
+     * @param chunkZ Specified chunk z.
+     * @param priority New priority.
+     *
+     * @see #raisePriority(ServerLevel, int, int, Priority)
+     * @see #raisePriority(ServerLevel, int, int, RegionFileType, Priority)
+     * @see #lowerPriority(ServerLevel, int, int, Priority)
+     * @see #lowerPriority(ServerLevel, int, int, RegionFileType, Priority)
+     */
+    public static void setPriority(final ServerLevel world, final int chunkX, final int chunkZ,
+                                   final PrioritisedExecutor.Priority priority) {
+        for (final RegionFileType type : CACHED_REGIONFILE_TYPES) {
+            RegionFileIOThread.setPriority(world, chunkX, chunkZ, type, priority);
+        }
+    }
+
+    /**
+     * Sets the priority for the specified regionfile type for the specified chunk. Note that great care should
+     * be taken using this method, as there can be multiple tasks tied to the same chunk that want different
+     * priorities.
+     *
+     * @param world Specified world.
+     * @param chunkX Specified chunk x.
+     * @param chunkZ Specified chunk z.
+     * @param type Specified regionfile type.
+     * @param priority New priority.
+     *
+     * @see #raisePriority(ServerLevel, int, int, Priority)
+     * @see #raisePriority(ServerLevel, int, int, RegionFileType, Priority)
+     * @see #lowerPriority(ServerLevel, int, int, Priority)
+     * @see #lowerPriority(ServerLevel, int, int, RegionFileType, Priority)
+     */
+    public static void setPriority(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type,
+                                   final PrioritisedExecutor.Priority priority) {
+        final RegionFileIOThread thread = RegionFileIOThread.selectThread(world, chunkX, chunkZ, type);
+        thread.setPriorityInternal(world, chunkX, chunkZ, type, priority);
+    }
+
+    void setPriorityInternal(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type,
+                             final PrioritisedExecutor.Priority priority) {
+        final ChunkDataController taskController = this.getControllerFor(world, type);
+        final ChunkDataTask task = taskController.tasks.get(Long.valueOf(CoordinateUtils.getChunkKey(chunkX, chunkZ)));
+
+        if (task != null) {
+            task.prioritisedTask.setPriority(priority);
+        }
+    }
+
+    /**
+     * Raises the priority for all regionfile types for the specified chunk.
+     *
+     * @param world Specified world.
+     * @param chunkX Specified chunk x.
+     * @param chunkZ Specified chunk z.
+     * @param priority New priority.
+     *
+     * @see #setPriority(ServerLevel, int, int, Priority)
+     * @see #setPriority(ServerLevel, int, int, RegionFileType, Priority)
+     * @see #lowerPriority(ServerLevel, int, int, Priority)
+     * @see #lowerPriority(ServerLevel, int, int, RegionFileType, Priority)
+     */
+    public static void raisePriority(final ServerLevel world, final int chunkX, final int chunkZ,
+                                     final PrioritisedExecutor.Priority priority) {
+        for (final RegionFileType type : CACHED_REGIONFILE_TYPES) {
+            RegionFileIOThread.raisePriority(world, chunkX, chunkZ, type, priority);
+        }
+    }
+
+    /**
+     * Raises the priority for the specified regionfile type for the specified chunk.
+     *
+     * @param world Specified world.
+     * @param chunkX Specified chunk x.
+     * @param chunkZ Specified chunk z.
+     * @param type Specified regionfile type.
+     * @param priority New priority.
+     *
+     * @see #setPriority(ServerLevel, int, int, Priority)
+     * @see #setPriority(ServerLevel, int, int, RegionFileType, Priority)
+     * @see #lowerPriority(ServerLevel, int, int, Priority)
+     * @see #lowerPriority(ServerLevel, int, int, RegionFileType, Priority)
+     */
+    public static void raisePriority(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type,
+                                     final PrioritisedExecutor.Priority priority) {
+        final RegionFileIOThread thread = RegionFileIOThread.selectThread(world, chunkX, chunkZ, type);
+        thread.raisePriorityInternal(world, chunkX, chunkZ, type, priority);
+    }
+
+    void raisePriorityInternal(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type,
+                               final PrioritisedExecutor.Priority priority) {
+        final ChunkDataController taskController = this.getControllerFor(world, type);
+        final ChunkDataTask task = taskController.tasks.get(Long.valueOf(CoordinateUtils.getChunkKey(chunkX, chunkZ)));
+
+        if (task != null) {
+            task.prioritisedTask.raisePriority(priority);
+        }
+    }
+
+    /**
+     * Lowers the priority for all regionfile types for the specified chunk.
+     *
+     * @param world Specified world.
+     * @param chunkX Specified chunk x.
+     * @param chunkZ Specified chunk z.
+     * @param priority New priority.
+     *
+     * @see #raisePriority(ServerLevel, int, int, Priority)
+     * @see #raisePriority(ServerLevel, int, int, RegionFileType, Priority)
+     * @see #setPriority(ServerLevel, int, int, Priority)
+     * @see #setPriority(ServerLevel, int, int, RegionFileType, Priority)
+     */
+    public static void lowerPriority(final ServerLevel world, final int chunkX, final int chunkZ,
+                                     final PrioritisedExecutor.Priority priority) {
+        for (final RegionFileType type : CACHED_REGIONFILE_TYPES) {
+            RegionFileIOThread.lowerPriority(world, chunkX, chunkZ, type, priority);
+        }
+    }
+
+    /**
+     * Lowers the priority for the specified regionfile type for the specified chunk.
+     *
+     * @param world Specified world.
+     * @param chunkX Specified chunk x.
+     * @param chunkZ Specified chunk z.
+     * @param type Specified regionfile type.
+     * @param priority New priority.
+     *
+     * @see #raisePriority(ServerLevel, int, int, Priority)
+     * @see #raisePriority(ServerLevel, int, int, RegionFileType, Priority)
+     * @see #setPriority(ServerLevel, int, int, Priority)
+     * @see #setPriority(ServerLevel, int, int, RegionFileType, Priority)
+     */
+    public static void lowerPriority(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type,
+                                     final PrioritisedExecutor.Priority priority) {
+        final RegionFileIOThread thread = RegionFileIOThread.selectThread(world, chunkX, chunkZ, type);
+        thread.lowerPriorityInternal(world, chunkX, chunkZ, type, priority);
+    }
+
+    void lowerPriorityInternal(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type,
+                               final PrioritisedExecutor.Priority priority) {
+        final ChunkDataController taskController = this.getControllerFor(world, type);
+        final ChunkDataTask task = taskController.tasks.get(Long.valueOf(CoordinateUtils.getChunkKey(chunkX, chunkZ)));
+
+        if (task != null) {
+            task.prioritisedTask.lowerPriority(priority);
+        }
+    }
+
+    /**
+     * Schedules the chunk data to be written asynchronously.
+     * <p>
+     *     Impl notes:
+     * </p>
+     * <li>
+     *     This function presumes a chunk load for the coordinates is not called during this function (anytime after is OK). This means
+     *     saves must be scheduled before a chunk is unloaded.
+     * </li>
+     * <li>
+     *     Writes may be called concurrently, although only the "later" write will go through.
+     * </li>
+     *
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param data Chunk's data
+     * @param type The regionfile type to write to.
+     *
+     * @throws IllegalStateException If the file io thread has shutdown.
+     */
+    public static void scheduleSave(final ServerLevel world, final int chunkX, final int chunkZ, final CompoundTag data,
+                                    final RegionFileType type) {
+        RegionFileIOThread.scheduleSave(world, chunkX, chunkZ, data, type, PrioritisedExecutor.Priority.NORMAL);
+    }
+
+    /**
+     * Schedules the chunk data to be written asynchronously.
+     * <p>
+     *     Impl notes:
+     * </p>
+     * <li>
+     *     This function presumes a chunk load for the coordinates is not called during this function (anytime after is OK). This means
+     *     saves must be scheduled before a chunk is unloaded.
+     * </li>
+     * <li>
+     *     Writes may be called concurrently, although only the "later" write will go through.
+     * </li>
+     *
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param data Chunk's data
+     * @param type The regionfile type to write to.
+     * @param priority The minimum priority to schedule at.
+     *
+     * @throws IllegalStateException If the file io thread has shutdown.
+     */
+    public static void scheduleSave(final ServerLevel world, final int chunkX, final int chunkZ, final CompoundTag data,
+                                    final RegionFileType type, final PrioritisedExecutor.Priority priority) {
+        final RegionFileIOThread thread = RegionFileIOThread.selectThread(world, chunkX, chunkZ, type);
+        thread.scheduleSaveInternal(world, chunkX, chunkZ, data, type, priority);
+    }
+
+    void scheduleSaveInternal(final ServerLevel world, final int chunkX, final int chunkZ, final CompoundTag data,
+                              final RegionFileType type, final PrioritisedExecutor.Priority priority) {
+        final ChunkDataController taskController = this.getControllerFor(world, type);
+
+        final boolean[] created = new boolean[1];
+        final ChunkCoordinate key = new ChunkCoordinate(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+        final ChunkDataTask task = taskController.tasks.compute(key, (final ChunkCoordinate keyInMap, final ChunkDataTask taskRunning) -> {
+            if (taskRunning == null || taskRunning.failedWrite) {
+                // no task is scheduled or the previous write failed - meaning we need to overwrite it
+
+                // create task
+                final ChunkDataTask newTask = new ChunkDataTask(world, chunkX, chunkZ, taskController, RegionFileIOThread.this, priority);
+                newTask.inProgressWrite = data;
+                created[0] = true;
+
+                return newTask;
+            }
+
+            taskRunning.inProgressWrite = data;
+
+            return taskRunning;
+        });
+
+        if (created[0]) {
+            task.prioritisedTask.queue();
+        } else {
+            task.prioritisedTask.raisePriority(priority);
+        }
+    }
+
+    /**
+     * Schedules a load to be executed asynchronously. This task will load all regionfile types, and then call
+     * {@code onComplete}. This is a bulk load operation, see {@link #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean)}
+     * for single load.
+     * <p>
+     *     Impl notes:
+     * </p>
+     * <li>
+     *     The {@code onComplete} parameter may be completed during the execution of this function synchronously or it may
+     *     be completed asynchronously on this file io thread. Interacting with the file IO thread in the completion of
+     *     data is undefined behaviour, and can cause deadlock.
+     * </li>
+     *
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param onComplete Consumer to execute once this task has completed
+     * @param intendingToBlock Whether the caller is intending to block on completion. This only affects the cost
+     *                         of this call.
+     *
+     * @return The {@link Cancellable} for this chunk load. Cancelling it will not affect other loads for the same chunk data.
+     *
+     * @see #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean)
+     * @see #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean, Priority)
+     * @see #loadChunkData(ServerLevel, int, int, Consumer, boolean, RegionFileType...)
+     * @see #loadChunkData(ServerLevel, int, int, Consumer, boolean, Priority, RegionFileType...)
+     */
+    public static Cancellable loadAllChunkData(final ServerLevel world, final int chunkX, final int chunkZ,
+                                               final Consumer<RegionFileData> onComplete, final boolean intendingToBlock) {
+        return RegionFileIOThread.loadAllChunkData(world, chunkX, chunkZ, onComplete, intendingToBlock, PrioritisedExecutor.Priority.NORMAL);
+    }
+
+    /**
+     * Schedules a load to be executed asynchronously. This task will load all regionfile types, and then call
+     * {@code onComplete}. This is a bulk load operation, see {@link #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean, Priority)}
+     * for single load.
+     * <p>
+     *     Impl notes:
+     * </p>
+     * <li>
+     *     The {@code onComplete} parameter may be completed during the execution of this function synchronously or it may
+     *     be completed asynchronously on this file io thread. Interacting with the file IO thread in the completion of
+     *     data is undefined behaviour, and can cause deadlock.
+     * </li>
+     *
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param onComplete Consumer to execute once this task has completed
+     * @param intendingToBlock Whether the caller is intending to block on completion. This only affects the cost
+     *                         of this call.
+     * @param priority The minimum priority to load the data at.
+     *
+     * @return The {@link Cancellable} for this chunk load. Cancelling it will not affect other loads for the same chunk data.
+     *
+     * @see #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean)
+     * @see #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean, Priority)
+     * @see #loadChunkData(ServerLevel, int, int, Consumer, boolean, RegionFileType...)
+     * @see #loadChunkData(ServerLevel, int, int, Consumer, boolean, Priority, RegionFileType...)
+     */
+    public static Cancellable loadAllChunkData(final ServerLevel world, final int chunkX, final int chunkZ,
+                                               final Consumer<RegionFileData> onComplete, final boolean intendingToBlock,
+                                               final PrioritisedExecutor.Priority priority) {
+        return RegionFileIOThread.loadChunkData(world, chunkX, chunkZ, onComplete, intendingToBlock, priority, CACHED_REGIONFILE_TYPES);
+    }
+
+    /**
+     * Schedules a load to be executed asynchronously. This task will load data for the specified regionfile type(s), and
+     * then call {@code onComplete}. This is a bulk load operation, see {@link #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean)}
+     * for single load.
+     * <p>
+     *     Impl notes:
+     * </p>
+     * <li>
+     *     The {@code onComplete} parameter may be completed during the execution of this function synchronously or it may
+     *     be completed asynchronously on this file io thread. Interacting with the file IO thread in the completion of
+     *     data is undefined behaviour, and can cause deadlock.
+     * </li>
+     *
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param onComplete Consumer to execute once this task has completed
+     * @param intendingToBlock Whether the caller is intending to block on completion. This only affects the cost
+     *                         of this call.
+     * @param types The regionfile type(s) to load.
+     *
+     * @return The {@link Cancellable} for this chunk load. Cancelling it will not affect other loads for the same chunk data.
+     *
+     * @see #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean)
+     * @see #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean, Priority)
+     * @see #loadAllChunkData(ServerLevel, int, int, Consumer, boolean)
+     * @see #loadAllChunkData(ServerLevel, int, int, Consumer, boolean, Priority)
+     */
+    public static Cancellable loadChunkData(final ServerLevel world, final int chunkX, final int chunkZ,
+                                            final Consumer<RegionFileData> onComplete, final boolean intendingToBlock,
+                                            final RegionFileType... types) {
+        return RegionFileIOThread.loadChunkData(world, chunkX, chunkZ, onComplete, intendingToBlock, PrioritisedExecutor.Priority.NORMAL, types);
+    }
+
+    /**
+     * Schedules a load to be executed asynchronously. This task will load data for the specified regionfile type(s), and
+     * then call {@code onComplete}. This is a bulk load operation, see {@link #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean, Priority)}
+     * for single load.
+     * <p>
+     *     Impl notes:
+     * </p>
+     * <li>
+     *     The {@code onComplete} parameter may be completed during the execution of this function synchronously or it may
+     *     be completed asynchronously on this file io thread. Interacting with the file IO thread in the completion of
+     *     data is undefined behaviour, and can cause deadlock.
+     * </li>
+     *
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param onComplete Consumer to execute once this task has completed
+     * @param intendingToBlock Whether the caller is intending to block on completion. This only affects the cost
+     *                         of this call.
+     * @param types The regionfile type(s) to load.
+     * @param priority The minimum priority to load the data at.
+     *
+     * @return The {@link Cancellable} for this chunk load. Cancelling it will not affect other loads for the same chunk data.
+     *
+     * @see #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean)
+     * @see #loadDataAsync(ServerLevel, int, int, RegionFileType, BiConsumer, boolean, Priority)
+     * @see #loadAllChunkData(ServerLevel, int, int, Consumer, boolean)
+     * @see #loadAllChunkData(ServerLevel, int, int, Consumer, boolean, Priority)
+     */
+    public static Cancellable loadChunkData(final ServerLevel world, final int chunkX, final int chunkZ,
+                                            final Consumer<RegionFileData> onComplete, final boolean intendingToBlock,
+                                            final PrioritisedExecutor.Priority priority, final RegionFileType... types) {
+        if (types == null) {
+            throw new NullPointerException("Types cannot be null");
+        }
+        if (types.length == 0) {
+            throw new IllegalArgumentException("Types cannot be empty");
+        }
+
+        final RegionFileData ret = new RegionFileData();
+
+        final Cancellable[] reads = new CancellableRead[types.length];
+        final AtomicInteger completions = new AtomicInteger();
+        final int expectedCompletions = types.length;
+
+        for (int i = 0; i < expectedCompletions; ++i) {
+            final RegionFileType type = types[i];
+            reads[i] = RegionFileIOThread.loadDataAsync(world, chunkX, chunkZ, type,
+                (final CompoundTag data, final Throwable throwable) -> {
+                    if (throwable != null) {
+                        ret.setThrowable(type, throwable);
+                    } else {
+                        ret.setData(type, data);
+                    }
+
+                    if (completions.incrementAndGet() == expectedCompletions) {
+                        onComplete.accept(ret);
+                    }
+                }, intendingToBlock, priority);
+        }
+
+        return new CancellableReads(reads);
+    }
+
+    /**
+     * Schedules a load to be executed asynchronously. This task will load the specified regionfile type, and then call
+     * {@code onComplete}.
+     * <p>
+     *     Impl notes:
+     * </p>
+     * <li>
+     *     The {@code onComplete} parameter may be completed during the execution of this function synchronously or it may
+     *     be completed asynchronously on this file io thread. Interacting with the file IO thread in the completion of
+     *     data is undefined behaviour, and can cause deadlock.
+     * </li>
+     *
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param onComplete Consumer to execute once this task has completed
+     * @param intendingToBlock Whether the caller is intending to block on completion. This only affects the cost
+     *                         of this call.
+     *
+     * @return The {@link Cancellable} for this chunk load. Cancelling it will not affect other loads for the same chunk data.
+     *
+     * @see #loadChunkData(ServerLevel, int, int, Consumer, boolean, RegionFileType...)
+     * @see #loadChunkData(ServerLevel, int, int, Consumer, boolean, Priority, RegionFileType...)
+     * @see #loadAllChunkData(ServerLevel, int, int, Consumer, boolean)
+     * @see #loadAllChunkData(ServerLevel, int, int, Consumer, boolean, Priority)
+     */
+    public static Cancellable loadDataAsync(final ServerLevel world, final int chunkX, final int chunkZ,
+                                            final RegionFileType type, final BiConsumer<CompoundTag, Throwable> onComplete,
+                                            final boolean intendingToBlock) {
+        return RegionFileIOThread.loadDataAsync(world, chunkX, chunkZ, type, onComplete, intendingToBlock, PrioritisedExecutor.Priority.NORMAL);
+    }
+
+    /**
+     * Schedules a load to be executed asynchronously. This task will load the specified regionfile type, and then call
+     * {@code onComplete}.
+     * <p>
+     *     Impl notes:
+     * </p>
+     * <li>
+     *     The {@code onComplete} parameter may be completed during the execution of this function synchronously or it may
+     *     be completed asynchronously on this file io thread. Interacting with the file IO thread in the completion of
+     *     data is undefined behaviour, and can cause deadlock.
+     * </li>
+     *
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param onComplete Consumer to execute once this task has completed
+     * @param intendingToBlock Whether the caller is intending to block on completion. This only affects the cost
+     *                         of this call.
+     * @param priority Minimum priority to load the data at.
+     *
+     * @return The {@link Cancellable} for this chunk load. Cancelling it will not affect other loads for the same chunk data.
+     *
+     * @see #loadChunkData(ServerLevel, int, int, Consumer, boolean, RegionFileType...)
+     * @see #loadChunkData(ServerLevel, int, int, Consumer, boolean, Priority, RegionFileType...)
+     * @see #loadAllChunkData(ServerLevel, int, int, Consumer, boolean)
+     * @see #loadAllChunkData(ServerLevel, int, int, Consumer, boolean, Priority)
+     */
+    public static Cancellable loadDataAsync(final ServerLevel world, final int chunkX, final int chunkZ,
+                                            final RegionFileType type, final BiConsumer<CompoundTag, Throwable> onComplete,
+                                            final boolean intendingToBlock, final PrioritisedExecutor.Priority priority) {
+        final RegionFileIOThread thread = RegionFileIOThread.selectThread(world, chunkX, chunkZ, type);
+        return thread.loadDataAsyncInternal(world, chunkX, chunkZ, type, onComplete, intendingToBlock, priority);
+    }
+
+    private static Boolean doesRegionFileExist(final int chunkX, final int chunkZ, final boolean intendingToBlock,
+                                               final ChunkDataController taskController) {
+        final ChunkPos chunkPos = new ChunkPos(chunkX, chunkZ);
+        if (intendingToBlock) {
+            return taskController.computeForRegionFile(chunkX, chunkZ, true, (final RegionFile file) -> {
+                if (file == null) { // null if no regionfile exists
+                    return Boolean.FALSE;
+                }
+
+                return file.hasChunk(chunkPos) ? Boolean.TRUE : Boolean.FALSE;
+            });
+        } else {
+            return taskController.computeForRegionFileIfLoaded(chunkX, chunkZ, (final RegionFile file) -> {
+                if (file == null) { // null if not loaded
+                    return Boolean.TRUE;
+                }
+
+                return file.hasChunk(chunkPos) ? Boolean.TRUE : Boolean.FALSE;
+            });
+        }
+    }
+
+    Cancellable loadDataAsyncInternal(final ServerLevel world, final int chunkX, final int chunkZ,
+                                      final RegionFileType type, final BiConsumer<CompoundTag, Throwable> onComplete,
+                                      final boolean intendingToBlock, final PrioritisedExecutor.Priority priority) {
+        final ChunkDataController taskController = this.getControllerFor(world, type);
+
+        final ImmediateCallbackCompletion callbackInfo = new ImmediateCallbackCompletion();
+
+        final ChunkCoordinate key = new ChunkCoordinate(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+        final BiFunction<ChunkCoordinate, ChunkDataTask, ChunkDataTask> compute = (final ChunkCoordinate keyInMap, final ChunkDataTask running) -> {
+            if (running == null) {
+                // not scheduled
+
+                if (callbackInfo.regionFileCalculation == null) {
+                    // caller will compute this outside of compute(), to avoid holding the bin lock
+                    callbackInfo.needsRegionFileTest = true;
+                    return null;
+                }
+
+                if (callbackInfo.regionFileCalculation == Boolean.FALSE) {
+                    // not on disk
+                    callbackInfo.data = null;
+                    callbackInfo.throwable = null;
+                    callbackInfo.completeNow = true;
+                    return null;
+                }
+
+                // set up task
+                final ChunkDataTask newTask = new ChunkDataTask(
+                    world, chunkX, chunkZ, taskController, RegionFileIOThread.this, priority
+                );
+                newTask.inProgressRead = new RegionFileIOThread.InProgressRead();
+                newTask.inProgressRead.waiters.add(onComplete);
+
+                callbackInfo.tasksNeedsScheduling = true;
+                return newTask;
+            }
+
+            final CompoundTag pendingWrite = running.inProgressWrite;
+
+            if (pendingWrite == ChunkDataTask.NOTHING_TO_WRITE) {
+                // need to add to waiters here, because the regionfile thread will use compute() to lock and check for cancellations
+                if (!running.inProgressRead.addToWaiters(onComplete)) {
+                    callbackInfo.data = running.inProgressRead.value;
+                    callbackInfo.throwable = running.inProgressRead.throwable;
+                    callbackInfo.completeNow = true;
+                }
+                return running;
+            }
+            // using the result sync here - don't bump priority
+
+            // at this stage we have to use the in progress write's data to avoid an order issue
+            callbackInfo.data = pendingWrite;
+            callbackInfo.throwable = null;
+            callbackInfo.completeNow = true;
+            return running;
+        };
+
+        ChunkDataTask curr = taskController.tasks.get(key);
+        if (curr == null) {
+            callbackInfo.regionFileCalculation = doesRegionFileExist(chunkX, chunkZ, intendingToBlock, taskController);
+        }
+        ChunkDataTask ret = taskController.tasks.compute(key, compute);
+        if (callbackInfo.needsRegionFileTest) {
+            // curr isn't null but when we went into compute() it was
+            callbackInfo.regionFileCalculation = doesRegionFileExist(chunkX, chunkZ, intendingToBlock, taskController);
+            // now it should be fine
+            ret = taskController.tasks.compute(key, compute);
+        }
+
+        // needs to be scheduled
+        if (callbackInfo.tasksNeedsScheduling) {
+            ret.prioritisedTask.queue();
+        } else if (callbackInfo.completeNow) {
+            try {
+                onComplete.accept(callbackInfo.data, callbackInfo.throwable);
+            } catch (final ThreadDeath thr) {
+                throw thr;
+            } catch (final Throwable thr) {
+                LOGGER.error("Callback " + ConcurrentUtil.genericToString(onComplete) + " synchronously failed to handle chunk data for task " + ret.toString(), thr);
+            }
+        } else {
+            // we're waiting on a task we didn't schedule, so raise its priority to what we want
+            ret.prioritisedTask.raisePriority(priority);
+        }
+
+        return new CancellableRead(onComplete, ret);
+    }
+
+    /**
+     * Schedules a load task to be executed asynchronously, and blocks on that task.
+     *
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param type Regionfile type
+     * @param priority Minimum priority to load the data at.
+     *
+     * @return The chunk data for the chunk. Note that a {@code null} result means the chunk or regionfile does not exist on disk.
+     *
+     * @throws IOException If the load fails for any reason
+     */
+    public static CompoundTag loadData(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileType type,
+                                       final PrioritisedExecutor.Priority priority) throws IOException {
+        final CompletableFuture<CompoundTag> ret = new CompletableFuture<>();
+
+        RegionFileIOThread.loadDataAsync(world, chunkX, chunkZ, type, (final CompoundTag compound, final Throwable thr) -> {
+            if (thr != null) {
+                ret.completeExceptionally(thr);
+            } else {
+                ret.complete(compound);
+            }
+        }, true, priority);
+
+        try {
+            return ret.join();
+        } catch (final CompletionException ex) {
+            throw new IOException(ex);
+        }
+    }
+
+    private static final class ImmediateCallbackCompletion {
+
+        public CompoundTag data;
+        public Throwable throwable;
+        public boolean completeNow;
+        public boolean tasksNeedsScheduling;
+        public boolean needsRegionFileTest;
+        public Boolean regionFileCalculation;
+
+    }
+
+    static final class CancellableRead implements Cancellable {
+
+        private BiConsumer<CompoundTag, Throwable> callback;
+        private RegionFileIOThread.ChunkDataTask task;
+
+        CancellableRead(final BiConsumer<CompoundTag, Throwable> callback, final RegionFileIOThread.ChunkDataTask task) {
+            this.callback = callback;
+            this.task = task;
+        }
+
+        @Override
+        public boolean cancel() {
+            final BiConsumer<CompoundTag, Throwable> callback = this.callback;
+            final RegionFileIOThread.ChunkDataTask task = this.task;
+
+            if (callback == null || task == null) {
+                return false;
+            }
+
+            this.callback = null;
+            this.task = null;
+
+            final RegionFileIOThread.InProgressRead read = task.inProgressRead;
+
+            // read can be null if no read was scheduled (i.e no regionfile existed or chunk in regionfile didn't)
+            return (read != null && read.waiters.remove(callback));
+        }
+    }
+
+    static final class CancellableReads implements Cancellable {
+
+        private Cancellable[] reads;
+
+        protected static final VarHandle READS_HANDLE = ConcurrentUtil.getVarHandle(CancellableReads.class, "reads", Cancellable[].class);
+
+        CancellableReads(final Cancellable[] reads) {
+            this.reads = reads;
+        }
+
+        @Override
+        public boolean cancel() {
+            final Cancellable[] reads = (Cancellable[])READS_HANDLE.getAndSet((CancellableReads)this, (Cancellable[])null);
+
+            if (reads == null) {
+                return false;
+            }
+
+            boolean ret = false;
+
+            for (final Cancellable read : reads) {
+                ret |= read.cancel();
+            }
+
+            return ret;
+        }
+    }
+
+    static final class InProgressRead {
+
+        private static final Logger LOGGER = LogUtils.getLogger();
+
+        CompoundTag value;
+        Throwable throwable;
+        final MultiThreadedQueue<BiConsumer<CompoundTag, Throwable>> waiters = new MultiThreadedQueue<>();
+
+        // rets false if already completed (callback not invoked), true if callback was added
+        boolean addToWaiters(final BiConsumer<CompoundTag, Throwable> callback) {
+            return this.waiters.add(callback);
+        }
+
+        void complete(final RegionFileIOThread.ChunkDataTask task, final CompoundTag value, final Throwable throwable) {
+            this.value = value;
+            this.throwable = throwable;
+
+            BiConsumer<CompoundTag, Throwable> consumer;
+            while ((consumer = this.waiters.pollOrBlockAdds()) != null) {
+                try {
+                    consumer.accept(value, throwable);
+                } catch (final ThreadDeath thr) {
+                    throw thr;
+                } catch (final Throwable thr) {
+                    LOGGER.error("Callback " + ConcurrentUtil.genericToString(consumer) + " failed to handle chunk data for task " + task.toString(), thr);
+                }
+            }
+        }
+    }
+
+    /**
+     * Class exists to replace {@link Long} usages as keys inside non-fastutil hashtables. The hash for some Long {@code x}
+     * is defined as {@code (x >>> 32) ^ x}. Chunk keys as long values are defined as {@code ((chunkX & 0xFFFFFFFFL) | (chunkZ << 32))},
+     * which means the hashcode as a Long value will be {@code chunkX ^ chunkZ}. Given that most chunks are created within a radius arounds players,
+     * this will lead to many hash collisions. So, this class uses a better hashing algorithm so that usage of
+     * non-fastutil collections is not degraded.
+     */
+    public static final class ChunkCoordinate implements Comparable<ChunkCoordinate> {
+
+        public final long key;
+
+        public ChunkCoordinate(final long key) {
+            this.key = key;
+        }
+
+        @Override
+        public int hashCode() {
+            return (int)HashCommon.mix(this.key);
+        }
+
+        @Override
+        public boolean equals(final Object obj) {
+            if (this == obj) {
+                return true;
+            }
+
+            if (!(obj instanceof ChunkCoordinate)) {
+                return false;
+            }
+
+            final ChunkCoordinate other = (ChunkCoordinate)obj;
+
+            return this.key == other.key;
+        }
+
+        // This class is intended for HashMap/ConcurrentHashMap usage, which do treeify bin nodes if the chain
+        // is too large. So we should implement compareTo to help.
+        @Override
+        public int compareTo(final RegionFileIOThread.ChunkCoordinate other) {
+            return Long.compare(this.key, other.key);
+        }
+
+        @Override
+        public String toString() {
+            return new ChunkPos(this.key).toString();
+        }
+    }
+
+    public static abstract class ChunkDataController {
+
+        // ConcurrentHashMap synchronizes per chain, so reduce the chance of task's hashes colliding.
+        protected final ConcurrentHashMap<ChunkCoordinate, ChunkDataTask> tasks = new ConcurrentHashMap<>(8192, 0.10f);
+
+        public final RegionFileType type;
+
+        public ChunkDataController(final RegionFileType type) {
+            this.type = type;
+        }
+
+        public abstract RegionFileStorage getCache();
+
+        public abstract void writeData(final int chunkX, final int chunkZ, final CompoundTag compound) throws IOException;
+
+        public abstract CompoundTag readData(final int chunkX, final int chunkZ) throws IOException;
+
+        public boolean hasTasks() {
+            return !this.tasks.isEmpty();
+        }
+
+        public <T> T computeForRegionFile(final int chunkX, final int chunkZ, final boolean existingOnly, final Function<RegionFile, T> function) {
+            final RegionFileStorage cache = this.getCache();
+            final RegionFile regionFile;
+            synchronized (cache) {
+                try {
+                    regionFile = cache.getRegionFile(new ChunkPos(chunkX, chunkZ), existingOnly, true);
+                } catch (final IOException ex) {
+                    throw new RuntimeException(ex);
+                }
+            }
+
+            try {
+                return function.apply(regionFile);
+            } finally {
+                if (regionFile != null) {
+                    regionFile.fileLock.unlock();
+                }
+            }
+        }
+
+        public <T> T computeForRegionFileIfLoaded(final int chunkX, final int chunkZ, final Function<RegionFile, T> function) {
+            final RegionFileStorage cache = this.getCache();
+            final RegionFile regionFile;
+
+            synchronized (cache) {
+                regionFile = cache.getRegionFileIfLoaded(new ChunkPos(chunkX, chunkZ));
+                if (regionFile != null) {
+                    regionFile.fileLock.lock();
+                }
+            }
+
+            try {
+                return function.apply(regionFile);
+            } finally {
+                if (regionFile != null) {
+                    regionFile.fileLock.unlock();
+                }
+            }
+        }
+    }
+
+    static final class ChunkDataTask implements Runnable {
+
+        protected static final CompoundTag NOTHING_TO_WRITE = new CompoundTag();
+
+        private static final Logger LOGGER = LogUtils.getLogger();
+
+        RegionFileIOThread.InProgressRead inProgressRead;
+        volatile CompoundTag inProgressWrite = NOTHING_TO_WRITE; // only needs to be acquire/release
+
+        boolean failedWrite;
+
+        final ServerLevel world;
+        final int chunkX;
+        final int chunkZ;
+        final RegionFileIOThread.ChunkDataController taskController;
+
+        final PrioritisedExecutor.PrioritisedTask prioritisedTask;
+
+        /*
+         * IO thread will perform reads before writes for a given chunk x and z
+         *
+         * How reads/writes are scheduled:
+         *
+         * If read is scheduled while scheduling write, take no special action and just schedule write
+         * If read is scheduled while scheduling read and no write is scheduled, chain the read task
+         *
+         *
+         * If write is scheduled while scheduling read, use the pending write data and ret immediately (so no read is scheduled)
+         * If write is scheduled while scheduling write (ignore read in progress), overwrite the write in progress data
+         *
+         * This allows the reads and writes to act as if they occur synchronously to the thread scheduling them, however
+         * it fails to properly propagate write failures thanks to writes overwriting each other
+         */
+
+        public ChunkDataTask(final ServerLevel world, final int chunkX, final int chunkZ, final RegionFileIOThread.ChunkDataController taskController,
+                             final PrioritisedExecutor executor, final PrioritisedExecutor.Priority priority) {
+            this.world = world;
+            this.chunkX = chunkX;
+            this.chunkZ = chunkZ;
+            this.taskController = taskController;
+            this.prioritisedTask = executor.createTask(this, priority);
+        }
+
+        @Override
+        public String toString() {
+            return "Task for world: '" + this.world.getWorld().getName() + "' at (" + this.chunkX + "," + this.chunkZ +
+                    ") type: " + this.taskController.type.name() + ", hash: " + this.hashCode();
+        }
+
+        @Override
+        public void run() {
+            final RegionFileIOThread.InProgressRead read = this.inProgressRead;
+            final ChunkCoordinate chunkKey = new ChunkCoordinate(CoordinateUtils.getChunkKey(this.chunkX, this.chunkZ));
+
+            if (read != null) {
+                final boolean[] canRead = new boolean[] { true };
+
+                if (read.waiters.isEmpty()) {
+                    // cancelled read? go to task controller to confirm
+                    final ChunkDataTask inMap = this.taskController.tasks.compute(chunkKey, (final ChunkCoordinate keyInMap, final ChunkDataTask valueInMap) -> {
+                        if (valueInMap == null) {
+                            throw new IllegalStateException("Write completed concurrently, expected this task: " + ChunkDataTask.this.toString() + ", report this!");
+                        }
+                        if (valueInMap != ChunkDataTask.this) {
+                            throw new IllegalStateException("Chunk task mismatch, expected this task: " + ChunkDataTask.this.toString() + ", got: " + valueInMap.toString() + ", report this!");
+                        }
+
+                        if (!read.waiters.isEmpty()) { // as per usual IntelliJ is unable to figure out that there are concurrent accesses.
+                            return valueInMap;
+                        } else {
+                            canRead[0] = false;
+                        }
+
+                        return valueInMap.inProgressWrite == NOTHING_TO_WRITE ? null : valueInMap;
+                    });
+
+                    if (inMap == null) {
+                        // read is cancelled - and no write pending, so we're done
+                        return;
+                    }
+                    // if there is a write in progress, we don't actually have to worry about waiters gaining new entries -
+                    // the readers will just use the in progress write, so the value in canRead is good to use without
+                    // further synchronisation.
+                }
+
+                if (canRead[0]) {
+                    CompoundTag compound = null;
+                    Throwable throwable = null;
+
+                    try {
+                        compound = this.taskController.readData(this.chunkX, this.chunkZ);
+                    } catch (final ThreadDeath thr) {
+                        throw thr;
+                    } catch (final Throwable thr) {
+                        throwable = thr;
+                        LOGGER.error("Failed to read chunk data for task: " + this.toString(), thr);
+                    }
+                    read.complete(this, compound, throwable);
+                }
+            }
+
+            CompoundTag write = this.inProgressWrite;
+
+            if (write == NOTHING_TO_WRITE) {
+                final ChunkDataTask inMap = this.taskController.tasks.compute(chunkKey, (final ChunkCoordinate keyInMap, final ChunkDataTask valueInMap) -> {
+                    if (valueInMap == null) {
+                        throw new IllegalStateException("Write completed concurrently, expected this task: " + ChunkDataTask.this.toString() + ", report this!");
+                    }
+                    if (valueInMap != ChunkDataTask.this) {
+                        throw new IllegalStateException("Chunk task mismatch, expected this task: " + ChunkDataTask.this.toString() + ", got: " + valueInMap.toString() + ", report this!");
+                    }
+                    return valueInMap.inProgressWrite == NOTHING_TO_WRITE ? null : valueInMap;
+                });
+
+                if (inMap == null) {
+                    return; // set the task value to null, indicating we're done
+                } // else: inProgressWrite changed, so now we have something to write
+            }
+
+            for (;;) {
+                write = this.inProgressWrite;
+                final CompoundTag dataWritten = write;
+
+                boolean failedWrite = false;
+
+                try {
+                    this.taskController.writeData(this.chunkX, this.chunkZ, write);
+                } catch (final ThreadDeath thr) {
+                    throw thr;
+                } catch (final Throwable thr) {
+                    if (thr instanceof RegionFileStorage.RegionFileSizeException) {
+                        final int maxSize = RegionFile.MAX_CHUNK_SIZE / (1024 * 1024);
+                        LOGGER.error("Chunk at (" + this.chunkX + "," + this.chunkZ + ") in '" + this.world.getWorld().getName() + "' exceeds max size of " + maxSize + "MiB, it has been deleted from disk.");
+                    } else {
+                        failedWrite = true;
+                        LOGGER.error("Failed to write chunk data for task: " + this.toString(), thr);
+                    }
+                }
+
+                final boolean finalFailWrite = failedWrite;
+                final boolean[] done = new boolean[] { false };
+
+                this.taskController.tasks.compute(chunkKey, (final ChunkCoordinate keyInMap, final ChunkDataTask valueInMap) -> {
+                    if (valueInMap == null) {
+                        throw new IllegalStateException("Write completed concurrently, expected this task: " + ChunkDataTask.this.toString() + ", report this!");
+                    }
+                    if (valueInMap != ChunkDataTask.this) {
+                        throw new IllegalStateException("Chunk task mismatch, expected this task: " + ChunkDataTask.this.toString() + ", got: " + valueInMap.toString() + ", report this!");
+                    }
+                    if (valueInMap.inProgressWrite == dataWritten) {
+                        valueInMap.failedWrite = finalFailWrite;
+                        done[0] = true;
+                        // keep the data in map if we failed the write so we can try to prevent data loss
+                        return finalFailWrite ? valueInMap : null;
+                    }
+                    // different data than expected, means we need to retry write
+                    return valueInMap;
+                });
+
+                if (done[0]) {
+                    return;
+                }
+
+                // fetch & write new data
+                continue;
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/light/LightQueue.java b/src/main/java/io/papermc/paper/chunk/system/light/LightQueue.java
new file mode 100644
index 0000000000000000000000000000000000000000..0b7a2b0ead4f3bc07bfd9a38c2b7cf024bd140c6
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/light/LightQueue.java
@@ -0,0 +1,280 @@
+package io.papermc.paper.chunk.system.light;
+
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.starlight.common.light.BlockStarLightEngine;
+import ca.spottedleaf.starlight.common.light.SkyStarLightEngine;
+import ca.spottedleaf.starlight.common.light.StarLightInterface;
+import io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler;
+import io.papermc.paper.util.CoordinateUtils;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.shorts.ShortCollection;
+import it.unimi.dsi.fastutil.shorts.ShortOpenHashSet;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.SectionPos;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+import java.util.function.BooleanSupplier;
+
+public final class LightQueue {
+
+    protected final Long2ObjectOpenHashMap<ChunkTasks> chunkTasks = new Long2ObjectOpenHashMap<>();
+    protected final StarLightInterface manager;
+    protected final ServerLevel world;
+
+    public LightQueue(final StarLightInterface manager) {
+        this.manager = manager;
+        this.world = ((ServerLevel)manager.getWorld());
+    }
+
+    public void lowerPriority(final int chunkX, final int chunkZ, final PrioritisedExecutor.Priority priority) {
+        final ChunkTasks task;
+        synchronized (this) {
+            task = this.chunkTasks.get(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+        }
+        if (task != null) {
+            task.lowerPriority(priority);
+        }
+    }
+
+    public void setPriority(final int chunkX, final int chunkZ, final PrioritisedExecutor.Priority priority) {
+        final ChunkTasks task;
+        synchronized (this) {
+            task = this.chunkTasks.get(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+        }
+        if (task != null) {
+            task.setPriority(priority);
+        }
+    }
+
+    public void raisePriority(final int chunkX, final int chunkZ, final PrioritisedExecutor.Priority priority) {
+        final ChunkTasks task;
+        synchronized (this) {
+            task = this.chunkTasks.get(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+        }
+        if (task != null) {
+            task.raisePriority(priority);
+        }
+    }
+
+    public PrioritisedExecutor.Priority getPriority(final int chunkX, final int chunkZ) {
+        final ChunkTasks task;
+        synchronized (this) {
+            task = this.chunkTasks.get(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+        }
+        if (task != null) {
+            return task.getPriority();
+        }
+
+        return PrioritisedExecutor.Priority.COMPLETING;
+    }
+
+    public boolean isEmpty() {
+        synchronized (this) {
+            return this.chunkTasks.isEmpty();
+        }
+    }
+
+    public CompletableFuture<Void> queueBlockChange(final BlockPos pos) {
+        final ChunkTasks tasks;
+        synchronized (this) {
+            tasks = this.chunkTasks.computeIfAbsent(CoordinateUtils.getChunkKey(pos), (final long keyInMap) -> {
+                return new ChunkTasks(keyInMap, LightQueue.this.manager, LightQueue.this);
+            });
+            tasks.changedPositions.add(pos.immutable());
+        }
+
+        tasks.schedule();
+
+        return tasks.onComplete;
+    }
+
+    public CompletableFuture<Void> queueSectionChange(final SectionPos pos, final boolean newEmptyValue) {
+        final ChunkTasks tasks;
+        synchronized (this) {
+            tasks = this.chunkTasks.computeIfAbsent(CoordinateUtils.getChunkKey(pos), (final long keyInMap) -> {
+                return new ChunkTasks(keyInMap, LightQueue.this.manager, LightQueue.this);
+            });
+
+            if (tasks.changedSectionSet == null) {
+                tasks.changedSectionSet = new Boolean[this.manager.maxSection - this.manager.minSection + 1];
+            }
+            tasks.changedSectionSet[pos.getY() - this.manager.minSection] = Boolean.valueOf(newEmptyValue);
+        }
+
+        tasks.schedule();
+
+        return tasks.onComplete;
+    }
+
+    public CompletableFuture<Void> queueChunkLightTask(final ChunkPos pos, final BooleanSupplier lightTask, final PrioritisedExecutor.Priority priority) {
+        final ChunkTasks tasks;
+        synchronized (this) {
+            tasks = this.chunkTasks.computeIfAbsent(CoordinateUtils.getChunkKey(pos), (final long keyInMap) -> {
+                return new ChunkTasks(keyInMap, LightQueue.this.manager, LightQueue.this, priority);
+            });
+            if (tasks.lightTasks == null) {
+                tasks.lightTasks = new ArrayList<>();
+            }
+            tasks.lightTasks.add(lightTask);
+        }
+
+        tasks.schedule();
+
+        return tasks.onComplete;
+    }
+
+    public CompletableFuture<Void> queueChunkSkylightEdgeCheck(final SectionPos pos, final ShortCollection sections) {
+        final ChunkTasks tasks;
+        synchronized (this) {
+            tasks = this.chunkTasks.computeIfAbsent(CoordinateUtils.getChunkKey(pos), (final long keyInMap) -> {
+                return new ChunkTasks(keyInMap, LightQueue.this.manager, LightQueue.this);
+            });
+
+            ShortOpenHashSet queuedEdges = tasks.queuedEdgeChecksSky;
+            if (queuedEdges == null) {
+                queuedEdges = tasks.queuedEdgeChecksSky = new ShortOpenHashSet();
+            }
+            queuedEdges.addAll(sections);
+        }
+
+        tasks.schedule();
+
+        return tasks.onComplete;
+    }
+
+    public CompletableFuture<Void> queueChunkBlocklightEdgeCheck(final SectionPos pos, final ShortCollection sections) {
+        final ChunkTasks tasks;
+
+        synchronized (this) {
+            tasks = this.chunkTasks.computeIfAbsent(CoordinateUtils.getChunkKey(pos), (final long keyInMap) -> {
+                return new ChunkTasks(keyInMap, LightQueue.this.manager, LightQueue.this);
+            });
+
+            ShortOpenHashSet queuedEdges = tasks.queuedEdgeChecksBlock;
+            if (queuedEdges == null) {
+                queuedEdges = tasks.queuedEdgeChecksBlock = new ShortOpenHashSet();
+            }
+            queuedEdges.addAll(sections);
+        }
+
+        tasks.schedule();
+
+        return tasks.onComplete;
+    }
+
+    public void removeChunk(final ChunkPos pos) {
+        final ChunkTasks tasks;
+        synchronized (this) {
+            tasks = this.chunkTasks.remove(CoordinateUtils.getChunkKey(pos));
+        }
+        if (tasks != null && tasks.cancel()) {
+            tasks.onComplete.complete(null);
+        }
+    }
+
+    protected static final class ChunkTasks implements Runnable {
+
+        final Set<BlockPos> changedPositions = new HashSet<>();
+        Boolean[] changedSectionSet;
+        ShortOpenHashSet queuedEdgeChecksSky;
+        ShortOpenHashSet queuedEdgeChecksBlock;
+        List<BooleanSupplier> lightTasks;
+
+        final CompletableFuture<Void> onComplete = new CompletableFuture<>();
+
+        public final long chunkCoordinate;
+        private final StarLightInterface lightEngine;
+        private final LightQueue queue;
+        private final PrioritisedExecutor.PrioritisedTask task;
+
+        public ChunkTasks(final long chunkCoordinate, final StarLightInterface lightEngine, final LightQueue queue) {
+            this(chunkCoordinate, lightEngine, queue, PrioritisedExecutor.Priority.NORMAL);
+        }
+
+        public ChunkTasks(final long chunkCoordinate, final StarLightInterface lightEngine, final LightQueue queue,
+                          final PrioritisedExecutor.Priority priority) {
+            this.chunkCoordinate = chunkCoordinate;
+            this.lightEngine = lightEngine;
+            this.queue = queue;
+            this.task = queue.world.chunkTaskScheduler.lightExecutor.createTask(this, priority);
+        }
+
+        public void schedule() {
+            this.task.queue();
+        }
+
+        public boolean cancel() {
+            return this.task.cancel();
+        }
+
+        public PrioritisedExecutor.Priority getPriority() {
+            return this.task.getPriority();
+        }
+
+        public void lowerPriority(final PrioritisedExecutor.Priority priority) {
+            this.task.lowerPriority(priority);
+        }
+
+        public void setPriority(final PrioritisedExecutor.Priority priority) {
+            this.task.setPriority(priority);
+        }
+
+        public void raisePriority(final PrioritisedExecutor.Priority priority) {
+            this.task.raisePriority(priority);
+        }
+
+        @Override
+        public void run() {
+            final SkyStarLightEngine skyEngine = this.lightEngine.getSkyLightEngine();
+            final BlockStarLightEngine blockEngine = this.lightEngine.getBlockLightEngine();
+            try {
+                synchronized (this.queue) {
+                    this.queue.chunkTasks.remove(this.chunkCoordinate);
+                }
+
+                boolean litChunk = false;
+                if (this.lightTasks != null) {
+                    for (final BooleanSupplier run : this.lightTasks) {
+                        if (run.getAsBoolean()) {
+                            litChunk = true;
+                            break;
+                        }
+                    }
+                }
+
+                final long coordinate = this.chunkCoordinate;
+                final int chunkX = CoordinateUtils.getChunkX(coordinate);
+                final int chunkZ = CoordinateUtils.getChunkZ(coordinate);
+
+                final Set<BlockPos> positions = this.changedPositions;
+                final Boolean[] sectionChanges = this.changedSectionSet;
+
+                if (!litChunk) {
+                    if (skyEngine != null && (!positions.isEmpty() || sectionChanges != null)) {
+                        skyEngine.blocksChangedInChunk(this.lightEngine.getLightAccess(), chunkX, chunkZ, positions, sectionChanges);
+                    }
+                    if (blockEngine != null && (!positions.isEmpty() || sectionChanges != null)) {
+                        blockEngine.blocksChangedInChunk(this.lightEngine.getLightAccess(), chunkX, chunkZ, positions, sectionChanges);
+                    }
+
+                    if (skyEngine != null && this.queuedEdgeChecksSky != null) {
+                        skyEngine.checkChunkEdges(this.lightEngine.getLightAccess(), chunkX, chunkZ, this.queuedEdgeChecksSky);
+                    }
+                    if (blockEngine != null && this.queuedEdgeChecksBlock != null) {
+                        blockEngine.checkChunkEdges(this.lightEngine.getLightAccess(), chunkX, chunkZ, this.queuedEdgeChecksBlock);
+                    }
+                }
+
+                this.onComplete.complete(null);
+            } finally {
+                this.lightEngine.releaseSkyLightEngine(skyEngine);
+                this.lightEngine.releaseBlockLightEngine(blockEngine);
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/poi/PoiChunk.java b/src/main/java/io/papermc/paper/chunk/system/poi/PoiChunk.java
new file mode 100644
index 0000000000000000000000000000000000000000..28b31ef4e1a63ca70c00052f9d9d4fd6cb81c3f1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/poi/PoiChunk.java
@@ -0,0 +1,168 @@
+package io.papermc.paper.chunk.system.poi;
+
+import com.mojang.logging.LogUtils;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.DataResult;
+import io.papermc.paper.util.WorldUtil;
+import net.minecraft.SharedConstants;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.NbtOps;
+import net.minecraft.nbt.Tag;
+import net.minecraft.resources.RegistryOps;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.ai.village.poi.PoiSection;
+import org.slf4j.Logger;
+
+import java.util.Optional;
+
+public final class PoiChunk {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    public final ServerLevel world;
+    public final int chunkX;
+    public final int chunkZ;
+    public final int minSection;
+    public final int maxSection;
+    // this is dumb
+    public final Runnable onModify = () -> {
+        PoiChunk.this.isDirty = true;
+    };
+
+    protected final PoiSection[] sections;
+
+    private boolean isDirty;
+
+    public PoiChunk(final ServerLevel world, final int chunkX, final int chunkZ, final int minSection, final int maxSection) {
+        this(world, chunkX, chunkZ, minSection, maxSection, new PoiSection[maxSection - minSection + 1]);
+    }
+
+    public PoiChunk(final ServerLevel world, final int chunkX, final int chunkZ, final int minSection, final int maxSection, final PoiSection[] sections) {
+        this.world = world;
+        this.chunkX = chunkX;
+        this.chunkZ = chunkZ;
+        this.minSection = minSection;
+        this.maxSection = maxSection;
+        this.sections = sections;
+        if (this.sections.length != (maxSection - minSection + 1)) {
+            throw new IllegalStateException("Incorrect length used, expected " + (maxSection - minSection + 1) + ", got " + this.sections.length);
+        }
+    }
+
+    public PoiSection getOrCreateSection(final int chunkY) {
+        if (chunkY >= this.minSection && chunkY <= this.maxSection) {
+            final int idx = chunkY - this.minSection;
+            final PoiSection ret = this.sections[idx];
+            if (ret != null) {
+                return ret;
+            }
+
+            return this.sections[idx] = new PoiSection(this.onModify);
+        }
+        throw new IllegalArgumentException("chunkY is out of bounds, chunkY: " + chunkY + " outside [" + this.minSection + "," + this.maxSection + "]");
+    }
+
+    public PoiSection getSection(final int chunkY) {
+        if (chunkY >= this.minSection && chunkY <= this.maxSection) {
+            return this.sections[chunkY - this.minSection];
+        }
+        return null;
+    }
+
+    public Optional<PoiSection> getSectionForVanilla(final int chunkY) {
+        if (chunkY >= this.minSection && chunkY <= this.maxSection) {
+            final PoiSection ret = this.sections[chunkY - this.minSection];
+            return ret == null ? Optional.empty() : ret.noAllocateOptional;
+        }
+        return Optional.empty();
+    }
+
+    public boolean isDirty() {
+        return this.isDirty;
+    }
+
+    public void setDirty(final boolean dirty) {
+        this.isDirty = dirty;
+    }
+
+    // returns null if empty
+    public CompoundTag save() {
+        final Codec<PoiSection> codec = PoiSection.codec(this.onModify);
+        final RegistryOps<Tag> registryOps = RegistryOps.create(NbtOps.INSTANCE, world.getPoiManager().registryAccess);
+
+        final CompoundTag ret = new CompoundTag();
+        final CompoundTag sections = new CompoundTag();
+        ret.put("Sections", sections);
+
+        ret.putInt("DataVersion", SharedConstants.getCurrentVersion().getWorldVersion());
+
+        final ServerLevel world = this.world;
+        final int chunkX = this.chunkX;
+        final int chunkZ = this.chunkZ;
+
+        for (int sectionY = this.minSection; sectionY <= this.maxSection; ++sectionY) {
+            final PoiSection chunk = this.sections[sectionY - this.minSection];
+            if (chunk == null || chunk.isEmpty()) {
+                continue;
+            }
+
+            final DataResult<Tag> serializedResult = codec.encodeStart(registryOps, chunk);
+            final int finalSectionY = sectionY;
+            final Tag serialized = serializedResult.resultOrPartial((final String description) -> {
+                LOGGER.error("Failed to serialize poi chunk for world: " + world.getWorld().getName() + ", chunk: (" + chunkX + "," + finalSectionY + "," + chunkZ + "); description: " + description);
+            }).orElse(null);
+            if (serialized == null) {
+                // failed, should be logged from the resultOrPartial
+                continue;
+            }
+
+            sections.put(Integer.toString(sectionY), serialized);
+        }
+
+        return sections.isEmpty() ? null : ret;
+    }
+
+    public static PoiChunk empty(final ServerLevel world, final int chunkX, final int chunkZ) {
+        return new PoiChunk(world, chunkX, chunkZ, WorldUtil.getMinSection(world), WorldUtil.getMaxSection(world));
+    }
+
+    public static PoiChunk parse(final ServerLevel world, final int chunkX, final int chunkZ, final CompoundTag data) {
+        final PoiChunk ret = empty(world, chunkX, chunkZ);
+
+        final Codec<PoiSection> codec = PoiSection.codec(ret.onModify);
+        final RegistryOps<Tag> registryOps = RegistryOps.create(NbtOps.INSTANCE, world.getPoiManager().registryAccess);
+
+        final CompoundTag sections = data.getCompound("Sections");
+
+        if (sections.isEmpty()) {
+            // nothing to parse
+            return ret;
+        }
+
+        boolean readAnything = false;
+
+        for (int sectionY = ret.minSection; sectionY <= ret.maxSection; ++sectionY) {
+            final String key = Integer.toString(sectionY);
+            if (!sections.contains(key)) {
+                continue;
+            }
+
+            final CompoundTag section = sections.getCompound(key);
+            final DataResult<PoiSection> deserializeResult = codec.parse(registryOps, section);
+            final int finalSectionY = sectionY;
+            final PoiSection deserialized = deserializeResult.resultOrPartial((final String description) -> {
+                LOGGER.error("Failed to deserialize poi chunk for world: " + world.getWorld().getName() + ", chunk: (" + chunkX + "," + finalSectionY + "," + chunkZ + "); description: " + description);
+            }).orElse(null);
+
+            if (deserialized == null || deserialized.isEmpty()) {
+                // completely empty, no point in storing this
+                continue;
+            }
+
+            readAnything = true;
+            ret.sections[sectionY - ret.minSection] = deserialized;
+        }
+
+        return ret;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkFullTask.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkFullTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..b02619d7111c52d1b4e3b50267e54da31d6161e3
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkFullTask.java
@@ -0,0 +1,125 @@
+package io.papermc.paper.chunk.system.scheduling;
+
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import com.mojang.logging.LogUtils;
+import net.minecraft.server.level.ChunkMap;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.ProtoChunk;
+import org.slf4j.Logger;
+import java.lang.invoke.VarHandle;
+
+public final class ChunkFullTask extends ChunkProgressionTask implements Runnable {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    protected final NewChunkHolder chunkHolder;
+    protected final ChunkAccess fromChunk;
+    protected final PrioritisedExecutor.PrioritisedTask convertToFullTask;
+
+    public ChunkFullTask(final ChunkTaskScheduler scheduler, final ServerLevel world, final int chunkX, final int chunkZ,
+                         final NewChunkHolder chunkHolder, final ChunkAccess fromChunk, final PrioritisedExecutor.Priority priority) {
+        super(scheduler, world, chunkX, chunkZ);
+        this.chunkHolder = chunkHolder;
+        this.fromChunk = fromChunk;
+        this.convertToFullTask = scheduler.createChunkTask(chunkX, chunkZ, this, priority);
+    }
+
+    @Override
+    public ChunkStatus getTargetStatus() {
+        return ChunkStatus.FULL;
+    }
+
+    @Override
+    public void run() {
+        // See Vanilla protoChunkToFullChunk for what this function should be doing
+        final LevelChunk chunk;
+        try {
+            if (this.fromChunk instanceof ImposterProtoChunk wrappedFull) {
+                chunk = wrappedFull.getWrapped();
+            } else {
+                final ServerLevel world = this.world;
+                final ProtoChunk protoChunk = (ProtoChunk)this.fromChunk;
+                chunk = new LevelChunk(this.world, protoChunk, (final LevelChunk unused) -> {
+                    ChunkMap.postLoadProtoChunk(world, protoChunk.getEntities());
+                });
+            }
+
+            chunk.setChunkHolder(this.scheduler.chunkHolderManager.getChunkHolder(this.chunkX, this.chunkZ)); // replaces setFullStatus
+            chunk.runPostLoad();
+            // Unlike Vanilla, we load the entity chunk here, as we load the NBT in empty status (unlike Vanilla)
+            // This brings entity addition back in line with older versions of the game
+            // Since we load the NBT in the empty status, this will never block for I/O
+            this.world.chunkTaskScheduler.chunkHolderManager.getOrCreateEntityChunk(this.chunkX, this.chunkZ, false);
+
+            // we don't need the entitiesInLevel trash, this system doesn't double run callbacks
+            chunk.setLoaded(true);
+            chunk.registerAllBlockEntitiesAfterLevelLoad();
+            chunk.registerTickContainerInLevel(this.world);
+        } catch (final Throwable throwable) {
+            this.complete(null, throwable);
+
+            if (throwable instanceof ThreadDeath) {
+                throw (ThreadDeath)throwable;
+            }
+            return;
+        }
+        this.complete(chunk, null);
+    }
+
+    protected volatile boolean scheduled;
+    protected static final VarHandle SCHEDULED_HANDLE = ConcurrentUtil.getVarHandle(ChunkFullTask.class, "scheduled", boolean.class);
+
+    @Override
+    public boolean isScheduled() {
+        return this.scheduled;
+    }
+
+    @Override
+    public void schedule() {
+        if ((boolean)SCHEDULED_HANDLE.getAndSet((ChunkFullTask)this, true)) {
+            throw new IllegalStateException("Cannot double call schedule()");
+        }
+        this.convertToFullTask.queue();
+    }
+
+    @Override
+    public void cancel() {
+        if (this.convertToFullTask.cancel()) {
+            this.complete(null, null);
+        }
+    }
+
+    @Override
+    public PrioritisedExecutor.Priority getPriority() {
+        return this.convertToFullTask.getPriority();
+    }
+
+    @Override
+    public void lowerPriority(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+        this.convertToFullTask.lowerPriority(priority);
+    }
+
+    @Override
+    public void setPriority(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+        this.convertToFullTask.setPriority(priority);
+    }
+
+    @Override
+    public void raisePriority(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+        this.convertToFullTask.raisePriority(priority);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..94fd7cc50507934c9e85c1403cb0266510d13d63
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
@@ -0,0 +1,1146 @@
+package io.papermc.paper.chunk.system.scheduling;
+
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.map.SWMRLong2ObjectHashTable;
+import com.google.common.collect.ImmutableList;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.chunk.system.io.RegionFileIOThread;
+import io.papermc.paper.chunk.system.poi.PoiChunk;
+import io.papermc.paper.util.CoordinateUtils;
+import io.papermc.paper.util.TickThread;
+import io.papermc.paper.util.misc.Delayed8WayDistancePropagator2D;
+import io.papermc.paper.world.ChunkEntitySlices;
+import it.unimi.dsi.fastutil.longs.Long2IntLinkedOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2IntMap;
+import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongArrayList;
+import it.unimi.dsi.fastutil.longs.LongIterator;
+import it.unimi.dsi.fastutil.objects.ObjectRBTreeSet;
+import it.unimi.dsi.fastutil.objects.ReferenceLinkedOpenHashSet;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ChunkMap;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.Ticket;
+import net.minecraft.server.level.TicketType;
+import net.minecraft.util.SortedArraySet;
+import net.minecraft.util.Unit;
+import net.minecraft.world.level.ChunkPos;
+import org.bukkit.plugin.Plugin;
+import org.slf4j.Logger;
+import java.io.IOException;
+import java.text.DecimalFormat;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Objects;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.locks.LockSupport;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Predicate;
+
+public final class ChunkHolderManager {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    public static final int FULL_LOADED_TICKET_LEVEL    = 33;
+    public static final int BLOCK_TICKING_TICKET_LEVEL  = 32;
+    public static final int ENTITY_TICKING_TICKET_LEVEL = 31;
+    public static final int MAX_TICKET_LEVEL = ChunkMap.MAX_CHUNK_DISTANCE; // inclusive
+
+    private static final long NO_TIMEOUT_MARKER = -1L;
+
+    final ReentrantLock ticketLock = new ReentrantLock();
+
+    private final SWMRLong2ObjectHashTable<NewChunkHolder> chunkHolders = new SWMRLong2ObjectHashTable<>(16384, 0.25f);
+    private final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> tickets = new Long2ObjectOpenHashMap<>(8192, 0.25f);
+    // what a disaster of a name
+    // this is a map of removal tick to a map of chunks and the number of tickets a chunk has that are to expire that tick
+    private final Long2ObjectOpenHashMap<Long2IntOpenHashMap> removeTickToChunkExpireTicketCount = new Long2ObjectOpenHashMap<>();
+    private final ServerLevel world;
+    private final ChunkTaskScheduler taskScheduler;
+    private long currentTick;
+
+    private final ReferenceLinkedOpenHashSet<NewChunkHolder> pendingFullLoadUpdate = new ReferenceLinkedOpenHashSet<>();
+    private final ObjectRBTreeSet<NewChunkHolder> autoSaveQueue = new ObjectRBTreeSet<>((final NewChunkHolder c1, final NewChunkHolder c2) -> {
+        if (c1 == c2) {
+            return 0;
+        }
+
+        final int saveTickCompare = Long.compare(c1.lastAutoSave, c2.lastAutoSave);
+
+        if (saveTickCompare != 0) {
+            return saveTickCompare;
+        }
+
+        final long coord1 = CoordinateUtils.getChunkKey(c1.chunkX, c1.chunkZ);
+        final long coord2 = CoordinateUtils.getChunkKey(c2.chunkX, c2.chunkZ);
+
+        if (coord1 == coord2) {
+            throw new IllegalStateException("Duplicate chunkholder in auto save queue");
+        }
+
+        return Long.compare(coord1, coord2);
+    });
+
+    public ChunkHolderManager(final ServerLevel world, final ChunkTaskScheduler taskScheduler) {
+        this.world = world;
+        this.taskScheduler = taskScheduler;
+    }
+
+    private long statusUpgradeId;
+
+    long getNextStatusUpgradeId() {
+        return ++this.statusUpgradeId;
+    }
+
+    public List<ChunkHolder> getOldChunkHolders() {
+        final List<NewChunkHolder> holders = this.getChunkHolders();
+        final List<ChunkHolder> ret = new ArrayList<>(holders.size());
+        for (final NewChunkHolder holder : holders) {
+            ret.add(holder.vanillaChunkHolder);
+        }
+        return ret;
+    }
+
+    public List<NewChunkHolder> getChunkHolders() {
+        final List<NewChunkHolder> ret = new ArrayList<>(this.chunkHolders.size());
+        this.chunkHolders.forEachValue(ret::add);
+        return ret;
+    }
+
+    public int size() {
+        return this.chunkHolders.size();
+    }
+
+    public void close(final boolean save, final boolean halt) {
+        TickThread.ensureTickThread("Closing world off-main");
+        if (halt) {
+            LOGGER.info("Waiting 60s for chunk system to halt for world '" + this.world.getWorld().getName() + "'");
+            if (!this.taskScheduler.halt(true, TimeUnit.SECONDS.toNanos(60L))) {
+                LOGGER.warn("Failed to halt world generation/loading tasks for world '" + this.world.getWorld().getName() + "'");
+            } else {
+                LOGGER.info("Halted chunk system for world '" + this.world.getWorld().getName() + "'");
+            }
+        }
+
+        if (save) {
+            this.saveAllChunks(true, true, true);
+        }
+
+        if (this.world.chunkDataControllerNew.hasTasks() || this.world.entityDataControllerNew.hasTasks() || this.world.poiDataControllerNew.hasTasks()) {
+            RegionFileIOThread.flush();
+        }
+
+        // kill regionfile cache
+        try {
+            this.world.chunkDataControllerNew.getCache().close();
+        } catch (final IOException ex) {
+            LOGGER.error("Failed to close chunk regionfile cache for world '" + this.world.getWorld().getName() + "'", ex);
+        }
+        try {
+            this.world.entityDataControllerNew.getCache().close();
+        } catch (final IOException ex) {
+            LOGGER.error("Failed to close entity regionfile cache for world '" + this.world.getWorld().getName() + "'", ex);
+        }
+        try {
+            this.world.poiDataControllerNew.getCache().close();
+        } catch (final IOException ex) {
+            LOGGER.error("Failed to close poi regionfile cache for world '" + this.world.getWorld().getName() + "'", ex);
+        }
+    }
+
+    void ensureInAutosave(final NewChunkHolder holder) {
+        if (!this.autoSaveQueue.contains(holder)) {
+            holder.lastAutoSave = MinecraftServer.currentTick;
+            this.autoSaveQueue.add(holder);
+        }
+    }
+
+    public void autoSave() {
+        final List<NewChunkHolder> reschedule = new ArrayList<>();
+        final long currentTick = MinecraftServer.currentTickLong;
+        final long maxSaveTime = currentTick - this.world.paperConfig().chunks.autoSaveInterval.value();
+        for (int autoSaved = 0; autoSaved < this.world.paperConfig().chunks.maxAutoSaveChunksPerTick && !this.autoSaveQueue.isEmpty();) {
+            final NewChunkHolder holder = this.autoSaveQueue.first();
+
+            if (holder.lastAutoSave > maxSaveTime) {
+                break;
+            }
+
+            this.autoSaveQueue.remove(holder);
+
+            if (holder.save(false, false)) {
+                ++autoSaved;
+            }
+            holder.lastAutoSave = currentTick;
+
+            if (holder.getChunkStatus().isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                reschedule.add(holder);
+            }
+        }
+
+        for (final NewChunkHolder holder : reschedule) {
+            if (holder.getChunkStatus().isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                this.autoSaveQueue.add(holder);
+            }
+        }
+    }
+
+    public void saveAllChunks(final boolean flush, final boolean shutdown, final boolean logProgress) {
+        final List<NewChunkHolder> holders = this.getChunkHolders();
+
+        if (flush) {
+            RegionFileIOThread.flush();
+        }
+
+        if (logProgress) {
+            LOGGER.info("Saving all chunkholders for world '" + this.world.getWorld().getName() + "'");
+        }
+
+        final DecimalFormat format = new DecimalFormat("#0.00");
+
+        int saved = 0;
+
+        long start = System.nanoTime();
+        long lastLog = start;
+        boolean needsFlush = false;
+
+        for (int i = 0, len = holders.size(); i < len; ++i) {
+            final NewChunkHolder holder = holders.get(i);
+            try {
+                if (holder.save(shutdown, false)) {
+                    ++saved;
+                    needsFlush = true;
+                }
+            } catch (final ThreadDeath thr) {
+                throw thr;
+            } catch (final Throwable thr) {
+                LOGGER.error("Failed to save chunk (" + holder.chunkX + "," + holder.chunkZ + ") in world '" + this.world.getWorld().getName() + "'", thr);
+            }
+            if (flush && needsFlush && (saved % 50) == 0) {
+                needsFlush = false;
+                RegionFileIOThread.flush();
+            }
+            if (logProgress) {
+                final long currTime = System.nanoTime();
+                if ((currTime - lastLog) > TimeUnit.SECONDS.toNanos(10L)) {
+                    lastLog = currTime;
+                    LOGGER.info("Saved " + saved + " chunks (" + format.format((double)(i+1)/(double)len * 100.0) + "%) in world '" + this.world.getWorld().getName() + "'");
+                }
+            }
+        }
+        if (flush) {
+            RegionFileIOThread.flush();
+        }
+        if (logProgress) {
+            LOGGER.info("Saved " + saved + " chunks in world '" + this.world.getWorld().getName() + "' in " + TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - start) + "s");
+        }
+    }
+
+    protected final Long2IntLinkedOpenHashMap ticketLevelUpdates = new Long2IntLinkedOpenHashMap() {
+        @Override
+        protected void rehash(final int newN) {
+            // no downsizing allowed
+            if (newN < this.n) {
+                return;
+            }
+            super.rehash(newN);
+        }
+    };
+
+    protected final Delayed8WayDistancePropagator2D ticketLevelPropagator = new Delayed8WayDistancePropagator2D(
+            (final long coordinate, final byte oldLevel, final byte newLevel) -> {
+                ChunkHolderManager.this.ticketLevelUpdates.putAndMoveToLast(coordinate, convertBetweenTicketLevels(newLevel));
+            }
+    );
+    // function for converting between ticket levels and propagator levels and vice versa
+    // the problem is the ticket level propagator will propagate from a set source down to zero, whereas mojang expects
+    // levels to propagate from a set value up to a maximum value. so we need to convert the levels we put into the propagator
+    // and the levels we get out of the propagator
+
+    public static int convertBetweenTicketLevels(final int level) {
+        return ChunkMap.MAX_CHUNK_DISTANCE - level + 1;
+    }
+
+    public boolean hasTickets() {
+        this.ticketLock.lock();
+        try {
+            return !this.tickets.isEmpty();
+        } finally {
+            this.ticketLock.unlock();
+        }
+    }
+
+    public String getTicketDebugString(final long coordinate) {
+        this.ticketLock.lock();
+        try {
+            final SortedArraySet<Ticket<?>> tickets = this.tickets.get(coordinate);
+
+            return tickets != null ? tickets.first().toString() : "no_ticket";
+        } finally {
+            this.ticketLock.unlock();
+        }
+    }
+
+    public Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> getTicketsCopy() {
+        this.ticketLock.lock();
+        try {
+            return this.tickets.clone();
+        } finally {
+            this.ticketLock.unlock();
+        }
+    }
+
+    public Collection<Plugin> getPluginChunkTickets(int x, int z) {
+        ImmutableList.Builder<Plugin> ret;
+        this.ticketLock.lock();
+        try {
+            SortedArraySet<Ticket<?>> tickets = this.tickets.get(ChunkPos.asLong(x, z));
+
+            if (tickets == null) {
+                return Collections.emptyList();
+            }
+
+            ret = ImmutableList.builder();
+            for (Ticket<?> ticket : tickets) {
+                if (ticket.getType() == TicketType.PLUGIN_TICKET) {
+                    ret.add((Plugin)ticket.key);
+                }
+            }
+        } finally {
+            this.ticketLock.unlock();
+        }
+
+        return ret.build();
+    }
+
+    protected final int getPropagatedTicketLevel(final long coordinate) {
+        return convertBetweenTicketLevels(this.ticketLevelPropagator.getLevel(coordinate));
+    }
+
+    protected final void updateTicketLevel(final long coordinate, final int ticketLevel) {
+        if (ticketLevel > ChunkMap.MAX_CHUNK_DISTANCE) {
+            this.ticketLevelPropagator.removeSource(coordinate);
+        } else {
+            this.ticketLevelPropagator.setSource(coordinate, convertBetweenTicketLevels(ticketLevel));
+        }
+    }
+
+    private static int getTicketLevelAt(SortedArraySet<Ticket<?>> tickets) {
+        return !tickets.isEmpty() ? tickets.first().getTicketLevel() : MAX_TICKET_LEVEL + 1;
+    }
+
+    public <T> boolean addTicketAtLevel(final TicketType<T> type, final ChunkPos chunkPos, final int level,
+                                        final T identifier) {
+        return this.addTicketAtLevel(type, CoordinateUtils.getChunkKey(chunkPos), level, identifier, -1L);
+    }
+
+    public <T> boolean addTicketAtLevel(final TicketType<T> type, final int chunkX, final int chunkZ, final int level,
+                                        final T identifier) {
+        return this.addTicketAtLevel(type, CoordinateUtils.getChunkKey(chunkX, chunkZ), level, identifier, -1L);
+    }
+
+    public <T> boolean addTicketAtLevel(final TicketType<T> type, final long chunk, final int level, final T identifier) {
+        return this.addTicketAtLevel(type, chunk, level, identifier, -1L);
+    }
+
+    /* removeDelay = 0 means no unload, this is VANILLA behavior, and tickets are __DEFINED__ this way, do not change */
+
+    public <T> boolean addTicketAtLevel(final TicketType<T> type, final ChunkPos chunkPos, final int level,
+                                        final T identifier, final long removeDelay) {
+        return this.addTicketAtLevel(type, CoordinateUtils.getChunkKey(chunkPos), level, identifier, removeDelay);
+    }
+
+    public <T> boolean addTicketAtLevel(final TicketType<T> type, final int chunkX, final int chunkZ, final int level,
+                                        final T identifier, final long removeDelay) {
+        return this.addTicketAtLevel(type, CoordinateUtils.getChunkKey(chunkX, chunkZ), level, identifier, removeDelay);
+    }
+
+    // supposed to return true if the ticket was added and did not replace another
+    // but, we always return false if the ticket cannot be added
+    public <T> boolean addTicketAtLevel(final TicketType<T> type, final long chunk, final int level, final T identifier,
+                                        long removeDelay) {
+        if (removeDelay < 0L) {
+            removeDelay = type.timeout;
+        }
+        if (level > MAX_TICKET_LEVEL) {
+            return false;
+        }
+
+        this.ticketLock.lock();
+        try {
+            final long removeTick = removeDelay == 0 ? NO_TIMEOUT_MARKER : this.currentTick + removeDelay;
+            final Ticket<T> ticket = new Ticket<>(type, level, identifier, removeTick);
+
+            final SortedArraySet<Ticket<?>> ticketsAtChunk = this.tickets.computeIfAbsent(chunk, (final long keyInMap) -> {
+                return SortedArraySet.create(4);
+            });
+
+            final int levelBefore = getTicketLevelAt(ticketsAtChunk);
+            final Ticket<T> current = (Ticket<T>)ticketsAtChunk.replace(ticket);
+            final int levelAfter = getTicketLevelAt(ticketsAtChunk);
+
+            if (current != ticket) {
+                final long oldRemovalTick = current.removalTick;
+                if (removeTick != oldRemovalTick) {
+                    if (oldRemovalTick != NO_TIMEOUT_MARKER) {
+                        final Long2IntOpenHashMap removeCounts = this.removeTickToChunkExpireTicketCount.get(oldRemovalTick);
+                        final int prevCount = removeCounts.addTo(chunk, -1);
+
+                        if (prevCount == 1) {
+                            removeCounts.remove(chunk);
+                            if (removeCounts.isEmpty()) {
+                                this.removeTickToChunkExpireTicketCount.remove(oldRemovalTick);
+                            }
+                        }
+                    }
+                    if (removeTick != NO_TIMEOUT_MARKER) {
+                        this.removeTickToChunkExpireTicketCount.computeIfAbsent(removeTick, (final long keyInMap) -> {
+                            return new Long2IntOpenHashMap();
+                        }).addTo(chunk, 1);
+                    }
+                }
+            } else {
+                if (removeTick != NO_TIMEOUT_MARKER) {
+                    this.removeTickToChunkExpireTicketCount.computeIfAbsent(removeTick, (final long keyInMap) -> {
+                        return new Long2IntOpenHashMap();
+                    }).addTo(chunk, 1);
+                }
+            }
+
+            if (levelBefore != levelAfter) {
+                this.updateTicketLevel(chunk, levelAfter);
+            }
+
+            return current == ticket;
+        } finally {
+            this.ticketLock.unlock();
+        }
+    }
+
+    public <T> boolean removeTicketAtLevel(final TicketType<T> type, final ChunkPos chunkPos, final int level, final T identifier) {
+        return this.removeTicketAtLevel(type, CoordinateUtils.getChunkKey(chunkPos), level, identifier);
+    }
+
+    public <T> boolean removeTicketAtLevel(final TicketType<T> type, final int chunkX, final int chunkZ, final int level, final T identifier) {
+        return this.removeTicketAtLevel(type, CoordinateUtils.getChunkKey(chunkX, chunkZ), level, identifier);
+    }
+
+    public <T> boolean removeTicketAtLevel(final TicketType<T> type, final long chunk, final int level, final T identifier) {
+        if (level > MAX_TICKET_LEVEL) {
+            return false;
+        }
+
+        this.ticketLock.lock();
+        try {
+            final SortedArraySet<Ticket<?>> ticketsAtChunk = this.tickets.get(chunk);
+            if (ticketsAtChunk == null) {
+                return false;
+            }
+
+            final int oldLevel = getTicketLevelAt(ticketsAtChunk);
+            final Ticket<T> ticket = (Ticket<T>)ticketsAtChunk.removeAndGet(new Ticket<>(type, level, identifier, -2L));
+
+            if (ticket == null) {
+                return false;
+            }
+
+            if (ticketsAtChunk.isEmpty()) {
+                this.tickets.remove(chunk);
+            }
+
+            final int newLevel = getTicketLevelAt(ticketsAtChunk);
+
+            final long removeTick = ticket.removalTick;
+            if (removeTick != NO_TIMEOUT_MARKER) {
+                final Long2IntOpenHashMap removeCounts = this.removeTickToChunkExpireTicketCount.get(removeTick);
+                final int currCount = removeCounts.addTo(chunk, -1);
+
+                if (currCount == 1) {
+                    removeCounts.remove(chunk);
+                    if (removeCounts.isEmpty()) {
+                        this.removeTickToChunkExpireTicketCount.remove(removeTick);
+                    }
+                }
+            }
+
+            if (oldLevel != newLevel) {
+                this.updateTicketLevel(chunk, newLevel);
+            }
+
+            return true;
+        } finally {
+            this.ticketLock.unlock();
+        }
+    }
+
+    public <T> void removeAllTicketsFor(final TicketType<T> ticketType, final int ticketLevel, final T ticketIdentifier) {
+        if (ticketLevel > MAX_TICKET_LEVEL) {
+            return;
+        }
+
+        this.ticketLock.lock();
+        try {
+            for (final LongIterator iterator = new LongArrayList(this.tickets.keySet()).longIterator(); iterator.hasNext();) {
+                final long chunk = iterator.nextLong();
+
+                this.removeTicketAtLevel(ticketType, chunk, ticketLevel, ticketIdentifier);
+            }
+        } finally {
+            this.ticketLock.unlock();
+        }
+    }
+
+    public void tick() {
+        TickThread.ensureTickThread("Cannot tick ticket manager off-main");
+
+        this.ticketLock.lock();
+        try {
+            final long tick = ++this.currentTick;
+
+            final Long2IntOpenHashMap toRemove = this.removeTickToChunkExpireTicketCount.remove(tick);
+
+            if (toRemove == null) {
+                return;
+            }
+
+            final Predicate<Ticket<?>> expireNow = (final Ticket<?> ticket) -> {
+                return ticket.removalTick == tick;
+            };
+
+            for (final LongIterator iterator = toRemove.keySet().longIterator(); iterator.hasNext();) {
+                final long chunk = iterator.nextLong();
+
+                final SortedArraySet<Ticket<?>> tickets = this.tickets.get(chunk);
+                tickets.removeIf(expireNow);
+                if (tickets.isEmpty()) {
+                    this.tickets.remove(chunk);
+                    this.ticketLevelPropagator.removeSource(chunk);
+                } else {
+                    this.ticketLevelPropagator.setSource(chunk, convertBetweenTicketLevels(tickets.first().getTicketLevel()));
+                }
+            }
+        } finally {
+            this.ticketLock.unlock();
+        }
+
+        this.processTicketUpdates();
+    }
+
+    public NewChunkHolder getChunkHolder(final int chunkX, final int chunkZ) {
+        return this.chunkHolders.get(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+    }
+
+    public NewChunkHolder getChunkHolder(final long position) {
+        return this.chunkHolders.get(position);
+    }
+
+    public void raisePriority(final int x, final int z, final PrioritisedExecutor.Priority priority) {
+        final NewChunkHolder chunkHolder = this.getChunkHolder(x, z);
+        if (chunkHolder != null) {
+            chunkHolder.raisePriority(priority);
+        }
+    }
+
+    public void setPriority(final int x, final int z, final PrioritisedExecutor.Priority priority) {
+        final NewChunkHolder chunkHolder = this.getChunkHolder(x, z);
+        if (chunkHolder != null) {
+            chunkHolder.setPriority(priority);
+        }
+    }
+
+    public void lowerPriority(final int x, final int z, final PrioritisedExecutor.Priority priority) {
+        final NewChunkHolder chunkHolder = this.getChunkHolder(x, z);
+        if (chunkHolder != null) {
+            chunkHolder.lowerPriority(priority);
+        }
+    }
+
+    // because this function creates the chunk holder without a ticket, it is the caller's responsibility to ensure
+    // the chunk holder eventually unloads. this should only be used to avoid using processTicketUpdates to create chunkholders,
+    // as processTicketUpdates may call plugin logic; in every other case a ticket is appropriate
+    private NewChunkHolder getOrCreateChunkHolder(final int chunkX, final int chunkZ) {
+        return this.getOrCreateChunkHolder(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+    }
+
+    private NewChunkHolder getOrCreateChunkHolder(final long position) {
+        if (!this.ticketLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Must hold ticket level update lock!");
+        }
+        if (!this.taskScheduler.schedulingLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Must hold scheduler lock!!");
+        }
+
+        // we could just acquire these locks, but...
+        // must own the locks because the caller needs to ensure that no unload can occur AFTER this function returns
+
+        NewChunkHolder current = this.chunkHolders.get(position);
+        if (current != null) {
+            return current;
+        }
+
+        current = new NewChunkHolder(this.world, CoordinateUtils.getChunkX(position), CoordinateUtils.getChunkZ(position), this.taskScheduler);
+
+        this.chunkHolders.put(position, current);
+
+        return current;
+    }
+
+    private long entityLoadCounter;
+
+    public ChunkEntitySlices getOrCreateEntityChunk(final int chunkX, final int chunkZ, final boolean transientChunk) {
+        TickThread.ensureTickThread(chunkX, chunkZ, "Cannot create entity chunk off-main");
+        ChunkEntitySlices ret;
+
+        NewChunkHolder current = this.getChunkHolder(chunkX, chunkZ);
+        if (current != null && (ret = current.getEntityChunk()) != null && (transientChunk || !ret.isTransient())) {
+            return ret;
+        }
+
+        final AtomicBoolean isCompleted = new AtomicBoolean();
+        final Thread waiter = Thread.currentThread();
+        final Long entityLoadId;
+        this.ticketLock.lock();
+        try {
+            entityLoadId = Long.valueOf(this.entityLoadCounter++);
+            this.addTicketAtLevel(TicketType.ENTITY_LOAD, chunkX, chunkZ, MAX_TICKET_LEVEL, entityLoadId);
+            this.taskScheduler.schedulingLock.lock();
+            try {
+                current = this.getOrCreateChunkHolder(chunkX, chunkZ);
+                if ((ret = current.getEntityChunk()) != null && (transientChunk || !ret.isTransient())) {
+                    return ret;
+                }
+
+                if (current.isEntityChunkNBTLoaded()) {
+                    isCompleted.setPlain(true);
+                } else {
+                    current.getOrLoadEntityData((final GenericDataLoadTask.TaskResult<CompoundTag, Throwable> result) -> {
+                        if (!transientChunk) {
+                            isCompleted.set(true);
+                            LockSupport.unpark(waiter);
+                        }
+                    });
+                    final ChunkLoadTask.EntityDataLoadTask entityLoad = current.getEntityDataLoadTask();
+
+                    if (entityLoad != null && !transientChunk) {
+                        entityLoad.raisePriority(PrioritisedExecutor.Priority.BLOCKING);
+                    }
+                }
+            } finally {
+                this.taskScheduler.schedulingLock.unlock();
+            }
+        } finally {
+            this.ticketLock.unlock();
+        }
+
+        if (!transientChunk) {
+            // Note: no need to busy wait on the chunk queue, entity load will complete off-main
+            boolean interrupted = false;
+            while (!isCompleted.get()) {
+                interrupted |= Thread.interrupted();
+                LockSupport.park();
+            }
+
+            if (interrupted) {
+                Thread.currentThread().interrupt();
+            }
+        }
+
+        // now that the entity data is loaded, we can load it into the world
+
+        ret = current.loadInEntityChunk(transientChunk);
+
+        this.removeTicketAtLevel(TicketType.ENTITY_LOAD, chunkX, chunkZ, MAX_TICKET_LEVEL, entityLoadId);
+
+        return ret;
+    }
+
+    public PoiChunk getPoiChunkIfLoaded(final int chunkX, final int chunkZ) {
+        final NewChunkHolder holder = this.getChunkHolder(chunkX, chunkZ);
+        if (holder != null) {
+            return holder.getPoiChunk();
+        }
+        return null;
+    }
+
+    public PoiChunk loadPoiChunk(final int chunkX, final int chunkZ) {
+        TickThread.ensureTickThread(chunkX, chunkZ, "Cannot create poi chunk off-main");
+        final PoiChunk ret;
+
+        NewChunkHolder current = this.getChunkHolder(chunkX, chunkZ);
+        if (current != null && (ret = current.getPoiChunk()) != null) {
+            return ret;
+        }
+
+        final AtomicReference<PoiChunk> completed = new AtomicReference<>();
+        final AtomicBoolean isCompleted = new AtomicBoolean();
+        final Thread waiter = Thread.currentThread();
+        this.ticketLock.lock();
+        try {
+            this.taskScheduler.schedulingLock.lock();
+            try {
+                current = this.getOrCreateChunkHolder(chunkX, chunkZ);
+                if (current.isPoiChunkLoaded()) {
+                    return current.getPoiChunk();
+                }
+
+                current.getOrLoadPoiData((final GenericDataLoadTask.TaskResult<PoiChunk, Throwable> result) -> {
+                    completed.setPlain(result.left());
+                    isCompleted.set(true);
+                    LockSupport.unpark(waiter);
+                });
+                final ChunkLoadTask.PoiDataLoadTask poiLoad = current.getPoiDataLoadTask();
+
+                if (poiLoad != null) {
+                    poiLoad.raisePriority(PrioritisedExecutor.Priority.BLOCKING);
+                }
+            } finally {
+                this.taskScheduler.schedulingLock.unlock();
+            }
+        } finally {
+            this.ticketLock.unlock();
+        }
+
+        // Note: no need to busy wait on the chunk queue, poi load will complete off-main
+
+        boolean interrupted = false;
+        while (!isCompleted.get()) {
+            interrupted |= Thread.interrupted();
+            LockSupport.park();
+        }
+
+        if (interrupted) {
+            Thread.currentThread().interrupt();
+        }
+
+        return completed.getPlain();
+    }
+
+    void addChangedStatuses(final List<NewChunkHolder> changedFullStatus) {
+        if (changedFullStatus.isEmpty()) {
+            return;
+        }
+        this.ticketLock.lock();
+        try {
+            final ReferenceLinkedOpenHashSet<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
+            for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
+                pendingFullLoadUpdate.add(changedFullStatus.get(i));
+            }
+        } finally {
+            this.ticketLock.unlock();
+        }
+        this.taskScheduler.scheduleChunkTask(this::processPendingFullUpdate, PrioritisedExecutor.Priority.HIGHEST);
+    }
+
+    final ReferenceLinkedOpenHashSet<NewChunkHolder> unloadQueue = new ReferenceLinkedOpenHashSet<>();
+
+    private void removeChunkHolder(final NewChunkHolder holder) {
+        holder.vanillaChunkHolder.onChunkRemove();
+        this.autoSaveQueue.remove(holder);
+        this.chunkHolders.remove(CoordinateUtils.getChunkKey(holder.chunkX, holder.chunkZ));
+    }
+
+    // note: never call while inside the chunk system, this will absolutely break everything
+    public void processUnloads() {
+        TickThread.ensureTickThread("Cannot unload chunks off-main");
+
+        if (this.ticketLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Cannot hold ticket update lock while calling processUnloads");
+        }
+        if (this.taskScheduler.schedulingLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Cannot hold scheduling lock while calling processUnloads");
+        }
+
+        final List<NewChunkHolder.UnloadState> unloadQueue;
+        final List<ChunkProgressionTask> scheduleList = new ArrayList<>();
+        this.ticketLock.lock();
+        try {
+            this.taskScheduler.schedulingLock.lock();
+            try {
+                if (this.unloadQueue.isEmpty()) {
+                    return;
+                }
+                // in order to ensure all chunks in the unload queue do not have a pending ticket level update,
+                // process them now
+                this.processTicketUpdates(false, false, scheduleList);
+                unloadQueue = new ArrayList<>(this.unloadQueue.size());
+
+                final int unloadCount = Math.max(50, (int)(this.unloadQueue.size() * 0.05));
+                for (int i = 0; i < unloadCount && !this.unloadQueue.isEmpty(); ++i) {
+                    final NewChunkHolder chunkHolder = this.unloadQueue.removeFirst();
+                    if (chunkHolder.isSafeToUnload() != null) {
+                        LOGGER.error("Chunkholder " + chunkHolder + " is not safe to unload but is inside the unload queue?");
+                        continue;
+                    }
+                    final NewChunkHolder.UnloadState state = chunkHolder.unloadStage1();
+                    if (state == null) {
+                        // can unload immediately
+                        this.removeChunkHolder(chunkHolder);
+                        continue;
+                    }
+                    unloadQueue.add(state);
+                }
+            } finally {
+                this.taskScheduler.schedulingLock.unlock();
+            }
+        } finally {
+            this.ticketLock.unlock();
+        }
+        // schedule tasks, we can't let processTicketUpdates do this because we call it holding the schedule lock
+        for (int i = 0, len = scheduleList.size(); i < len; ++i) {
+            scheduleList.get(i).schedule();
+        }
+
+        final List<NewChunkHolder> toRemove = new ArrayList<>(unloadQueue.size());
+
+        final Boolean before = BLOCK_TICKET_UPDATES.get();
+        BLOCK_TICKET_UPDATES.set(Boolean.TRUE);
+        try {
+            for (int i = 0, len = unloadQueue.size(); i < len; ++i) {
+                final NewChunkHolder.UnloadState state = unloadQueue.get(i);
+                final NewChunkHolder holder = state.holder();
+
+                holder.unloadStage2(state);
+                toRemove.add(holder);
+            }
+        } finally {
+            BLOCK_TICKET_UPDATES.set(before);
+        }
+
+        this.ticketLock.lock();
+        try {
+            this.taskScheduler.schedulingLock.lock();
+            try {
+                for (int i = 0, len = toRemove.size(); i < len; ++i) {
+                    final NewChunkHolder holder = toRemove.get(i);
+
+                    if (holder.unloadStage3()) {
+                        this.removeChunkHolder(holder);
+                    } else {
+                        // add cooldown so the next unload check is not immediately next tick
+                        this.addTicketAtLevel(TicketType.UNLOAD_COOLDOWN, holder.chunkX, holder.chunkZ, MAX_TICKET_LEVEL, Unit.INSTANCE, 10L * 20L); // delay for 10s
+                    }
+                }
+            } finally {
+                this.taskScheduler.schedulingLock.unlock();
+            }
+        } finally {
+            this.ticketLock.unlock();
+        }
+    }
+
+    private final ThreadLocal<Boolean> BLOCK_TICKET_UPDATES = ThreadLocal.withInitial(() -> Boolean.FALSE);
+
+    public boolean processTicketUpdates() {
+        return this.processTicketUpdates(true, true, null);
+    }
+
+    private boolean processTicketUpdates(final boolean checkLocks, final boolean processFullUpdates, List<ChunkProgressionTask> scheduledTasks) {
+        if (BLOCK_TICKET_UPDATES.get() == Boolean.TRUE) {
+            throw new IllegalStateException("Cannot update ticket level while unloading chunks");
+        }
+        if (checkLocks && this.ticketLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Illegal recursive processTicketUpdates!");
+        }
+        if (checkLocks && this.taskScheduler.schedulingLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Cannot update ticket levels from a scheduler context!");
+        }
+
+        List<NewChunkHolder> changedFullStatus = null;
+
+        final boolean isTickThread = TickThread.isTickThread();
+
+        boolean ret = false;
+        final boolean canProcessFullUpdates = processFullUpdates & isTickThread;
+        final boolean canProcessScheduling = scheduledTasks == null;
+
+        this.ticketLock.lock();
+        try {
+            final boolean levelsUpdated = this.ticketLevelPropagator.propagateUpdates();
+            if (levelsUpdated) {
+                // Unlike CB, ticket level updates cannot happen recursively. Thank god.
+                if (!this.ticketLevelUpdates.isEmpty()) {
+                    ret = true;
+
+                    // first the necessary chunkholders must be created, so just update the ticket levels
+                    for (final Iterator<Long2IntMap.Entry> iterator = this.ticketLevelUpdates.long2IntEntrySet().fastIterator(); iterator.hasNext();) {
+                        final Long2IntMap.Entry entry = iterator.next();
+                        final long key = entry.getLongKey();
+                        final int newLevel = entry.getIntValue();
+
+                        NewChunkHolder current = this.chunkHolders.get(key);
+                        if (current == null && newLevel > MAX_TICKET_LEVEL) {
+                            // not loaded and it shouldn't be loaded!
+                            iterator.remove();
+                            continue;
+                        }
+
+                        final int currentLevel = current == null ? MAX_TICKET_LEVEL + 1 : current.getCurrentTicketLevel();
+                        if (currentLevel == newLevel) {
+                            // nothing to do
+                            iterator.remove();
+                            continue;
+                        }
+
+                        if (current == null) {
+                            // must create
+                            current = new NewChunkHolder(this.world, CoordinateUtils.getChunkX(key), CoordinateUtils.getChunkZ(key), this.taskScheduler);
+                            this.chunkHolders.put(key, current);
+                            current.updateTicketLevel(newLevel);
+                        } else {
+                            current.updateTicketLevel(newLevel);
+                        }
+                    }
+
+                    if (scheduledTasks == null) {
+                        scheduledTasks = new ArrayList<>();
+                    }
+                    changedFullStatus = new ArrayList<>();
+
+                    // allow the chunkholders to process ticket level updates without needing to acquire the schedule lock every time
+                    this.taskScheduler.schedulingLock.lock();
+                    try {
+                        for (final Iterator<Long2IntMap.Entry> iterator = this.ticketLevelUpdates.long2IntEntrySet().fastIterator(); iterator.hasNext();) {
+                            final Long2IntMap.Entry entry = iterator.next();
+                            final long key = entry.getLongKey();
+                            final NewChunkHolder current = this.chunkHolders.get(key);
+
+                            if (current == null) {
+                                throw new IllegalStateException("Expected chunk holder to be created");
+                            }
+
+                            current.processTicketLevelUpdate(scheduledTasks, changedFullStatus);
+                        }
+                    } finally {
+                        this.taskScheduler.schedulingLock.unlock();
+                    }
+
+                    if (!canProcessFullUpdates && !changedFullStatus.isEmpty()) {
+                        // if we have changed full status, and we're NOT on main, we need to add the changed chunks to
+                        // the pending full load update to preserve legacy behavior that if a chunk is brought up to
+                        // full status (level 33) and is completed generation, that the chunk has the plugin events loaded
+                        // and isChunkLoaded returns true and getChunkAtIfLoadedImmediately(x,z) != null immediately after
+                        // invoking the ticket level update
+                        final ReferenceLinkedOpenHashSet<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
+                        for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
+                            pendingFullLoadUpdate.add(changedFullStatus.get(i));
+                        }
+                    }
+
+                    this.ticketLevelUpdates.clear();
+                }
+            }
+        } finally {
+            this.ticketLock.unlock();
+        }
+
+        if (ret) {
+            // only schedule tasks while holding no locks
+            if (canProcessScheduling) {
+                for (int i = 0, len = scheduledTasks.size(); i < len; ++i) {
+                    scheduledTasks.get(i).schedule();
+                }
+            }
+
+            if (canProcessFullUpdates) {
+                this.processPendingFullUpdate();
+                this.handleChunkChangedFullStatuses(changedFullStatus);
+            } else {
+                this.taskScheduler.scheduleChunkTask(this::processPendingFullUpdate, PrioritisedExecutor.Priority.HIGHEST);
+            }
+        } else {
+            if (canProcessFullUpdates) {
+                ret |= this.processPendingFullUpdate();
+            }
+        }
+
+        return ret;
+    }
+
+    protected final ArrayDeque<NewChunkHolder> pendingFullUpdate = new ArrayDeque<>();
+
+    // only call on tick thread
+    protected final boolean processPendingFullUpdate() {
+        final ArrayDeque<NewChunkHolder> pendingFullUpdate = this.pendingFullUpdate;
+        this.ticketLock.lock();
+        try {
+            if (this.pendingFullLoadUpdate.isEmpty()) {
+                return false;
+            }
+            for (final NewChunkHolder chunkHolder : this.pendingFullLoadUpdate) {
+                pendingFullUpdate.add(chunkHolder);
+            }
+            this.pendingFullLoadUpdate.clear();
+        } finally {
+            this.ticketLock.unlock();
+        }
+
+        NewChunkHolder holder;
+        while ((holder = pendingFullUpdate.poll()) != null) {
+            holder.handleFullStatusChange();
+        }
+
+        return true;
+    }
+
+    protected final void handleChunkChangedFullStatuses(final List<NewChunkHolder> chunkHolders) {
+        for (int i = 0, len = chunkHolders.size(); i < len; ++i) {
+            chunkHolders.get(i).handleFullStatusChange();
+        }
+    }
+
+    public JsonObject getDebugJsonForWatchdog() {
+        // try and detect any potential deadlock that would require us to read unlocked
+        try {
+            if (this.ticketLock.tryLock(10, TimeUnit.SECONDS)) {
+                try {
+                    if (this.taskScheduler.schedulingLock.tryLock(10, TimeUnit.SECONDS)) {
+                        try {
+                            return this.getDebugJsonNoLock();
+                        } finally {
+                            this.taskScheduler.schedulingLock.unlock();
+                        }
+                    }
+                } finally {
+                    this.ticketLock.unlock();
+                }
+            }
+        } catch (final InterruptedException ignore) {}
+
+        LOGGER.error("Failed to acquire ticket and scheduling lock before timeout for world " + this.world.getWorld().getName());
+
+        // because we read without locks, it may throw exceptions for fastutil maps
+        // so just try until it works...
+        Throwable lastException = null;
+        for (int count = 0;count < 1000;++count) {
+            try {
+                return this.getDebugJsonNoLock();
+            } catch (final ThreadDeath death) {
+                throw death;
+            } catch (final Throwable thr) {
+                lastException = thr;
+                Thread.yield();
+                LockSupport.parkNanos(10_000L);
+            }
+        }
+
+        // failed, return
+        LOGGER.error("Failed to retrieve debug json for watchdog thread without locking", lastException);
+        return null;
+    }
+
+    private JsonObject getDebugJsonNoLock() {
+        final JsonObject ret = new JsonObject();
+        ret.addProperty("current_tick", Long.valueOf(this.currentTick));
+
+        final JsonArray unloadQueue = new JsonArray();
+        ret.add("unload_queue", unloadQueue);
+        for (final NewChunkHolder holder : this.unloadQueue) {
+            final JsonObject coordinate = new JsonObject();
+            unloadQueue.add(coordinate);
+
+            coordinate.addProperty("chunkX", Integer.valueOf(holder.chunkX));
+            coordinate.addProperty("chunkZ", Integer.valueOf(holder.chunkZ));
+        }
+
+        final JsonArray holders = new JsonArray();
+        ret.add("chunkholders", holders);
+
+        for (final NewChunkHolder holder : this.getChunkHolders()) {
+            holders.add(holder.getDebugJson());
+        }
+
+        final JsonArray removeTickToChunkExpireTicketCount = new JsonArray();
+        ret.add("remove_tick_to_chunk_expire_ticket_count", removeTickToChunkExpireTicketCount);
+
+        for (final Long2ObjectMap.Entry<Long2IntOpenHashMap> tickEntry : this.removeTickToChunkExpireTicketCount.long2ObjectEntrySet()) {
+            final long tick = tickEntry.getLongKey();
+            final Long2IntOpenHashMap coordinateToCount = tickEntry.getValue();
+
+            final JsonObject tickJson = new JsonObject();
+            removeTickToChunkExpireTicketCount.add(tickJson);
+
+            tickJson.addProperty("tick", Long.valueOf(tick));
+
+            final JsonArray tickEntries = new JsonArray();
+            tickJson.add("entries", tickEntries);
+
+            for (final Long2IntMap.Entry entry : coordinateToCount.long2IntEntrySet()) {
+                final long coordinate = entry.getLongKey();
+                final int count = entry.getIntValue();
+
+                final JsonObject entryJson = new JsonObject();
+                tickEntries.add(entryJson);
+
+                entryJson.addProperty("chunkX", Long.valueOf(CoordinateUtils.getChunkX(coordinate)));
+                entryJson.addProperty("chunkZ", Long.valueOf(CoordinateUtils.getChunkZ(coordinate)));
+                entryJson.addProperty("count", Integer.valueOf(count));
+            }
+        }
+
+        final JsonArray allTicketsJson = new JsonArray();
+        ret.add("tickets", allTicketsJson);
+
+        for (final Long2ObjectMap.Entry<SortedArraySet<Ticket<?>>> coordinateTickets : this.tickets.long2ObjectEntrySet()) {
+            final long coordinate = coordinateTickets.getLongKey();
+            final SortedArraySet<Ticket<?>> tickets = coordinateTickets.getValue();
+
+            final JsonObject coordinateJson = new JsonObject();
+            allTicketsJson.add(coordinateJson);
+
+            coordinateJson.addProperty("chunkX", Long.valueOf(CoordinateUtils.getChunkX(coordinate)));
+            coordinateJson.addProperty("chunkZ", Long.valueOf(CoordinateUtils.getChunkZ(coordinate)));
+
+            final JsonArray ticketsSerialized = new JsonArray();
+            coordinateJson.add("tickets", ticketsSerialized);
+
+            for (final Ticket<?> ticket : tickets) {
+                final JsonObject ticketSerialized = new JsonObject();
+                ticketsSerialized.add(ticketSerialized);
+
+                ticketSerialized.addProperty("type", ticket.getType().toString());
+                ticketSerialized.addProperty("level", Integer.valueOf(ticket.getTicketLevel()));
+                ticketSerialized.addProperty("identifier", Objects.toString(ticket.key));
+                ticketSerialized.addProperty("remove_tick", Long.valueOf(ticket.removalTick));
+            }
+        }
+
+        return ret;
+    }
+
+    public JsonObject getDebugJson() {
+        final List<ChunkProgressionTask> scheduleList = new ArrayList<>();
+        try {
+            final JsonObject ret;
+            this.ticketLock.lock();
+            try {
+                this.taskScheduler.schedulingLock.lock();
+                try {
+                    this.processTicketUpdates(false, false, scheduleList);
+                    ret = this.getDebugJsonNoLock();
+                } finally {
+                    this.taskScheduler.schedulingLock.unlock();
+                }
+            } finally {
+                this.ticketLock.unlock();
+            }
+            return ret;
+        } finally {
+            // schedule tasks, we can't let processTicketUpdates do this because we call it holding the schedule lock
+            for (int i = 0, len = scheduleList.size(); i < len; ++i) {
+                scheduleList.get(i).schedule();
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLightTask.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLightTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..53ddd7e9ac05e6a9eb809f329796e6d4f6bb2ab1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLightTask.java
@@ -0,0 +1,181 @@
+package io.papermc.paper.chunk.system.scheduling;
+
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.starlight.common.light.StarLightEngine;
+import ca.spottedleaf.starlight.common.light.StarLightInterface;
+import io.papermc.paper.chunk.system.light.LightQueue;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.ProtoChunk;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import java.util.function.BooleanSupplier;
+
+public final class ChunkLightTask extends ChunkProgressionTask {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    protected final ChunkAccess fromChunk;
+
+    private final LightTaskPriorityHolder priorityHolder;
+
+    public ChunkLightTask(final ChunkTaskScheduler scheduler, final ServerLevel world, final int chunkX, final int chunkZ,
+                          final ChunkAccess chunk, final PrioritisedExecutor.Priority priority) {
+        super(scheduler, world, chunkX, chunkZ);
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+        this.priorityHolder = new LightTaskPriorityHolder(priority, this);
+        this.fromChunk = chunk;
+    }
+
+    @Override
+    public boolean isScheduled() {
+        return this.priorityHolder.isScheduled();
+    }
+
+    @Override
+    public ChunkStatus getTargetStatus() {
+        return ChunkStatus.LIGHT;
+    }
+
+    @Override
+    public void schedule() {
+        this.priorityHolder.schedule();
+    }
+
+    @Override
+    public void cancel() {
+        this.priorityHolder.cancel();
+    }
+
+    @Override
+    public PrioritisedExecutor.Priority getPriority() {
+        return this.priorityHolder.getPriority();
+    }
+
+    @Override
+    public void lowerPriority(final PrioritisedExecutor.Priority priority) {
+        this.priorityHolder.raisePriority(priority);
+    }
+
+    @Override
+    public void setPriority(final PrioritisedExecutor.Priority priority) {
+        this.priorityHolder.setPriority(priority);
+    }
+
+    @Override
+    public void raisePriority(final PrioritisedExecutor.Priority priority) {
+        this.priorityHolder.raisePriority(priority);
+    }
+
+    private static final class LightTaskPriorityHolder extends PriorityHolder {
+
+        protected final ChunkLightTask task;
+
+        protected LightTaskPriorityHolder(final PrioritisedExecutor.Priority priority, final ChunkLightTask task) {
+            super(priority);
+            this.task = task;
+        }
+
+        @Override
+        protected void cancelScheduled() {
+            final ChunkLightTask task = this.task;
+            task.complete(null, null);
+        }
+
+        @Override
+        protected PrioritisedExecutor.Priority getScheduledPriority() {
+            final ChunkLightTask task = this.task;
+            return task.world.getChunkSource().getLightEngine().theLightEngine.lightQueue.getPriority(task.chunkX, task.chunkZ);
+        }
+
+        @Override
+        protected void scheduleTask(final PrioritisedExecutor.Priority priority) {
+            final ChunkLightTask task = this.task;
+            final StarLightInterface starLightInterface = task.world.getChunkSource().getLightEngine().theLightEngine;
+            final LightQueue lightQueue = starLightInterface.lightQueue;
+            lightQueue.queueChunkLightTask(new ChunkPos(task.chunkX, task.chunkZ), new LightTask(starLightInterface, task), priority);
+            lightQueue.setPriority(task.chunkX, task.chunkZ, priority);
+        }
+
+        @Override
+        protected void lowerPriorityScheduled(final PrioritisedExecutor.Priority priority) {
+            final ChunkLightTask task = this.task;
+            final StarLightInterface starLightInterface = task.world.getChunkSource().getLightEngine().theLightEngine;
+            final LightQueue lightQueue = starLightInterface.lightQueue;
+            lightQueue.lowerPriority(task.chunkX, task.chunkZ, priority);
+        }
+
+        @Override
+        protected void setPriorityScheduled(final PrioritisedExecutor.Priority priority) {
+            final ChunkLightTask task = this.task;
+            final StarLightInterface starLightInterface = task.world.getChunkSource().getLightEngine().theLightEngine;
+            final LightQueue lightQueue = starLightInterface.lightQueue;
+            lightQueue.setPriority(task.chunkX, task.chunkZ, priority);
+        }
+
+        @Override
+        protected void raisePriorityScheduled(final PrioritisedExecutor.Priority priority) {
+            final ChunkLightTask task = this.task;
+            final StarLightInterface starLightInterface = task.world.getChunkSource().getLightEngine().theLightEngine;
+            final LightQueue lightQueue = starLightInterface.lightQueue;
+            lightQueue.raisePriority(task.chunkX, task.chunkZ, priority);
+        }
+    }
+
+    private static final class LightTask implements BooleanSupplier {
+
+        protected final StarLightInterface lightEngine;
+        protected final ChunkLightTask task;
+
+        public LightTask(final StarLightInterface lightEngine, final ChunkLightTask task) {
+            this.lightEngine = lightEngine;
+            this.task = task;
+        }
+
+        @Override
+        public boolean getAsBoolean() {
+            final ChunkLightTask task = this.task;
+            // executed on light thread
+            if (!task.priorityHolder.markExecuting()) {
+                // cancelled
+                return false;
+            }
+
+            try {
+                final Boolean[] emptySections = StarLightEngine.getEmptySectionsForChunk(task.fromChunk);
+
+                if (task.fromChunk.isLightCorrect() && task.fromChunk.getStatus().isOrAfter(ChunkStatus.LIGHT)) {
+                    this.lightEngine.forceLoadInChunk(task.fromChunk, emptySections);
+                    this.lightEngine.checkChunkEdges(task.chunkX, task.chunkZ);
+                } else {
+                    task.fromChunk.setLightCorrect(false);
+                    this.lightEngine.lightChunk(task.fromChunk, emptySections);
+                    task.fromChunk.setLightCorrect(true);
+                }
+                // we need to advance status
+                if (task.fromChunk instanceof ProtoChunk chunk && chunk.getStatus() == ChunkStatus.LIGHT.getParent()) {
+                    chunk.setStatus(ChunkStatus.LIGHT);
+                }
+            } catch (final Throwable thr) {
+                if (!(thr instanceof ThreadDeath)) {
+                    LOGGER.fatal("Failed to light chunk " + task.fromChunk.getPos().toString() + " in world '" + this.lightEngine.getWorld().getWorld().getName() + "'", thr);
+                }
+
+                task.complete(null, thr);
+
+                if (thr instanceof ThreadDeath) {
+                    throw (ThreadDeath)thr;
+                }
+
+                return true;
+            }
+
+            task.complete(task.fromChunk, null);
+            return true;
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLoadTask.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLoadTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..b0252f13c8cebef293d9a4fc49778184cb17e3ff
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLoadTask.java
@@ -0,0 +1,457 @@
+package io.papermc.paper.chunk.system.scheduling;
+
+import ca.spottedleaf.concurrentutil.collection.MultiThreadedQueue;
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import ca.spottedleaf.dataconverter.minecraft.MCDataConverter;
+import ca.spottedleaf.dataconverter.minecraft.datatypes.MCTypeRegistry;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.chunk.system.io.RegionFileIOThread;
+import io.papermc.paper.chunk.system.poi.PoiChunk;
+import net.minecraft.SharedConstants;
+import net.minecraft.core.Registry;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.level.ChunkMap;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.ProtoChunk;
+import net.minecraft.world.level.chunk.UpgradeData;
+import net.minecraft.world.level.chunk.storage.ChunkSerializer;
+import net.minecraft.world.level.chunk.storage.EntityStorage;
+import net.minecraft.world.level.levelgen.blending.BlendingData;
+import org.slf4j.Logger;
+import java.lang.invoke.VarHandle;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Consumer;
+
+public final class ChunkLoadTask extends ChunkProgressionTask {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    private final NewChunkHolder chunkHolder;
+    private final ChunkDataLoadTask loadTask;
+
+    private boolean cancelled;
+    private NewChunkHolder.GenericDataLoadTaskCallback entityLoadTask;
+    private NewChunkHolder.GenericDataLoadTaskCallback poiLoadTask;
+
+    protected ChunkLoadTask(final ChunkTaskScheduler scheduler, final ServerLevel world, final int chunkX, final int chunkZ,
+                            final NewChunkHolder chunkHolder, final PrioritisedExecutor.Priority priority) {
+        super(scheduler, world, chunkX, chunkZ);
+        this.chunkHolder = chunkHolder;
+        this.loadTask = new ChunkDataLoadTask(scheduler, world, chunkX, chunkZ, priority);
+        this.loadTask.addCallback((final GenericDataLoadTask.TaskResult<ChunkAccess, Throwable> result) -> {
+            ChunkLoadTask.this.complete(result == null ? null : result.left(), result == null ? null : result.right());
+        });
+    }
+
+    @Override
+    public ChunkStatus getTargetStatus() {
+        return ChunkStatus.EMPTY;
+    }
+
+    private boolean scheduled;
+
+    @Override
+    public boolean isScheduled() {
+        return this.scheduled;
+    }
+
+    @Override
+    public void schedule() {
+        final NewChunkHolder.GenericDataLoadTaskCallback entityLoadTask;
+        final NewChunkHolder.GenericDataLoadTaskCallback poiLoadTask;
+
+        final AtomicInteger count = new AtomicInteger();
+        final Consumer<GenericDataLoadTask.TaskResult<?, ?>> scheduleLoadTask = (final GenericDataLoadTask.TaskResult<?, ?> result) -> {
+            if (count.decrementAndGet() == 0) {
+                ChunkLoadTask.this.loadTask.schedule();
+            }
+        };
+
+        // NOTE: it is IMPOSSIBLE for getOrLoadEntityData/getOrLoadPoiData to complete synchronously, because
+        // they must schedule a task to off main or to on main to complete
+        this.scheduler.schedulingLock.lock();
+        try {
+            if (this.scheduled) {
+                throw new IllegalStateException("schedule() called twice");
+            }
+            this.scheduled = true;
+            if (this.cancelled) {
+                return;
+            }
+            if (!this.chunkHolder.isEntityChunkNBTLoaded()) {
+                entityLoadTask = this.chunkHolder.getOrLoadEntityData((Consumer)scheduleLoadTask);
+                count.setPlain(count.getPlain() + 1);
+            } else {
+                entityLoadTask = null;
+            }
+
+            if (!this.chunkHolder.isPoiChunkLoaded()) {
+                poiLoadTask = this.chunkHolder.getOrLoadPoiData((Consumer)scheduleLoadTask);
+                count.setPlain(count.getPlain() + 1);
+            } else {
+                poiLoadTask = null;
+            }
+
+            this.entityLoadTask = entityLoadTask;
+            this.poiLoadTask = poiLoadTask;
+        } finally {
+            this.scheduler.schedulingLock.unlock();
+        }
+
+        if (entityLoadTask == null && poiLoadTask == null) {
+            // no need to wait on those, we can schedule now
+            this.loadTask.schedule();
+        }
+    }
+
+    @Override
+    public void cancel() {
+        // must be before load task access, so we can synchronise with the writes to the fields
+        this.scheduler.schedulingLock.lock();
+        try {
+            this.cancelled = true;
+        } finally {
+            this.scheduler.schedulingLock.unlock();
+        }
+
+        /*
+        Note: The entityLoadTask/poiLoadTask do not complete when cancelled,
+        but this is fine because if they are successfully cancelled then
+        we will successfully cancel the load task, which will complete when cancelled
+        */
+
+        if (this.entityLoadTask != null) {
+            this.entityLoadTask.cancel();
+        }
+        if (this.poiLoadTask != null) {
+            this.poiLoadTask.cancel();
+        }
+        this.loadTask.cancel();
+    }
+
+    @Override
+    public PrioritisedExecutor.Priority getPriority() {
+        return this.loadTask.getPriority();
+    }
+
+    @Override
+    public void lowerPriority(final PrioritisedExecutor.Priority priority) {
+        final EntityDataLoadTask entityLoad = this.chunkHolder.getEntityDataLoadTask();
+        if (entityLoad != null) {
+            entityLoad.lowerPriority(priority);
+        }
+
+        final PoiDataLoadTask poiLoad = this.chunkHolder.getPoiDataLoadTask();
+
+        if (poiLoad != null) {
+            poiLoad.lowerPriority(priority);
+        }
+
+        this.loadTask.lowerPriority(priority);
+    }
+
+    @Override
+    public void setPriority(final PrioritisedExecutor.Priority priority) {
+        final EntityDataLoadTask entityLoad = this.chunkHolder.getEntityDataLoadTask();
+        if (entityLoad != null) {
+            entityLoad.setPriority(priority);
+        }
+
+        final PoiDataLoadTask poiLoad = this.chunkHolder.getPoiDataLoadTask();
+
+        if (poiLoad != null) {
+            poiLoad.setPriority(priority);
+        }
+
+        this.loadTask.setPriority(priority);
+    }
+
+    @Override
+    public void raisePriority(final PrioritisedExecutor.Priority priority) {
+        final EntityDataLoadTask entityLoad = this.chunkHolder.getEntityDataLoadTask();
+        if (entityLoad != null) {
+            entityLoad.raisePriority(priority);
+        }
+
+        final PoiDataLoadTask poiLoad = this.chunkHolder.getPoiDataLoadTask();
+
+        if (poiLoad != null) {
+            poiLoad.raisePriority(priority);
+        }
+
+        this.loadTask.raisePriority(priority);
+    }
+
+    protected static abstract class CallbackDataLoadTask<OnMain,FinalCompletion> extends GenericDataLoadTask<OnMain,FinalCompletion> {
+
+        private TaskResult<FinalCompletion, Throwable> result;
+        private final MultiThreadedQueue<Consumer<TaskResult<FinalCompletion, Throwable>>> waiters = new MultiThreadedQueue<>();
+
+        protected volatile boolean completed;
+        protected static final VarHandle COMPLETED_HANDLE = ConcurrentUtil.getVarHandle(CallbackDataLoadTask.class, "completed", boolean.class);
+
+        protected CallbackDataLoadTask(final ChunkTaskScheduler scheduler, final ServerLevel world, final int chunkX,
+                                       final int chunkZ, final RegionFileIOThread.RegionFileType type,
+                                       final PrioritisedExecutor.Priority priority) {
+            super(scheduler, world, chunkX, chunkZ, type, priority);
+        }
+
+        public void addCallback(final Consumer<TaskResult<FinalCompletion, Throwable>> consumer) {
+            if (!this.waiters.add(consumer)) {
+                try {
+                    consumer.accept(this.result);
+                } catch (final Throwable throwable) {
+                    this.scheduler.unrecoverableChunkSystemFailure(this.chunkX, this.chunkZ, Map.of(
+                        "Consumer", ChunkTaskScheduler.stringIfNull(consumer),
+                        "Completed throwable", ChunkTaskScheduler.stringIfNull(this.result.right())
+                    ), throwable);
+                    if (throwable instanceof ThreadDeath) {
+                        throw (ThreadDeath)throwable;
+                    }
+                }
+            }
+        }
+
+        @Override
+        protected void onComplete(final TaskResult<FinalCompletion, Throwable> result) {
+            if ((boolean)COMPLETED_HANDLE.getAndSet((CallbackDataLoadTask)this, (boolean)true)) {
+                throw new IllegalStateException("Already completed");
+            }
+            this.result = result;
+            Consumer<TaskResult<FinalCompletion, Throwable>> consumer;
+            while ((consumer = this.waiters.pollOrBlockAdds()) != null) {
+                try {
+                    consumer.accept(result);
+                } catch (final Throwable throwable) {
+                    this.scheduler.unrecoverableChunkSystemFailure(this.chunkX, this.chunkZ, Map.of(
+                        "Consumer", ChunkTaskScheduler.stringIfNull(consumer),
+                        "Completed throwable", ChunkTaskScheduler.stringIfNull(result.right())
+                    ), throwable);
+                    if (throwable instanceof ThreadDeath) {
+                        throw (ThreadDeath)throwable;
+                    }
+                    return;
+                }
+            }
+        }
+    }
+
+    public static final class ChunkDataLoadTask extends CallbackDataLoadTask<ChunkSerializer.InProgressChunkHolder, ChunkAccess> {
+        protected ChunkDataLoadTask(final ChunkTaskScheduler scheduler, final ServerLevel world, final int chunkX,
+                                    final int chunkZ, final PrioritisedExecutor.Priority priority) {
+            super(scheduler, world, chunkX, chunkZ, RegionFileIOThread.RegionFileType.CHUNK_DATA, priority);
+        }
+
+        @Override
+        protected boolean hasOffMain() {
+            return true;
+        }
+
+        @Override
+        protected boolean hasOnMain() {
+            return true;
+        }
+
+        @Override
+        protected PrioritisedExecutor.PrioritisedTask createOffMain(final Runnable run, final PrioritisedExecutor.Priority priority) {
+            return this.scheduler.loadExecutor.createTask(run, priority);
+        }
+
+        @Override
+        protected PrioritisedExecutor.PrioritisedTask createOnMain(final Runnable run, final PrioritisedExecutor.Priority priority) {
+            return this.scheduler.createChunkTask(this.chunkX, this.chunkZ, run, priority);
+        }
+
+        @Override
+        protected TaskResult<ChunkSerializer.InProgressChunkHolder, Throwable> runOffMain(final CompoundTag data, final Throwable throwable) {
+            if (throwable != null) {
+                LOGGER.error("Failed to load chunk data for task: " + this.toString() + ", chunk data will be lost", throwable);
+                return new TaskResult<>(null, null);
+            }
+
+            if (data == null) {
+                return new TaskResult<>(null, null);
+            }
+
+            // need to convert data, and then deserialize it
+
+            try {
+                final ChunkPos chunkPos = new ChunkPos(this.chunkX, this.chunkZ);
+                final ChunkMap chunkMap = this.world.getChunkSource().chunkMap;
+                // run converters
+                // note: upgradeChunkTag copies the data already
+                final CompoundTag converted = chunkMap.upgradeChunkTag(
+                    this.world.getTypeKey(), chunkMap.overworldDataStorage, data, chunkMap.generator.getTypeNameForDataFixer(),
+                    chunkPos, this.world
+                );
+                // deserialize
+                final ChunkSerializer.InProgressChunkHolder chunkHolder = ChunkSerializer.loadChunk(
+                    this.world, chunkMap.getPoiManager(), chunkPos, converted, true
+                );
+
+                return new TaskResult<>(chunkHolder, null);
+            } catch (final ThreadDeath death) {
+                throw death;
+            } catch (final Throwable thr2) {
+                LOGGER.error("Failed to run parse chunk data for task: " + this.toString() + ", chunk data will be lost", thr2);
+                return new TaskResult<>(null, thr2);
+            }
+        }
+
+        private ProtoChunk getEmptyChunk() {
+            return new ProtoChunk(
+                new ChunkPos(this.chunkX, this.chunkZ), UpgradeData.EMPTY, this.world,
+                this.world.registryAccess().registryOrThrow(Registry.BIOME_REGISTRY), (BlendingData)null
+            );
+        }
+
+        @Override
+        protected TaskResult<ChunkAccess, Throwable> runOnMain(final ChunkSerializer.InProgressChunkHolder data, final Throwable throwable) {
+            if (data == null || data.protoChunk == null) {
+                // throwable could be non-null, but the off-main task will print its exceptions - so we don't need to care,
+                // it's handled already
+
+                return new TaskResult<>(this.getEmptyChunk(), null);
+            }
+
+            // have tasks to run (at this point, it's just the POI consistency checking)
+            try {
+                if (data.tasks != null) {
+                    for (int i = 0, len = data.tasks.size(); i < len; ++i) {
+                        data.tasks.poll().run();
+                    }
+                }
+
+                return new TaskResult<>(data.protoChunk, null);
+            } catch (final ThreadDeath death) {
+                throw death;
+            } catch (final Throwable thr2) {
+                LOGGER.error("Failed to parse main tasks for task " + this.toString() + ", chunk data will be lost", thr2);
+                return new TaskResult<>(this.getEmptyChunk(), null);
+            }
+        }
+    }
+
+    public static final class PoiDataLoadTask extends CallbackDataLoadTask<PoiChunk, PoiChunk> {
+        public PoiDataLoadTask(final ChunkTaskScheduler scheduler, final ServerLevel world, final int chunkX,
+                                  final int chunkZ, final PrioritisedExecutor.Priority priority) {
+            super(scheduler, world, chunkX, chunkZ, RegionFileIOThread.RegionFileType.POI_DATA, priority);
+        }
+
+        @Override
+        protected boolean hasOffMain() {
+            return true;
+        }
+
+        @Override
+        protected boolean hasOnMain() {
+            return false;
+        }
+
+        @Override
+        protected PrioritisedExecutor.PrioritisedTask createOffMain(final Runnable run, final PrioritisedExecutor.Priority priority) {
+            return this.scheduler.loadExecutor.createTask(run, priority);
+        }
+
+        @Override
+        protected PrioritisedExecutor.PrioritisedTask createOnMain(final Runnable run, final PrioritisedExecutor.Priority priority) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        protected TaskResult<PoiChunk, Throwable> runOffMain(CompoundTag data, final Throwable throwable) {
+            if (throwable != null) {
+                LOGGER.error("Failed to load poi data for task: " + this.toString() + ", poi data will be lost", throwable);
+                return new TaskResult<>(PoiChunk.empty(this.world, this.chunkX, this.chunkZ), null);
+            }
+
+            if (data == null || data.isEmpty()) {
+                // nothing to do
+                return new TaskResult<>(PoiChunk.empty(this.world, this.chunkX, this.chunkZ), null);
+            }
+
+            try {
+                data = data.copy(); // coming from the I/O thread, so we need to copy
+                // run converters
+                final int dataVersion = !data.contains(SharedConstants.DATA_VERSION_TAG, 99) ? 1945 : data.getInt(SharedConstants.DATA_VERSION_TAG);
+                final CompoundTag converted = MCDataConverter.convertTag(
+                    MCTypeRegistry.POI_CHUNK, data, dataVersion, SharedConstants.getCurrentVersion().getWorldVersion()
+                );
+
+                // now we need to parse it
+                return new TaskResult<>(PoiChunk.parse(this.world, this.chunkX, this.chunkZ, converted), null);
+            } catch (final ThreadDeath death) {
+                throw death;
+            } catch (final Throwable thr2) {
+                LOGGER.error("Failed to run parse poi data for task: " + this.toString() + ", poi data will be lost", thr2);
+                return new TaskResult<>(PoiChunk.empty(this.world, this.chunkX, this.chunkZ), null);
+            }
+        }
+
+        @Override
+        protected TaskResult<PoiChunk, Throwable> runOnMain(final PoiChunk data, final Throwable throwable) {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+    public static final class EntityDataLoadTask extends CallbackDataLoadTask<CompoundTag, CompoundTag> {
+
+        public EntityDataLoadTask(final ChunkTaskScheduler scheduler, final ServerLevel world, final int chunkX,
+                                  final int chunkZ, final PrioritisedExecutor.Priority priority) {
+            super(scheduler, world, chunkX, chunkZ, RegionFileIOThread.RegionFileType.ENTITY_DATA, priority);
+        }
+
+        @Override
+        protected boolean hasOffMain() {
+            return true;
+        }
+
+        @Override
+        protected boolean hasOnMain() {
+            return false;
+        }
+
+        @Override
+        protected PrioritisedExecutor.PrioritisedTask createOffMain(final Runnable run, final PrioritisedExecutor.Priority priority) {
+            return this.scheduler.loadExecutor.createTask(run, priority);
+        }
+
+        @Override
+        protected PrioritisedExecutor.PrioritisedTask createOnMain(final Runnable run, final PrioritisedExecutor.Priority priority) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        protected TaskResult<CompoundTag, Throwable> runOffMain(final CompoundTag data, final Throwable throwable) {
+            if (throwable != null) {
+                LOGGER.error("Failed to load entity data for task: " + this.toString() + ", entity data will be lost", throwable);
+                return new TaskResult<>(null, null);
+            }
+
+            if (data == null || data.isEmpty()) {
+                // nothing to do
+                return new TaskResult<>(null, null);
+            }
+
+            try {
+                // note: data comes from the I/O thread, so we need to copy it
+                return new TaskResult<>(EntityStorage.upgradeChunkTag(data.copy()), null);
+            } catch (final ThreadDeath death) {
+                throw death;
+            } catch (final Throwable thr2) {
+                LOGGER.error("Failed to run converters for entity data for task: " + this.toString() + ", entity data will be lost", thr2);
+                return new TaskResult<>(null, thr2);
+            }
+        }
+
+        @Override
+        protected TaskResult<CompoundTag, Throwable> runOnMain(final CompoundTag data, final Throwable throwable) {
+            throw new UnsupportedOperationException();
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkProgressionTask.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkProgressionTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..322675a470eacbf0e5452f4009c643f2d0b4ce24
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkProgressionTask.java
@@ -0,0 +1,105 @@
+package io.papermc.paper.chunk.system.scheduling;
+
+import ca.spottedleaf.concurrentutil.collection.MultiThreadedQueue;
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import java.lang.invoke.VarHandle;
+import java.util.Map;
+import java.util.function.BiConsumer;
+
+public abstract class ChunkProgressionTask {
+
+    private final MultiThreadedQueue<BiConsumer<ChunkAccess, Throwable>> waiters = new MultiThreadedQueue<>();
+    private ChunkAccess completedChunk;
+    private Throwable completedThrowable;
+
+    protected final ChunkTaskScheduler scheduler;
+    protected final ServerLevel world;
+    protected final int chunkX;
+    protected final int chunkZ;
+
+    protected volatile boolean completed;
+    protected static final VarHandle COMPLETED_HANDLE = ConcurrentUtil.getVarHandle(ChunkProgressionTask.class, "completed", boolean.class);
+
+    protected ChunkProgressionTask(final ChunkTaskScheduler scheduler, final ServerLevel world, final int chunkX, final int chunkZ) {
+        this.scheduler = scheduler;
+        this.world = world;
+        this.chunkX = chunkX;
+        this.chunkZ = chunkZ;
+    }
+
+    // Used only for debug json
+    public abstract boolean isScheduled();
+
+    // Note: It is the responsibility of the task to set the chunk's status once it has completed
+    public abstract ChunkStatus getTargetStatus();
+
+    /* Only executed once */
+    /* Implementations must be prepared to handle cases where cancel() is called before schedule() */
+    public abstract void schedule();
+
+    /* May be called multiple times */
+    public abstract void cancel();
+
+    public abstract PrioritisedExecutor.Priority getPriority();
+
+    /* Schedule lock is always held for the priority update calls */
+
+    public abstract void lowerPriority(final PrioritisedExecutor.Priority priority);
+
+    public abstract void setPriority(final PrioritisedExecutor.Priority priority);
+
+    public abstract void raisePriority(final PrioritisedExecutor.Priority priority);
+
+    public final void onComplete(final BiConsumer<ChunkAccess, Throwable> onComplete) {
+        if (!this.waiters.add(onComplete)) {
+            try {
+                onComplete.accept(this.completedChunk, this.completedThrowable);
+            } catch (final Throwable throwable) {
+                this.scheduler.unrecoverableChunkSystemFailure(this.chunkX, this.chunkZ, Map.of(
+                    "Consumer", ChunkTaskScheduler.stringIfNull(onComplete),
+                    "Completed throwable", ChunkTaskScheduler.stringIfNull(this.completedThrowable)
+                ), throwable);
+                if (throwable instanceof ThreadDeath) {
+                    throw (ThreadDeath)throwable;
+                }
+            }
+        }
+    }
+
+    protected final void complete(final ChunkAccess chunk, final Throwable throwable) {
+        try {
+            this.complete0(chunk, throwable);
+        } catch (final Throwable thr2) {
+            this.scheduler.unrecoverableChunkSystemFailure(this.chunkX, this.chunkZ, Map.of(
+                "Completed throwable", ChunkTaskScheduler.stringIfNull(throwable)
+            ), thr2);
+            if (thr2 instanceof ThreadDeath) {
+                throw (ThreadDeath)thr2;
+            }
+        }
+    }
+
+    private void complete0(final ChunkAccess chunk, final Throwable throwable) {
+        if ((boolean)COMPLETED_HANDLE.getAndSet((ChunkProgressionTask)this, (boolean)true)) {
+            throw new IllegalStateException("Already completed");
+        }
+        this.completedChunk = chunk;
+        this.completedThrowable = throwable;
+
+        BiConsumer<ChunkAccess, Throwable> consumer;
+        while ((consumer = this.waiters.pollOrBlockAdds()) != null) {
+            consumer.accept(chunk, throwable);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "ChunkProgressionTask{class: " + this.getClass().getName() + ", for world: " + this.world.getWorld().getName() +
+            ", chunk: (" + this.chunkX + "," + this.chunkZ + "), hashcode: " + System.identityHashCode(this) + ", priority: " + this.getPriority() +
+            ", status: " + this.getTargetStatus().toString() + ", scheduled: " + this.isScheduled() + "}";
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
new file mode 100644
index 0000000000000000000000000000000000000000..ea1876187b82b6485b727d20a51311ff14650db0
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
@@ -0,0 +1,752 @@
+package io.papermc.paper.chunk.system.scheduling;
+
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedThreadPool;
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedThreadedTaskQueue;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.configuration.GlobalConfiguration;
+import io.papermc.paper.util.CoordinateUtils;
+import io.papermc.paper.util.TickThread;
+import it.unimi.dsi.fastutil.objects.ReferenceLinkedOpenHashSet;
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
+import net.minecraft.CrashReport;
+import net.minecraft.CrashReportCategory;
+import net.minecraft.ReportedException;
+import net.minecraft.server.MCUtil;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ChunkMap;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.TicketType;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import org.bukkit.Bukkit;
+import org.slf4j.Logger;
+import java.io.File;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.BooleanSupplier;
+import java.util.function.Consumer;
+
+public final class ChunkTaskScheduler {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    static int newChunkSystemIOThreads;
+    static int newChunkSystemWorkerThreads;
+    static int newChunkSystemGenParallelism;
+    static int newChunkSystemLoadParallelism;
+
+    public static ca.spottedleaf.concurrentutil.executor.standard.PrioritisedThreadPool workerThreads;
+
+    private static boolean initialised = false;
+
+    public static void init(final GlobalConfiguration.ChunkSystem config) {
+        if (initialised) {
+            return;
+        }
+        initialised = true;
+        newChunkSystemIOThreads = config.ioThreads;
+        newChunkSystemWorkerThreads = config.workerThreads;
+        if (newChunkSystemIOThreads < 0) {
+            newChunkSystemIOThreads = 1;
+        } else {
+            newChunkSystemIOThreads = Math.max(1, newChunkSystemIOThreads);
+        }
+        int defaultWorkerThreads = Runtime.getRuntime().availableProcessors() / 2;
+        if (defaultWorkerThreads <= 4) {
+            defaultWorkerThreads = defaultWorkerThreads <= 3 ? 1 : 2;
+        } else {
+            defaultWorkerThreads = defaultWorkerThreads / 2;
+        }
+        defaultWorkerThreads = Integer.getInteger("Paper.WorkerThreadCount", Integer.valueOf(defaultWorkerThreads));
+
+        if (newChunkSystemWorkerThreads < 0) {
+            newChunkSystemWorkerThreads = defaultWorkerThreads;
+        } else {
+            newChunkSystemWorkerThreads = Math.max(1, newChunkSystemWorkerThreads);
+        }
+
+        String newChunkSystemGenParallelism = config.genParallelism;
+        if (newChunkSystemGenParallelism.equalsIgnoreCase("default")) {
+            newChunkSystemGenParallelism = "true";
+        }
+        boolean useParallelGen;
+        if (newChunkSystemGenParallelism.equalsIgnoreCase("on") || newChunkSystemGenParallelism.equalsIgnoreCase("enabled")
+            || newChunkSystemGenParallelism.equalsIgnoreCase("true")) {
+            useParallelGen = true;
+        } else if (newChunkSystemGenParallelism.equalsIgnoreCase("off") || newChunkSystemGenParallelism.equalsIgnoreCase("disabled")
+            || newChunkSystemGenParallelism.equalsIgnoreCase("false")) {
+            useParallelGen = false;
+        } else {
+            throw new IllegalStateException("Invalid option for gen-parallelism: must be one of [on, off, enabled, disabled, true, false, default]");
+        }
+
+        ChunkTaskScheduler.newChunkSystemGenParallelism = useParallelGen ? newChunkSystemWorkerThreads : 1;
+        ChunkTaskScheduler.newChunkSystemLoadParallelism = newChunkSystemWorkerThreads;
+
+        io.papermc.paper.chunk.system.io.RegionFileIOThread.init(newChunkSystemIOThreads);
+        workerThreads = new ca.spottedleaf.concurrentutil.executor.standard.PrioritisedThreadPool(
+            "Paper Chunk System Worker Pool", newChunkSystemWorkerThreads,
+            (final Thread thread, final Integer id) -> {
+                thread.setPriority(Thread.NORM_PRIORITY - 2);
+                thread.setName("Tuinity Chunk System Worker #" + id.intValue());
+                thread.setUncaughtExceptionHandler(io.papermc.paper.chunk.system.scheduling.NewChunkHolder.CHUNKSYSTEM_UNCAUGHT_EXCEPTION_HANDLER);
+            }, (long)(20.0e6)); // 20ms
+    }
+
+    public final ServerLevel world;
+    public final PrioritisedThreadPool workers;
+    public final PrioritisedThreadPool.PrioritisedPoolExecutor lightExecutor;
+    public final PrioritisedThreadPool.PrioritisedPoolExecutor genExecutor;
+    public final PrioritisedThreadPool.PrioritisedPoolExecutor parallelGenExecutor;
+    public final PrioritisedThreadPool.PrioritisedPoolExecutor loadExecutor;
+
+    private final PrioritisedThreadedTaskQueue mainThreadExecutor = new PrioritisedThreadedTaskQueue();
+
+    final ReentrantLock schedulingLock = new ReentrantLock();
+    public final ChunkHolderManager chunkHolderManager;
+
+    static {
+        ChunkStatus.EMPTY.writeRadius = 0;
+        ChunkStatus.STRUCTURE_STARTS.writeRadius = 0;
+        ChunkStatus.STRUCTURE_REFERENCES.writeRadius = 0;
+        ChunkStatus.BIOMES.writeRadius = 0;
+        ChunkStatus.NOISE.writeRadius = 0;
+        ChunkStatus.SURFACE.writeRadius = 0;
+        ChunkStatus.CARVERS.writeRadius = 0;
+        ChunkStatus.LIQUID_CARVERS.writeRadius = 0;
+        ChunkStatus.FEATURES.writeRadius = 1;
+        ChunkStatus.LIGHT.writeRadius = 1;
+        ChunkStatus.SPAWN.writeRadius = 0;
+        ChunkStatus.HEIGHTMAPS.writeRadius = 0;
+        ChunkStatus.FULL.writeRadius = 0;
+
+        /*
+          It's important that the neighbour read radius is taken into account. If _any_ later status is using some chunk as
+          a neighbour, it must be also safe if that neighbour is being generated. i.e for any status later than FEATURES,
+          for a status to be parallel safe it must not read the block data from its neighbours.
+         */
+        final List<ChunkStatus> parallelCapableStatus = Arrays.asList(
+                // No-op executor.
+                ChunkStatus.EMPTY,
+
+                // This is parallel capable, as CB has fixed the concurrency issue with stronghold generations.
+                // Does not touch neighbour chunks.
+                // TODO On another note, what the fuck is StructureFeatureManager.StructureCheck and why is it used? it's leaking
+                ChunkStatus.STRUCTURE_STARTS,
+
+                // Surprisingly this is parallel capable. It is simply reading the already-created structure starts
+                // into the structure references for the chunk. So while it reads from it neighbours, its neighbours
+                // will not change, even if executed in parallel.
+                ChunkStatus.STRUCTURE_REFERENCES,
+
+                // Safe. Mojang runs it in parallel as well.
+                ChunkStatus.BIOMES,
+
+                // Safe. Mojang runs it in parallel as well.
+                ChunkStatus.NOISE,
+
+                // Parallel safe. Only touches the target chunk. Biome retrieval is now noise based, which is
+                // completely thread-safe.
+                ChunkStatus.SURFACE,
+
+                // No global state is modified in the carvers. It only touches the specified chunk. So it is parallel safe.
+                ChunkStatus.CARVERS,
+
+                // No-op executor. Was replaced in 1.18 with carvers, I think.
+                ChunkStatus.LIQUID_CARVERS,
+
+                // FEATURES is not parallel safe. It writes to neighbours.
+
+                // LIGHT is not parallel safe. It also doesn't run on the generation executor, so no point.
+
+                // Only writes to the specified chunk. State is not read by later statuses. Parallel safe.
+                // Note: it may look unsafe because it writes to a worldgenregion, but the region size is always 0 -
+                // see the task margin.
+                // However, if the neighbouring FEATURES chunk is unloaded, but then fails to load in again (for whatever
+                // reason), then it would write to this chunk - and since this status reads blocks from itself, it's not
+                // safe to execute this in parallel.
+                // SPAWN
+
+                // No-op executor.
+                ChunkStatus.HEIGHTMAPS
+
+                // FULL is executed on main.
+        );
+
+        for (final ChunkStatus status : parallelCapableStatus) {
+            status.isParallelCapable = true;
+        }
+    }
+
+    public ChunkTaskScheduler(final ServerLevel world, final PrioritisedThreadPool workers) {
+        this.world = world;
+        this.workers = workers;
+
+        final String worldName = world.getWorld().getName();
+        this.genExecutor = workers.createExecutor("Chunk single-threaded generation executor for world '" + worldName + "'", 1);
+        // same as genExecutor, as there are race conditions between updating blocks in FEATURE status while lighting chunks
+        this.lightExecutor = this.genExecutor;
+        this.parallelGenExecutor = newChunkSystemGenParallelism <= 1 ? this.genExecutor
+                : workers.createExecutor("Chunk parallel generation executor for world '" + worldName + "'", newChunkSystemGenParallelism);
+        this.loadExecutor = workers.createExecutor("Chunk load executor for world '" + worldName + "'", newChunkSystemLoadParallelism);
+        this.chunkHolderManager = new ChunkHolderManager(world, this);
+    }
+
+    private final AtomicBoolean failedChunkSystem = new AtomicBoolean();
+
+    public static Object stringIfNull(final Object obj) {
+        return obj == null ? "null" : obj;
+    }
+
+    public void unrecoverableChunkSystemFailure(final int chunkX, final int chunkZ, final Map<String, Object> objectsOfInterest, final Throwable thr) {
+        final NewChunkHolder holder = this.chunkHolderManager.getChunkHolder(chunkX, chunkZ);
+        LOGGER.error("Chunk system error at chunk (" + chunkX + "," + chunkZ + "), holder: " + holder + ", exception:", new Throwable(thr));
+
+        if (this.failedChunkSystem.getAndSet(true)) {
+            return;
+        }
+
+        final ReportedException reportedException = thr instanceof ReportedException ? (ReportedException)thr : new ReportedException(new CrashReport("Chunk system error", thr));
+
+        CrashReportCategory crashReportCategory = reportedException.getReport().addCategory("Chunk system details");
+        crashReportCategory.setDetail("Chunk coordinate", new ChunkPos(chunkX, chunkZ).toString());
+        crashReportCategory.setDetail("ChunkHolder", Objects.toString(holder));
+        crashReportCategory.setDetail("unrecoverableChunkSystemFailure caller thread", Thread.currentThread().getName());
+
+        crashReportCategory = reportedException.getReport().addCategory("Chunk System Objects of Interest");
+        for (final Map.Entry<String, Object> entry : objectsOfInterest.entrySet()) {
+            if (entry.getValue() instanceof Throwable thrObject) {
+                crashReportCategory.setDetailError(Objects.toString(entry.getKey()), thrObject);
+            } else {
+                crashReportCategory.setDetail(Objects.toString(entry.getKey()), Objects.toString(entry.getValue()));
+            }
+        }
+
+        final Runnable crash = () -> {
+            throw new RuntimeException("Chunk system crash propagated from unrecoverableChunkSystemFailure", reportedException);
+        };
+
+        // this may not be good enough, specifically thanks to stupid ass plugins swallowing exceptions
+        this.scheduleChunkTask(chunkX, chunkZ, crash, PrioritisedExecutor.Priority.BLOCKING);
+        // so, make the main thread pick it up
+        MinecraftServer.chunkSystemCrash = new RuntimeException("Chunk system crash propagated from unrecoverableChunkSystemFailure", reportedException);
+        // TODO handle cases where the main thread has died
+    }
+
+    public boolean executeMainThreadTask() {
+        TickThread.ensureTickThread("Cannot execute main thread task off-main");
+        return this.mainThreadExecutor.executeTask();
+    }
+
+    public void raisePriority(final int x, final int z, final PrioritisedExecutor.Priority priority) {
+        this.chunkHolderManager.raisePriority(x, z, priority);
+    }
+
+    public void setPriority(final int x, final int z, final PrioritisedExecutor.Priority priority) {
+        this.chunkHolderManager.setPriority(x, z, priority);
+    }
+
+    public void lowerPriority(final int x, final int z, final PrioritisedExecutor.Priority priority) {
+        this.chunkHolderManager.lowerPriority(x, z, priority);
+    }
+
+    private final AtomicLong chunkLoadCounter = new AtomicLong();
+
+    public void scheduleTickingState(final int chunkX, final int chunkZ, final ChunkHolder.FullChunkStatus toStatus,
+                                     final boolean addTicket, final PrioritisedExecutor.Priority priority,
+                                     final Consumer<ChunkAccess> onComplete) {
+        if (this.chunkHolderManager.ticketLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Cannot schedule chunk load during ticket level update");
+        }
+        if (this.schedulingLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Cannot schedule chunk loading recursively");
+        }
+
+        if (toStatus == ChunkHolder.FullChunkStatus.INACCESSIBLE) {
+            throw new IllegalArgumentException("Cannot wait for INACCESSIBLE status");
+        }
+
+        final int minLevel = 33 - (toStatus.ordinal() - 1);
+        final Long chunkReference = addTicket ? Long.valueOf(this.chunkLoadCounter.getAndIncrement()) : null;
+        final long chunkKey = CoordinateUtils.getChunkKey(chunkX, chunkZ);
+
+        if (addTicket) {
+            this.chunkHolderManager.addTicketAtLevel(TicketType.CHUNK_LOAD, chunkKey, minLevel, chunkReference);
+            this.chunkHolderManager.processTicketUpdates();
+        }
+
+        final Consumer<ChunkAccess> loadCallback = (final ChunkAccess chunk) -> {
+            try {
+                if (onComplete != null) {
+                    onComplete.accept(chunk);
+                }
+            } finally {
+                if (addTicket) {
+                    ChunkTaskScheduler.this.chunkHolderManager.removeTicketAtLevel(TicketType.CHUNK_LOAD, chunkKey, minLevel, chunkReference);
+                }
+            }
+        };
+
+        final boolean scheduled;
+        final ChunkAccess chunk;
+        this.chunkHolderManager.ticketLock.lock();
+        try {
+            this.schedulingLock.lock();
+            try {
+                final NewChunkHolder chunkHolder = this.chunkHolderManager.getChunkHolder(chunkKey);
+                if (chunkHolder == null || chunkHolder.getTicketLevel() > minLevel) {
+                    scheduled = false;
+                    chunk = null;
+                } else {
+                    final ChunkHolder.FullChunkStatus currStatus = chunkHolder.getChunkStatus();
+                    if (currStatus.isOrAfter(toStatus)) {
+                        scheduled = false;
+                        chunk = chunkHolder.getCurrentChunk();
+                    } else {
+                        scheduled = true;
+                        chunk = null;
+                        chunkHolder.raisePriority(priority);
+
+                        // ticket level should schedule for us
+                        chunkHolder.addFullStatusConsumer(toStatus, loadCallback);
+                    }
+                }
+            } finally {
+                this.schedulingLock.unlock();
+            }
+        } finally {
+            this.chunkHolderManager.ticketLock.unlock();
+        }
+
+        if (!scheduled) {
+            // couldn't schedule
+            try {
+                loadCallback.accept(chunk);
+            } catch (final ThreadDeath thr) {
+                throw thr;
+            } catch (final Throwable thr) {
+                LOGGER.error("Failed to process chunk full status callback", thr);
+            }
+        }
+    }
+
+    public void scheduleChunkLoad(final int chunkX, final int chunkZ, final boolean gen, final ChunkStatus toStatus, final boolean addTicket,
+                                  final PrioritisedExecutor.Priority priority, final Consumer<ChunkAccess> onComplete) {
+        if (gen) {
+            this.scheduleChunkLoad(chunkX, chunkZ, toStatus, addTicket, priority, onComplete);
+            return;
+        }
+        this.scheduleChunkLoad(chunkX, chunkZ, ChunkStatus.EMPTY, addTicket, priority, (final ChunkAccess chunk) -> {
+            if (chunk == null) {
+                onComplete.accept(null);
+            } else {
+                if (chunk.getStatus().isOrAfter(toStatus)) {
+                    this.scheduleChunkLoad(chunkX, chunkZ, toStatus, addTicket, priority, onComplete);
+                } else {
+                    onComplete.accept(null);
+                }
+            }
+        });
+    }
+
+    public void scheduleChunkLoad(final int chunkX, final int chunkZ, final ChunkStatus toStatus, final boolean addTicket,
+                                  final PrioritisedExecutor.Priority priority, final Consumer<ChunkAccess> onComplete) {
+        if (this.chunkHolderManager.ticketLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Cannot schedule chunk load during ticket level update");
+        }
+        if (this.schedulingLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Cannot schedule chunk loading recursively");
+        }
+
+        if (toStatus == ChunkStatus.FULL) {
+            this.scheduleTickingState(chunkX, chunkZ, ChunkHolder.FullChunkStatus.BORDER, addTicket, priority, onComplete);
+            return;
+        }
+
+        final int minLevel = 33 + ChunkStatus.getDistance(toStatus);
+        final Long chunkReference = addTicket ? Long.valueOf(this.chunkLoadCounter.getAndIncrement()) : null;
+        final long chunkKey = CoordinateUtils.getChunkKey(chunkX, chunkZ);
+
+        if (addTicket) {
+            this.chunkHolderManager.addTicketAtLevel(TicketType.CHUNK_LOAD, chunkKey, minLevel, chunkReference);
+            this.chunkHolderManager.processTicketUpdates();
+        }
+
+        final Consumer<ChunkAccess> loadCallback = (final ChunkAccess chunk) -> {
+            try {
+                if (onComplete != null) {
+                    onComplete.accept(chunk);
+                }
+            } finally {
+                if (addTicket) {
+                    ChunkTaskScheduler.this.chunkHolderManager.removeTicketAtLevel(TicketType.CHUNK_LOAD, chunkKey, minLevel, chunkReference);
+                }
+            }
+        };
+
+        final List<ChunkProgressionTask> tasks = new ArrayList<>();
+
+        final boolean scheduled;
+        final ChunkAccess chunk;
+        this.chunkHolderManager.ticketLock.lock();
+        try {
+            this.schedulingLock.lock();
+            try {
+                final NewChunkHolder chunkHolder = this.chunkHolderManager.getChunkHolder(chunkKey);
+                if (chunkHolder == null || chunkHolder.getTicketLevel() > minLevel) {
+                    scheduled = false;
+                    chunk = null;
+                } else {
+                    final ChunkStatus genStatus = chunkHolder.getCurrentGenStatus();
+                    if (genStatus != null && genStatus.isOrAfter(toStatus)) {
+                        scheduled = false;
+                        chunk = chunkHolder.getCurrentChunk();
+                    } else {
+                        scheduled = true;
+                        chunk = null;
+                        chunkHolder.raisePriority(priority);
+
+                        if (!chunkHolder.upgradeGenTarget(toStatus)) {
+                            this.schedule(chunkX, chunkZ, toStatus, chunkHolder, tasks);
+                        }
+                        chunkHolder.addStatusConsumer(toStatus, loadCallback);
+                    }
+                }
+            } finally {
+                this.schedulingLock.unlock();
+            }
+        } finally {
+            this.chunkHolderManager.ticketLock.unlock();
+        }
+
+        for (int i = 0, len = tasks.size(); i < len; ++i) {
+            tasks.get(i).schedule();
+        }
+
+        if (!scheduled) {
+            // couldn't schedule
+            try {
+                loadCallback.accept(chunk);
+            } catch (final ThreadDeath thr) {
+                throw thr;
+            } catch (final Throwable thr) {
+                LOGGER.error("Failed to process chunk status callback", thr);
+            }
+        }
+    }
+
+    private ChunkProgressionTask createTask(final int chunkX, final int chunkZ, final ChunkAccess chunk,
+                                            final NewChunkHolder chunkHolder, final List<ChunkAccess> neighbours,
+                                            final ChunkStatus toStatus, final PrioritisedExecutor.Priority initialPriority) {
+        if (toStatus == ChunkStatus.EMPTY) {
+            return new ChunkLoadTask(this, this.world, chunkX, chunkZ, chunkHolder, initialPriority);
+        }
+        if (toStatus == ChunkStatus.LIGHT) {
+            return new ChunkLightTask(this, this.world, chunkX, chunkZ, chunk, initialPriority);
+        }
+        if (toStatus == ChunkStatus.FULL) {
+            return new ChunkFullTask(this, this.world, chunkX, chunkZ, chunkHolder, chunk, initialPriority);
+        }
+
+        return new ChunkUpgradeGenericStatusTask(this, this.world, chunkX, chunkZ, chunk, neighbours, toStatus, initialPriority);
+    }
+
+    ChunkProgressionTask schedule(final int chunkX, final int chunkZ, final ChunkStatus targetStatus, final NewChunkHolder chunkHolder,
+                                  final List<ChunkProgressionTask> allTasks) {
+        return this.schedule(chunkX, chunkZ, targetStatus, chunkHolder, allTasks, chunkHolder.getEffectivePriority());
+    }
+
+    // rets new task scheduled for the _specified_ chunk
+    // note: this must hold the scheduling lock
+    // minPriority is only used to pass the priority through to neighbours, as priority calculation has not yet been done
+    // schedule will ignore the generation target, so it should be checked by the caller to ensure the target is not regressed!
+    private ChunkProgressionTask schedule(final int chunkX, final int chunkZ, final ChunkStatus targetStatus,
+                                          final NewChunkHolder chunkHolder, final List<ChunkProgressionTask> allTasks,
+                                          final PrioritisedExecutor.Priority minPriority) {
+        if (!this.schedulingLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Not holding scheduling lock");
+        }
+
+        if (chunkHolder.hasGenerationTask()) {
+            chunkHolder.upgradeGenTarget(targetStatus);
+            return null;
+        }
+
+        final PrioritisedExecutor.Priority requestedPriority = PrioritisedExecutor.Priority.max(minPriority, chunkHolder.getEffectivePriority());
+        final ChunkStatus currentGenStatus = chunkHolder.getCurrentGenStatus();
+        final ChunkAccess chunk = chunkHolder.getCurrentChunk();
+
+        if (currentGenStatus == null) {
+            // not yet loaded
+            final ChunkProgressionTask task = this.createTask(
+                chunkX, chunkZ, chunk, chunkHolder, Collections.emptyList(), ChunkStatus.EMPTY, requestedPriority
+            );
+
+            allTasks.add(task);
+
+            final List<NewChunkHolder> chunkHolderNeighbours = new ArrayList<>(1);
+            chunkHolderNeighbours.add(chunkHolder);
+
+            chunkHolder.setGenerationTarget(targetStatus);
+            chunkHolder.setGenerationTask(task, ChunkStatus.EMPTY, chunkHolderNeighbours);
+
+            return task;
+        }
+
+        if (currentGenStatus.isOrAfter(targetStatus)) {
+            // nothing to do
+            return null;
+        }
+
+        // we know for sure now that we want to schedule _something_, so set the target
+        chunkHolder.setGenerationTarget(targetStatus);
+
+        final ChunkStatus chunkRealStatus = chunk.getStatus();
+        final ChunkStatus toStatus = currentGenStatus.getNextStatus();
+
+        // if this chunk has already generated up to or past the specified status, then we don't
+        // need the neighbours AT ALL.
+        final int neighbourReadRadius = chunkRealStatus.isOrAfter(toStatus) ? toStatus.loadRange : toStatus.getRange();
+
+        boolean unGeneratedNeighbours = false;
+
+        // copied from MCUtil.getSpiralOutChunks
+        for (int r = 1; r <= neighbourReadRadius; r++) {
+            int x = -r;
+            int z = r;
+
+            // Iterates the edge of half of the box; then negates for other half.
+            while (x <= r && z > -r) {
+                final int radius = Math.max(Math.abs(x), Math.abs(z));
+                final ChunkStatus requiredNeighbourStatus = ChunkMap.getDependencyStatus(toStatus, radius);
+
+                unGeneratedNeighbours |= this.checkNeighbour(
+                    chunkX + x, chunkZ + z, requiredNeighbourStatus, chunkHolder, allTasks, requestedPriority
+                );
+                unGeneratedNeighbours |= this.checkNeighbour(
+                    chunkX - x, chunkZ - z, requiredNeighbourStatus, chunkHolder, allTasks, requestedPriority
+                );
+
+                if (x < r) {
+                    x++;
+                } else {
+                    z--;
+                }
+            }
+        }
+
+        if (unGeneratedNeighbours) {
+            // can't schedule, but neighbour completion will schedule for us when they're ALL done
+
+            // propagate our priority to neighbours
+            chunkHolder.recalculateNeighbourPriorities();
+            return null;
+        }
+
+        // need to gather neighbours
+
+        final List<ChunkAccess> neighbours;
+        final List<NewChunkHolder> chunkHolderNeighbours;
+        if (neighbourReadRadius <= 0) {
+            neighbours = new ArrayList<>(1);
+            chunkHolderNeighbours = new ArrayList<>(1);
+            neighbours.add(chunk);
+            chunkHolderNeighbours.add(chunkHolder);
+        } else {
+            // the iteration order is _very_ important, as all generation statuses expect a certain order such that:
+            // chunkAtRelative = neighbours.get(relX + relZ * (2 * radius + 1))
+            neighbours = new ArrayList<>((2 * neighbourReadRadius + 1) * (2 * neighbourReadRadius + 1));
+            chunkHolderNeighbours = new ArrayList<>((2 * neighbourReadRadius + 1) * (2 * neighbourReadRadius + 1));
+            for (int dz = -neighbourReadRadius; dz <= neighbourReadRadius; ++dz) {
+                for (int dx = -neighbourReadRadius; dx <= neighbourReadRadius; ++dx) {
+                    final NewChunkHolder holder = (dx | dz) == 0 ? chunkHolder : this.chunkHolderManager.getChunkHolder(dx + chunkX, dz + chunkZ);
+                    neighbours.add(holder.getChunkForNeighbourAccess());
+                    chunkHolderNeighbours.add(holder);
+                }
+            }
+        }
+
+        final ChunkProgressionTask task = this.createTask(chunkX, chunkZ, chunk, chunkHolder, neighbours, toStatus, chunkHolder.getEffectivePriority());
+        allTasks.add(task);
+
+        chunkHolder.setGenerationTask(task, toStatus, chunkHolderNeighbours);
+
+        return task;
+    }
+
+    // rets true if the neighbour is not at the required status, false otherwise
+    private boolean checkNeighbour(final int chunkX, final int chunkZ, final ChunkStatus requiredStatus, final NewChunkHolder center,
+                                   final List<ChunkProgressionTask> tasks, final PrioritisedExecutor.Priority minPriority) {
+        final NewChunkHolder chunkHolder = this.chunkHolderManager.getChunkHolder(chunkX, chunkZ);
+
+        if (chunkHolder == null) {
+            throw new IllegalStateException("Missing chunkholder when required");
+        }
+
+        final ChunkStatus holderStatus = chunkHolder.getCurrentGenStatus();
+        if (holderStatus != null && holderStatus.isOrAfter(requiredStatus)) {
+            return false;
+        }
+
+        if (chunkHolder.hasFailedGeneration()) {
+            return true;
+        }
+
+        center.addGenerationBlockingNeighbour(chunkHolder);
+        chunkHolder.addWaitingNeighbour(center, requiredStatus);
+
+        if (chunkHolder.upgradeGenTarget(requiredStatus)) {
+            return true;
+        }
+
+        // not at status required, so we need to schedule its generation
+        this.schedule(
+            chunkX, chunkZ, requiredStatus, chunkHolder, tasks, minPriority
+        );
+
+        return true;
+    }
+
+    /**
+     * @deprecated Chunk tasks must be tied to coordinates in the future
+     */
+    @Deprecated
+    public PrioritisedExecutor.PrioritisedTask scheduleChunkTask(final Runnable run) {
+        return this.scheduleChunkTask(run, PrioritisedExecutor.Priority.NORMAL);
+    }
+
+    /**
+     * @deprecated Chunk tasks must be tied to coordinates in the future
+     */
+    @Deprecated
+    public PrioritisedExecutor.PrioritisedTask scheduleChunkTask(final Runnable run, final PrioritisedExecutor.Priority priority) {
+        return this.mainThreadExecutor.queueRunnable(run, priority);
+    }
+
+    public PrioritisedExecutor.PrioritisedTask createChunkTask(final int chunkX, final int chunkZ, final Runnable run) {
+        return this.createChunkTask(chunkX, chunkZ, run, PrioritisedExecutor.Priority.NORMAL);
+    }
+
+    public PrioritisedExecutor.PrioritisedTask createChunkTask(final int chunkX, final int chunkZ, final Runnable run,
+                                                               final PrioritisedExecutor.Priority priority) {
+        return this.mainThreadExecutor.createTask(run, priority);
+    }
+
+    public PrioritisedExecutor.PrioritisedTask scheduleChunkTask(final int chunkX, final int chunkZ, final Runnable run) {
+        return this.mainThreadExecutor.queueRunnable(run);
+    }
+
+    public PrioritisedExecutor.PrioritisedTask scheduleChunkTask(final int chunkX, final int chunkZ, final Runnable run,
+                                                                 final PrioritisedExecutor.Priority priority) {
+        return this.mainThreadExecutor.queueRunnable(run, priority);
+    }
+
+    public void executeTasksUntil(final BooleanSupplier exit) {
+        if (Bukkit.isPrimaryThread()) {
+            this.mainThreadExecutor.executeConditionally(exit);
+        } else {
+            long counter = 1L;
+            while (!exit.getAsBoolean()) {
+                counter = ConcurrentUtil.linearLongBackoff(counter, 100_000L, 5_000_000L); // 100us, 5ms
+            }
+        }
+    }
+
+    public boolean halt(final boolean sync, final long maxWaitNS) {
+        this.lightExecutor.halt();
+        this.genExecutor.halt();
+        this.parallelGenExecutor.halt();
+        this.loadExecutor.halt();
+        final long time = System.nanoTime();
+        if (sync) {
+            for (long failures = 9L;; failures = ConcurrentUtil.linearLongBackoff(failures, 500_000L, 50_000_000L)) {
+                if (
+                    !this.lightExecutor.isActive() &&
+                        !this.genExecutor.isActive() &&
+                        !this.parallelGenExecutor.isActive() &&
+                        !this.loadExecutor.isActive()
+                ) {
+                    return true;
+                }
+                if ((System.nanoTime() - time) >= maxWaitNS) {
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+
+    public static final ArrayDeque<ChunkInfo> WAITING_CHUNKS = new ArrayDeque<>(); // stack
+
+    private static final class ChunkInfo {
+
+        public final int chunkX;
+        public final int chunkZ;
+        public final ServerLevel world;
+
+        public ChunkInfo(final int chunkX, final int chunkZ, final ServerLevel world) {
+            this.chunkX = chunkX;
+            this.chunkZ = chunkZ;
+            this.world = world;
+        }
+
+        @Override
+        public String toString() {
+            return "[( " + this.chunkX + "," + this.chunkZ + ") in '" + this.world.getWorld().getName() + "']";
+        }
+    }
+
+    public static void pushChunkWait(final ServerLevel world, final int chunkX, final int chunkZ) {
+        synchronized (WAITING_CHUNKS) {
+            WAITING_CHUNKS.push(new ChunkInfo(chunkX, chunkZ, world));
+        }
+    }
+
+    public static void popChunkWait() {
+        synchronized (WAITING_CHUNKS) {
+            WAITING_CHUNKS.pop();
+        }
+    }
+
+    private static ChunkInfo[] getChunkInfos() {
+        synchronized (WAITING_CHUNKS) {
+            return WAITING_CHUNKS.toArray(new ChunkInfo[0]);
+        }
+    }
+
+    public static void dumpAllChunkLoadInfo(final boolean longPrint) {
+        final ChunkInfo[] chunkInfos = getChunkInfos();
+        if (chunkInfos.length > 0) {
+            LOGGER.error("Chunk wait task info below: ");
+            for (final ChunkInfo chunkInfo : chunkInfos) {
+                final NewChunkHolder holder = chunkInfo.world.chunkTaskScheduler.chunkHolderManager.getChunkHolder(chunkInfo.chunkX, chunkInfo.chunkZ);
+                LOGGER.error("Chunk wait: " + chunkInfo);
+                LOGGER.error("Chunk holder: " + holder);
+            }
+
+            if (longPrint) {
+                final File file = new File(new File(new File("."), "debug"), "chunks-watchdog.txt");
+                LOGGER.error("Writing chunk information dump to " + file);
+                try {
+                    MCUtil.dumpChunks(file, true);
+                    LOGGER.error("Successfully written chunk information!");
+                } catch (final Throwable thr) {
+                    MinecraftServer.LOGGER.warn("Failed to dump chunk information to file " + file.toString(), thr);
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkUpgradeGenericStatusTask.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkUpgradeGenericStatusTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..e96ecf351a1952b4e23e9a352f32d326146380e7
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkUpgradeGenericStatusTask.java
@@ -0,0 +1,209 @@
+package io.papermc.paper.chunk.system.scheduling;
+
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import com.mojang.datafixers.util.Either;
+import com.mojang.logging.LogUtils;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ChunkMap;
+import net.minecraft.server.level.ServerChunkCache;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.ProtoChunk;
+import org.slf4j.Logger;
+import java.lang.invoke.VarHandle;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.CompletableFuture;
+
+public final class ChunkUpgradeGenericStatusTask extends ChunkProgressionTask implements Runnable {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    protected final ChunkAccess fromChunk;
+    protected final ChunkStatus fromStatus;
+    protected final ChunkStatus toStatus;
+    protected final List<ChunkAccess> neighbours;
+
+    protected final PrioritisedExecutor.PrioritisedTask generateTask;
+
+    public ChunkUpgradeGenericStatusTask(final ChunkTaskScheduler scheduler, final ServerLevel world, final int chunkX,
+                                         final int chunkZ, final ChunkAccess chunk, final List<ChunkAccess> neighbours,
+                                         final ChunkStatus toStatus, final PrioritisedExecutor.Priority priority) {
+        super(scheduler, world, chunkX, chunkZ);
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+        this.fromChunk = chunk;
+        this.fromStatus = chunk.getStatus();
+        this.toStatus = toStatus;
+        this.neighbours = neighbours;
+        this.generateTask = (this.toStatus.isParallelCapable ? this.scheduler.parallelGenExecutor : this.scheduler.genExecutor)
+            .createTask(this, priority);
+    }
+
+    @Override
+    public ChunkStatus getTargetStatus() {
+        return this.toStatus;
+    }
+
+    private boolean isEmptyTask() {
+        // must use fromStatus here to avoid any race condition with run() overwriting the status
+        final boolean generation = !this.fromStatus.isOrAfter(this.toStatus);
+        return (generation && this.toStatus.isEmptyGenStatus()) || (!generation && this.toStatus.isEmptyLoadStatus());
+    }
+
+    @Override
+    public void run() {
+        final ChunkAccess chunk = this.fromChunk;
+
+        final ServerChunkCache serverChunkCache = this.world.chunkSource;
+        final ChunkMap chunkMap = serverChunkCache.chunkMap;
+
+        final CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completeFuture;
+
+        final boolean generation;
+        boolean completing = false;
+
+        // note: should optimise the case where the chunk does not need to execute the status, because
+        // schedule() calls this synchronously if it will run through that path
+
+        try {
+            generation = !chunk.getStatus().isOrAfter(this.toStatus);
+            if (generation) {
+                if (this.toStatus.isEmptyGenStatus()) {
+                    if (chunk instanceof ProtoChunk) {
+                        ((ProtoChunk)chunk).setStatus(this.toStatus);
+                    }
+                    completing = true;
+                    this.complete(chunk, null);
+                    return;
+                }
+                completeFuture = this.toStatus.generate(Runnable::run, this.world, chunkMap.generator, chunkMap.structureTemplateManager,
+                    serverChunkCache.getLightEngine(), null, this.neighbours, false)
+                    .whenComplete((final Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either, final Throwable throwable) -> {
+                        final ChunkAccess newChunk = (either == null) ? null : either.left().orElse(null);
+                        if (newChunk instanceof ProtoChunk) {
+                            ((ProtoChunk)newChunk).setStatus(ChunkUpgradeGenericStatusTask.this.toStatus);
+                        }
+                    }
+                );
+            } else {
+                if (this.toStatus.isEmptyLoadStatus()) {
+                    completing = true;
+                    this.complete(chunk, null);
+                    return;
+                }
+                completeFuture = this.toStatus.load(this.world, chunkMap.structureTemplateManager, serverChunkCache.getLightEngine(), null, chunk);
+            }
+        } catch (final Throwable throwable) {
+            if (!completing) {
+                this.complete(null, throwable);
+
+                if (throwable instanceof ThreadDeath) {
+                    throw (ThreadDeath)throwable;
+                }
+                return;
+            }
+
+            this.scheduler.unrecoverableChunkSystemFailure(this.chunkX, this.chunkZ, Map.of(
+                "Target status", ChunkTaskScheduler.stringIfNull(this.toStatus),
+                "From status", ChunkTaskScheduler.stringIfNull(this.fromStatus),
+                "Generation task", this
+            ), throwable);
+
+            if (!(throwable instanceof ThreadDeath)) {
+                LOGGER.error("Failed to complete status for chunk: status:" + this.toStatus + ", chunk: (" + this.chunkX + "," + this.chunkZ + "), world: " + this.world.getWorld().getName(), throwable);
+            } else {
+                // ensure the chunk system can respond, then die
+                throw (ThreadDeath)throwable;
+            }
+            return;
+        }
+
+        if (!completeFuture.isDone() && !this.toStatus.warnedAboutNoImmediateComplete.getAndSet(true)) {
+            LOGGER.warn("Future status not complete after scheduling: " + this.toStatus.toString() + ", generate: " + generation);
+        }
+
+        final Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either;
+        final ChunkAccess newChunk;
+
+        try {
+            either = completeFuture.join();
+            newChunk = (either == null) ? null : either.left().orElse(null);
+        } catch (final Throwable throwable) {
+            this.complete(null, throwable);
+            // ensure the chunk system can respond, then die
+            if (throwable instanceof ThreadDeath) {
+                throw (ThreadDeath)throwable;
+            }
+            return;
+        }
+
+        if (newChunk == null) {
+            this.complete(null, new IllegalStateException("Chunk for status: " + ChunkUpgradeGenericStatusTask.this.toStatus.toString() + ", generation: " + generation + " should not be null! Either: " + either).fillInStackTrace());
+            return;
+        }
+
+        this.complete(newChunk, null);
+    }
+
+    protected volatile boolean scheduled;
+    protected static final VarHandle SCHEDULED_HANDLE = ConcurrentUtil.getVarHandle(ChunkUpgradeGenericStatusTask.class, "scheduled", boolean.class);
+
+    @Override
+    public boolean isScheduled() {
+        return this.scheduled;
+    }
+
+    @Override
+    public void schedule() {
+        if ((boolean)SCHEDULED_HANDLE.getAndSet((ChunkUpgradeGenericStatusTask)this, true)) {
+            throw new IllegalStateException("Cannot double call schedule()");
+        }
+        if (this.isEmptyTask()) {
+            if (this.generateTask.cancel()) {
+                this.run();
+            }
+        } else {
+            this.generateTask.queue();
+        }
+    }
+
+    @Override
+    public void cancel() {
+        if (this.generateTask.cancel()) {
+            this.complete(null, null);
+        }
+    }
+
+    @Override
+    public PrioritisedExecutor.Priority getPriority() {
+        return this.generateTask.getPriority();
+    }
+
+    @Override
+    public void lowerPriority(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+        this.generateTask.lowerPriority(priority);
+    }
+
+    @Override
+    public void setPriority(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+        this.generateTask.setPriority(priority);
+    }
+
+    @Override
+    public void raisePriority(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+        this.generateTask.raisePriority(priority);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/GenericDataLoadTask.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/GenericDataLoadTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..7917e65ac61a258242f5081092045f8edfdf04bb
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/GenericDataLoadTask.java
@@ -0,0 +1,732 @@
+package io.papermc.paper.chunk.system.scheduling;
+
+import ca.spottedleaf.concurrentutil.completable.Completable;
+import ca.spottedleaf.concurrentutil.executor.Cancellable;
+import ca.spottedleaf.concurrentutil.executor.standard.DelayedPrioritisedTask;
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.chunk.system.io.RegionFileIOThread;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.level.ServerLevel;
+import org.slf4j.Logger;
+import java.lang.invoke.VarHandle;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.BiConsumer;
+
+public abstract class GenericDataLoadTask<OnMain,FinalCompletion> {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    protected static final CompoundTag CANCELLED_DATA = new CompoundTag();
+
+    // reference count is the upper 32 bits
+    protected final AtomicLong stageAndReferenceCount = new AtomicLong(STAGE_NOT_STARTED);
+
+    protected static final long STAGE_MASK        = 0xFFFFFFFFL;
+    protected static final long STAGE_CANCELLED   = 0xFFFFFFFFL;
+    protected static final long STAGE_NOT_STARTED = 0L;
+    protected static final long STAGE_LOADING     = 1L;
+    protected static final long STAGE_PROCESSING  = 2L;
+    protected static final long STAGE_COMPLETED   = 3L;
+
+    // for loading data off disk
+    protected final LoadDataFromDiskTask loadDataFromDiskTask;
+    // processing off-main
+    protected final PrioritisedExecutor.PrioritisedTask processOffMain;
+    // processing on-main
+    protected final PrioritisedExecutor.PrioritisedTask processOnMain;
+
+    protected final ChunkTaskScheduler scheduler;
+    protected final ServerLevel world;
+    protected final int chunkX;
+    protected final int chunkZ;
+    protected final RegionFileIOThread.RegionFileType type;
+
+    public GenericDataLoadTask(final ChunkTaskScheduler scheduler, final ServerLevel world, final int chunkX,
+                               final int chunkZ, final RegionFileIOThread.RegionFileType type,
+                               final PrioritisedExecutor.Priority priority) {
+        this.scheduler = scheduler;
+        this.world = world;
+        this.chunkX = chunkX;
+        this.chunkZ = chunkZ;
+        this.type = type;
+
+        final ProcessOnMainTask mainTask;
+        if (this.hasOnMain()) {
+            mainTask = new ProcessOnMainTask();
+            this.processOnMain = this.createOnMain(mainTask, priority);
+        } else {
+            mainTask = null;
+            this.processOnMain = null;
+        }
+
+        final ProcessOffMainTask offMainTask;
+        if (this.hasOffMain()) {
+            offMainTask = new ProcessOffMainTask(mainTask);
+            this.processOffMain = this.createOffMain(offMainTask, priority);
+        } else {
+            offMainTask = null;
+            this.processOffMain = null;
+        }
+
+        if (this.processOffMain == null && this.processOnMain == null) {
+            throw new IllegalStateException("Illegal class implementation: " + this.getClass().getName() + ", should be able to schedule at least one task!");
+        }
+
+        this.loadDataFromDiskTask = new LoadDataFromDiskTask(world, chunkX, chunkZ, type, new DataLoadCallback(offMainTask, mainTask), priority);
+    }
+
+    public static final record TaskResult<L, R>(L left, R right) {}
+
+    protected abstract boolean hasOffMain();
+
+    protected abstract boolean hasOnMain();
+
+    protected abstract PrioritisedExecutor.PrioritisedTask createOffMain(final Runnable run, final PrioritisedExecutor.Priority priority);
+
+    protected abstract PrioritisedExecutor.PrioritisedTask createOnMain(final Runnable run, final PrioritisedExecutor.Priority priority);
+
+    protected abstract TaskResult<OnMain, Throwable> runOffMain(final CompoundTag data, final Throwable throwable);
+
+    protected abstract TaskResult<FinalCompletion, Throwable> runOnMain(final OnMain data, final Throwable throwable);
+
+    protected abstract void onComplete(final TaskResult<FinalCompletion,Throwable> result);
+
+    @Override
+    public String toString() {
+        return "GenericDataLoadTask{class: " + this.getClass().getName() + ", world: " + this.world.getWorld().getName() +
+            ", chunk: (" + this.chunkX + "," + this.chunkZ + "), hashcode: " + System.identityHashCode(this) + ", priority: " + this.getPriority() +
+            ", type: " + this.type.toString() + "}";
+    }
+
+    public PrioritisedExecutor.Priority getPriority() {
+        if (this.processOnMain != null) {
+            return this.processOnMain.getPriority();
+        } else {
+            return this.processOffMain.getPriority();
+        }
+    }
+
+    public void lowerPriority(final PrioritisedExecutor.Priority priority) {
+        // can't lower I/O tasks, we don't know what they affect
+        if (this.processOffMain != null) {
+            this.processOffMain.lowerPriority(priority);
+        }
+        if (this.processOnMain != null) {
+            this.processOnMain.lowerPriority(priority);
+        }
+    }
+
+    public void setPriority(final PrioritisedExecutor.Priority priority) {
+        // can't lower I/O tasks, we don't know what they affect
+        this.loadDataFromDiskTask.raisePriority(priority);
+        if (this.processOffMain != null) {
+            this.processOffMain.setPriority(priority);
+        }
+        if (this.processOnMain != null) {
+            this.processOnMain.setPriority(priority);
+        }
+    }
+
+    public void raisePriority(final PrioritisedExecutor.Priority priority) {
+        // can't lower I/O tasks, we don't know what they affect
+        this.loadDataFromDiskTask.raisePriority(priority);
+        if (this.processOffMain != null) {
+            this.processOffMain.raisePriority(priority);
+        }
+        if (this.processOnMain != null) {
+            this.processOnMain.raisePriority(priority);
+        }
+    }
+
+    public void schedule() {
+        if (this.stageAndReferenceCount.get() != STAGE_NOT_STARTED ||
+            !this.stageAndReferenceCount.compareAndSet(STAGE_NOT_STARTED, (1L << 32) | STAGE_LOADING)) {
+            // try and increment reference count
+            int failures = 0;
+            for (long curr = this.stageAndReferenceCount.get();;) {
+                if ((curr & STAGE_MASK) == STAGE_CANCELLED || (curr & STAGE_MASK) == STAGE_COMPLETED) {
+                    // cancelled or completed, nothing to do here
+                    return;
+                }
+
+                if (curr == (curr = this.stageAndReferenceCount.compareAndExchange(curr, curr + (1L << 32)))) {
+                    // successful
+                    return;
+                }
+
+                ++failures;
+                for (int i = 0; i < failures; ++i) {
+                    ConcurrentUtil.backoff();
+                }
+            }
+        }
+
+        this.loadDataFromDiskTask.schedule(); // will schedule the rest
+    }
+
+    // assumes the current stage cannot be completed
+    // returns false if cancelled, returns true if can proceed
+    private boolean advanceStage(final long expect, final long to) {
+        int failures = 0;
+        for (long curr = this.stageAndReferenceCount.get();;) {
+            if ((curr & STAGE_MASK) != expect) {
+                // must be cancelled
+                return false;
+            }
+
+            final long newVal = (curr & ~STAGE_MASK) | to;
+            if (curr == (curr = this.stageAndReferenceCount.compareAndExchange(curr, newVal))) {
+                return true;
+            }
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    public boolean cancel() {
+        int failures = 0;
+        for (long curr = this.stageAndReferenceCount.get();;) {
+            if ((curr & STAGE_MASK) == STAGE_COMPLETED || (curr & STAGE_MASK) == STAGE_CANCELLED) {
+                return false;
+            }
+
+             if ((curr & STAGE_MASK) == STAGE_NOT_STARTED || (curr & ~STAGE_MASK) == (1L << 32)) {
+                // no other references, so we can cancel
+                final long newVal = STAGE_CANCELLED;
+                if (curr == (curr = this.stageAndReferenceCount.compareAndExchange(curr, newVal))) {
+                    this.loadDataFromDiskTask.cancel();
+                    if (this.processOffMain != null) {
+                        this.processOffMain.cancel();
+                    }
+                    if (this.processOnMain != null) {
+                        this.processOnMain.cancel();
+                    }
+                    this.onComplete(null);
+                    return true;
+                }
+            } else {
+                if ((curr & ~STAGE_MASK) == (0L << 32)) {
+                    throw new IllegalStateException("Reference count cannot be zero here");
+                }
+                // just decrease the reference count
+                final long newVal = curr - (1L << 32);
+                if (curr == (curr = this.stageAndReferenceCount.compareAndExchange(curr, newVal))) {
+                    return false;
+                }
+            }
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    protected final class DataLoadCallback implements BiConsumer<CompoundTag, Throwable> {
+
+        protected final ProcessOffMainTask offMainTask;
+        protected final ProcessOnMainTask onMainTask;
+
+        public DataLoadCallback(final ProcessOffMainTask offMainTask, final ProcessOnMainTask onMainTask) {
+            this.offMainTask = offMainTask;
+            this.onMainTask = onMainTask;
+        }
+
+        @Override
+        public void accept(final CompoundTag compoundTag, final Throwable throwable) {
+            if (GenericDataLoadTask.this.stageAndReferenceCount.get() == STAGE_CANCELLED) {
+                // don't try to schedule further
+                return;
+            }
+
+            try {
+                if (compoundTag == CANCELLED_DATA) {
+                    // cancelled, except this isn't possible
+                    LOGGER.error("Data callback says cancelled, but stage does not?");
+                    return;
+                }
+
+                // get off of the regionfile callback ASAP, no clue what locks are held right now...
+                if (GenericDataLoadTask.this.processOffMain != null) {
+                    this.offMainTask.data = compoundTag;
+                    this.offMainTask.throwable = throwable;
+                    GenericDataLoadTask.this.processOffMain.queue();
+                    return;
+                } else {
+                    // no off-main task, so go straight to main
+                    this.onMainTask.data = (OnMain)compoundTag;
+                    this.onMainTask.throwable = throwable;
+                    GenericDataLoadTask.this.processOnMain.queue();
+                }
+            } catch (final ThreadDeath death) {
+                throw death;
+            } catch (final Throwable thr2) {
+                LOGGER.error("Failed I/O callback for task: " + GenericDataLoadTask.this.toString(), thr2);
+                GenericDataLoadTask.this.scheduler.unrecoverableChunkSystemFailure(
+                    GenericDataLoadTask.this.chunkX, GenericDataLoadTask.this.chunkZ, Map.of(
+                        "Callback throwable", ChunkTaskScheduler.stringIfNull(throwable)
+                    ), thr2);
+            }
+        }
+    }
+
+    protected final class ProcessOffMainTask implements Runnable {
+
+        protected CompoundTag data;
+        protected Throwable throwable;
+        protected final ProcessOnMainTask schedule;
+
+        public ProcessOffMainTask(final ProcessOnMainTask schedule) {
+            this.schedule = schedule;
+        }
+
+        @Override
+        public void run() {
+            if (!GenericDataLoadTask.this.advanceStage(STAGE_LOADING, this.schedule == null ? STAGE_COMPLETED : STAGE_PROCESSING)) {
+                // cancelled
+                return;
+            }
+            final TaskResult<OnMain, Throwable> newData = GenericDataLoadTask.this.runOffMain(this.data, this.throwable);
+
+            if (GenericDataLoadTask.this.stageAndReferenceCount.get() == STAGE_CANCELLED) {
+                // don't try to schedule further
+                return;
+            }
+
+            if (this.schedule != null) {
+                this.schedule.data = newData.left;
+                this.schedule.throwable = newData.right;
+
+                GenericDataLoadTask.this.processOnMain.queue();
+            } else {
+                GenericDataLoadTask.this.onComplete((TaskResult<FinalCompletion, Throwable>)newData);
+            }
+        }
+    }
+
+    protected final class ProcessOnMainTask implements Runnable {
+
+        protected OnMain data;
+        protected Throwable throwable;
+
+        @Override
+        public void run() {
+            if (!GenericDataLoadTask.this.advanceStage(STAGE_PROCESSING, STAGE_COMPLETED)) {
+                // cancelled
+                return;
+            }
+            final TaskResult<FinalCompletion, Throwable> result = GenericDataLoadTask.this.runOnMain(this.data, this.throwable);
+
+            GenericDataLoadTask.this.onComplete(result);
+        }
+    }
+
+    public static final class LoadDataFromDiskTask {
+
+        protected volatile int priority;
+        protected static final VarHandle PRIORITY_HANDLE = ConcurrentUtil.getVarHandle(LoadDataFromDiskTask.class, "priority", int.class);
+
+        protected static final int PRIORITY_EXECUTED         = Integer.MIN_VALUE >>> 0;
+        protected static final int PRIORITY_LOAD_SCHEDULED   = Integer.MIN_VALUE >>> 1;
+        protected static final int PRIORITY_UNLOAD_SCHEDULED = Integer.MIN_VALUE >>> 2;
+
+        protected static final int PRIORITY_FLAGS = ~Character.MAX_VALUE;
+
+        protected final int getPriorityVolatile() {
+            return (int)PRIORITY_HANDLE.getVolatile((LoadDataFromDiskTask)this);
+        }
+
+        protected final int compareAndExchangePriorityVolatile(final int expect, final int update) {
+            return (int)PRIORITY_HANDLE.compareAndExchange((LoadDataFromDiskTask)this, (int)expect, (int)update);
+        }
+
+        protected final int getAndOrPriorityVolatile(final int val) {
+            return (int)PRIORITY_HANDLE.getAndBitwiseOr((LoadDataFromDiskTask)this, (int)val);
+        }
+
+        protected final void setPriorityPlain(final int val) {
+            PRIORITY_HANDLE.set((LoadDataFromDiskTask)this, (int)val);
+        }
+
+        private final ServerLevel world;
+        private final int chunkX;
+        private final int chunkZ;
+
+        private final RegionFileIOThread.RegionFileType type;
+        private Cancellable dataLoadTask;
+        private Cancellable dataUnloadCancellable;
+        private DelayedPrioritisedTask dataUnloadTask;
+
+        private final BiConsumer<CompoundTag, Throwable> onComplete;
+
+        // onComplete should be caller sensitive, it may complete synchronously with schedule() - which does
+        // hold a priority lock.
+        public LoadDataFromDiskTask(final ServerLevel world, final int chunkX, final int chunkZ,
+                                    final RegionFileIOThread.RegionFileType type,
+                                    final BiConsumer<CompoundTag, Throwable> onComplete,
+                                    final PrioritisedExecutor.Priority priority) {
+            if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+                throw new IllegalArgumentException("Invalid priority " + priority);
+            }
+            this.world = world;
+            this.chunkX = chunkX;
+            this.chunkZ = chunkZ;
+            this.type = type;
+            this.onComplete = onComplete;
+            this.setPriorityPlain(priority.priority);
+        }
+
+        private void complete(final CompoundTag data, final Throwable throwable) {
+            try {
+                this.onComplete.accept(data, throwable);
+            } catch (final Throwable thr2) {
+                this.world.chunkTaskScheduler.unrecoverableChunkSystemFailure(this.chunkX, this.chunkZ, Map.of(
+                    "Completed throwable", ChunkTaskScheduler.stringIfNull(throwable),
+                    "Regionfile type", ChunkTaskScheduler.stringIfNull(this.type)
+                ), thr2);
+                if (thr2 instanceof ThreadDeath) {
+                    throw (ThreadDeath)thr2;
+                }
+            }
+        }
+
+        protected boolean markExecuting() {
+            return (this.getAndOrPriorityVolatile(PRIORITY_EXECUTED) & PRIORITY_EXECUTED) == 0;
+        }
+
+        protected boolean isMarkedExecuted() {
+            return (this.getPriorityVolatile() & PRIORITY_EXECUTED) != 0;
+        }
+
+        public void lowerPriority(final PrioritisedExecutor.Priority priority) {
+            if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+                throw new IllegalArgumentException("Invalid priority " + priority);
+            }
+
+            int failures = 0;
+            for (int curr = this.getPriorityVolatile();;) {
+                if ((curr & PRIORITY_EXECUTED) != 0) {
+                    // cancelled or executed
+                    return;
+                }
+
+                if ((curr & PRIORITY_LOAD_SCHEDULED) != 0) {
+                    RegionFileIOThread.lowerPriority(this.world, this.chunkX, this.chunkZ, this.type, priority);
+                    return;
+                }
+
+                if ((curr & PRIORITY_UNLOAD_SCHEDULED) != 0) {
+                    if (this.dataUnloadTask != null) {
+                        this.dataUnloadTask.lowerPriority(priority);
+                    }
+                    // no return - we need to propagate priority
+                }
+
+                if (!priority.isHigherPriority(curr & ~PRIORITY_FLAGS)) {
+                    return;
+                }
+
+                if (curr == (curr = this.compareAndExchangePriorityVolatile(curr, priority.priority | (curr & PRIORITY_FLAGS)))) {
+                    return;
+                }
+
+                // failed, retry
+
+                ++failures;
+                for (int i = 0; i < failures; ++i) {
+                    ConcurrentUtil.backoff();
+                }
+            }
+        }
+
+        public void setPriority(final PrioritisedExecutor.Priority priority) {
+            if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+                throw new IllegalArgumentException("Invalid priority " + priority);
+            }
+
+            int failures = 0;
+            for (int curr = this.getPriorityVolatile();;) {
+                if ((curr & PRIORITY_EXECUTED) != 0) {
+                    // cancelled or executed
+                    return;
+                }
+
+                if ((curr & PRIORITY_LOAD_SCHEDULED) != 0) {
+                    RegionFileIOThread.setPriority(this.world, this.chunkX, this.chunkZ, this.type, priority);
+                    return;
+                }
+
+                if ((curr & PRIORITY_UNLOAD_SCHEDULED) != 0) {
+                    if (this.dataUnloadTask != null) {
+                        this.dataUnloadTask.setPriority(priority);
+                    }
+                    // no return - we need to propagate priority
+                }
+
+                if (curr == (curr = this.compareAndExchangePriorityVolatile(curr, priority.priority | (curr & PRIORITY_FLAGS)))) {
+                    return;
+                }
+
+                // failed, retry
+
+                ++failures;
+                for (int i = 0; i < failures; ++i) {
+                    ConcurrentUtil.backoff();
+                }
+            }
+        }
+
+        public void raisePriority(final PrioritisedExecutor.Priority priority) {
+            if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+                throw new IllegalArgumentException("Invalid priority " + priority);
+            }
+
+            int failures = 0;
+            for (int curr = this.getPriorityVolatile();;) {
+                if ((curr & PRIORITY_EXECUTED) != 0) {
+                    // cancelled or executed
+                    return;
+                }
+
+                if ((curr & PRIORITY_LOAD_SCHEDULED) != 0) {
+                    RegionFileIOThread.raisePriority(this.world, this.chunkX, this.chunkZ, this.type, priority);
+                    return;
+                }
+
+                if ((curr & PRIORITY_UNLOAD_SCHEDULED) != 0) {
+                    if (this.dataUnloadTask != null) {
+                        this.dataUnloadTask.raisePriority(priority);
+                    }
+                    // no return - we need to propagate priority
+                }
+
+                if (!priority.isLowerPriority(curr & ~PRIORITY_FLAGS)) {
+                    return;
+                }
+
+                if (curr == (curr = this.compareAndExchangePriorityVolatile(curr, priority.priority | (curr & PRIORITY_FLAGS)))) {
+                    return;
+                }
+
+                // failed, retry
+
+                ++failures;
+                for (int i = 0; i < failures; ++i) {
+                    ConcurrentUtil.backoff();
+                }
+            }
+        }
+
+        public void cancel() {
+            if ((this.getAndOrPriorityVolatile(PRIORITY_EXECUTED) & PRIORITY_EXECUTED) != 0) {
+                // cancelled or executed already
+                return;
+            }
+
+            // OK if we miss the field read, the task cannot complete if the cancelled bit is set and
+            // the write to dataLoadTask will check for the cancelled bit
+            if (this.dataUnloadCancellable != null) {
+                this.dataUnloadCancellable.cancel();
+            }
+
+            if (this.dataLoadTask != null) {
+                this.dataLoadTask.cancel();
+            }
+
+            this.complete(CANCELLED_DATA, null);
+        }
+
+        private final AtomicBoolean scheduled = new AtomicBoolean();
+
+        public void schedule() {
+            if (this.scheduled.getAndSet(true)) {
+                throw new IllegalStateException("schedule() called twice");
+            }
+            int priority = this.getPriorityVolatile();
+
+            if ((priority & PRIORITY_EXECUTED) != 0) {
+                // cancelled
+                return;
+            }
+
+            final BiConsumer<CompoundTag, Throwable> consumer = (final CompoundTag data, final Throwable thr) -> {
+                // because cancelScheduled() cannot actually stop this task from executing in every case, we need
+                // to mark complete here to ensure we do not double complete
+                if (LoadDataFromDiskTask.this.markExecuting()) {
+                    LoadDataFromDiskTask.this.complete(data, thr);
+                } // else: cancelled
+            };
+
+            final PrioritisedExecutor.Priority initialPriority = PrioritisedExecutor.Priority.getPriority(priority);
+            boolean scheduledUnload = false;
+
+            final NewChunkHolder holder = this.world.chunkTaskScheduler.chunkHolderManager.getChunkHolder(this.chunkX, this.chunkZ);
+            if (holder != null) {
+                final BiConsumer<CompoundTag, Throwable> unloadConsumer = (final CompoundTag data, final Throwable thr) -> {
+                    if (data != null) {
+                        consumer.accept(data, null);
+                    } else {
+                        // need to schedule task
+                        LoadDataFromDiskTask.this.schedule(false, consumer, PrioritisedExecutor.Priority.getPriority(LoadDataFromDiskTask.this.getPriorityVolatile() & ~PRIORITY_FLAGS));
+                    }
+                };
+                Cancellable unloadCancellable = null;
+                CompoundTag syncComplete = null;
+                final DelayedPrioritisedTask unloadTask;
+                this.world.chunkTaskScheduler.schedulingLock.lock();
+                try {
+                    unloadTask = holder.getUnloadTask(this.type); // can be null if no task exists
+                    final Completable<CompoundTag> unloadCompletable = holder.getUnloadCompletable(this.type);
+                    if (unloadCompletable != null) {
+                        unloadCancellable = unloadCompletable.addAsynchronousWaiter(unloadConsumer);
+                        if (unloadCancellable == null) {
+                            syncComplete = unloadCompletable.getResult();
+                        }
+                    }
+                } finally {
+                    this.world.chunkTaskScheduler.schedulingLock.unlock();
+                }
+
+                if (unloadCancellable != null) {
+                    scheduledUnload = true;
+                    this.dataUnloadCancellable = unloadCancellable;
+                    this.dataUnloadTask = unloadTask;
+                }
+
+                if (syncComplete != null) {
+                    consumer.accept(syncComplete, null);
+                    return;
+                }
+            }
+
+            this.schedule(scheduledUnload, consumer, initialPriority);
+        }
+
+        private void schedule(final boolean scheduledUnload, final BiConsumer<CompoundTag, Throwable> consumer, final PrioritisedExecutor.Priority initialPriority) {
+            int priority = this.getPriorityVolatile();
+
+            if ((priority & PRIORITY_EXECUTED) != 0) {
+                // cancelled
+                return;
+            }
+
+            if (!scheduledUnload) {
+                this.dataLoadTask = RegionFileIOThread.loadDataAsync(
+                    this.world, this.chunkX, this.chunkZ, this.type, consumer,
+                    initialPriority.isHigherPriority(PrioritisedExecutor.Priority.NORMAL), initialPriority
+                );
+            }
+
+            int failures = 0;
+            for (;;) {
+                if (priority == (priority = this.compareAndExchangePriorityVolatile(priority, priority | (scheduledUnload ? PRIORITY_UNLOAD_SCHEDULED : PRIORITY_LOAD_SCHEDULED)))) {
+                    return;
+                }
+
+                if ((priority & PRIORITY_EXECUTED) != 0) {
+                    // cancelled or executed
+                    if (this.dataUnloadCancellable != null) {
+                        this.dataUnloadCancellable.cancel();
+                    }
+
+                    if (this.dataLoadTask != null) {
+                        this.dataLoadTask.cancel();
+                    }
+                    return;
+                }
+
+                if (scheduledUnload) {
+                    if (this.dataUnloadTask != null) {
+                        this.dataUnloadTask.setPriority(PrioritisedExecutor.Priority.getPriority(priority & ~PRIORITY_FLAGS));
+                    }
+                } else {
+                    RegionFileIOThread.setPriority(this.world, this.chunkX, this.chunkZ, this.type, PrioritisedExecutor.Priority.getPriority(priority & ~PRIORITY_FLAGS));
+                }
+
+                ++failures;
+                for (int i = 0; i < failures; ++i) {
+                    ConcurrentUtil.backoff();
+                }
+            }
+        }
+
+        /*
+        private static final class LoadDataPriorityHolder extends PriorityHolder {
+
+            protected final LoadDataFromDiskTask task;
+
+            protected LoadDataPriorityHolder(final PrioritisedExecutor.Priority priority, final LoadDataFromDiskTask task) {
+                super(priority);
+                this.task = task;
+            }
+
+            @Override
+            protected void cancelScheduled() {
+                final Cancellable dataLoadTask = this.task.dataLoadTask;
+                if (dataLoadTask != null) {
+                    // OK if we miss the field read, the task cannot complete if the cancelled bit is set and
+                    // the write to dataLoadTask will check for the cancelled bit
+                    this.task.dataLoadTask.cancel();
+                }
+                this.task.complete(CANCELLED_DATA, null);
+            }
+
+            @Override
+            protected PrioritisedExecutor.Priority getScheduledPriority() {
+                final LoadDataFromDiskTask task = this.task;
+                return RegionFileIOThread.getPriority(task.world, task.chunkX, task.chunkZ, task.type);
+            }
+
+            @Override
+            protected void scheduleTask(final PrioritisedExecutor.Priority priority) {
+                final LoadDataFromDiskTask task = this.task;
+                final BiConsumer<CompoundTag, Throwable> consumer = (final CompoundTag data, final Throwable thr) -> {
+                    // because cancelScheduled() cannot actually stop this task from executing in every case, we need
+                    // to mark complete here to ensure we do not double complete
+                    if (LoadDataPriorityHolder.this.markExecuting()) {
+                        LoadDataPriorityHolder.this.task.complete(data, thr);
+                    } // else: cancelled
+                };
+                task.dataLoadTask = RegionFileIOThread.loadDataAsync(
+                    task.world, task.chunkX, task.chunkZ, task.type, consumer,
+                    priority.isHigherPriority(PrioritisedExecutor.Priority.NORMAL), priority
+                );
+                if (this.isMarkedExecuted()) {
+                    // if we are marked as completed, it could be:
+                    // 1. we were cancelled
+                    // 2. the consumer was completed
+                    // in the 2nd case, cancel() does nothing
+                    // in the 1st case, we ensure cancel() is called as it is possible for the cancelling thread
+                    // to miss the field write here
+                    task.dataLoadTask.cancel();
+                }
+            }
+
+            @Override
+            protected void lowerPriorityScheduled(final PrioritisedExecutor.Priority priority) {
+                final LoadDataFromDiskTask task = this.task;
+                RegionFileIOThread.lowerPriority(task.world, task.chunkX, task.chunkZ, task.type, priority);
+            }
+
+            @Override
+            protected void setPriorityScheduled(final PrioritisedExecutor.Priority priority) {
+                final LoadDataFromDiskTask task = this.task;
+                RegionFileIOThread.setPriority(task.world, task.chunkX, task.chunkZ, task.type, priority);
+            }
+
+            @Override
+            protected void raisePriorityScheduled(final PrioritisedExecutor.Priority priority) {
+                final LoadDataFromDiskTask task = this.task;
+                RegionFileIOThread.raisePriority(task.world, task.chunkX, task.chunkZ, task.type, priority);
+            }
+        }
+         */
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..9bb8f278149cb1809767935375ca155e6c7916b5
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
@@ -0,0 +1,1948 @@
+package io.papermc.paper.chunk.system.scheduling;
+
+import ca.spottedleaf.concurrentutil.completable.Completable;
+import ca.spottedleaf.concurrentutil.executor.Cancellable;
+import ca.spottedleaf.concurrentutil.executor.standard.DelayedPrioritisedTask;
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonPrimitive;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.chunk.system.io.RegionFileIOThread;
+import io.papermc.paper.chunk.system.poi.PoiChunk;
+import io.papermc.paper.util.CoordinateUtils;
+import io.papermc.paper.util.TickThread;
+import io.papermc.paper.util.WorldUtil;
+import io.papermc.paper.world.ChunkEntitySlices;
+import it.unimi.dsi.fastutil.objects.Reference2ObjectLinkedOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Reference2ObjectMap;
+import it.unimi.dsi.fastutil.objects.Reference2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ReferenceLinkedOpenHashSet;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ChunkMap;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.TicketType;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.storage.ChunkSerializer;
+import net.minecraft.world.level.chunk.storage.EntityStorage;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.slf4j.Logger;
+import java.lang.invoke.VarHandle;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.function.Consumer;
+
+public final class NewChunkHolder {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    public static final Thread.UncaughtExceptionHandler CHUNKSYSTEM_UNCAUGHT_EXCEPTION_HANDLER = new Thread.UncaughtExceptionHandler() {
+        @Override
+        public void uncaughtException(final Thread thread, final Throwable throwable) {
+            LOGGER.error("Uncaught exception in thread " + thread.getName(), throwable);
+            // TODO terminate chunk system
+        }
+    };
+
+    public final ServerLevel world;
+    public final int chunkX;
+    public final int chunkZ;
+
+    public final ChunkTaskScheduler scheduler;
+
+    // load/unload state
+
+    // chunk data state
+
+    private ChunkEntitySlices entityChunk;
+    // entity chunk that is loaded, but not yet deserialized
+    private CompoundTag pendingEntityChunk;
+
+    ChunkEntitySlices loadInEntityChunk(final boolean transientChunk) {
+        TickThread.ensureTickThread(this.chunkX, this.chunkZ, "Cannot sync load entity data off-main");
+        final CompoundTag entityChunk;
+        final ChunkEntitySlices ret;
+        this.scheduler.schedulingLock.lock();
+        try {
+            if (this.entityChunk != null && (transientChunk || !this.entityChunk.isTransient())) {
+                return this.entityChunk;
+            }
+            final CompoundTag pendingEntityChunk = this.pendingEntityChunk;
+            if (!transientChunk && pendingEntityChunk == null) {
+                throw new IllegalStateException("Must load entity data from disk before loading in the entity chunk!");
+            }
+
+            if (this.entityChunk == null) {
+                ret = this.entityChunk = new ChunkEntitySlices(
+                    this.world, this.chunkX, this.chunkZ, this.getChunkStatus(),
+                    WorldUtil.getMinSection(this.world), WorldUtil.getMaxSection(this.world)
+                );
+
+                ret.setTransient(transientChunk);
+
+                this.world.getEntityLookup().entitySectionLoad(this.chunkX, this.chunkZ, ret);
+            } else {
+                // transientChunk = false here
+                ret = this.entityChunk;
+                this.entityChunk.setTransient(false);
+            }
+
+            if (!transientChunk) {
+                this.pendingEntityChunk = null;
+                entityChunk = pendingEntityChunk == EMPTY_ENTITY_CHUNK ? null : pendingEntityChunk;
+            } else {
+                entityChunk = null;
+            }
+        } finally {
+            this.scheduler.schedulingLock.unlock();
+        }
+
+        if (!transientChunk) {
+            if (entityChunk != null) {
+                final List<Entity> entities = EntityStorage.readEntities(this.world, entityChunk);
+
+                this.world.getEntityLookup().addEntityChunkEntities(entities);
+
+                CraftEventFactory.callEntitiesLoadEvent(this.world, new ChunkPos(this.chunkX, this.chunkZ), entities);
+            } else {
+                // must call for empty entities
+                CraftEventFactory.callEntitiesLoadEvent(this.world, new ChunkPos(this.chunkX, this.chunkZ), new ArrayList<>());
+            }
+        }
+
+        return ret;
+    }
+
+    // needed to distinguish whether the entity chunk has been read from disk but is empty or whether it has _not_
+    // been read from disk
+    private static final CompoundTag EMPTY_ENTITY_CHUNK = new CompoundTag();
+
+    private ChunkLoadTask.EntityDataLoadTask entityDataLoadTask;
+    // note: if entityDataLoadTask is cancelled, but on its completion entityDataLoadTaskWaiters.size() != 0,
+    // then the task is rescheduled
+    private List<GenericDataLoadTaskCallback> entityDataLoadTaskWaiters;
+
+    public ChunkLoadTask.EntityDataLoadTask getEntityDataLoadTask() {
+        return this.entityDataLoadTask;
+    }
+
+    // must hold schedule lock for the two below functions
+
+    // returns only if the data has been loaded from disk, DOES NOT relate to whether it has been deserialized
+    // or added into the world (or even into entityChunk)
+    public boolean isEntityChunkNBTLoaded() {
+        return (this.entityChunk != null && !this.entityChunk.isTransient()) || this.pendingEntityChunk != null;
+    }
+
+    private void completeEntityLoad(final GenericDataLoadTask.TaskResult<CompoundTag, Throwable> result) {
+        final List<GenericDataLoadTaskCallback> completeWaiters;
+        this.scheduler.schedulingLock.lock();
+        try {
+            final List<GenericDataLoadTaskCallback> waiters = this.entityDataLoadTaskWaiters;
+            this.entityDataLoadTask = null;
+            if (result != null) {
+                this.entityDataLoadTaskWaiters = null;
+                this.pendingEntityChunk = result.left() == null ? EMPTY_ENTITY_CHUNK : result.left();
+                if (result.right() != null) {
+                    LOGGER.error("Unhandled entity data load exception, data data will be lost: ", result.right());
+                }
+
+                completeWaiters = waiters;
+            } else {
+                // cancelled
+                completeWaiters = null;
+
+                // need to re-schedule?
+                if (waiters.isEmpty()) {
+                    this.entityDataLoadTaskWaiters = null;
+                    // no tasks to schedule _for_
+                } else {
+                    this.entityDataLoadTask = new ChunkLoadTask.EntityDataLoadTask(
+                        this.scheduler, this.world, this.chunkX, this.chunkZ, this.getEffectivePriority()
+                    );
+                    this.entityDataLoadTask.addCallback(this::completeEntityLoad);
+                    // need one schedule() per waiter
+                    for (final GenericDataLoadTaskCallback callback : waiters) {
+                        this.entityDataLoadTask.schedule();
+                    }
+                }
+            }
+        } finally {
+            this.scheduler.schedulingLock.unlock();
+        }
+
+        // avoid holding the scheduling lock while completing
+        if (completeWaiters != null) {
+            for (final GenericDataLoadTaskCallback callback : completeWaiters) {
+                callback.accept(result);
+            }
+        }
+
+        this.scheduler.schedulingLock.lock();
+        try {
+            this.checkUnload();
+        } finally {
+            this.scheduler.schedulingLock.unlock();
+        }
+    }
+
+    // note: it is guaranteed that the consumer cannot be called for the entirety that the schedule lock is held
+    // however, when the consumer is invoked, it will hold the schedule lock
+    public GenericDataLoadTaskCallback getOrLoadEntityData(final Consumer<GenericDataLoadTask.TaskResult<CompoundTag, Throwable>> consumer) {
+        if (this.isEntityChunkNBTLoaded()) {
+            throw new IllegalStateException("Cannot load entity data, it is already loaded");
+        }
+        // why not just acquire the lock? because the caller NEEDS to call isEntityChunkNBTLoaded before this!
+        if (!this.scheduler.schedulingLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Must hold scheduling lock");
+        }
+
+        final GenericDataLoadTaskCallback ret = new EntityDataLoadTaskCallback((Consumer)consumer, this);
+
+        if (this.entityDataLoadTask == null) {
+            this.entityDataLoadTask = new ChunkLoadTask.EntityDataLoadTask(
+                this.scheduler, this.world, this.chunkX, this.chunkZ, this.getEffectivePriority()
+            );
+            this.entityDataLoadTask.addCallback(this::completeEntityLoad);
+            this.entityDataLoadTaskWaiters = new ArrayList<>();
+        }
+        this.entityDataLoadTaskWaiters.add(ret);
+        this.entityDataLoadTask.schedule(); // TODO get this schedule() outside of the lock
+        this.checkUnload();
+
+        return ret;
+    }
+
+    private static final class EntityDataLoadTaskCallback extends GenericDataLoadTaskCallback {
+
+        public EntityDataLoadTaskCallback(final Consumer<GenericDataLoadTask.TaskResult<?, Throwable>> consumer, final NewChunkHolder chunkHolder) {
+            super(consumer, chunkHolder);
+        }
+
+        @Override
+        void internalCancel() {
+            this.chunkHolder.entityDataLoadTaskWaiters.remove(this);
+            this.chunkHolder.entityDataLoadTask.cancel();
+        }
+    }
+
+    private PoiChunk poiChunk;
+
+    private ChunkLoadTask.PoiDataLoadTask poiDataLoadTask;
+    // note: if entityDataLoadTask is cancelled, but on its completion entityDataLoadTaskWaiters.size() != 0,
+    // then the task is rescheduled
+    private List<GenericDataLoadTaskCallback> poiDataLoadTaskWaiters;
+
+    public ChunkLoadTask.PoiDataLoadTask getPoiDataLoadTask() {
+        return this.poiDataLoadTask;
+    }
+
+    // must hold schedule lock for the two below functions
+
+    public boolean isPoiChunkLoaded() {
+        return this.poiChunk != null;
+    }
+
+    private void completePoiLoad(final GenericDataLoadTask.TaskResult<PoiChunk, Throwable> result) {
+        final List<GenericDataLoadTaskCallback> completeWaiters;
+        this.scheduler.schedulingLock.lock();
+        try {
+            final List<GenericDataLoadTaskCallback> waiters = this.poiDataLoadTaskWaiters;
+            this.poiDataLoadTask = null;
+            if (result != null) {
+                this.poiDataLoadTaskWaiters = null;
+                this.poiChunk = result.left();
+                if (result.right() != null) {
+                    LOGGER.error("Unhandled poi load exception, poi data will be lost: ", result.right());
+                }
+
+                completeWaiters = waiters;
+            } else {
+                // cancelled
+                completeWaiters = null;
+
+                // need to re-schedule?
+                if (waiters.isEmpty()) {
+                    this.poiDataLoadTaskWaiters = null;
+                    // no tasks to schedule _for_
+                } else {
+                    this.poiDataLoadTask = new ChunkLoadTask.PoiDataLoadTask(
+                        this.scheduler, this.world, this.chunkX, this.chunkZ, this.getEffectivePriority()
+                    );
+                    this.poiDataLoadTask.addCallback(this::completePoiLoad);
+                    // need one schedule() per waiter
+                    for (final GenericDataLoadTaskCallback callback : waiters) {
+                        this.poiDataLoadTask.schedule();
+                    }
+                }
+            }
+        } finally {
+            this.scheduler.schedulingLock.unlock();
+        }
+
+        // avoid holding the scheduling lock while completing
+        if (completeWaiters != null) {
+            for (final GenericDataLoadTaskCallback callback : completeWaiters) {
+                callback.accept(result);
+            }
+        }
+        this.scheduler.schedulingLock.lock();
+        try {
+            this.checkUnload();
+        } finally {
+            this.scheduler.schedulingLock.unlock();
+        }
+    }
+
+    // note: it is guaranteed that the consumer cannot be called for the entirety that the schedule lock is held
+    // however, when the consumer is invoked, it will hold the schedule lock
+    public GenericDataLoadTaskCallback getOrLoadPoiData(final Consumer<GenericDataLoadTask.TaskResult<PoiChunk, Throwable>> consumer) {
+        if (this.isPoiChunkLoaded()) {
+            throw new IllegalStateException("Cannot load poi data, it is already loaded");
+        }
+        // why not just acquire the lock? because the caller NEEDS to call isPoiChunkLoaded before this!
+        if (!this.scheduler.schedulingLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Must hold scheduling lock");
+        }
+
+        final GenericDataLoadTaskCallback ret = new PoiDataLoadTaskCallback((Consumer)consumer, this);
+
+        if (this.poiDataLoadTask == null) {
+            this.poiDataLoadTask = new ChunkLoadTask.PoiDataLoadTask(
+                this.scheduler, this.world, this.chunkX, this.chunkZ, this.getEffectivePriority()
+            );
+            this.poiDataLoadTask.addCallback(this::completePoiLoad);
+            this.poiDataLoadTaskWaiters = new ArrayList<>();
+        }
+        this.poiDataLoadTaskWaiters.add(ret);
+        this.poiDataLoadTask.schedule(); // TODO get this schedule() outside of the lock
+        this.checkUnload();
+
+        return ret;
+    }
+
+    private static final class PoiDataLoadTaskCallback extends GenericDataLoadTaskCallback {
+
+        public PoiDataLoadTaskCallback(final Consumer<GenericDataLoadTask.TaskResult<?, Throwable>> consumer, final NewChunkHolder chunkHolder) {
+            super(consumer, chunkHolder);
+        }
+
+        @Override
+        void internalCancel() {
+            this.chunkHolder.poiDataLoadTaskWaiters.remove(this);
+            this.chunkHolder.poiDataLoadTask.cancel();
+        }
+    }
+
+    public static abstract class GenericDataLoadTaskCallback implements Cancellable, Consumer<GenericDataLoadTask.TaskResult<?, Throwable>> {
+
+        protected final Consumer<GenericDataLoadTask.TaskResult<?, Throwable>> consumer;
+        protected final NewChunkHolder chunkHolder;
+        protected boolean completed;
+
+        public GenericDataLoadTaskCallback(final Consumer<GenericDataLoadTask.TaskResult<?, Throwable>> consumer,
+                                           final NewChunkHolder chunkHolder) {
+            this.consumer = consumer;
+            this.chunkHolder = chunkHolder;
+        }
+
+        boolean isCompleted() {
+            return this.completed;
+        }
+
+        // must hold scheduling lock
+        private boolean setCompleted() {
+            if (this.completed) {
+                return false;
+            }
+            return this.completed = true;
+        }
+
+        @Override
+        public void accept(final GenericDataLoadTask.TaskResult<?, Throwable> result) {
+            if (result != null) {
+                if (this.setCompleted()) {
+                    this.consumer.accept(result);
+                } else {
+                    throw new IllegalStateException("Cannot be cancelled at this point");
+                }
+            } else {
+                throw new NullPointerException("Result cannot be null (cancelled)");
+            }
+        }
+
+        // holds scheduling lock
+        abstract void internalCancel();
+
+        @Override
+        public boolean cancel() {
+            this.chunkHolder.scheduler.schedulingLock.lock();
+            try {
+                if (!this.completed) {
+                    this.completed = true;
+                    this.internalCancel();
+                    return true;
+                }
+                return false;
+            } finally {
+                this.chunkHolder.scheduler.schedulingLock.unlock();
+            }
+        }
+    }
+
+    private ChunkAccess currentChunk;
+
+    // generation status state
+
+    /**
+     * Current status the chunk has been brought up to by the chunk system. null indicates no work at all
+     */
+    private ChunkStatus currentGenStatus;
+
+    // This allows unsynchronised access to the chunk and last gen status
+    private volatile ChunkCompletion lastChunkCompletion;
+
+    public ChunkCompletion getLastChunkCompletion() {
+        return this.lastChunkCompletion;
+    }
+
+    public static final record ChunkCompletion(ChunkAccess chunk, ChunkStatus genStatus) {};
+
+    /**
+     * The target final chunk status the chunk system will bring the chunk to.
+     */
+    private ChunkStatus requestedGenStatus;
+
+    private ChunkProgressionTask generationTask;
+    private ChunkStatus generationTaskStatus;
+
+    /**
+     * contains the neighbours that this chunk generation is blocking on
+     */
+    protected final ReferenceLinkedOpenHashSet<NewChunkHolder> neighboursBlockingGenTask = new ReferenceLinkedOpenHashSet<>(4);
+
+    /**
+     * map of ChunkHolder -> Required Status for this chunk
+     */
+    protected final Reference2ObjectLinkedOpenHashMap<NewChunkHolder, ChunkStatus> neighboursWaitingForUs = new Reference2ObjectLinkedOpenHashMap<>();
+
+    public void addGenerationBlockingNeighbour(final NewChunkHolder neighbour) {
+        this.neighboursBlockingGenTask.add(neighbour);
+    }
+
+    public void addWaitingNeighbour(final NewChunkHolder neighbour, final ChunkStatus requiredStatus) {
+        final boolean wasEmpty = this.neighboursWaitingForUs.isEmpty();
+        this.neighboursWaitingForUs.put(neighbour, requiredStatus);
+        if (wasEmpty) {
+            this.checkUnload();
+        }
+    }
+
+    // priority state
+
+    // the target priority for this chunk to generate at
+    // TODO this will screw over scheduling at lower priorities to neighbours, fix
+    private PrioritisedExecutor.Priority priority = PrioritisedExecutor.Priority.NORMAL;
+    private boolean priorityLocked;
+
+    // the priority neighbouring chunks have requested this chunk generate at
+    private PrioritisedExecutor.Priority neighbourRequestedPriority = PrioritisedExecutor.Priority.IDLE;
+
+    public PrioritisedExecutor.Priority getEffectivePriority() {
+        return PrioritisedExecutor.Priority.max(this.priority, this.neighbourRequestedPriority);
+    }
+
+    protected void recalculateNeighbourRequestedPriority() {
+        if (this.neighboursWaitingForUs.isEmpty()) {
+            this.neighbourRequestedPriority = PrioritisedExecutor.Priority.IDLE;
+            return;
+        }
+
+        PrioritisedExecutor.Priority max = PrioritisedExecutor.Priority.IDLE;
+
+        for (final NewChunkHolder holder : this.neighboursWaitingForUs.keySet()) {
+            final PrioritisedExecutor.Priority neighbourPriority = holder.getEffectivePriority();
+            if (neighbourPriority.isHigherPriority(max)) {
+                max = neighbourPriority;
+            }
+        }
+
+        final PrioritisedExecutor.Priority current = this.getEffectivePriority();
+        this.neighbourRequestedPriority = max;
+        final PrioritisedExecutor.Priority next = this.getEffectivePriority();
+
+        if (current == next) {
+            return;
+        }
+
+        // our effective priority has changed, so change our task
+        if (this.generationTask != null) {
+            this.generationTask.setPriority(next);
+        }
+
+        // now propagate this to our neighbours
+        this.recalculateNeighbourPriorities();
+    }
+
+    public void recalculateNeighbourPriorities() {
+        for (final NewChunkHolder holder : this.neighboursBlockingGenTask) {
+            holder.recalculateNeighbourRequestedPriority();
+        }
+    }
+
+    // must hold scheduling lock
+    public void raisePriority(final PrioritisedExecutor.Priority priority) {
+        if (this.priority != null && this.priority.isHigherOrEqualPriority(priority)) {
+            return;
+        }
+        this.setPriority(priority);
+    }
+
+    private void lockPriority() {
+        this.priority = PrioritisedExecutor.Priority.NORMAL;
+        this.priorityLocked = true;
+    }
+
+    // must hold scheduling lock
+    public void setPriority(final PrioritisedExecutor.Priority priority) {
+        if (this.priorityLocked) {
+            return;
+        }
+        final PrioritisedExecutor.Priority old = this.getEffectivePriority();
+        this.priority = priority;
+        final PrioritisedExecutor.Priority newPriority = this.getEffectivePriority();
+
+        if (old != newPriority) {
+            if (this.generationTask != null) {
+                this.generationTask.setPriority(newPriority);
+            }
+        }
+
+        this.recalculateNeighbourPriorities();
+    }
+
+    // must hold scheduling lock
+    public void lowerPriority(final PrioritisedExecutor.Priority priority) {
+        if (this.priority != null && this.priority.isLowerOrEqualPriority(priority)) {
+            return;
+        }
+        this.setPriority(priority);
+    }
+
+    // error handling state
+    private ChunkStatus failedGenStatus;
+    private Throwable genTaskException;
+    private Thread genTaskFailedThread;
+
+    private boolean failedLightUpdate;
+
+    public void failedLightUpdate() {
+        this.failedLightUpdate = true;
+    }
+
+    public boolean hasFailedGeneration() {
+        return this.genTaskException != null;
+    }
+
+    // ticket level state
+    private int oldTicketLevel = ChunkMap.MAX_CHUNK_DISTANCE + 1;
+    private int currentTicketLevel = ChunkMap.MAX_CHUNK_DISTANCE + 1;
+
+    public int getTicketLevel() {
+        return this.currentTicketLevel;
+    }
+
+    public final ChunkHolder vanillaChunkHolder;
+
+    public NewChunkHolder(final ServerLevel world, final int chunkX, final int chunkZ, final ChunkTaskScheduler scheduler) {
+        this.world = world;
+        this.chunkX = chunkX;
+        this.chunkZ = chunkZ;
+        this.scheduler = scheduler;
+        this.vanillaChunkHolder = new ChunkHolder(new ChunkPos(chunkX, chunkZ), world, world.getLightEngine(), world.chunkSource.chunkMap, this);
+    }
+
+    protected ImposterProtoChunk wrappedChunkForNeighbour;
+
+    // holds scheduling lock
+    // TODO Vanilla ChunkHolder getUnchecked still needs to be adjusted?
+    public ChunkAccess getChunkForNeighbourAccess() {
+        // Vanilla overrides the status futures with an imposter chunk to prevent writes to full chunks
+        // But we don't store per-status futures, so we need this hack
+        if (this.wrappedChunkForNeighbour != null) {
+            return this.wrappedChunkForNeighbour;
+        }
+        final ChunkAccess ret = this.currentChunk;
+        return ret instanceof LevelChunk fullChunk ? this.wrappedChunkForNeighbour = new ImposterProtoChunk(fullChunk, false) : ret;
+    }
+
+    public ChunkAccess getCurrentChunk() {
+        return this.currentChunk;
+    }
+
+    int getCurrentTicketLevel() {
+        return this.currentTicketLevel;
+    }
+
+    void updateTicketLevel(final int toLevel) {
+        this.currentTicketLevel = toLevel;
+    }
+
+    private int totalNeighboursUsingThisChunk = 0;
+
+    // holds schedule lock
+    public void addNeighbourUsingChunk() {
+        final int now = ++this.totalNeighboursUsingThisChunk;
+
+        if (now == 1) {
+            this.checkUnload();
+        }
+    }
+
+    // holds schedule lock
+    public void removeNeighbourUsingChunk() {
+        final int now = --this.totalNeighboursUsingThisChunk;
+
+        if (now == 0) {
+            this.checkUnload();
+        }
+
+        if (now < 0) {
+            throw new IllegalStateException("Neighbours using this chunk cannot be negative");
+        }
+    }
+
+    // must hold scheduling lock
+    // returns string reason for why chunk should remain loaded, null otherwise
+    public final String isSafeToUnload() {
+        // is ticket level below threshold?
+        if (this.oldTicketLevel <= ChunkHolderManager.MAX_TICKET_LEVEL) {
+            return "ticket_level";
+        }
+
+        // are we being used by another chunk for generation?
+        if (this.totalNeighboursUsingThisChunk != 0) {
+            return "neighbours_generating";
+        }
+
+        // are we going to be used by another chunk for generation?
+        if (!this.neighboursWaitingForUs.isEmpty()) {
+            return "neighbours_waiting";
+        }
+
+        // chunk must be marked inaccessible (i.e unloaded to plugins)
+        if (this.getChunkStatus() != ChunkHolder.FullChunkStatus.INACCESSIBLE) {
+            return "fullchunkstatus";
+        }
+
+        // are we currently generating anything, or have requested generation?
+        if (this.generationTask != null) {
+            return "generating";
+        }
+        if (this.requestedGenStatus != null) {
+            return "requested_generation";
+        }
+
+        // entity data requested?
+        if (this.entityDataLoadTask != null) {
+            return "entity_data_requested";
+        }
+
+        // poi data requested?
+        if (this.poiDataLoadTask != null) {
+            return "poi_data_requested";
+        }
+
+        // are we pending serialization?
+        if (this.entityDataUnload != null) {
+            return "entity_serialization";
+        }
+        if (this.poiDataUnload != null) {
+            return "poi_serialization";
+        }
+        if (this.chunkDataUnload != null) {
+            return "chunk_serialization";
+        }
+
+        // Note: light tasks do not need a check, as they add a ticket.
+
+        // nothing is using this chunk, so it should be unloaded
+        return null;
+    }
+
+    // must hold scheduling lock
+    private void checkUnload() {
+        if (this.isSafeToUnload() == null) {
+            // ensure in unload queue
+            this.scheduler.chunkHolderManager.unloadQueue.add(this);
+        } else {
+            // ensure not in unload queue
+            this.scheduler.chunkHolderManager.unloadQueue.remove(this);
+        }
+    }
+
+    static final record UnloadState(NewChunkHolder holder, ChunkAccess chunk, ChunkEntitySlices entityChunk, PoiChunk poiChunk) {};
+
+    // note: these are completed with null to indicate that no write occurred
+    // they are also completed with null to indicate a null write occured
+    private Completable<CompoundTag> chunkDataUnload;
+    private Completable<CompoundTag> entityDataUnload;
+    private Completable<CompoundTag> poiDataUnload;
+    private DelayedPrioritisedTask chunkDataUnloadTask;
+
+    public Completable<CompoundTag> getUnloadCompletable(final RegionFileIOThread.RegionFileType type) {
+        switch (type) {
+            case CHUNK_DATA:
+                return this.chunkDataUnload;
+            case ENTITY_DATA:
+                return this.entityDataUnload;
+            case POI_DATA:
+                return this.poiDataUnload;
+            default:
+                throw new IllegalStateException("Unknown regionfile type " + type);
+        }
+    }
+
+    public DelayedPrioritisedTask getUnloadTask(final RegionFileIOThread.RegionFileType type) {
+        switch (type) {
+            case CHUNK_DATA:
+                return this.chunkDataUnloadTask;
+            case ENTITY_DATA:
+                return null;
+            case POI_DATA:
+                return null;
+            default:
+                throw new IllegalStateException("Unknown regionfile type " + type);
+        }
+    }
+
+    private UnloadState unloadState;
+
+    // holds schedule lock
+    UnloadState unloadStage1() {
+        // because we hold the scheduling lock, we cannot actually unload anything
+        // so we need to null this chunk's state
+        final ChunkAccess chunk = this.currentChunk;
+        final ChunkEntitySlices entityChunk = this.entityChunk;
+        final PoiChunk poiChunk = this.poiChunk;
+        // chunk state
+        this.currentChunk = null;
+        this.currentGenStatus = null;
+        this.wrappedChunkForNeighbour = null;
+        this.lastChunkCompletion = null;
+        // entity chunk state
+        this.entityChunk = null;
+        this.pendingEntityChunk = null;
+
+        // poi chunk state
+        this.poiChunk = null;
+
+        // priority state
+        this.priorityLocked = false;
+
+        if (chunk != null) {
+            this.chunkDataUnload = new Completable<>();
+            this.chunkDataUnloadTask = new DelayedPrioritisedTask(PrioritisedExecutor.Priority.NORMAL);
+        }
+        if (entityChunk != null) {
+            this.entityDataUnload = new Completable<>();
+        }
+        if (poiChunk != null) {
+            this.poiDataUnload = new Completable<>();
+        }
+
+        return this.unloadState = (chunk != null || entityChunk != null || poiChunk != null) ? new UnloadState(this, chunk, entityChunk, poiChunk) : null;
+    }
+
+    // data is null if failed
+    void completeAsyncChunkDataSave(final CompoundTag data) {
+        if (data != null) {
+            RegionFileIOThread.scheduleSave(this.world, this.chunkX, this.chunkZ, data, RegionFileIOThread.RegionFileType.CHUNK_DATA);
+        }
+        this.chunkDataUnload.complete(data);
+        this.scheduler.schedulingLock.lock();
+        try {
+            // can only write to these fields while holding the schedule lock
+            this.chunkDataUnload = null;
+            this.chunkDataUnloadTask = null;
+            this.checkUnload();
+        } finally {
+            this.scheduler.schedulingLock.unlock();
+        }
+    }
+
+    void unloadStage2(final UnloadState state) {
+        this.unloadState = null;
+        final ChunkAccess chunk = state.chunk();
+        final ChunkEntitySlices entityChunk = state.entityChunk();
+        final PoiChunk poiChunk = state.poiChunk();
+
+        // unload chunk data
+        if (chunk != null) {
+            if (chunk instanceof LevelChunk levelChunk) {
+                levelChunk.setLoaded(false);
+            }
+
+            this.saveChunk(chunk, true);
+
+            if (chunk instanceof LevelChunk levelChunk) {
+                this.world.unload(levelChunk);
+            }
+        }
+
+        // unload entity data
+        if (entityChunk != null) {
+            this.saveEntities(entityChunk, true);
+            // yes this is a hack to pass the compound tag through...
+            final CompoundTag lastEntityUnload = this.lastEntityUnload;
+            this.lastEntityUnload = null;
+
+            if (entityChunk.unload()) {
+                this.scheduler.schedulingLock.lock();
+                try {
+                    entityChunk.setTransient(true);
+                    this.entityChunk = entityChunk;
+                } finally {
+                    this.scheduler.schedulingLock.unlock();
+                }
+            } else {
+                this.world.getEntityLookup().entitySectionUnload(this.chunkX, this.chunkZ);
+            }
+            // we need to delay the callback until after determining transience, otherwise a potential loader could
+            // set entityChunk before we do
+            this.entityDataUnload.complete(lastEntityUnload);
+        }
+
+        // unload poi data
+        if (poiChunk != null) {
+            if (poiChunk.isDirty()) {
+                this.savePOI(poiChunk, true);
+            } else {
+                this.poiDataUnload.complete(null);
+            }
+
+            this.world.getPoiManager().onUnload(CoordinateUtils.getChunkKey(this.chunkX, this.chunkZ));
+        }
+    }
+
+    boolean unloadStage3() {
+        // can only write to these while holding the schedule lock, and we instantly complete them in stage2
+        this.poiDataUnload = null;
+        this.entityDataUnload = null;
+
+        // we need to check if anything has been loaded in the meantime (or if we have transient entities)
+        if (this.entityChunk != null || this.poiChunk != null || this.currentChunk != null) {
+            return false;
+        }
+
+        return this.isSafeToUnload() == null;
+    }
+
+    private void cancelGenTask() {
+        if (this.generationTask != null) {
+            this.generationTask.cancel();
+        } else {
+            // otherwise, we are blocking on neighbours, so remove them
+            if (!this.neighboursBlockingGenTask.isEmpty()) {
+                for (final NewChunkHolder neighbour : this.neighboursBlockingGenTask) {
+                    if (neighbour.neighboursWaitingForUs.remove(this) == null) {
+                        throw new IllegalStateException("Corrupt state");
+                    }
+                    if (neighbour.neighboursWaitingForUs.isEmpty()) {
+                        neighbour.checkUnload();
+                    }
+                }
+                this.neighboursBlockingGenTask.clear();
+                this.checkUnload();
+            }
+        }
+    }
+
+    // holds: ticket level update lock
+    // holds: schedule lock
+    public void processTicketLevelUpdate(final List<ChunkProgressionTask> scheduledTasks, final List<NewChunkHolder> changedLoadStatus) {
+        final int oldLevel = this.oldTicketLevel;
+        final int newLevel = this.currentTicketLevel;
+
+        if (oldLevel == newLevel) {
+            return;
+        }
+
+        this.oldTicketLevel = newLevel;
+
+        final ChunkHolder.FullChunkStatus oldState = ChunkHolder.getFullChunkStatus(oldLevel);
+        final ChunkHolder.FullChunkStatus newState = ChunkHolder.getFullChunkStatus(newLevel);
+        final boolean oldUnloaded = oldLevel > ChunkHolderManager.MAX_TICKET_LEVEL;
+        final boolean newUnloaded = newLevel > ChunkHolderManager.MAX_TICKET_LEVEL;
+
+        final ChunkStatus maxGenerationStatusOld = ChunkHolder.getStatus(oldLevel);
+        final ChunkStatus maxGenerationStatusNew = ChunkHolder.getStatus(newLevel);
+
+        if (oldState != newState) {
+            if (this.onTicketUpdate(oldState, newState)) {
+                changedLoadStatus.add(this);
+            }
+        }
+
+        // check for cancellations from downgrading ticket level
+        if (this.requestedGenStatus != null && !newState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && newLevel > oldLevel) {
+            // note: cancel() may invoke onChunkGenComplete synchronously here
+            if (newUnloaded) {
+                // need to cancel all tasks
+                // note: requested status must be set to null here before cancellation, to indicate to the
+                // completion logic that we do not want rescheduling to occur
+                this.requestedGenStatus = null;
+                this.cancelGenTask();
+            } else {
+                final ChunkStatus toCancel = maxGenerationStatusNew.getNextStatus();
+                final ChunkStatus currentRequestedStatus = this.requestedGenStatus;
+
+                if (currentRequestedStatus.isOrAfter(toCancel)) {
+                    // we do have to cancel something here
+                    // clamp requested status to the maximum
+                    if (this.currentGenStatus != null && this.currentGenStatus.isOrAfter(maxGenerationStatusNew)) {
+                        // already generated to status, so we must cancel
+                        this.requestedGenStatus = null;
+                        this.cancelGenTask();
+                    } else {
+                        // not generated to status, so we may have to cancel
+                        // note: gen task is always 1 status above current gen status if not null
+                        this.requestedGenStatus = maxGenerationStatusNew;
+                        if (this.generationTaskStatus != null && this.generationTaskStatus.isOrAfter(toCancel)) {
+                            // TOOD is this even possible? i don't think so
+                            throw new IllegalStateException("?????");
+                        }
+                    }
+                }
+            }
+        }
+
+        if (newState != oldState) {
+            if (newState.isOrAfter(oldState)) {
+                // status upgrade
+                if (!oldState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && newState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                    // may need to schedule full load
+                    if (this.currentGenStatus != ChunkStatus.FULL) {
+                        if (this.requestedGenStatus != null) {
+                            this.requestedGenStatus = ChunkStatus.FULL;
+                        } else {
+                            this.scheduler.schedule(
+                                this.chunkX, this.chunkZ, ChunkStatus.FULL, this, scheduledTasks
+                            );
+                        }
+                    } else {
+                        // now we are fully loaded
+                        this.onFullChunkLoadChange(true, changedLoadStatus);
+                    }
+                }
+            } else {
+                // status downgrade
+                if (!newState.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING) && oldState.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING)) {
+                    this.completeFullStatusConsumers(ChunkHolder.FullChunkStatus.ENTITY_TICKING, null);
+                }
+
+                if (!newState.isOrAfter(ChunkHolder.FullChunkStatus.TICKING) && oldState.isOrAfter(ChunkHolder.FullChunkStatus.TICKING)) {
+                    this.completeFullStatusConsumers(ChunkHolder.FullChunkStatus.TICKING, null);
+                }
+
+                if (!newState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && oldState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                    if (this.currentGenStatus == ChunkStatus.FULL) {
+                        this.onFullChunkLoadChange(false, changedLoadStatus);
+                    }
+                    this.completeFullStatusConsumers(ChunkHolder.FullChunkStatus.BORDER, null);
+                }
+            }
+        }
+
+        if (oldUnloaded != newUnloaded) {
+            this.checkUnload();
+        }
+    }
+
+    /*
+        For full chunks, vanilla just loads chunks around it up to FEATURES, 1 radius
+
+        For ticking chunks, it updates the persistent entity manager (soon to be completely nuked by EntitySliceManager, which
+        will also need to be updated but with far less implications)
+        It also shoves the scheduled block ticks into the tick scheduler
+
+        For entity ticking chunks, updates the entity manager (see above)
+     */
+
+    static final int NEIGHBOUR_RADIUS = 2;
+    private long fullNeighbourChunksLoadedBitset;
+
+    private static int getFullNeighbourIndex(final int relativeX, final int relativeZ) {
+        // index = (relativeX + NEIGHBOUR_CACHE_RADIUS) + (relativeZ + NEIGHBOUR_CACHE_RADIUS) * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)
+        // optimised variant of the above by moving some of the ops to compile time
+        return relativeX + (relativeZ * (NEIGHBOUR_RADIUS * 2 + 1)) + (NEIGHBOUR_RADIUS + NEIGHBOUR_RADIUS * ((NEIGHBOUR_RADIUS * 2 + 1)));
+    }
+    public final boolean isNeighbourFullLoaded(final int relativeX, final int relativeZ) {
+        return (this.fullNeighbourChunksLoadedBitset & (1L << getFullNeighbourIndex(relativeX, relativeZ))) != 0;
+    }
+
+    // returns true if this chunk changed full status
+    public final boolean setNeighbourFullLoaded(final int relativeX, final int relativeZ) {
+        final long before = this.fullNeighbourChunksLoadedBitset;
+        final int index = getFullNeighbourIndex(relativeX, relativeZ);
+        this.fullNeighbourChunksLoadedBitset |= (1L << index);
+        return this.onNeighbourChange(before, this.fullNeighbourChunksLoadedBitset);
+    }
+
+    // returns true if this chunk changed full status
+    public final boolean setNeighbourFullUnloaded(final int relativeX, final int relativeZ) {
+        final long before = this.fullNeighbourChunksLoadedBitset;
+        final int index = getFullNeighbourIndex(relativeX, relativeZ);
+        this.fullNeighbourChunksLoadedBitset &= ~(1L << index);
+        return this.onNeighbourChange(before, this.fullNeighbourChunksLoadedBitset);
+    }
+
+    public static boolean areNeighboursFullLoaded(final long bitset, final int radius) {
+        // index = relativeX + (relativeZ * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)) + (NEIGHBOUR_CACHE_RADIUS + NEIGHBOUR_CACHE_RADIUS * ((NEIGHBOUR_CACHE_RADIUS * 2 + 1)))
+        switch (radius) {
+            case 0: {
+                return (bitset & (1L << getFullNeighbourIndex(0, 0))) != 0L;
+            }
+            case 1: {
+                long mask = 0L;
+                for (int dx = -1; dx <= 1; ++dx) {
+                    for (int dz = -1; dz <= 1; ++dz) {
+                        mask |= (1L << getFullNeighbourIndex(dx, dz));
+                    }
+                }
+                return (bitset & mask) == mask;
+            }
+            case 2: {
+                long mask = 0L;
+                for (int dx = -2; dx <= 2; ++dx) {
+                    for (int dz = -2; dz <= 2; ++dz) {
+                        mask |= (1L << getFullNeighbourIndex(dx, dz));
+                    }
+                }
+                return (bitset & mask) == mask;
+            }
+
+            default: {
+                throw new IllegalArgumentException("Radius not recognized: " + radius);
+            }
+        }
+    }
+
+    // upper 16 bits are pending status, lower 16 bits are current status
+    private volatile long chunkStatus;
+    private static final long PENDING_STATUS_MASK = Long.MIN_VALUE >> 31;
+    private static final ChunkHolder.FullChunkStatus[] CHUNK_STATUS_BY_ID = ChunkHolder.FullChunkStatus.values();
+    private static final VarHandle CHUNK_STATUS_HANDLE = ConcurrentUtil.getVarHandle(NewChunkHolder.class, "chunkStatus", long.class);
+
+    public ChunkHolder.FullChunkStatus getChunkStatus() {
+        return CHUNK_STATUS_BY_ID[(int)((long)CHUNK_STATUS_HANDLE.getVolatile((NewChunkHolder)this))];
+    }
+
+    public boolean isEntityTickingReady() {
+        return this.getChunkStatus().isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING);
+    }
+
+    public boolean isTickingReady() {
+        return this.getChunkStatus().isOrAfter(ChunkHolder.FullChunkStatus.TICKING);
+    }
+
+    public boolean isFullChunkReady() {
+        return this.getChunkStatus().isOrAfter(ChunkHolder.FullChunkStatus.BORDER);
+    }
+
+    private static ChunkHolder.FullChunkStatus getStatusForBitset(final long bitset) {
+        if (areNeighboursFullLoaded(bitset, 2)) {
+            return ChunkHolder.FullChunkStatus.ENTITY_TICKING;
+        } else if (areNeighboursFullLoaded(bitset, 1)) {
+            return ChunkHolder.FullChunkStatus.TICKING;
+        } else if (areNeighboursFullLoaded(bitset, 0)) {
+            return ChunkHolder.FullChunkStatus.BORDER;
+        } else {
+            return ChunkHolder.FullChunkStatus.INACCESSIBLE;
+        }
+    }
+
+    // note: only while updating ticket level, so holds ticket update lock + scheduling lock
+    protected final boolean onTicketUpdate(final ChunkHolder.FullChunkStatus oldState, final ChunkHolder.FullChunkStatus newState) {
+        if (oldState == newState) {
+            return false;
+        }
+
+        final ChunkHolder.FullChunkStatus byNeighbours = getStatusForBitset(this.fullNeighbourChunksLoadedBitset);
+
+        final ChunkHolder.FullChunkStatus toSet;
+
+        if (newState.isOrAfter(byNeighbours)) {
+            // must clamp to neighbours level, as we don't have the ticket level for it
+            toSet = byNeighbours;
+        } else {
+            // must clamp to ticket level, even though we have the neighbours
+            toSet = newState;
+        }
+
+        long curr = (long)CHUNK_STATUS_HANDLE.getVolatile((NewChunkHolder)this);
+
+        if (curr == ((long)toSet.ordinal() | ((long)toSet.ordinal() << 32))) {
+            // nothing to do
+            return false;
+        }
+
+        int failures = 0;
+        for (;;) {
+            final long update = (curr & ~PENDING_STATUS_MASK) | ((long)toSet.ordinal() << 32);
+            if (curr == (curr = (long)CHUNK_STATUS_HANDLE.compareAndExchange((NewChunkHolder)this, curr, update))) {
+                return true;
+            }
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    protected final boolean onNeighbourChange(final long bitsetBefore, final long bitsetAfter) {
+        ChunkHolder.FullChunkStatus oldState = getStatusForBitset(bitsetBefore);
+        ChunkHolder.FullChunkStatus newState = getStatusForBitset(bitsetAfter);
+        final ChunkHolder.FullChunkStatus currStateTicketLevel = ChunkHolder.getFullChunkStatus(this.oldTicketLevel);
+        if (oldState.isOrAfter(currStateTicketLevel)) {
+            oldState = currStateTicketLevel;
+        }
+        if (newState.isOrAfter(currStateTicketLevel)) {
+            newState = currStateTicketLevel;
+        }
+
+        if (oldState == newState) {
+            return false;
+        }
+
+        int failures = 0;
+        for (long curr = (long)CHUNK_STATUS_HANDLE.getVolatile((NewChunkHolder)this);;) {
+            final long update = (curr & ~PENDING_STATUS_MASK) | ((long)newState.ordinal() << 32);
+            if (curr == (curr = (long)CHUNK_STATUS_HANDLE.compareAndExchange((NewChunkHolder)this, curr, update))) {
+                return true;
+            }
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    // only call on main thread, must hold ticket level and scheduling lock
+    private void onFullChunkLoadChange(final boolean loaded, final List<NewChunkHolder> changedFullStatus) {
+        for (int dz = -NEIGHBOUR_RADIUS; dz <= NEIGHBOUR_RADIUS; ++dz) {
+            for (int dx = -NEIGHBOUR_RADIUS; dx <= NEIGHBOUR_RADIUS; ++dx) {
+                final NewChunkHolder holder = (dx | dz) == 0 ? this : this.scheduler.chunkHolderManager.getChunkHolder(dx + this.chunkX, dz + this.chunkZ);
+                if (loaded) {
+                    if (holder.setNeighbourFullLoaded(-dx, -dz)) {
+                        changedFullStatus.add(holder);
+                    }
+                } else {
+                    if (holder.setNeighbourFullUnloaded(-dx, -dz)) {
+                        changedFullStatus.add(holder);
+                    }
+                }
+            }
+        }
+    }
+
+    private ChunkHolder.FullChunkStatus updateCurrentState(final ChunkHolder.FullChunkStatus to) {
+        int failures = 0;
+        for (long curr = (long)CHUNK_STATUS_HANDLE.getVolatile((NewChunkHolder)this);;) {
+            final long update = (curr & PENDING_STATUS_MASK) | (long)to.ordinal();
+            if (curr == (curr = (long)CHUNK_STATUS_HANDLE.compareAndExchange((NewChunkHolder)this, curr, update))) {
+                return CHUNK_STATUS_BY_ID[(int)(curr >>> 32)];
+            }
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    // only to be called on the main thread, no locks need to be held
+    public void handleFullStatusChange() {
+        TickThread.ensureTickThread(this.chunkX, this.chunkZ, "Cannot update full status thread off-main");
+
+        final ChunkHolderManager holderManager = this.world.chunkTaskScheduler.chunkHolderManager;
+        final int ticketKeep;
+        final Long ticketId;
+        holderManager.ticketLock.lock();
+        try {
+            ticketKeep = this.currentTicketLevel;
+            ticketId = Long.valueOf(holderManager.getNextStatusUpgradeId());
+            holderManager.addTicketAtLevel(TicketType.STATUS_UPGRADE, this.chunkX, this.chunkZ, ticketKeep, ticketId);
+        } finally {
+            holderManager.ticketLock.unlock();
+        }
+        try {
+            for (;;) {
+                final long currStateEncoded = (long)CHUNK_STATUS_HANDLE.getVolatile((NewChunkHolder)this);
+                final ChunkHolder.FullChunkStatus currState = CHUNK_STATUS_BY_ID[(int)currStateEncoded];
+                ChunkHolder.FullChunkStatus nextState = CHUNK_STATUS_BY_ID[(int)(currStateEncoded >>> 32)];
+                if (currState == nextState) {
+                    if (nextState == ChunkHolder.FullChunkStatus.INACCESSIBLE) {
+                        this.scheduler.schedulingLock.lock();
+                        try {
+                            this.checkUnload();
+                        } finally {
+                            this.scheduler.schedulingLock.unlock();
+                        }
+                    }
+                    break;
+                }
+
+                // chunks cannot downgrade state while status is pending a change
+                final LevelChunk chunk = (LevelChunk)this.currentChunk;
+
+                // Note: we assume that only load/unload contain plugin logic
+                // plugin logic is anything stupid enough to possibly change the chunk status while it is already
+                // being changed (i.e during load it is possible it will try to set to full ticking)
+                // in order to allow this change, we also need this plugin logic to be contained strictly after all
+                // of the chunk system load callbacks are invoked
+                if (nextState.isOrAfter(currState)) {
+                    // state upgrade
+                    if (!currState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && nextState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                        // specifically for chunk loading, we set it to loaded before the callback so that plugins see it as loaded
+                        nextState = this.updateCurrentState(ChunkHolder.FullChunkStatus.BORDER);
+                        this.scheduler.chunkHolderManager.ensureInAutosave(this);
+                        chunk.onChunkLoad(this);
+                        this.completeFullStatusConsumers(ChunkHolder.FullChunkStatus.BORDER, chunk);
+                    }
+
+                    if (!currState.isOrAfter(ChunkHolder.FullChunkStatus.TICKING) && nextState.isOrAfter(ChunkHolder.FullChunkStatus.TICKING)) {
+                        chunk.onChunkTicking(this);
+                        nextState = this.updateCurrentState(ChunkHolder.FullChunkStatus.TICKING);
+                        this.completeFullStatusConsumers(ChunkHolder.FullChunkStatus.TICKING, chunk);
+                    }
+
+                    if (!currState.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING) && nextState.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING)) {
+                        chunk.onChunkEntityTicking(this);
+                        nextState = this.updateCurrentState(ChunkHolder.FullChunkStatus.ENTITY_TICKING);
+                        this.completeFullStatusConsumers(ChunkHolder.FullChunkStatus.ENTITY_TICKING, chunk);
+                    }
+                } else {
+                    // state downgrade
+                    if (currState.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING) && !nextState.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING)) {
+                        chunk.onChunkNotEntityTicking(this);
+                        nextState = this.updateCurrentState(ChunkHolder.FullChunkStatus.TICKING);
+                    }
+
+                    if (currState.isOrAfter(ChunkHolder.FullChunkStatus.TICKING) && !nextState.isOrAfter(ChunkHolder.FullChunkStatus.TICKING)) {
+                        chunk.onChunkNotTicking(this);
+                        nextState = this.updateCurrentState(ChunkHolder.FullChunkStatus.BORDER);
+                    }
+
+                    if (currState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && !nextState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                        chunk.onChunkUnload(this);
+                        nextState = this.updateCurrentState(ChunkHolder.FullChunkStatus.INACCESSIBLE);
+                    }
+                }
+            }
+        } finally {
+            holderManager.removeTicketAtLevel(TicketType.STATUS_UPGRADE, this.chunkX, this.chunkZ, ticketKeep, ticketId);
+        }
+    }
+
+    // note: must hold scheduling lock
+    // rets true if the current requested gen status is not null (effectively, whether further scheduling is not needed)
+    boolean upgradeGenTarget(final ChunkStatus toStatus) {
+        if (toStatus == null) {
+            throw new NullPointerException("toStatus cannot be null");
+        }
+        if (this.requestedGenStatus == null) {
+            return false;
+        }
+        if (!this.requestedGenStatus.isOrAfter(toStatus)) {
+            this.requestedGenStatus = toStatus;
+        }
+        return true;
+    }
+
+    public void setGenerationTarget(final ChunkStatus toStatus) {
+        this.requestedGenStatus = toStatus;
+    }
+
+    public boolean hasGenerationTask() {
+        return this.generationTask != null;
+    }
+
+    public ChunkStatus getCurrentGenStatus() {
+        return this.currentGenStatus;
+    }
+
+    public ChunkStatus getRequestedGenStatus() {
+        return this.requestedGenStatus;
+    }
+
+    private final Reference2ObjectOpenHashMap<ChunkStatus, List<Consumer<ChunkAccess>>> statusWaiters = new Reference2ObjectOpenHashMap<>();
+
+    void addStatusConsumer(final ChunkStatus status, final Consumer<ChunkAccess> consumer) {
+        this.statusWaiters.computeIfAbsent(status, (final ChunkStatus keyInMap) -> {
+            return new ArrayList<>(4);
+        }).add(consumer);
+    }
+
+    private void completeStatusConsumers(ChunkStatus status, final ChunkAccess chunk) {
+        // need to tell future statuses to complete if cancelled
+        do {
+            this.completeStatusConsumers0(status, chunk);
+        } while (chunk == null && status != (status = status.getNextStatus()));
+    }
+
+    private void completeStatusConsumers0(final ChunkStatus status, final ChunkAccess chunk) {
+        final List<Consumer<ChunkAccess>> consumers;
+        consumers = this.statusWaiters.remove(status);
+
+        if (consumers == null) {
+            return;
+        }
+
+        // must be scheduled to main, we do not trust the callback to not do anything stupid
+        this.scheduler.scheduleChunkTask(this.chunkX, this.chunkZ, () -> {
+            for (final Consumer<ChunkAccess> consumer : consumers) {
+                try {
+                    consumer.accept(chunk);
+                } catch (final ThreadDeath thr) {
+                    throw thr;
+                } catch (final Throwable thr) {
+                    LOGGER.error("Failed to process chunk status callback", thr);
+                }
+            }
+        }, PrioritisedExecutor.Priority.HIGHEST);
+    }
+
+    private final Reference2ObjectOpenHashMap<ChunkHolder.FullChunkStatus, List<Consumer<ChunkAccess>>> fullStatusWaiters = new Reference2ObjectOpenHashMap<>();
+
+    void addFullStatusConsumer(final ChunkHolder.FullChunkStatus status, final Consumer<ChunkAccess> consumer) {
+        this.fullStatusWaiters.computeIfAbsent(status, (final ChunkHolder.FullChunkStatus keyInMap) -> {
+            return new ArrayList<>(4);
+        }).add(consumer);
+    }
+
+    private void completeFullStatusConsumers(ChunkHolder.FullChunkStatus status, final ChunkAccess chunk) {
+        // need to tell future statuses to complete if cancelled
+        final ChunkHolder.FullChunkStatus max = CHUNK_STATUS_BY_ID[CHUNK_STATUS_BY_ID.length - 1];
+
+        for (;;) {
+            this.completeFullStatusConsumers0(status, chunk);
+            if (chunk != null || status == max) {
+                break;
+            }
+            status = CHUNK_STATUS_BY_ID[status.ordinal() + 1];
+        }
+    }
+
+    private void completeFullStatusConsumers0(final ChunkHolder.FullChunkStatus status, final ChunkAccess chunk) {
+        final List<Consumer<ChunkAccess>> consumers;
+        consumers = this.fullStatusWaiters.remove(status);
+
+        if (consumers == null) {
+            return;
+        }
+
+        // must be scheduled to main, we do not trust the callback to not do anything stupid
+        this.scheduler.scheduleChunkTask(this.chunkX, this.chunkZ, () -> {
+            for (final Consumer<ChunkAccess> consumer : consumers) {
+                try {
+                    consumer.accept(chunk);
+                } catch (final ThreadDeath thr) {
+                    throw thr;
+                } catch (final Throwable thr) {
+                    LOGGER.error("Failed to process chunk status callback", thr);
+                }
+            }
+        }, PrioritisedExecutor.Priority.HIGHEST);
+    }
+
+    // note: must hold scheduling lock
+    private void onChunkGenComplete(final ChunkAccess newChunk, final ChunkStatus newStatus,
+                                    final List<ChunkProgressionTask> scheduleList, final List<NewChunkHolder> changedLoadStatus) {
+        if (!this.neighboursBlockingGenTask.isEmpty()) {
+            throw new IllegalStateException("Cannot have neighbours blocking this gen task");
+        }
+        if (newChunk != null || (this.requestedGenStatus == null || !this.requestedGenStatus.isOrAfter(newStatus))) {
+            this.completeStatusConsumers(newStatus, newChunk);
+        }
+        // done now, clear state (must be done before scheduling new tasks)
+        this.generationTask = null;
+        this.generationTaskStatus = null;
+        if (newChunk == null) {
+            // task was cancelled
+            // should be careful as this could be called while holding the schedule lock and/or inside the
+            // ticket level update
+            // while a task may be cancelled, it is possible for it to be later re-scheduled
+            // however, because generationTask is only set to null on _completion_, the scheduler leaves
+            // the rescheduling logic to us here
+            final ChunkStatus requestedGenStatus = this.requestedGenStatus;
+            this.requestedGenStatus = null;
+            if (requestedGenStatus != null) {
+                // it looks like it has been requested, so we must reschedule
+                if (!this.neighboursWaitingForUs.isEmpty()) {
+                    for (final Iterator<Reference2ObjectMap.Entry<NewChunkHolder, ChunkStatus>> iterator = this.neighboursWaitingForUs.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
+                        final Reference2ObjectMap.Entry<NewChunkHolder, ChunkStatus> entry = iterator.next();
+
+                        final NewChunkHolder chunkHolder = entry.getKey();
+                        final ChunkStatus toStatus = entry.getValue();
+
+                        if (!requestedGenStatus.isOrAfter(toStatus)) {
+                            // if we were cancelled, we are responsible for removing the waiter
+                            if (!chunkHolder.neighboursBlockingGenTask.remove(this)) {
+                                throw new IllegalStateException("Corrupt state");
+                            }
+                            if (chunkHolder.neighboursBlockingGenTask.isEmpty()) {
+                                chunkHolder.checkUnload();
+                            }
+                            iterator.remove();
+                            continue;
+                        }
+                    }
+                }
+
+                // note: only after generationTask -> null, generationTaskStatus -> null, and requestedGenStatus -> null
+                this.scheduler.schedule(
+                    this.chunkX, this.chunkZ, requestedGenStatus, this, scheduleList
+                );
+
+                // return, can't do anything further
+                return;
+            }
+
+            if (!this.neighboursWaitingForUs.isEmpty()) {
+                for (final NewChunkHolder chunkHolder : this.neighboursWaitingForUs.keySet()) {
+                    if (!chunkHolder.neighboursBlockingGenTask.remove(this)) {
+                        throw new IllegalStateException("Corrupt state");
+                    }
+                    if (chunkHolder.neighboursBlockingGenTask.isEmpty()) {
+                        chunkHolder.checkUnload();
+                    }
+                }
+                this.neighboursWaitingForUs.clear();
+            }
+            // reset priority, we have nothing left to generate to
+            this.setPriority(PrioritisedExecutor.Priority.NORMAL);
+            this.checkUnload();
+            return;
+        }
+
+        this.currentChunk = newChunk;
+        this.currentGenStatus = newStatus;
+        this.lastChunkCompletion = new ChunkCompletion(newChunk, newStatus);
+
+        final ChunkStatus requestedGenStatus = this.requestedGenStatus;
+
+        List<NewChunkHolder> needsScheduling = null;
+        boolean recalculatePriority = false;
+        for (final Iterator<Reference2ObjectMap.Entry<NewChunkHolder, ChunkStatus>> iterator
+             = this.neighboursWaitingForUs.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
+            final Reference2ObjectMap.Entry<NewChunkHolder, ChunkStatus> entry = iterator.next();
+            final NewChunkHolder neighbour = entry.getKey();
+            final ChunkStatus requiredStatus = entry.getValue();
+
+            if (!newStatus.isOrAfter(requiredStatus)) {
+                if (requestedGenStatus == null || !requestedGenStatus.isOrAfter(requiredStatus)) {
+                    // if we're cancelled, still need to clear this map
+                    if (!neighbour.neighboursBlockingGenTask.remove(this)) {
+                        throw new IllegalStateException("Neighbour is not waiting for us?");
+                    }
+                    if (neighbour.neighboursBlockingGenTask.isEmpty()) {
+                        neighbour.checkUnload();
+                    }
+
+                    iterator.remove();
+                }
+                continue;
+            }
+
+            // doesn't matter what isCancelled is here, we need to schedule if we can
+
+            recalculatePriority = true;
+            if (!neighbour.neighboursBlockingGenTask.remove(this)) {
+                throw new IllegalStateException("Neighbour is not waiting for us?");
+            }
+
+            if (neighbour.neighboursBlockingGenTask.isEmpty()) {
+                if (neighbour.requestedGenStatus != null) {
+                    if (needsScheduling == null) {
+                        needsScheduling = new ArrayList<>();
+                    }
+                    needsScheduling.add(neighbour);
+                } else {
+                    neighbour.checkUnload();
+                }
+            }
+
+            // remove last; access to entry will throw if removed
+            iterator.remove();
+        }
+
+        if (newStatus == ChunkStatus.FULL) {
+            this.lockPriority();
+            // must use oldTicketLevel, we hold the schedule lock but not the ticket level lock
+            // however, schedule lock needs to be held for ticket level callback, so we're fine here
+            if (ChunkHolder.getFullChunkStatus(this.oldTicketLevel).isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
+                this.onFullChunkLoadChange(true, changedLoadStatus);
+            }
+        }
+
+        if (recalculatePriority) {
+            this.recalculateNeighbourRequestedPriority();
+        }
+
+        if (requestedGenStatus != null && !newStatus.isOrAfter(requestedGenStatus)) {
+            this.scheduleNeighbours(needsScheduling, scheduleList);
+
+            // we need to schedule more tasks now
+            this.scheduler.schedule(
+                this.chunkX, this.chunkZ, requestedGenStatus, this, scheduleList
+            );
+        } else {
+            // we're done now
+            if (requestedGenStatus != null) {
+                this.requestedGenStatus = null;
+            }
+            // reached final stage, so stop scheduling now
+            this.setPriority(PrioritisedExecutor.Priority.NORMAL);
+            this.checkUnload();
+
+            this.scheduleNeighbours(needsScheduling, scheduleList);
+        }
+    }
+
+    private void scheduleNeighbours(final List<NewChunkHolder> needsScheduling, final List<ChunkProgressionTask> scheduleList) {
+        if (needsScheduling != null) {
+            for (int i = 0, len = needsScheduling.size(); i < len; ++i) {
+                final NewChunkHolder neighbour = needsScheduling.get(i);
+
+                this.scheduler.schedule(
+                    neighbour.chunkX, neighbour.chunkZ, neighbour.requestedGenStatus, neighbour, scheduleList
+                );
+            }
+        }
+    }
+
+    public void setGenerationTask(final ChunkProgressionTask generationTask, final ChunkStatus taskStatus,
+                                  final List<NewChunkHolder> neighbours) {
+        if (this.generationTask != null || (this.currentGenStatus != null && this.currentGenStatus.isOrAfter(taskStatus))) {
+            throw new IllegalStateException("Currently generating or provided task is trying to generate to a level we are already at!");
+        }
+        if (this.requestedGenStatus == null || !this.requestedGenStatus.isOrAfter(taskStatus)) {
+            throw new IllegalStateException("Cannot schedule generation task when not requested");
+        }
+        this.generationTask = generationTask;
+        this.generationTaskStatus = taskStatus;
+
+        for (int i = 0, len = neighbours.size(); i < len; ++i) {
+            neighbours.get(i).addNeighbourUsingChunk();
+        }
+
+        this.checkUnload();
+
+        generationTask.onComplete((final ChunkAccess access, final Throwable thr) -> {
+            if (generationTask != this.generationTask) {
+                throw new IllegalStateException(
+                    "Cannot complete generation task '" + generationTask + "' because we are waiting on '" + this.generationTask + "' instead!"
+                );
+            }
+            if (thr != null) {
+                if (this.genTaskException != null) {
+                    // first one is probably the TRUE problem
+                    return;
+                }
+                // don't set generation task to null, so that scheduling will not attempt to create another task and it
+                // will automatically block any further scheduling usage of this chunk as it will wait forever for a failed
+                // task to complete
+                this.genTaskException = thr;
+                this.failedGenStatus = taskStatus;
+                this.genTaskFailedThread = Thread.currentThread();
+
+                this.scheduler.unrecoverableChunkSystemFailure(this.chunkX, this.chunkZ, Map.of(
+                    "Generation task", ChunkTaskScheduler.stringIfNull(generationTask),
+                    "Task to status", ChunkTaskScheduler.stringIfNull(taskStatus)
+                ), thr);
+                return;
+            }
+
+            final List<ChunkProgressionTask> tasks = new ArrayList<>();
+            final List<NewChunkHolder> changedLoadStatus = new ArrayList<>();
+            this.scheduler.schedulingLock.lock();
+            try {
+                for (int i = 0, len = neighbours.size(); i < len; ++i) {
+                    neighbours.get(i).removeNeighbourUsingChunk();
+                }
+                this.onChunkGenComplete(access, taskStatus, tasks, changedLoadStatus);
+            } finally {
+                this.scheduler.schedulingLock.unlock();
+            }
+            this.scheduler.chunkHolderManager.addChangedStatuses(changedLoadStatus);
+
+            // can't hold the lock while scheduling, so we have to build the tasks and then schedule after
+            for (int i = 0, len = tasks.size(); i < len; ++i) {
+                tasks.get(i).schedule();
+            }
+        });
+    }
+
+    public PoiChunk getPoiChunk() {
+        return this.poiChunk;
+    }
+
+    public ChunkEntitySlices getEntityChunk() {
+        return this.entityChunk;
+    }
+
+    public long lastAutoSave;
+
+    public boolean save(final boolean shutdown, final boolean unloading) {
+        TickThread.ensureTickThread(this.chunkX, this.chunkZ, "Cannot save data off-main");
+
+        ChunkAccess chunk = this.getCurrentChunk();
+        PoiChunk poi = this.getPoiChunk();
+        ChunkEntitySlices entities = this.getEntityChunk();
+        boolean executedUnloadTask = false;
+
+        if (shutdown) {
+            // make sure that the async unloads complete
+            if (this.unloadState != null) {
+                // must have errored during unload
+                chunk = this.unloadState.chunk();
+                poi = this.unloadState.poiChunk();
+                entities = this.unloadState.entityChunk();
+            }
+            final DelayedPrioritisedTask chunkDataUnloadTask = this.chunkDataUnloadTask;
+            if (chunkDataUnloadTask != null) {
+                final PrioritisedExecutor.PrioritisedTask unloadTask = chunkDataUnloadTask.getTask();
+                if (unloadTask != null) {
+                    executedUnloadTask = unloadTask.execute();
+                }
+            }
+        }
+
+        if (chunk instanceof LevelChunk levelChunk && levelChunk.mustNotSave) {
+            return false;
+        }
+        boolean canSaveChunk = chunk != null && (shutdown || (chunk instanceof LevelChunk && chunk.isUnsaved()));
+        boolean canSavePOI = poi != null && poi.isDirty();
+        boolean canSaveEntities = entities != null;
+
+        try (co.aikar.timings.Timing ignored = this.world.timings.chunkSave.startTiming()) { // Paper
+            if (canSaveChunk) {
+                canSaveChunk = this.saveChunk(chunk, unloading);
+            }
+            if (canSavePOI) {
+                canSavePOI = this.savePOI(poi, unloading);
+            }
+            if (canSaveEntities) {
+                // on shutdown, we need to force transient entity chunks to save
+                canSaveEntities = this.saveEntities(entities, unloading || shutdown);
+                if (unloading || shutdown) {
+                    this.lastEntityUnload = null;
+                }
+            }
+        }
+
+        return executedUnloadTask | canSaveChunk | canSaveEntities | canSavePOI;
+    }
+
+    static final class AsyncChunkSerializeTask implements Runnable {
+
+        private final ServerLevel world;
+        private final ChunkAccess chunk;
+        private final ChunkSerializer.AsyncSaveData asyncSaveData;
+        private final NewChunkHolder toComplete;
+
+        public AsyncChunkSerializeTask(final ServerLevel world, final ChunkAccess chunk, final ChunkSerializer.AsyncSaveData asyncSaveData,
+                                       final NewChunkHolder toComplete) {
+            this.world = world;
+            this.chunk = chunk;
+            this.asyncSaveData = asyncSaveData;
+            this.toComplete = toComplete;
+        }
+
+        @Override
+        public void run() {
+            final CompoundTag toSerialize;
+            try {
+                toSerialize = ChunkSerializer.saveChunk(this.world, this.chunk, this.asyncSaveData);
+            } catch (final ThreadDeath death) {
+                throw death;
+            } catch (final Throwable throwable) {
+                LOGGER.error("Failed to asynchronously save chunk " + this.chunk.getPos() + " for world '" + this.world.getWorld().getName() + "', falling back to synchronous save", throwable);
+                this.world.chunkTaskScheduler.scheduleChunkTask(this.chunk.locX, this.chunk.locZ, () -> {
+                    final CompoundTag synchronousSave;
+                    try {
+                        synchronousSave = ChunkSerializer.saveChunk(AsyncChunkSerializeTask.this.world, AsyncChunkSerializeTask.this.chunk, AsyncChunkSerializeTask.this.asyncSaveData);
+                    } catch (final ThreadDeath death) {
+                        throw death;
+                    } catch (final Throwable throwable2) {
+                        LOGGER.error("Failed to synchronously save chunk " + AsyncChunkSerializeTask.this.chunk.getPos() + " for world '" + AsyncChunkSerializeTask.this.world.getWorld().getName() + "', chunk data will be lost", throwable2);
+                        AsyncChunkSerializeTask.this.toComplete.completeAsyncChunkDataSave(null);
+                        return;
+                    }
+
+                    AsyncChunkSerializeTask.this.toComplete.completeAsyncChunkDataSave(synchronousSave);
+                    LOGGER.info("Successfully serialized chunk " + AsyncChunkSerializeTask.this.chunk.getPos() + " for world '" + AsyncChunkSerializeTask.this.world.getWorld().getName() + "' synchronously");
+
+                }, PrioritisedExecutor.Priority.HIGHEST);
+                return;
+            }
+            this.toComplete.completeAsyncChunkDataSave(toSerialize);
+        }
+
+        @Override
+        public String toString() {
+            return "AsyncChunkSerializeTask{" +
+                "chunk={pos=" + this.chunk.getPos() + ",world=\"" + this.world.getWorld().getName() + "\"}" +
+                "}";
+        }
+    }
+
+    private boolean saveChunk(final ChunkAccess chunk, final boolean unloading) {
+        if (chunk instanceof ImposterProtoChunk) {
+            if (unloading) {
+                this.completeAsyncChunkDataSave(null);
+            }
+            return false;
+        }
+        boolean completing = false;
+        try {
+            if (unloading) {
+                try {
+                    final ChunkSerializer.AsyncSaveData asyncSaveData = ChunkSerializer.getAsyncSaveData(this.world, chunk);
+
+                    final PrioritisedExecutor.PrioritisedTask task = this.scheduler.loadExecutor.createTask(new AsyncChunkSerializeTask(this.world, chunk, asyncSaveData, this));
+
+                    this.chunkDataUnloadTask.setTask(task);
+
+                    task.queue();
+
+                    return true;
+                } catch (final ThreadDeath death) {
+                    throw death;
+                } catch (final Throwable thr) {
+                    LOGGER.error("Failed to prepare async chunk data (" + this.chunkX + "," + this.chunkZ + ") in world '" + this.world.getWorld().getName() + "', falling back to synchronous save", thr);
+                    // fall through to synchronous save
+                }
+            }
+
+            final CompoundTag save = ChunkSerializer.saveChunk(this.world, chunk, null);
+
+            if (unloading) {
+                completing = true;
+                this.completeAsyncChunkDataSave(save);
+                LOGGER.info("Successfully serialized chunk data (" + this.chunkX + "," + this.chunkZ + ") in world '" + this.world.getWorld().getName() + "' synchronously");
+            } else {
+                RegionFileIOThread.scheduleSave(this.world, this.chunkX, this.chunkZ, save, RegionFileIOThread.RegionFileType.CHUNK_DATA);
+            }
+        } catch (final ThreadDeath death) {
+            throw death;
+        } catch (final Throwable thr) {
+            LOGGER.error("Failed to save chunk data (" + this.chunkX + "," + this.chunkZ + ") in world '" + this.world.getWorld().getName() + "'");
+            if (unloading && !completing) {
+                this.completeAsyncChunkDataSave(null);
+            }
+        }
+
+        return true;
+    }
+
+    private boolean lastEntitySaveNull;
+    private CompoundTag lastEntityUnload;
+    private boolean saveEntities(final ChunkEntitySlices entities, final boolean unloading) {
+        try {
+            CompoundTag mergeFrom = null;
+            if (entities.isTransient()) {
+                if (!unloading) {
+                    // if we're a transient chunk, we cannot save until unloading because otherwise a double save will
+                    // result in double adding the entities
+                    return false;
+                }
+                try {
+                    mergeFrom = RegionFileIOThread.loadData(this.world, this.chunkX, this.chunkZ, RegionFileIOThread.RegionFileType.ENTITY_DATA, PrioritisedExecutor.Priority.BLOCKING);
+                } catch (final Exception ex) {
+                    LOGGER.error("Cannot merge transient entities for chunk (" + this.chunkX + "," + this.chunkZ + ") in world '" + this.world.getWorld().getName() + "', data on disk will be replaced", ex);
+                }
+            }
+
+            final CompoundTag save = entities.save();
+            if (mergeFrom != null) {
+                if (save == null) {
+                    // don't override the data on disk with nothing
+                    return false;
+                } else {
+                    EntityStorage.copyEntities(mergeFrom, save);
+                }
+            }
+            if (save == null && this.lastEntitySaveNull) {
+                return false;
+            }
+
+            RegionFileIOThread.scheduleSave(this.world, this.chunkX, this.chunkZ, save, RegionFileIOThread.RegionFileType.ENTITY_DATA);
+            this.lastEntitySaveNull = save == null;
+            if (unloading) {
+                this.lastEntityUnload = save;
+            }
+        } catch (final ThreadDeath death) {
+            throw death;
+        } catch (final Throwable thr) {
+            LOGGER.error("Failed to save entity data (" + this.chunkX + "," + this.chunkZ + ") in world '" + this.world.getWorld().getName() + "'");
+        }
+
+        return true;
+    }
+
+    private boolean lastPoiSaveNull;
+    private boolean savePOI(final PoiChunk poi, final boolean unloading) {
+        try {
+            final CompoundTag save = poi.save();
+            poi.setDirty(false);
+            if (save == null && this.lastPoiSaveNull) {
+                if (unloading) {
+                    this.poiDataUnload.complete(null);
+                }
+                return false;
+            }
+
+            RegionFileIOThread.scheduleSave(this.world, this.chunkX, this.chunkZ, save, RegionFileIOThread.RegionFileType.POI_DATA);
+            this.lastPoiSaveNull = save == null;
+            if (unloading) {
+                this.poiDataUnload.complete(save);
+            }
+        } catch (final ThreadDeath death) {
+            throw death;
+        } catch (final Throwable thr) {
+            LOGGER.error("Failed to save poi data (" + this.chunkX + "," + this.chunkZ + ") in world '" + this.world.getWorld().getName() + "'");
+        }
+
+        return true;
+    }
+
+    @Override
+    public String toString() {
+        final ChunkCompletion lastCompletion = this.lastChunkCompletion;
+        final ChunkEntitySlices entityChunk = this.entityChunk;
+        return "NewChunkHolder{" +
+            "world=" + this.world.getWorld().getName() +
+            ", chunkX=" + this.chunkX +
+            ", chunkZ=" + this.chunkZ +
+            ", entityChunkFromDisk=" + (entityChunk != null && !entityChunk.isTransient()) +
+            ", lastChunkCompletion={chunk_class=" + (lastCompletion == null || lastCompletion.chunk() == null ? "null" : lastCompletion.chunk().getClass().getName()) + ",status=" + (lastCompletion == null ? "null" : lastCompletion.genStatus()) + "}" +
+            ", currentGenStatus=" + this.currentGenStatus +
+            ", requestedGenStatus=" + this.requestedGenStatus +
+            ", generationTask=" + this.generationTask +
+            ", generationTaskStatus=" + this.generationTaskStatus +
+            ", priority=" + this.priority +
+            ", priorityLocked=" + this.priorityLocked +
+            ", neighbourRequestedPriority=" + this.neighbourRequestedPriority +
+            ", effective_priority=" + this.getEffectivePriority() +
+            ", oldTicketLevel=" + this.oldTicketLevel +
+            ", currentTicketLevel=" + this.currentTicketLevel +
+            ", totalNeighboursUsingThisChunk=" + this.totalNeighboursUsingThisChunk +
+            ", fullNeighbourChunksLoadedBitset=" + this.fullNeighbourChunksLoadedBitset +
+            ", chunkStatus=" + this.chunkStatus +
+            ", is_unload_safe=" + this.isSafeToUnload() +
+            '}';
+    }
+
+    private static JsonElement serializeCompletable(final Completable<?> completable) {
+        if (completable == null) {
+            return new JsonPrimitive("null");
+        }
+
+        final JsonObject ret = new JsonObject();
+        final boolean isCompleted = completable.isCompleted();
+        ret.addProperty("completed", Boolean.valueOf(isCompleted));
+
+        if (isCompleted) {
+            ret.addProperty("completed_exceptionally", Boolean.valueOf(completable.getThrowable() != null));
+        }
+
+        return ret;
+    }
+
+    // holds ticket and scheduling lock
+    public JsonObject getDebugJson() {
+        final JsonObject ret = new JsonObject();
+
+        final ChunkCompletion lastCompletion = this.lastChunkCompletion;
+        final ChunkEntitySlices slices = this.entityChunk;
+        final PoiChunk poiChunk = this.poiChunk;
+
+        ret.addProperty("chunkX", Integer.valueOf(this.chunkX));
+        ret.addProperty("chunkZ", Integer.valueOf(this.chunkZ));
+        ret.addProperty("entity_chunk", slices == null ? "null" : "transient=" + slices.isTransient());
+        ret.addProperty("poi_chunk", "null=" + (poiChunk == null));
+        ret.addProperty("completed_chunk_class", lastCompletion == null ? "null" : lastCompletion.chunk().getClass().getName());
+        ret.addProperty("completed_gen_status", lastCompletion == null ? "null" : lastCompletion.genStatus().toString());
+        ret.addProperty("priority", Objects.toString(this.priority));
+        ret.addProperty("neighbour_requested_priority", Objects.toString(this.neighbourRequestedPriority));
+        ret.addProperty("generation_task", Objects.toString(this.generationTask));
+        ret.addProperty("is_safe_unload", Objects.toString(this.isSafeToUnload()));
+        ret.addProperty("old_ticket_level", Integer.valueOf(this.oldTicketLevel));
+        ret.addProperty("current_ticket_level", Integer.valueOf(this.currentTicketLevel));
+        ret.addProperty("neighbours_using_chunk", Integer.valueOf(this.totalNeighboursUsingThisChunk));
+
+        final JsonObject neighbourWaitState = new JsonObject();
+        ret.add("neighbour_state", neighbourWaitState);
+
+        final JsonArray blockingGenNeighbours = new JsonArray();
+        neighbourWaitState.add("blocking_gen_task", blockingGenNeighbours);
+        for (final NewChunkHolder blockingGenNeighbour : this.neighboursBlockingGenTask) {
+            final JsonObject neighbour = new JsonObject();
+            blockingGenNeighbours.add(neighbour);
+
+            neighbour.addProperty("chunkX", Integer.valueOf(blockingGenNeighbour.chunkX));
+            neighbour.addProperty("chunkZ", Integer.valueOf(blockingGenNeighbour.chunkZ));
+        }
+
+        final JsonArray neighboursWaitingForUs = new JsonArray();
+        neighbourWaitState.add("neighbours_waiting_on_us", neighboursWaitingForUs);
+        for (final Reference2ObjectMap.Entry<NewChunkHolder, ChunkStatus> entry : this.neighboursWaitingForUs.reference2ObjectEntrySet()) {
+            final NewChunkHolder holder = entry.getKey();
+            final ChunkStatus status = entry.getValue();
+
+            final JsonObject neighbour = new JsonObject();
+            neighboursWaitingForUs.add(neighbour);
+
+
+            neighbour.addProperty("chunkX", Integer.valueOf(holder.chunkX));
+            neighbour.addProperty("chunkZ", Integer.valueOf(holder.chunkZ));
+            neighbour.addProperty("waiting_for", Objects.toString(status));
+        }
+
+        ret.addProperty("fullchunkstatus", Objects.toString(this.getChunkStatus()));
+        ret.addProperty("fullchunkstatus_raw", Long.valueOf(this.chunkStatus));
+        ret.addProperty("generation_task", Objects.toString(this.generationTask));
+        ret.addProperty("requested_generation", Objects.toString(this.requestedGenStatus));
+        ret.addProperty("has_entity_load_task", Boolean.valueOf(this.entityDataLoadTask != null));
+        ret.addProperty("has_poi_load_task", Boolean.valueOf(this.poiDataLoadTask != null));
+        ret.add("entity_unload_completable", serializeCompletable(this.entityDataUnload));
+        ret.add("poi_unload_completable", serializeCompletable(this.poiDataUnload));
+        ret.add("chunk_unload_completable", serializeCompletable(this.chunkDataUnload));
+
+        final DelayedPrioritisedTask unloadTask = this.chunkDataUnloadTask;
+        if (unloadTask == null) {
+            ret.addProperty("unload_task_priority", "null");
+            ret.addProperty("unload_task_priority_raw", "null");
+        } else {
+            ret.addProperty("unload_task_priority", Objects.toString(unloadTask.getPriority()));
+            ret.addProperty("unload_task_priority_raw", Integer.valueOf(unloadTask.getPriorityInternal()));
+        }
+
+        return ret;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/PriorityHolder.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/PriorityHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..b4c56bf12dc8dd17452210ece4fd67411cc6b2fd
--- /dev/null
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/PriorityHolder.java
@@ -0,0 +1,215 @@
+package io.papermc.paper.chunk.system.scheduling;
+
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import java.lang.invoke.VarHandle;
+
+public abstract class PriorityHolder {
+
+    protected volatile int priority;
+    protected static final VarHandle PRIORITY_HANDLE = ConcurrentUtil.getVarHandle(PriorityHolder.class, "priority", int.class);
+
+    protected static final int PRIORITY_SCHEDULED = Integer.MIN_VALUE >>> 0;
+    protected static final int PRIORITY_EXECUTED  = Integer.MIN_VALUE >>> 1;
+
+    protected final int getPriorityVolatile() {
+        return (int)PRIORITY_HANDLE.getVolatile((PriorityHolder)this);
+    }
+
+    protected final int compareAndExchangePriorityVolatile(final int expect, final int update) {
+        return (int)PRIORITY_HANDLE.compareAndExchange((PriorityHolder)this, (int)expect, (int)update);
+    }
+
+    protected final int getAndOrPriorityVolatile(final int val) {
+        return (int)PRIORITY_HANDLE.getAndBitwiseOr((PriorityHolder)this, (int)val);
+    }
+
+    protected final void setPriorityPlain(final int val) {
+        PRIORITY_HANDLE.set((PriorityHolder)this, (int)val);
+    }
+
+    protected PriorityHolder(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+        this.setPriorityPlain(priority.priority);
+    }
+
+    // used only for debug json
+    public boolean isScheduled() {
+        return (this.getPriorityVolatile() & PRIORITY_SCHEDULED) != 0;
+    }
+
+    // returns false if cancelled
+    protected boolean markExecuting() {
+        return (this.getAndOrPriorityVolatile(PRIORITY_EXECUTED) & PRIORITY_EXECUTED) == 0;
+    }
+
+    protected boolean isMarkedExecuted() {
+        return (this.getPriorityVolatile() & PRIORITY_EXECUTED) != 0;
+    }
+
+    public void cancel() {
+        if ((this.getAndOrPriorityVolatile(PRIORITY_EXECUTED) & PRIORITY_EXECUTED) != 0) {
+            // cancelled already
+            return;
+        }
+        this.cancelScheduled();
+    }
+
+    public void schedule() {
+        int priority = this.getPriorityVolatile();
+
+        if ((priority & PRIORITY_SCHEDULED) != 0) {
+            throw new IllegalStateException("schedule() called twice");
+        }
+
+        if ((priority & PRIORITY_EXECUTED) != 0) {
+            // cancelled
+            return;
+        }
+
+        this.scheduleTask(PrioritisedExecutor.Priority.getPriority(priority));
+
+        int failures = 0;
+        for (;;) {
+            if (priority == (priority = this.compareAndExchangePriorityVolatile(priority, priority | PRIORITY_SCHEDULED))) {
+                return;
+            }
+
+            if ((priority & PRIORITY_SCHEDULED) != 0) {
+                throw new IllegalStateException("schedule() called twice");
+            }
+
+            if ((priority & PRIORITY_EXECUTED) != 0) {
+                // cancelled or executed
+                return;
+            }
+
+            this.setPriorityScheduled(PrioritisedExecutor.Priority.getPriority(priority));
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    public final PrioritisedExecutor.Priority getPriority() {
+        final int ret = this.getPriorityVolatile();
+        if ((ret & PRIORITY_EXECUTED) != 0) {
+            return PrioritisedExecutor.Priority.COMPLETING;
+        }
+        if ((ret & PRIORITY_SCHEDULED) != 0) {
+            return this.getScheduledPriority();
+        }
+        return PrioritisedExecutor.Priority.getPriority(ret);
+    }
+
+    public final void lowerPriority(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+
+        int failures = 0;
+        for (int curr = this.getPriorityVolatile();;) {
+            if ((curr & PRIORITY_EXECUTED) != 0) {
+                return;
+            }
+
+            if ((curr & PRIORITY_SCHEDULED) != 0) {
+                this.lowerPriorityScheduled(priority);
+                return;
+            }
+
+            if (!priority.isLowerPriority(curr)) {
+                return;
+            }
+
+            if (curr == (curr = this.compareAndExchangePriorityVolatile(curr, priority.priority))) {
+                return;
+            }
+
+            // failed, retry
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    public final void setPriority(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+
+        int failures = 0;
+        for (int curr = this.getPriorityVolatile();;) {
+            if ((curr & PRIORITY_EXECUTED) != 0) {
+                return;
+            }
+
+            if ((curr & PRIORITY_SCHEDULED) != 0) {
+                this.setPriorityScheduled(priority);
+                return;
+            }
+
+            if (curr == (curr = this.compareAndExchangePriorityVolatile(curr, priority.priority))) {
+                return;
+            }
+
+            // failed, retry
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    public final void raisePriority(final PrioritisedExecutor.Priority priority) {
+        if (!PrioritisedExecutor.Priority.isValidPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority " + priority);
+        }
+
+        int failures = 0;
+        for (int curr = this.getPriorityVolatile();;) {
+            if ((curr & PRIORITY_EXECUTED) != 0) {
+                return;
+            }
+
+            if ((curr & PRIORITY_SCHEDULED) != 0) {
+                this.raisePriorityScheduled(priority);
+                return;
+            }
+
+            if (!priority.isHigherPriority(curr)) {
+                return;
+            }
+
+            if (curr == (curr = this.compareAndExchangePriorityVolatile(curr, priority.priority))) {
+                return;
+            }
+
+            // failed, retry
+
+            ++failures;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.backoff();
+            }
+        }
+    }
+
+    protected abstract void cancelScheduled();
+
+    protected abstract PrioritisedExecutor.Priority getScheduledPriority();
+
+    protected abstract void scheduleTask(final PrioritisedExecutor.Priority priority);
+
+    protected abstract void lowerPriorityScheduled(final PrioritisedExecutor.Priority priority);
+
+    protected abstract void setPriorityScheduled(final PrioritisedExecutor.Priority priority);
+
+    protected abstract void raisePriorityScheduled(final PrioritisedExecutor.Priority priority);
+}
diff --git a/src/main/java/io/papermc/paper/command/PaperCommand.java b/src/main/java/io/papermc/paper/command/PaperCommand.java
index 60b0ce4557390ee7030efe4c90933402c57bab59..0167864dd8fbc8145af31597040d187a0660228c 100644
--- a/src/main/java/io/papermc/paper/command/PaperCommand.java
+++ b/src/main/java/io/papermc/paper/command/PaperCommand.java
@@ -45,7 +45,7 @@ public final class PaperCommand extends Command {
         commands.put(Set.of("entity"), new EntityCommand());
         commands.put(Set.of("reload"), new ReloadCommand());
         commands.put(Set.of("version"), new VersionCommand());
-        commands.put(Set.of("debug", "chunkinfo"), new ChunkDebugCommand());
+        commands.put(Set.of("debug", "chunkinfo", "holderinfo"), new ChunkDebugCommand());
         commands.put(Set.of("fixlight"), new FixLightCommand());
         commands.put(Set.of("syncloadinfo"), new SyncLoadInfoCommand());
         commands.put(Set.of("dumpitem"), new DumpItemCommand());
diff --git a/src/main/java/io/papermc/paper/command/subcommands/ChunkDebugCommand.java b/src/main/java/io/papermc/paper/command/subcommands/ChunkDebugCommand.java
index 4b367982fae4662c326aa247824e9c4185896de1..f225573e5b866614e8007835574d00daafcb02bb 100644
--- a/src/main/java/io/papermc/paper/command/subcommands/ChunkDebugCommand.java
+++ b/src/main/java/io/papermc/paper/command/subcommands/ChunkDebugCommand.java
@@ -13,6 +13,10 @@ import net.minecraft.server.MCUtil;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ChunkHolder;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.ProtoChunk;
 import org.bukkit.Bukkit;
 import org.bukkit.command.CommandSender;
 import org.bukkit.craftbukkit.CraftWorld;
@@ -33,6 +37,7 @@ public final class ChunkDebugCommand implements PaperSubcommand {
         switch (subCommand) {
             case "debug" -> this.doDebug(sender, args);
             case "chunkinfo" -> this.doChunkInfo(sender, args);
+            case "holderinfo" -> this.doHolderInfo(sender, args);
         }
         return true;
     }
@@ -45,6 +50,16 @@ public final class ChunkDebugCommand implements PaperSubcommand {
                     return CommandUtil.getListMatchingLast(sender, args, "help", "chunks");
                 }
             }
+            case "holderinfo" -> {
+                List<String> worldNames = new ArrayList<>();
+                worldNames.add("*");
+                for (org.bukkit.World world : Bukkit.getWorlds()) {
+                    worldNames.add(world.getName());
+                }
+                if (args.length == 1) {
+                    return CommandUtil.getListMatchingLast(sender, args, worldNames);
+                }
+            }
             case "chunkinfo" -> {
                 List<String> worldNames = new ArrayList<>();
                 worldNames.add("*");
@@ -90,14 +105,14 @@ public final class ChunkDebugCommand implements PaperSubcommand {
             int ticking = 0;
             int entityTicking = 0;
 
-            for (final ChunkHolder chunk : world.getChunkSource().chunkMap.updatingChunks.getUpdatingMap().values()) { // Paper - change updating chunks map
+            for (final ChunkHolder chunk : world.chunkTaskScheduler.chunkHolderManager.getOldChunkHolders()) { // Paper - change updating chunks map
                 if (chunk.getFullChunkNowUnchecked() == null) {
                     continue;
                 }
 
                 ++total;
 
-                ChunkHolder.FullChunkStatus state = ChunkHolder.getFullChunkStatus(chunk.getTicketLevel());
+                ChunkHolder.FullChunkStatus state = chunk.getFullStatus(); // Paper - rewrite chunk system
 
                 switch (state) {
                     case INACCESSIBLE -> ++inactive;
@@ -134,6 +149,89 @@ public final class ChunkDebugCommand implements PaperSubcommand {
         }
     }
 
+    private void doHolderInfo(final CommandSender sender, final String[] args) {
+        List<org.bukkit.World> worlds;
+        if (args.length < 1 || args[0].equals("*")) {
+            worlds = Bukkit.getWorlds();
+        } else {
+            worlds = new ArrayList<>(args.length);
+            for (final String arg : args) {
+                org.bukkit.@Nullable World world = Bukkit.getWorld(arg);
+                if (world == null) {
+                    sender.sendMessage(text("World '" + arg + "' is invalid", RED));
+                    return;
+                }
+                worlds.add(world);
+            }
+        }
+
+        int accumulatedTotal = 0;
+        int accumulatedCanUnload = 0;
+        int accumulatedNull = 0;
+        int accumulatedReadOnly = 0;
+        int accumulatedProtoChunk = 0;
+        int accumulatedFullChunk = 0;
+
+        for (final org.bukkit.World bukkitWorld : worlds) {
+            final ServerLevel world = ((CraftWorld) bukkitWorld).getHandle();
+
+            int total = 0;
+            int canUnload = 0;
+            int nullChunks = 0;
+            int readOnly = 0;
+            int protoChunk = 0;
+            int fullChunk = 0;
+
+            for (final ChunkHolder chunk : world.chunkTaskScheduler.chunkHolderManager.getOldChunkHolders()) { // Paper - change updating chunks map
+                final ChunkAccess lastChunk = chunk.getAvailableChunkNow();
+
+                ++total;
+
+                if (lastChunk == null) {
+                    ++nullChunks;
+                } else if (lastChunk instanceof ImposterProtoChunk) {
+                    ++readOnly;
+                } else if (lastChunk instanceof ProtoChunk) {
+                    ++protoChunk;
+                } else if (lastChunk instanceof LevelChunk) {
+                    ++fullChunk;
+                }
+
+                if (chunk.newChunkHolder.isSafeToUnload() == null) {
+                    ++canUnload;
+                }
+            }
+
+            accumulatedTotal += total;
+            accumulatedCanUnload += canUnload;
+            accumulatedNull += nullChunks;
+            accumulatedReadOnly += readOnly;
+            accumulatedProtoChunk += protoChunk;
+            accumulatedFullChunk += fullChunk;
+
+            sender.sendMessage(text().append(text("Chunks in ", BLUE), text(bukkitWorld.getName(), GREEN), text(":")));
+            sender.sendMessage(text().color(DARK_AQUA).append(
+                text("Total: ", BLUE), text(total),
+                text(" Unloadable: ", BLUE), text(canUnload),
+                text(" Null: ", BLUE), text(nullChunks),
+                text(" ReadOnly: ", BLUE), text(readOnly),
+                text(" Proto: ", BLUE), text(protoChunk),
+                text(" Full: ", BLUE), text(fullChunk)
+            ));
+        }
+        if (worlds.size() > 1) {
+            sender.sendMessage(text().append(text("Chunks in ", BLUE), text("all listed worlds", GREEN), text(":", DARK_AQUA)));
+            sender.sendMessage(text().color(DARK_AQUA).append(
+                text("Total: ", BLUE), text(accumulatedTotal),
+                text(" Unloadable: ", BLUE), text(accumulatedCanUnload),
+                text(" Null: ", BLUE), text(accumulatedNull),
+                text(" ReadOnly: ", BLUE), text(accumulatedReadOnly),
+                text(" Proto: ", BLUE), text(accumulatedProtoChunk),
+                text(" Full: ", BLUE), text(accumulatedFullChunk)
+            ));
+        }
+    }
+
     private void doDebug(final CommandSender sender, final String[] args) {
         if (args.length < 1) {
             sender.sendMessage(text("Use /paper debug [chunks] help for more information on a specific command", RED));
@@ -151,7 +249,7 @@ public final class ChunkDebugCommand implements PaperSubcommand {
                     "chunks-" + DateTimeFormatter.ofPattern("yyyy-MM-dd_HH.mm.ss").format(LocalDateTime.now()) + ".txt");
                 sender.sendMessage(text("Writing chunk information dump to " + file, GREEN));
                 try {
-                    MCUtil.dumpChunks(file);
+                    MCUtil.dumpChunks(file, false);
                     sender.sendMessage(text("Successfully written chunk information!", GREEN));
                 } catch (Throwable thr) {
                     MinecraftServer.LOGGER.warn("Failed to dump chunk information to file " + file.toString(), thr);
diff --git a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
index 456595e4b7e0c7f50617aa2694b0d2dfc368ab81..34ecd95145c99e0dc794ada29da6a7a7fc847a3c 100644
--- a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
@@ -132,6 +132,20 @@ public class GlobalConfiguration extends ConfigurationPart {
         public double playerMaxChunkLoadRate = -1.0;
     }
 
+    public ChunkSystem chunkSystem;
+
+    public class ChunkSystem extends ConfigurationPart.Post {
+
+        public int ioThreads = -1;
+        public int workerThreads = -1;
+        public String genParallelism = "default";
+
+        @Override
+        public void postProcess() {
+            io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.init(this);
+        }
+    }
+
     public UnsupportedSettings unsupportedSettings;
 
     public class UnsupportedSettings extends ConfigurationPart {
diff --git a/src/main/java/io/papermc/paper/util/TickThread.java b/src/main/java/io/papermc/paper/util/TickThread.java
index c92f7e59f490f7b289325d9cc2bf7c2cf1750c7a..ebe684c816a9b6f8e46ccc891a668811e36c8438 100644
--- a/src/main/java/io/papermc/paper/util/TickThread.java
+++ b/src/main/java/io/papermc/paper/util/TickThread.java
@@ -1,9 +1,9 @@
 package io.papermc.paper.util;
 
 import net.minecraft.server.MinecraftServer;
-import org.bukkit.Bukkit;
+import java.util.concurrent.atomic.AtomicInteger;
 
-public final class TickThread extends Thread {
+public class TickThread extends Thread {
 
     public static final boolean STRICT_THREAD_CHECKS = Boolean.getBoolean("paper.strict-thread-checks");
 
@@ -13,6 +13,10 @@ public final class TickThread extends Thread {
         }
     }
 
+    /**
+     * @deprecated Use {@link #ensureTickThread(int, int, String)}
+     */
+    @Deprecated
     public static void softEnsureTickThread(final String reason) {
         if (!STRICT_THREAD_CHECKS) {
             return;
@@ -21,8 +25,19 @@ public final class TickThread extends Thread {
     }
 
 
+    /**
+     * @deprecated Use {@link #ensureTickThread(int, int, String)}
+     */
+    @Deprecated
     public static void ensureTickThread(final String reason) {
-        if (!Bukkit.isPrimaryThread()) {
+        if (!isTickThread()) {
+            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+            throw new IllegalStateException(reason);
+        }
+    }
+
+    public static void ensureTickThread(final int chunkX, final int chunkZ, final String reason) {
+        if (!isTickThreadFor(chunkX, chunkZ)) {
             MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
             throw new IllegalStateException(reason);
         }
@@ -30,7 +45,17 @@ public final class TickThread extends Thread {
 
     public final int id; /* We don't override getId as the spec requires that it be unique (with respect to all other threads) */
 
-    public TickThread(final Runnable run, final String name, final int id) {
+    private static final AtomicInteger ID_GENERATOR = new AtomicInteger();
+
+    public TickThread(final String name) {
+        this(null, name);
+    }
+
+    public TickThread(final Runnable run, final String name) {
+        this(run, name, ID_GENERATOR.incrementAndGet());
+    }
+
+    private TickThread(final Runnable run, final String name, final int id) {
         super(run, name);
         this.id = id;
     }
@@ -38,4 +63,12 @@ public final class TickThread extends Thread {
     public static TickThread getCurrentTickThread() {
         return (TickThread)Thread.currentThread();
     }
+
+    public static boolean isTickThread() {
+        return Thread.currentThread() instanceof TickThread;
+    }
+
+    public static boolean isTickThreadFor(final int chunkX, final int chunkZ) {
+        return Thread.currentThread() instanceof TickThread;
+    }
 }
diff --git a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
index 47b5f75d9f27cf3ab947fd1f69cbd609fb9f2749..8463b6084322122f611588746431234a9e4fc0f9 100644
--- a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
+++ b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
@@ -3,6 +3,7 @@ package io.papermc.paper.world;
 import com.destroystokyo.paper.util.maplist.EntityList;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectMap;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectOpenHashMap;
+import net.minecraft.nbt.CompoundTag;
 import net.minecraft.server.level.ChunkHolder;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.Mth;
@@ -10,7 +11,11 @@ import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.boss.EnderDragonPart;
 import net.minecraft.world.entity.boss.enderdragon.EnderDragon;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.storage.EntityStorage;
+import net.minecraft.world.level.entity.LevelCallback;
 import net.minecraft.world.phys.AABB;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
@@ -31,6 +36,16 @@ public final class ChunkEntitySlices {
 
     public ChunkHolder.FullChunkStatus status;
 
+    protected boolean isTransient;
+
+    public boolean isTransient() {
+        return this.isTransient;
+    }
+
+    public void setTransient(final boolean value) {
+        this.isTransient = value;
+    }
+
     // TODO implement container search optimisations
 
     public ChunkEntitySlices(final ServerLevel world, final int chunkX, final int chunkZ, final ChunkHolder.FullChunkStatus status,
@@ -65,28 +80,101 @@ public final class ChunkEntitySlices {
 
         return ret.toArray(new org.bukkit.entity.Entity[0]);
     }
+
+    public CompoundTag save() {
+        final int len = this.entities.size();
+        if (len == 0) {
+            return null;
+        }
+
+        final Entity[] rawData = this.entities.getRawData();
+        final List<Entity> collectedEntities = new ArrayList<>(len);
+        for (int i = 0; i < len; ++i) {
+            final Entity entity = rawData[i];
+            if (entity.shouldBeSaved()) {
+                collectedEntities.add(entity);
+            }
+        }
+
+        if (collectedEntities.isEmpty()) {
+            return null;
+        }
+
+        return EntityStorage.saveEntityChunk(collectedEntities, new ChunkPos(this.chunkX, this.chunkZ), this.world);
+    }
+
+    // returns true if this chunk has transient entities remaining
+    public boolean unload() {
+        final int len = this.entities.size();
+        final Entity[] collectedEntities = Arrays.copyOf(this.entities.getRawData(), len);
+
+        for (int i = 0; i < len; ++i) {
+            final Entity entity = collectedEntities[i];
+            if (entity.isRemoved()) {
+                // removed by us below
+                continue;
+            }
+            if (entity.shouldBeSaved()) {
+                entity.setRemoved(Entity.RemovalReason.UNLOADED_TO_CHUNK);
+                if (entity.isVehicle()) {
+                    // we cannot assume that these entities are contained within this chunk, because entities can
+                    // desync - so we need to remove them all
+                    for (final Entity passenger : entity.getIndirectPassengers()) {
+                        passenger.setRemoved(Entity.RemovalReason.UNLOADED_TO_CHUNK);
+                    }
+                }
+            }
+        }
+
+        return this.entities.size() != 0;
+    }
     // Paper end - optimise CraftChunk#getEntities
 
     public boolean isEmpty() {
         return this.entities.size() == 0;
     }
 
-    private void updateTicketLevels() {
+    public void mergeInto(final ChunkEntitySlices slices) {
         final Entity[] entities = this.entities.getRawData();
         for (int i = 0, size = Math.min(entities.length, this.entities.size()); i < size; ++i) {
             final Entity entity = entities[i];
-            entity.chunkStatus = this.status;
+            slices.addEntity(entity, entity.sectionY);
         }
     }
 
-    public synchronized void updateStatus(final ChunkHolder.FullChunkStatus status) {
+    public void updateStatus(final ChunkHolder.FullChunkStatus status, final LevelCallback<Entity> callback) {
+        final ChunkHolder.FullChunkStatus oldStatus = this.status;
         this.status = status;
-        this.updateTicketLevels();
+
+        final Entity[] entities = this.entities.getRawData();
+
+        // NOTE: this HOLDS the lock for this class, so we cannot do anything REMOTELY dangerous
+        // Note: tracking callback invoke is absent; this is controlled solely from entity unload/load
+
+        if (status.isOrAfter(oldStatus)) {
+            // status upgrade
+            if (!oldStatus.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING) && status.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING)) {
+                for (int i = 0, size = Math.min(entities.length, this.entities.size()); i < size; ++i) {
+                    final Entity entity = entities[i];
+                    callback.onTickingStart(entity);
+                    entity.chunkStatus = status;
+                }
+            }
+        } else {
+            // status downgrade
+            if (oldStatus.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING) && !status.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING)) {
+                for (int i = 0, size = Math.min(entities.length, this.entities.size()); i < size; ++i) {
+                    final Entity entity = entities[i];
+                    callback.onTickingEnd(entity);
+                    entity.chunkStatus = status;
+                }
+            }
+        }
     }
 
-    public synchronized void addEntity(final Entity entity, final int chunkSection) {
+    public boolean addEntity(final Entity entity, final int chunkSection) {
         if (!this.entities.add(entity)) {
-            return;
+            return false;
         }
         entity.chunkStatus = this.status;
         final int sectionIndex = chunkSection - this.minSection;
@@ -105,13 +193,15 @@ public final class ChunkEntitySlices {
                 entry.getValue().addEntity(entity, sectionIndex);
             }
         }
+
+        return true;
     }
 
-    public synchronized void removeEntity(final Entity entity, final int chunkSection) {
+    public boolean removeEntity(final Entity entity, final int chunkSection) {
         if (!this.entities.remove(entity)) {
-            return;
+            return false;
         }
-        entity.chunkStatus = ChunkHolder.FullChunkStatus.INACCESSIBLE;
+        entity.chunkStatus = null;
         final int sectionIndex = chunkSection - this.minSection;
 
         this.allEntities.removeEntity(entity, sectionIndex);
@@ -128,6 +218,8 @@ public final class ChunkEntitySlices {
                 entry.getValue().removeEntity(entity, sectionIndex);
             }
         }
+
+        return true;
     }
 
     public void getHardCollidingEntities(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
@@ -138,6 +230,10 @@ public final class ChunkEntitySlices {
         this.allEntities.getEntitiesWithEnderDragonParts(except, box, into, predicate);
     }
 
+    public void getEntitiesWithoutDragonParts(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
+        this.allEntities.getEntities(except, box, into, predicate);
+    }
+
     public <T extends Entity> void getEntities(final EntityType<?> type, final AABB box, final List<? super T> into,
                                                final Predicate<? super T> predicate) {
         this.allEntities.getEntities(type, box, (List)into, (Predicate)predicate);
@@ -172,21 +268,11 @@ public final class ChunkEntitySlices {
         if (collection != null) {
             collection.getEntitiesWithEnderDragonParts(except, clazz, box, (List)into, (Predicate)predicate);
         } else {
-            synchronized (this) {
-                this.entitiesByClass.putIfAbsent(clazz, collection = this.initClass(clazz));
-            }
+            this.entitiesByClass.putIfAbsent(clazz, collection = this.initClass(clazz));
             collection.getEntitiesWithEnderDragonParts(except, clazz, box, (List)into, (Predicate)predicate);
         }
     }
 
-    public synchronized void updateEntity(final Entity entity) {
-        /*// TODO
-        if (prev aabb != entity.getBoundingBox()) {
-            this.entityMap.delete(entity, prev aabb);
-            this.entityMap.insert(entity, prev aabb = entity.getBoundingBox());
-        }*/
-    }
-
     protected static final class BasicEntityList<E extends Entity> {
 
         protected static final Entity[] EMPTY = new Entity[0];
@@ -321,8 +407,6 @@ public final class ChunkEntitySlices {
             final int min = Mth.clamp(Mth.floor(box.minY - 2.0) >> 4, minSection, maxSection);
             final int max = Mth.clamp(Mth.floor(box.maxY + 2.0) >> 4, minSection, maxSection);
 
-            // TODO use the bitset
-
             final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
 
             for (int section = min; section <= max; ++section) {
@@ -362,8 +446,6 @@ public final class ChunkEntitySlices {
             final int min = Mth.clamp(Mth.floor(box.minY - 2.0) >> 4, minSection, maxSection);
             final int max = Mth.clamp(Mth.floor(box.maxY + 2.0) >> 4, minSection, maxSection);
 
-            // TODO use the bitset
-
             final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
 
             for (int section = min; section <= max; ++section) {
@@ -415,8 +497,6 @@ public final class ChunkEntitySlices {
             final int min = Mth.clamp(Mth.floor(box.minY - 2.0) >> 4, minSection, maxSection);
             final int max = Mth.clamp(Mth.floor(box.maxY + 2.0) >> 4, minSection, maxSection);
 
-            // TODO use the bitset
-
             final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
 
             for (int section = min; section <= max; ++section) {
@@ -468,8 +548,6 @@ public final class ChunkEntitySlices {
             final int min = Mth.clamp(Mth.floor(box.minY - 2.0) >> 4, minSection, maxSection);
             final int max = Mth.clamp(Mth.floor(box.maxY + 2.0) >> 4, minSection, maxSection);
 
-            // TODO use the bitset
-
             final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
 
             for (int section = min; section <= max; ++section) {
diff --git a/src/main/java/io/papermc/paper/world/EntitySliceManager.java b/src/main/java/io/papermc/paper/world/EntitySliceManager.java
index 3ba094e640d7fe7803e2bbdab8ff3beb6f50e8a0..6608e54922a1e35a8719742e3020110526de1053 100644
--- a/src/main/java/io/papermc/paper/world/EntitySliceManager.java
+++ b/src/main/java/io/papermc/paper/world/EntitySliceManager.java
@@ -46,7 +46,7 @@ public final class EntitySliceManager {
             this.statusMap.put(CoordinateUtils.getChunkKey(x, z), newStatus);
             final ChunkEntitySlices slices = this.getChunk(x, z);
             if (slices != null) {
-                slices.updateStatus(newStatus);
+                //slices.updateStatus(newStatus); // Paper - rewrite chunk system - not used, don't care! delete patch later!
             }
         }
     }
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index 7034af8ad42940c5af6b9032b9873ce36c55a2a7..7ef6273f9205f5d116b3ccf1d9e4d7e95939aa16 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -39,6 +39,7 @@ import org.spigotmc.AsyncCatcher;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import java.io.*;
+import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Queue;
@@ -331,7 +332,7 @@ public final class MCUtil {
      * @return
      */
     public static void ensureMain(String reason, Runnable run) {
-        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread) {
+        if (!io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
             if (reason != null) {
                 new IllegalStateException("Asynchronous " + reason + "!").printStackTrace();
             }
@@ -356,7 +357,7 @@ public final class MCUtil {
      * @return
      */
     public static <T> T ensureMain(String reason, Supplier<T> run) {
-        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread) {
+        if (!io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
             if (reason != null) {
                 new IllegalStateException("Asynchronous " + reason + "! Blocking thread until it returns ").printStackTrace();
             }
@@ -559,64 +560,17 @@ public final class MCUtil {
     }
 
     public static ChunkStatus getChunkStatus(ChunkHolder chunk) {
-        List<ChunkStatus> statuses = net.minecraft.server.level.ServerChunkCache.CHUNK_STATUSES;
-        for (int i = statuses.size() - 1; i >= 0; --i) {
-            ChunkStatus curr = statuses.get(i);
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = chunk.getFutureIfPresentUnchecked(curr);
-            if (future != ChunkHolder.UNLOADED_CHUNK_FUTURE) {
-                return curr;
-            }
-        }
-        return null; // unloaded
+        return chunk.newChunkHolder.getCurrentGenStatus(); // Paper - rewrite chunk system
     }
 
-    public static void dumpChunks(File file) throws IOException {
+    public static void dumpChunks(File file, boolean watchdog) throws IOException {
         file.getParentFile().mkdirs();
         file.createNewFile();
-        /*
-         * Json format:
-         *
-         * Main data format:
-         *  -server-version:<string>
-         *  -data-version:<int>
-         *  -worlds:
-         *    -name:<world name>
-         *    -view-distance:<int>
-         *    -keep-spawn-loaded:<boolean>
-         *    -keep-spawn-loaded-range:<int>
-         *    -visible-chunk-count:<int>
-         *    -loaded-chunk-count:<int>
-         *    -verified-fully-loaded-chunks:<int>
-         *    -players:<array of player>
-         *    -chunk-data:<array of chunks>
-         *
-         * Player format:
-         *  -name:<string>
-         *  -x:<double>
-         *  -y:<double>
-         *  -z:<double>
-         *
-         * Chunk Format:
-         *  -x:<integer>
-         *  -z:<integer>
-         *  -ticket-level:<integer>
-         *  -state:<string>
-         *  -queued-for-unload:<boolean>
-         *  -status:<string>
-         *  -tickets:<array of tickets>
-         *
-         *
-         * Ticket format:
-         *  -ticket-type:<string>
-         *  -ticket-level:<int>
-         *  -add-tick:<long>
-         *  -object-reason:<string> // This depends on the type of ticket. ie POST_TELEPORT -> entity id
-         */
         List<org.bukkit.World> worlds = org.bukkit.Bukkit.getWorlds();
         JsonObject data = new JsonObject();
 
         data.addProperty("server-version", org.bukkit.Bukkit.getVersion());
-        data.addProperty("data-version", 0);
+        data.addProperty("data-version", 1);
 
         JsonArray worldsData = new JsonArray();
 
@@ -624,36 +578,13 @@ public final class MCUtil {
             JsonObject worldData = new JsonObject();
 
             ServerLevel world = ((org.bukkit.craftbukkit.CraftWorld)bukkitWorld).getHandle();
-            ChunkMap chunkMap = world.getChunkSource().chunkMap;
-            Long2ObjectLinkedOpenHashMap<ChunkHolder> visibleChunks = chunkMap.updatingChunks.getVisibleMap(); // Paper
-            DistanceManager chunkMapDistance = chunkMap.distanceManager;
-            List<ChunkHolder> allChunks = new ArrayList<>(visibleChunks.values());
             List<ServerPlayer> players = world.players;
 
-            int fullLoadedChunks = 0;
-
-            for (ChunkHolder chunk : allChunks) {
-                if (chunk.getFullChunkNowUnchecked() != null) {
-                    ++fullLoadedChunks;
-                }
-            }
-
-            // sorting by coordinate makes the log easier to read
-            allChunks.sort((ChunkHolder v1, ChunkHolder v2) -> {
-                if (v1.pos.x != v2.pos.x) {
-                    return Integer.compare(v1.pos.x, v2.pos.x);
-                }
-                return Integer.compare(v1.pos.z, v2.pos.z);
-            });
-
             worldData.addProperty("name", world.getWorld().getName());
             worldData.addProperty("view-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetNoTickViewDistance()); // Paper - replace chunk loader system
             worldData.addProperty("tick-view-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance()); // Paper - replace chunk loader system
             worldData.addProperty("keep-spawn-loaded", world.keepSpawnInMemory);
             worldData.addProperty("keep-spawn-loaded-range", world.paperConfig().spawn.keepSpawnLoadedRange * 16);
-            worldData.addProperty("visible-chunk-count", visibleChunks.size());
-            worldData.addProperty("loaded-chunk-count", chunkMap.entitiesInLevel.size());
-            worldData.addProperty("verified-fully-loaded-chunks", fullLoadedChunks);
 
             JsonArray playersData = new JsonArray();
 
@@ -666,48 +597,10 @@ public final class MCUtil {
                 playerData.addProperty("z", player.getZ());
 
                 playersData.add(playerData);
-
             }
 
             worldData.add("players", playersData);
-
-            JsonArray chunksData = new JsonArray();
-
-            for (ChunkHolder playerChunk : allChunks) {
-                JsonObject chunkData = new JsonObject();
-
-                Set<Ticket<?>> tickets = chunkMapDistance.tickets.get(playerChunk.pos.longKey);
-                ChunkStatus status = getChunkStatus(playerChunk);
-
-                chunkData.addProperty("x", playerChunk.pos.x);
-                chunkData.addProperty("z", playerChunk.pos.z);
-                chunkData.addProperty("ticket-level", playerChunk.getTicketLevel());
-                chunkData.addProperty("priority", playerChunk.queueLevel); // Paper - priority
-                chunkData.addProperty("state", ChunkHolder.getFullChunkStatus(playerChunk.getTicketLevel()).toString());
-                chunkData.addProperty("queued-for-unload", chunkMap.toDrop.contains(playerChunk.pos.longKey));
-                chunkData.addProperty("status", status == null ? "unloaded" : status.toString());
-
-                JsonArray ticketsData = new JsonArray();
-
-                if (tickets != null) {
-                    for (Ticket<?> ticket : tickets) {
-                        JsonObject ticketData = new JsonObject();
-
-                        ticketData.addProperty("ticket-type", ticket.getType().toString());
-                        ticketData.addProperty("ticket-level", ticket.getTicketLevel());
-                        ticketData.addProperty("object-reason", String.valueOf(ticket.key));
-                        ticketData.addProperty("add-tick", ticket.createdTick);
-
-                        ticketsData.add(ticketData);
-                    }
-                }
-
-                chunkData.add("tickets", ticketsData);
-                chunksData.add(chunkData);
-            }
-
-
-            worldData.add("chunk-data", chunksData);
+            worldData.add("chunk-data", watchdog ? world.chunkTaskScheduler.chunkHolderManager.getDebugJsonForWatchdog() : world.chunkTaskScheduler.chunkHolderManager.getDebugJson());
             worldsData.add(worldData);
         }
 
@@ -721,7 +614,7 @@ public final class MCUtil {
 
         String fileData = stringWriter.toString();
 
-        try (PrintStream out = new PrintStream(new FileOutputStream(file), false, "UTF-8")) {
+        try (PrintStream out = new PrintStream(new FileOutputStream(file), false, StandardCharsets.UTF_8)) {
             out.print(fileData);
         }
     }
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index f23be38ef96a81ce3867a3b6fdccf632fe285f31..85bb2ab74b76a4cc2ced8520892ca0562ea296b7 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -301,7 +301,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     public static <S extends MinecraftServer> S spin(Function<Thread, S> serverFactory) {
         AtomicReference<S> atomicreference = new AtomicReference();
-        Thread thread = new Thread(() -> {
+        Thread thread = new io.papermc.paper.util.TickThread(() -> { // Paper - rewrite chunk system
             ((MinecraftServer) atomicreference.get()).runServer();
         }, "Server thread");
 
@@ -615,7 +615,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.forceDifficulty();
         for (ServerLevel worldserver : this.getAllLevels()) {
             this.prepareLevels(worldserver.getChunkSource().chunkMap.progressListener, worldserver);
-            worldserver.entityManager.tick(); // SPIGOT-6526: Load pending entities so they are available to the API
+            //worldserver.entityManager.tick(); // SPIGOT-6526: Load pending entities so they are available to the API // Paper - rewrite chunk system, not required to "tick" anything
             this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldLoadEvent(worldserver.getWorld()));
         }
 
@@ -832,6 +832,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public abstract boolean shouldRconBroadcast();
 
     public boolean saveAllChunks(boolean suppressLogs, boolean flush, boolean force) {
+        // Paper start - rewrite chunk system - add close param
+        // This allows us to avoid double saving chunks by closing instead of saving then closing
+        return this.saveAllChunks(suppressLogs, flush, force, false);
+    }
+    public boolean saveAllChunks(boolean suppressLogs, boolean flush, boolean force, boolean close) {
+        // Paper end - rewrite chunk system - add close param
         boolean flag3 = false;
 
         for (Iterator iterator = this.getAllLevels().iterator(); iterator.hasNext(); flag3 = true) {
@@ -840,8 +846,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             if (!suppressLogs) {
                 MinecraftServer.LOGGER.info("Saving chunks for level '{}'/{}", worldserver, worldserver.dimension().location());
             }
-
-            worldserver.save((ProgressListener) null, flush, worldserver.noSave && !force);
+            // Paper start - rewrite chunk system
+            worldserver.save((ProgressListener) null, flush, worldserver.noSave && !force, close);
+            if (flush) {
+                MinecraftServer.LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", worldserver.getChunkSource().chunkMap.getStorageName());
+            }
+            // Paper end - rewrite chunk system
         }
 
         // CraftBukkit start - moved to WorldServer.save
@@ -860,7 +870,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             while (iterator1.hasNext()) {
                 ServerLevel worldserver2 = (ServerLevel) iterator1.next();
 
-                MinecraftServer.LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", worldserver2.getChunkSource().chunkMap.getStorageName());
+                //MinecraftServer.LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", worldserver2.getChunkSource().chunkMap.getStorageName()); // Paper - move up
             }
 
             MinecraftServer.LOGGER.info("ThreadedAnvilChunkStorage: All dimensions are saved");
@@ -964,38 +974,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
         // Paper end - let's be a little more intelligent around crashes
 
-        while (this.levels.values().stream().anyMatch((worldserver1) -> {
-            return worldserver1.getChunkSource().chunkMap.hasWork();
-        })) {
-            this.nextTickTime = Util.getMillis() + 1L;
-            iterator = this.getAllLevels().iterator();
-
-            while (iterator.hasNext()) {
-                worldserver = (ServerLevel) iterator.next();
-                worldserver.getChunkSource().removeTicketsOnClosing();
-                worldserver.getChunkSource().tick(() -> {
-                    return true;
-                }, false);
-                while (worldserver.getChunkSource().pollTask()); // Paper - drain tasks
-            }
-
-            this.forceTicks = true; // Paper
-            while (this.pollTask()); // Paper - drain tasks
-        }
-
-        this.saveAllChunks(false, true, false);
-        iterator = this.getAllLevels().iterator();
+        // Paper - rewrite chunk system
 
-        while (iterator.hasNext()) {
-            worldserver = (ServerLevel) iterator.next();
-            if (worldserver != null) {
-                try {
-                    worldserver.close();
-                } catch (IOException ioexception) {
-                    MinecraftServer.LOGGER.error("Exception closing the level", ioexception);
-                }
-            }
-        }
+        this.saveAllChunks(false, true, false, true); // Paper - rewrite chunk system - move closing into here
+        // Paper - rewrite chunk system
 
         this.isSaving = false;
         this.resources.close();
@@ -1016,7 +998,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // Spigot end
         // Paper start - move final shutdown items here
         LOGGER.info("Flushing Chunk IO");
-        com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.close(true, true); // Paper
+        io.papermc.paper.chunk.system.io.RegionFileIOThread.close(true); // Paper // Paper - rewrite chunk system
         LOGGER.info("Closing Thread Pool");
         Util.shutdownExecutors(); // Paper
         LOGGER.info("Closing Server");
@@ -1118,6 +1100,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     // Paper End
     // Spigot End
 
+    public static volatile RuntimeException chunkSystemCrash; // Paper - rewrite chunk system
+
     protected void runServer() {
         try {
             long serverStartTime = Util.getNanos(); // Paper
@@ -1150,6 +1134,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             long start = System.nanoTime(), curTime, tickSection = start; // Paper - Further improve server tick loop
             lastTick = start - TICK_TIME; // Paper
             while (this.running) {
+                // Paper start - rewrite chunk system
+                // guarantee that nothing can stop the server from halting if it can at least still tick
+                if (this.chunkSystemCrash != null) {
+                    throw this.chunkSystemCrash;
+                }
+                // Paper end - rewrite chunk system
                 long i = ((curTime = System.nanoTime()) / (1000L * 1000L)) - this.nextTickTime; // Paper
 
                 if (i > 5000L && this.nextTickTime - this.lastOverloadWarning >= 30000L) { // CraftBukkit
@@ -2052,7 +2042,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             net.minecraft.world.item.alchemy.PotionBrewing.reload(); // Paper
             new io.papermc.paper.event.server.ServerResourcesReloadedEvent(cause).callEvent(); // Paper
             // Paper start
-            if (Thread.currentThread() != this.serverThread) {
+            if (!io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
                 return;
             }
             // this.getPlayerList().saveAll(); // Paper - we don't need to save everything, just advancements
@@ -2460,7 +2450,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     // CraftBukkit start
     @Override
     public boolean isSameThread() {
-        return super.isSameThread() /*|| this.isStopped()*/; // CraftBukkit - MC-142590 // Paper - causes issues elsewhere
+        return io.papermc.paper.util.TickThread.isTickThread(); // Paper - rewrite chunk system
     }
 
     public boolean isDebugging() {
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index 11cd31691307749e925930c4b6e10e3f3b4fad25..a62b8a9f0afdcd94801dac7d02ceb1545958bf0b 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -50,17 +50,12 @@ public class ChunkHolder {
     private static final List<ChunkStatus> CHUNK_STATUSES = ChunkStatus.getStatusList();
     private static final ChunkHolder.FullChunkStatus[] FULL_CHUNK_STATUSES = ChunkHolder.FullChunkStatus.values();
     private static final int BLOCKS_BEFORE_RESEND_FUDGE = 64;
-    private final AtomicReferenceArray<CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> futures;
+    // Paper - rewrite chunk system
     private final LevelHeightAccessor levelHeightAccessor;
-    private volatile CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> fullChunkFuture; private int fullChunkCreateCount; private volatile boolean isFullChunkReady; // Paper - cache chunk ticking stage
-    private volatile CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> tickingChunkFuture; private volatile boolean isTickingReady; // Paper - cache chunk ticking stage
-    private volatile CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> entityTickingChunkFuture; private volatile boolean isEntityTickingReady; // Paper - cache chunk ticking stage
-    public CompletableFuture<ChunkAccess> chunkToSave;  // Paper - public
+    // Paper - rewrite chunk system
     @Nullable
     private final DebugBuffer<ChunkHolder.ChunkSaveDebug> chunkToSaveHistory;
-    public int oldTicketLevel;
-    private int ticketLevel;
-    public volatile int queueLevel; // Paper - private->public, make volatile since this is concurrently accessed
+    // Paper - rewrite chunk system
     public final ChunkPos pos;
     private boolean hasChangedSections;
     private final ShortSet[] changedBlocksPerSection;
@@ -69,12 +64,12 @@ public class ChunkHolder {
     private final LevelLightEngine lightEngine;
     private final ChunkHolder.LevelChangeListener onLevelChange;
     public final ChunkHolder.PlayerProvider playerProvider;
-    private boolean wasAccessibleSinceLastSave;
+    // Paper - rewrite chunk system
     private boolean resendLight;
-    private CompletableFuture<Void> pendingFullStateConfirmation;
+    // Paper - rewrite chunk system
 
     public ServerLevel getWorld() { return chunkMap.level; } // Paper
-    boolean isUpdateQueued = false; // Paper
+    // Paper - rewrite chunk system
     private final ChunkMap chunkMap; // Paper
     // Paper start - no-tick view distance
     public final LevelChunk getSendingChunk() {
@@ -110,7 +105,7 @@ public class ChunkHolder {
         // Paper end - optimise checkDespawn
     }
 
-    void onChunkRemove() {
+    public void onChunkRemove() { // Paper - rewrite chunk system
         this.playersInMobSpawnRange = null;
         this.playersInChunkTickRange = null;
         // Paper start - optimise chunk tick iteration
@@ -128,33 +123,22 @@ public class ChunkHolder {
     // Paper end - optimise anyPlayerCloseEnoughForSpawning
     long lastAutoSaveTime; // Paper - incremental autosave
     long inactiveTimeStart; // Paper - incremental autosave
-    // Paper start - optimize chunk status progression without jumping through thread pool
-    public boolean canAdvanceStatus() {
-        ChunkStatus status = getChunkHolderStatus();
-        ChunkAccess chunk = getAvailableChunkNow();
-        return chunk != null && (status == null || chunk.getStatus().isOrAfter(getNextStatus(status)));
-    }
-    // Paper end
+    // Paper - rewrite chunk system
+
+    public final io.papermc.paper.chunk.system.scheduling.NewChunkHolder newChunkHolder; // Paper - rewrite chunk system
 
-    public ChunkHolder(ChunkPos pos, int level, LevelHeightAccessor world, LevelLightEngine lightingProvider, ChunkHolder.LevelChangeListener levelUpdateListener, ChunkHolder.PlayerProvider playersWatchingChunkProvider) {
-        this.futures = new AtomicReferenceArray(ChunkHolder.CHUNK_STATUSES.size());
-        this.fullChunkFuture = ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE;
-        this.tickingChunkFuture = ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE;
-        this.entityTickingChunkFuture = ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE;
-        this.chunkToSave = CompletableFuture.completedFuture(null); // CraftBukkit - decompile error
+    public ChunkHolder(ChunkPos pos, LevelHeightAccessor world, LevelLightEngine lightingProvider, ChunkHolder.PlayerProvider playersWatchingChunkProvider, io.papermc.paper.chunk.system.scheduling.NewChunkHolder newChunkHolder) { // Paper - rewrite chunk system
+        this.newChunkHolder = newChunkHolder; // Paper - rewrite chunk system
         this.chunkToSaveHistory = null;
         this.blockChangedLightSectionFilter = new BitSet();
         this.skyChangedLightSectionFilter = new BitSet();
-        this.pendingFullStateConfirmation = CompletableFuture.completedFuture(null); // CraftBukkit - decompile error
+        // Paper - rewrite chunk system
         this.pos = pos;
         this.levelHeightAccessor = world;
         this.lightEngine = lightingProvider;
-        this.onLevelChange = levelUpdateListener;
+        this.onLevelChange = null; // Paper - rewrite chunk system
         this.playerProvider = playersWatchingChunkProvider;
-        this.oldTicketLevel = ChunkMap.MAX_CHUNK_DISTANCE + 1;
-        this.ticketLevel = this.oldTicketLevel;
-        this.queueLevel = this.oldTicketLevel;
-        this.setTicketLevel(level);
+        // Paper - rewrite chunk system
         this.changedBlocksPerSection = new ShortSet[world.getSectionsCount()];
         this.chunkMap = (ChunkMap)playersWatchingChunkProvider; // Paper
         this.onChunkAdd(); // Paper - optimise anyPlayerCloseEnoughForSpawning
@@ -162,120 +146,83 @@ public class ChunkHolder {
 
     // Paper start
     public @Nullable ChunkAccess getAvailableChunkNow() {
-        // TODO can we just getStatusFuture(EMPTY)?
-        for (ChunkStatus curr = ChunkStatus.FULL, next = curr.getParent(); curr != next; curr = next, next = next.getParent()) {
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = this.getFutureIfPresentUnchecked(curr);
-            Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = future.getNow(null);
-            if (either == null || either.left().isEmpty()) {
-                continue;
-            }
-            return either.left().get();
-        }
-        return null;
+        return this.newChunkHolder.getCurrentChunk(); // Paper - rewrite chunk system
     }
     // Paper end
     // CraftBukkit start
     public LevelChunk getFullChunkNow() {
-        // Note: We use the oldTicketLevel for isLoaded checks.
-        if (!ChunkHolder.getFullChunkStatus(this.oldTicketLevel).isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) return null;
-        return this.getFullChunkNowUnchecked();
+        // Paper start - rewrite chunk system
+        ChunkAccess chunk = this.getAvailableChunkNow();
+        if (!this.isFullChunkReady() || !(chunk instanceof LevelChunk)) return null; // instanceof to avoid a race condition on off-main threads
+        return (LevelChunk)chunk;
+        // Paper end - rewrite chunk system
     }
 
     public LevelChunk getFullChunkNowUnchecked() {
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> statusFuture = this.getFutureIfPresentUnchecked(ChunkStatus.FULL);
-        Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = (Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>) statusFuture.getNow(null);
-        return (either == null) ? null : (LevelChunk) either.left().orElse(null);
+        // Paper start - rewrite chunk system
+        ChunkAccess chunk = this.getAvailableChunkNow();
+        return chunk instanceof LevelChunk ? (LevelChunk)chunk : null;
+        // Paper end - rewrite chunk system
     }
     // CraftBukkit end
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getFutureIfPresentUnchecked(ChunkStatus leastStatus) {
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = (CompletableFuture) this.futures.get(leastStatus.getIndex());
-
-        return completablefuture == null ? ChunkHolder.UNLOADED_CHUNK_FUTURE : completablefuture;
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system TODO
     }
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getFutureIfPresent(ChunkStatus leastStatus) {
-        return ChunkHolder.getStatus(this.ticketLevel).isOrAfter(leastStatus) ? this.getFutureIfPresentUnchecked(leastStatus) : ChunkHolder.UNLOADED_CHUNK_FUTURE;
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system TODO
     }
 
     public final CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> getTickingChunkFuture() { // Paper - final for inline
-        return this.tickingChunkFuture;
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system TODO keep?
     }
 
     public final CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> getEntityTickingChunkFuture() { // Paper - final for inline
-        return this.entityTickingChunkFuture;
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system TODO keep?
     }
 
     public final CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> getFullChunkFuture() { // Paper - final for inline
-        return this.fullChunkFuture;
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system TODO keep?
     }
 
     @Nullable
     public final LevelChunk getTickingChunk() { // Paper - final for inline
-        CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getTickingChunkFuture();
-        Either<LevelChunk, ChunkHolder.ChunkLoadingFailure> either = (Either) completablefuture.getNow(null); // CraftBukkit - decompile error
-
-        return either == null ? null : (LevelChunk) either.left().orElse(null); // CraftBukkit - decompile error
+        // Paper start - rewrite chunk system
+        if (!this.isTickingReady()) {
+            return null;
+        }
+        return (LevelChunk)this.getAvailableChunkNow();
+        // Paper end - rewrite chunk system
     }
 
     @Nullable
     public final LevelChunk getFullChunk() { // Paper - final for inline
-        CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getFullChunkFuture();
-        Either<LevelChunk, ChunkHolder.ChunkLoadingFailure> either = (Either) completablefuture.getNow(null); // CraftBukkit - decompile error
-
-        return either == null ? null : (LevelChunk) either.left().orElse(null); // CraftBukkit - decompile error
+        // Paper start - rewrite chunk system
+        if (!this.isFullChunkReady()) {
+            return null;
+        }
+        return (LevelChunk)this.getAvailableChunkNow();
+        // Paper end - rewrite chunk system
     }
 
     @Nullable
     public ChunkStatus getLastAvailableStatus() {
-        for (int i = ChunkHolder.CHUNK_STATUSES.size() - 1; i >= 0; --i) {
-            ChunkStatus chunkstatus = (ChunkStatus) ChunkHolder.CHUNK_STATUSES.get(i);
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getFutureIfPresentUnchecked(chunkstatus);
-
-            if (((Either) completablefuture.getNow(ChunkHolder.UNLOADED_CHUNK)).left().isPresent()) {
-                return chunkstatus;
-            }
-        }
-
-        return null;
+        return this.newChunkHolder.getCurrentGenStatus(); // Paper - rewrite chunk system
     }
 
     // Paper start
     public ChunkStatus getChunkHolderStatus() {
-        for (ChunkStatus curr = ChunkStatus.FULL, next = curr.getParent(); curr != next; curr = next, next = next.getParent()) {
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = this.getFutureIfPresentUnchecked(curr);
-            Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = future.getNow(null);
-            if (either == null || !either.left().isPresent()) {
-                continue;
-            }
-            return curr;
-        }
-
-        return null;
+        return this.newChunkHolder.getCurrentGenStatus(); // Paper - rewrite chunk system
     }
     // Paper end
 
     @Nullable
     public ChunkAccess getLastAvailable() {
-        for (int i = ChunkHolder.CHUNK_STATUSES.size() - 1; i >= 0; --i) {
-            ChunkStatus chunkstatus = (ChunkStatus) ChunkHolder.CHUNK_STATUSES.get(i);
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getFutureIfPresentUnchecked(chunkstatus);
-
-            if (!completablefuture.isCompletedExceptionally()) {
-                Optional<ChunkAccess> optional = ((Either) completablefuture.getNow(ChunkHolder.UNLOADED_CHUNK)).left();
-
-                if (optional.isPresent()) {
-                    return (ChunkAccess) optional.get();
-                }
-            }
-        }
-
-        return null;
+        return this.newChunkHolder.getCurrentChunk(); // Paper - rewrite chunk system
     }
 
-    public final CompletableFuture<ChunkAccess> getChunkToSave() { // Paper - final for inline
-        return this.chunkToSave;
-    }
+    // Paper - rewrite chunk system
 
     public void blockChanged(BlockPos pos) {
         if (!pos.isInsideBuildHeightAndWorldBoundsHorizontal(levelHeightAccessor)) return; // Paper - SPIGOT-6086 for all invalid locations; avoid acquiring locks
@@ -430,61 +377,10 @@ public class ChunkHolder {
         // Paper end - per player view distance
     }
 
-    public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getOrScheduleFuture(ChunkStatus targetStatus, ChunkMap chunkStorage) {
-        int i = targetStatus.getIndex();
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = (CompletableFuture) this.futures.get(i);
-
-        if (completablefuture != null) {
-            Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = (Either) completablefuture.getNow(ChunkHolder.NOT_DONE_YET);
-
-            if (either == null) {
-                String s = "value in future for status: " + targetStatus + " was incorrectly set to null at chunk: " + this.pos;
-
-                throw chunkStorage.debugFuturesAndCreateReportedException(new IllegalStateException("null value previously set for chunk status"), s);
-            }
-
-            if (either == ChunkHolder.NOT_DONE_YET || either.right().isEmpty()) {
-                return completablefuture;
-            }
-        }
-
-        if (ChunkHolder.getStatus(this.ticketLevel).isOrAfter(targetStatus)) {
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture1 = chunkStorage.schedule(this, targetStatus);
-
-            this.updateChunkToSave(completablefuture1, "schedule " + targetStatus);
-            this.futures.set(i, completablefuture1);
-            return completablefuture1;
-        } else {
-            return completablefuture == null ? ChunkHolder.UNLOADED_CHUNK_FUTURE : completablefuture;
-        }
-    }
-
-    protected void addSaveDependency(String thenDesc, CompletableFuture<?> then) {
-        if (this.chunkToSaveHistory != null) {
-            this.chunkToSaveHistory.push(new ChunkHolder.ChunkSaveDebug(Thread.currentThread(), then, thenDesc));
-        }
-
-        this.chunkToSave = this.chunkToSave.thenCombine(then, (ichunkaccess, object) -> {
-            return ichunkaccess;
-        });
-    }
-
-    private void updateChunkToSave(CompletableFuture<? extends Either<? extends ChunkAccess, ChunkHolder.ChunkLoadingFailure>> then, String thenDesc) {
-        if (this.chunkToSaveHistory != null) {
-            this.chunkToSaveHistory.push(new ChunkHolder.ChunkSaveDebug(Thread.currentThread(), then, thenDesc));
-        }
-
-        this.chunkToSave = this.chunkToSave.thenCombine(then, (ichunkaccess, either) -> {
-            return (ChunkAccess) either.map((ichunkaccess1) -> {
-                return ichunkaccess1;
-            }, (playerchunk_failure) -> {
-                return ichunkaccess;
-            });
-        });
-    }
+    // Paper - rewrite chunk system
 
     public ChunkHolder.FullChunkStatus getFullStatus() {
-        return ChunkHolder.getFullChunkStatus(this.ticketLevel);
+        return this.newChunkHolder.getChunkStatus(); // Paper - rewrite chunk system
     }
 
     public final ChunkPos getPos() { // Paper - final for inline
@@ -492,292 +388,10 @@ public class ChunkHolder {
     }
 
     public final int getTicketLevel() { // Paper - final for inline
-        return this.ticketLevel;
+        return this.newChunkHolder.getTicketLevel(); // Paper - rewrite chunk system
     }
 
-    public int getQueueLevel() {
-        return this.queueLevel;
-    }
-
-    private void setQueueLevel(int level) {
-        this.queueLevel = level;
-    }
-
-    public void setTicketLevel(int level) {
-        this.ticketLevel = level;
-    }
-
-    private void scheduleFullChunkPromotion(ChunkMap playerchunkmap, CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completablefuture, Executor executor, ChunkHolder.FullChunkStatus playerchunk_state) {
-        this.pendingFullStateConfirmation.cancel(false);
-        CompletableFuture<Void> completablefuture1 = new CompletableFuture();
-
-        completablefuture1.thenRunAsync(() -> {
-            // Paper start - do not allow ticket level changes
-            boolean unloadingBefore = this.chunkMap.unloadingPlayerChunk;
-            this.chunkMap.unloadingPlayerChunk = true;
-            try {
-            // Paper end  - do not allow ticket level changes
-            playerchunkmap.onFullChunkStatusChange(this.pos, playerchunk_state);
-            } finally { this.chunkMap.unloadingPlayerChunk = unloadingBefore; } // Paper - do not allow ticket level changes
-        }, executor);
-        this.pendingFullStateConfirmation = completablefuture1;
-        completablefuture.thenAccept((either) -> {
-            either.ifLeft((chunk) -> {
-                completablefuture1.complete(null); // CraftBukkit - decompile error
-            });
-        });
-    }
-
-    // Paper start
-    private boolean loadCallbackScheduled = false;
-    private boolean unloadCallbackScheduled = false;
-    // Paper end
-
-    private void demoteFullChunk(ChunkMap playerchunkmap, ChunkHolder.FullChunkStatus playerchunk_state) {
-        this.pendingFullStateConfirmation.cancel(false);
-        // Paper start - do not allow ticket level changes
-        boolean unloadingBefore = this.chunkMap.unloadingPlayerChunk;
-        this.chunkMap.unloadingPlayerChunk = true;
-        try { // Paper end  - do not allow ticket level changes
-        playerchunkmap.onFullChunkStatusChange(this.pos, playerchunk_state);
-        } finally { this.chunkMap.unloadingPlayerChunk = unloadingBefore; } // Paper - do not allow ticket level changes
-    }
-
-    protected long updateCount; // Paper - correctly handle recursion
-    protected void updateFutures(ChunkMap chunkStorage, Executor executor) {
-        io.papermc.paper.util.TickThread.ensureTickThread("Async ticket level update"); // Paper
-        long updateCount = ++this.updateCount; // Paper - correctly handle recursion
-        ChunkStatus chunkstatus = ChunkHolder.getStatus(this.oldTicketLevel);
-        ChunkStatus chunkstatus1 = ChunkHolder.getStatus(this.ticketLevel);
-        boolean flag = this.oldTicketLevel <= ChunkMap.MAX_CHUNK_DISTANCE;
-        boolean flag1 = this.ticketLevel <= ChunkMap.MAX_CHUNK_DISTANCE;
-        ChunkHolder.FullChunkStatus playerchunk_state = ChunkHolder.getFullChunkStatus(this.oldTicketLevel);
-        ChunkHolder.FullChunkStatus playerchunk_state1 = ChunkHolder.getFullChunkStatus(this.ticketLevel);
-        // CraftBukkit start
-        // ChunkUnloadEvent: Called before the chunk is unloaded: isChunkLoaded is still true and chunk can still be modified by plugins.
-        if (playerchunk_state.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && !playerchunk_state1.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
-            this.getFutureIfPresentUnchecked(ChunkStatus.FULL).thenAccept((either) -> {
-                io.papermc.paper.util.TickThread.ensureTickThread("Async full status chunk future completion"); // Paper
-                LevelChunk chunk = (LevelChunk)either.left().orElse(null);
-                if (chunk != null && chunk.wasLoadCallbackInvoked() && ChunkHolder.this.ticketLevel > 33) { // Paper - only invoke unload if load was called
-                    // Paper  start - only schedule once, now the future is no longer completed as RIGHT if unloaded...
-                    if (ChunkHolder.this.unloadCallbackScheduled) {
-                        return;
-                    }
-                    ChunkHolder.this.unloadCallbackScheduled = true;
-                    // Paper  end - only schedule once, now the future is no longer completed as RIGHT if unloaded...
-                    chunkStorage.callbackExecutor.execute(() -> {
-                        // Paper  start - only schedule once, now the future is no longer completed as RIGHT if unloaded...
-                        ChunkHolder.this.unloadCallbackScheduled = false;
-                        if (ChunkHolder.this.ticketLevel <= 33) {
-                            return;
-                        }
-                        // Paper  end - only schedule once, now the future is no longer completed as RIGHT if unloaded...
-                        // Minecraft will apply the chunks tick lists to the world once the chunk got loaded, and then store the tick
-                        // lists again inside the chunk once the chunk becomes inaccessible and set the chunk's needsSaving flag.
-                        // These actions may however happen deferred, so we manually set the needsSaving flag already here.
-                        chunk.setUnsaved(true);
-                        chunk.unloadCallback();
-                    });
-                }
-            }).exceptionally((throwable) -> {
-                // ensure exceptions are printed, by default this is not the case
-                MinecraftServer.LOGGER.error("Failed to schedule unload callback for chunk " + ChunkHolder.this.pos, throwable);
-                return null;
-            });
-
-            // Run callback right away if the future was already done
-            chunkStorage.callbackExecutor.run();
-            // Paper start - correctly handle recursion
-            if (this.updateCount != updateCount) {
-                // something else updated ticket level for us.
-                return;
-            }
-            // Paper end - correctly handle recursion
-        }
-        // CraftBukkit end
-
-        if (flag) {
-            Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = Either.right(new ChunkHolder.ChunkLoadingFailure() {
-                public String toString() {
-                    return "Unloaded ticket level " + ChunkHolder.this.pos;
-                }
-            });
-
-            for (int i = flag1 ? chunkstatus1.getIndex() + 1 : 0; i <= chunkstatus.getIndex(); ++i) {
-                CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = (CompletableFuture) this.futures.get(i);
-
-                if (completablefuture == null) {
-                    this.futures.set(i, CompletableFuture.completedFuture(either));
-                }
-            }
-        }
-
-        boolean flag2 = playerchunk_state.isOrAfter(ChunkHolder.FullChunkStatus.BORDER);
-        boolean flag3 = playerchunk_state1.isOrAfter(ChunkHolder.FullChunkStatus.BORDER);
-
-        boolean prevHasBeenLoaded = this.wasAccessibleSinceLastSave; // Paper
-        this.wasAccessibleSinceLastSave |= flag3;
-        // Paper start - incremental autosave
-        if (this.wasAccessibleSinceLastSave & !prevHasBeenLoaded) {
-            long timeSinceAutoSave = this.inactiveTimeStart - this.lastAutoSaveTime;
-            if (timeSinceAutoSave < 0) {
-                // safest bet is to assume autosave is needed here
-                timeSinceAutoSave = this.chunkMap.level.paperConfig().chunks.autoSaveInterval.value();
-            }
-            this.lastAutoSaveTime = this.chunkMap.level.getGameTime() - timeSinceAutoSave;
-            this.chunkMap.autoSaveQueue.add(this);
-        }
-        // Paper end
-        if (!flag2 && flag3) {
-            int expectCreateCount = ++this.fullChunkCreateCount; // Paper
-            this.fullChunkFuture = chunkStorage.prepareAccessibleChunk(this);
-            this.scheduleFullChunkPromotion(chunkStorage, this.fullChunkFuture, executor, ChunkHolder.FullChunkStatus.BORDER);
-            // Paper start - cache ticking ready status
-            this.fullChunkFuture.thenAccept(either -> {
-                io.papermc.paper.util.TickThread.ensureTickThread("Async full chunk future completion"); // Paper
-                final Optional<LevelChunk> left = either.left();
-                if (left.isPresent() && ChunkHolder.this.fullChunkCreateCount == expectCreateCount) {
-                    // note: Here is a very good place to add callbacks to logic waiting on this.
-                    LevelChunk fullChunk = either.left().get();
-                    ChunkHolder.this.isFullChunkReady = true;
-                    fullChunk.playerChunk = ChunkHolder.this;
-                    this.chunkMap.distanceManager.clearPriorityTickets(pos);
-                }
-            });
-            this.updateChunkToSave(this.fullChunkFuture, "full");
-        }
-
-        if (flag2 && !flag3) {
-            this.fullChunkFuture.complete(ChunkHolder.UNLOADED_LEVEL_CHUNK);
-            this.fullChunkFuture = ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE;
-            ++this.fullChunkCreateCount; // Paper - cache ticking ready status
-            this.isFullChunkReady = false; // Paper - cache ticking ready status
-        }
-
-        boolean flag4 = playerchunk_state.isOrAfter(ChunkHolder.FullChunkStatus.TICKING);
-        boolean flag5 = playerchunk_state1.isOrAfter(ChunkHolder.FullChunkStatus.TICKING);
-
-        if (!flag4 && flag5) {
-            this.tickingChunkFuture = chunkStorage.prepareTickingChunk(this);
-            this.scheduleFullChunkPromotion(chunkStorage, this.tickingChunkFuture, executor, ChunkHolder.FullChunkStatus.TICKING);
-            // Paper start - cache ticking ready status
-            this.tickingChunkFuture.thenAccept(either -> {
-                io.papermc.paper.util.TickThread.ensureTickThread("Async full chunk future completion"); // Paper
-                either.ifLeft(chunk -> {
-                    // note: Here is a very good place to add callbacks to logic waiting on this.
-                    ChunkHolder.this.isTickingReady = true;
-                    // Paper start - ticking chunk set
-                    ChunkHolder.this.chunkMap.level.getChunkSource().tickingChunks.add(chunk);
-                    // Paper end - ticking chunk set
-                });
-            });
-            // Paper end
-            this.updateChunkToSave(this.tickingChunkFuture, "ticking");
-        }
-
-        if (flag4 && !flag5) {
-            this.tickingChunkFuture.complete(ChunkHolder.UNLOADED_LEVEL_CHUNK); this.isTickingReady = false; // Paper - cache chunk ticking stage
-            this.tickingChunkFuture = ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE;
-            // Paper start - ticking chunk set
-            LevelChunk chunkIfCached = this.getFullChunkNowUnchecked();
-            if (chunkIfCached != null) {
-                this.chunkMap.level.getChunkSource().tickingChunks.remove(chunkIfCached);
-            }
-            // Paper end - ticking chunk set
-        }
-
-        boolean flag6 = playerchunk_state.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING);
-        boolean flag7 = playerchunk_state1.isOrAfter(ChunkHolder.FullChunkStatus.ENTITY_TICKING);
-
-        if (!flag6 && flag7) {
-            if (this.entityTickingChunkFuture != ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE) {
-                throw (IllegalStateException) Util.pauseInIde(new IllegalStateException());
-            }
-
-            this.entityTickingChunkFuture = chunkStorage.prepareEntityTickingChunk(this.pos);
-            this.scheduleFullChunkPromotion(chunkStorage, this.entityTickingChunkFuture, executor, ChunkHolder.FullChunkStatus.ENTITY_TICKING);
-            // Paper start - cache ticking ready status
-            this.entityTickingChunkFuture.thenAccept(either -> {
-                io.papermc.paper.util.TickThread.ensureTickThread("Async full chunk future completion"); // Paper
-                either.ifLeft(chunk -> {
-                    ChunkHolder.this.isEntityTickingReady = true;
-                    // Paper start - entity ticking chunk set
-                    ChunkHolder.this.chunkMap.level.getChunkSource().entityTickingChunks.add(chunk);
-                    // Paper end - entity ticking chunk set
-                });
-            });
-            // Paper end
-            this.updateChunkToSave(this.entityTickingChunkFuture, "entity ticking");
-        }
-
-        if (flag6 && !flag7) {
-            this.entityTickingChunkFuture.complete(ChunkHolder.UNLOADED_LEVEL_CHUNK); this.isEntityTickingReady = false; // Paper - cache chunk ticking stage
-            this.entityTickingChunkFuture = ChunkHolder.UNLOADED_LEVEL_CHUNK_FUTURE;
-            // Paper start - entity ticking chunk set
-            LevelChunk chunkIfCached = this.getFullChunkNowUnchecked();
-            if (chunkIfCached != null) {
-                this.chunkMap.level.getChunkSource().entityTickingChunks.remove(chunkIfCached);
-            }
-            // Paper end - entity ticking chunk set
-        }
-
-        if (!playerchunk_state1.isOrAfter(playerchunk_state)) {
-            this.demoteFullChunk(chunkStorage, playerchunk_state1);
-        }
-
-        //this.onLevelChange.onLevelChange(this.pos, this::getQueueLevel, this.ticketLevel, this::setQueueLevel);
-        // Paper start - raise IO/load priority if priority changes, use our preferred priority
-        priorityBoost = chunkMap.distanceManager.getChunkPriority(pos);
-        int currRequestedPriority = this.requestedPriority;
-        int priority = getDemandedPriority();
-        int newRequestedPriority = this.requestedPriority = priority;
-        if (this.queueLevel > priority) {
-            int ioPriority = com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY;
-            if (priority <= 10) {
-                ioPriority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY;
-            } else if (priority <= 20) {
-                ioPriority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGH_PRIORITY;
-            }
-            chunkMap.level.asyncChunkTaskManager.raisePriority(pos.x, pos.z, ioPriority);
-            chunkMap.level.getChunkSource().getLightEngine().queue.changePriority(pos.toLong(), this.queueLevel, priority); // Paper // Restore this in chunk priority later?
-        }
-        if (currRequestedPriority != newRequestedPriority) {
-            this.onLevelChange.onLevelChange(this.pos, () -> this.queueLevel, priority, p -> this.queueLevel = p); // use preferred priority
-            int neighborsPriority = getNeighborsPriority();
-            this.neighbors.forEach((neighbor, neighborDesired) -> neighbor.setNeighborPriority(this, neighborsPriority));
-        }
-        // Paper end
-        this.oldTicketLevel = this.ticketLevel;
-        // CraftBukkit start
-        // ChunkLoadEvent: Called after the chunk is loaded: isChunkLoaded returns true and chunk is ready to be modified by plugins.
-        if (!playerchunk_state.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && playerchunk_state1.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
-            this.getFutureIfPresentUnchecked(ChunkStatus.FULL).thenAccept((either) -> {
-                io.papermc.paper.util.TickThread.ensureTickThread("Async full status chunk future completion"); // Paper
-                LevelChunk chunk = (LevelChunk)either.left().orElse(null);
-                if (chunk != null && ChunkHolder.this.oldTicketLevel <= 33 && !chunk.wasLoadCallbackInvoked()) { // Paper - ensure ticket level is set to loaded before calling, as now this can complete with ticket level > 33
-                    // Paper  start - only schedule once, now the future is no longer completed as RIGHT if unloaded...
-                    if (ChunkHolder.this.loadCallbackScheduled) {
-                        return;
-                    }
-                    ChunkHolder.this.loadCallbackScheduled = true;
-                    // Paper  end - only schedule once, now the future is no longer completed as RIGHT if unloaded...
-                    chunkStorage.callbackExecutor.execute(() -> {
-                        ChunkHolder.this.loadCallbackScheduled = false; // Paper  - only schedule once, now the future is no longer completed as RIGHT if unloaded...
-                        if (ChunkHolder.this.oldTicketLevel <= 33) chunk.loadCallback(); // Paper "
-                    });
-                }
-            }).exceptionally((throwable) -> {
-                // ensure exceptions are printed, by default this is not the case
-                MinecraftServer.LOGGER.error("Failed to schedule load callback for chunk " + ChunkHolder.this.pos, throwable);
-                return null;
-            });
-
-            // Run callback right away if the future was already done
-            chunkStorage.callbackExecutor.run();
-        }
-        // CraftBukkit end
-    }
+    // Paper - rewrite chunk system
 
     public static ChunkStatus getStatus(int level) {
         return level < 33 ? ChunkStatus.FULL : ChunkStatus.getStatusAroundFullChunk(level - 33);
@@ -787,62 +401,14 @@ public class ChunkHolder {
         return ChunkHolder.FULL_CHUNK_STATUSES[Mth.clamp(33 - distance + 1, (int) 0, ChunkHolder.FULL_CHUNK_STATUSES.length - 1)];
     }
 
-    public boolean wasAccessibleSinceLastSave() {
-        return this.wasAccessibleSinceLastSave;
-    }
-
-    public void refreshAccessibility() {
-        boolean prev = this.wasAccessibleSinceLastSave; // Paper
-        this.wasAccessibleSinceLastSave = ChunkHolder.getFullChunkStatus(this.ticketLevel).isOrAfter(ChunkHolder.FullChunkStatus.BORDER);
-        // Paper start - incremental autosave
-        if (prev != this.wasAccessibleSinceLastSave) {
-            if (this.wasAccessibleSinceLastSave) {
-                long timeSinceAutoSave = this.inactiveTimeStart - this.lastAutoSaveTime;
-                if (timeSinceAutoSave < 0) {
-                    // safest bet is to assume autosave is needed here
-                    timeSinceAutoSave = this.chunkMap.level.paperConfig().chunks.autoSaveInterval.value();
-                }
-                this.lastAutoSaveTime = this.chunkMap.level.getGameTime() - timeSinceAutoSave;
-                this.chunkMap.autoSaveQueue.add(this);
-            } else {
-                this.inactiveTimeStart = this.chunkMap.level.getGameTime();
-                this.chunkMap.autoSaveQueue.remove(this);
-            }
-        }
-        // Paper end
-    }
-
-    // Paper start - incremental autosave
-    public boolean setHasBeenLoaded() {
-        this.wasAccessibleSinceLastSave = getFullChunkStatus(this.ticketLevel).isOrAfter(ChunkHolder.FullChunkStatus.BORDER);
-        return this.wasAccessibleSinceLastSave;
-    }
-    // Paper end
+    // Paper - rewrite chunk system
 
     public void replaceProtoChunk(ImposterProtoChunk chunk) {
-        for (int i = 0; i < this.futures.length(); ++i) {
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = (CompletableFuture) this.futures.get(i);
-
-            if (completablefuture != null) {
-                Optional<ChunkAccess> optional = ((Either) completablefuture.getNow(ChunkHolder.UNLOADED_CHUNK)).left();
-
-                if (!optional.isEmpty() && optional.get() instanceof ProtoChunk) {
-                    this.futures.set(i, CompletableFuture.completedFuture(Either.left(chunk)));
-                }
-            }
-        }
-
-        this.updateChunkToSave(CompletableFuture.completedFuture(Either.left(chunk.getWrapped())), "replaceProto");
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     public List<Pair<ChunkStatus, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>>> getAllFutures() {
-        List<Pair<ChunkStatus, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>>> list = new ArrayList();
-
-        for (int i = 0; i < ChunkHolder.CHUNK_STATUSES.size(); ++i) {
-            list.add(Pair.of((ChunkStatus) ChunkHolder.CHUNK_STATUSES.get(i), (CompletableFuture) this.futures.get(i)));
-        }
-
-        return list;
+        return new ArrayList<>(); // Paper - rewrite chunk system TODO
     }
 
     @FunctionalInterface
@@ -889,95 +455,7 @@ public class ChunkHolder {
         };
     }
 
-    // Paper start - Chunk gen/load priority system
-    volatile int neighborPriority = -1;
-    volatile int priorityBoost = 0;
-    public final java.util.concurrent.ConcurrentHashMap<ChunkHolder, ChunkStatus> neighbors = new java.util.concurrent.ConcurrentHashMap<>();
-    public final it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<Integer> neighborPriorities = new it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<>();
-    int requestedPriority = ChunkMap.MAX_CHUNK_DISTANCE + 1; // this priority is possible pending, but is used to ensure needless updates are not queued
-
-    private int getDemandedPriority() {
-        int priority = neighborPriority; // if we have a neighbor priority, use it
-        int myPriority = getMyPriority();
-
-        if (priority == -1 || (ticketLevel <= 33 && priority > myPriority)) {
-            priority = myPriority;
-        }
-
-        return Math.max(1, Math.min(Math.max(ticketLevel, ChunkMap.MAX_CHUNK_DISTANCE), priority));
-    }
-
-    private int getMyPriority() {
-        if (priorityBoost == DistanceManager.URGENT_PRIORITY) {
-            return 2; // Urgent - ticket level isn't always 31 so 33-30 = 3, but allow 1 more tasks to go below this for dependents
-        }
-        return ticketLevel - priorityBoost;
-    }
-
-    private int getNeighborsPriority() {
-        return (neighborPriorities.isEmpty() ? getMyPriority() : getDemandedPriority()) + 1;
-    }
-
-    public void onNeighborRequest(ChunkHolder neighbor, ChunkStatus status) {
-        neighbor.setNeighborPriority(this, getNeighborsPriority());
-        this.neighbors.compute(neighbor, (playerChunk, currentWantedStatus) -> {
-            if (currentWantedStatus == null || !currentWantedStatus.isOrAfter(status)) {
-                //System.out.println(this + " request " + neighbor + " at " + status + " currently " + currentWantedStatus);
-                return status;
-            } else {
-                //System.out.println(this + " requested " + neighbor + " at " + status + " but thats lower than other wanted status " + currentWantedStatus);
-                return currentWantedStatus;
-            }
-        });
-
-    }
-
-    public void onNeighborDone(ChunkHolder neighbor, ChunkStatus chunkstatus, ChunkAccess chunk) {
-        this.neighbors.compute(neighbor, (playerChunk, wantedStatus) -> {
-            if (wantedStatus != null && chunkstatus.isOrAfter(wantedStatus)) {
-                //System.out.println(this + " neighbor done at " + neighbor + " for status " + chunkstatus + " wanted " + wantedStatus);
-                neighbor.removeNeighborPriority(this);
-                return null;
-            } else {
-                //System.out.println(this + " neighbor finished our previous request at " + neighbor + " for status " + chunkstatus + " but we now want instead " + wantedStatus);
-                return wantedStatus;
-            }
-        });
-    }
-
-    private void removeNeighborPriority(ChunkHolder requester) {
-        synchronized (neighborPriorities) {
-            neighborPriorities.remove(requester.pos.toLong());
-            recalcNeighborPriority();
-        }
-        checkPriority();
-    }
-
-
-    private void setNeighborPriority(ChunkHolder requester, int priority) {
-        synchronized (neighborPriorities) {
-            if (!Integer.valueOf(priority).equals(neighborPriorities.put(requester.pos.toLong(), Integer.valueOf(priority)))) {
-                recalcNeighborPriority();
-            }
-        }
-        checkPriority();
-    }
-
-    private void recalcNeighborPriority() {
-        neighborPriority = -1;
-        if (!neighborPriorities.isEmpty()) {
-            synchronized (neighborPriorities) {
-                for (Integer neighbor : neighborPriorities.values()) {
-                    if (neighbor < neighborPriority || neighborPriority == -1) {
-                        neighborPriority = neighbor;
-                    }
-                }
-            }
-        }
-    }
-    private void checkPriority() {
-        if (this.requestedPriority != getDemandedPriority()) this.chunkMap.queueHolderUpdate(this);
-    }
+    // Paper - rewrite chunk system
 
     public final double getDistance(ServerPlayer player) {
         return getDistance(player.getX(), player.getZ());
@@ -1000,33 +478,26 @@ public class ChunkHolder {
         }
         return CHUNK_STATUSES.get(status.getIndex() + 1);
     }
-    public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getStatusFutureUncheckedMain(ChunkStatus chunkstatus) {
-        return ensureMain(getFutureIfPresentUnchecked(chunkstatus));
-    }
-    public <T> CompletableFuture<T> ensureMain(CompletableFuture<T> future) {
-        return future.thenApplyAsync(r -> r, chunkMap.mainInvokingExecutor);
-    }
+    // Paper - rewrite chunk system
 
     @Override
     public String toString() {
+        // Paper start - rewrite chunk system
         return "PlayerChunk{" +
-            "location=" + pos +
-            ", ticketLevel=" + ticketLevel + "/" + getStatus(this.ticketLevel) +
-            ", chunkHolderStatus=" + getChunkHolderStatus() +
-            ", neighborPriority=" + getNeighborsPriority() +
-            ", priority=(" + ticketLevel + " - " + priorityBoost +" vs N " + neighborPriority + ") = " + getDemandedPriority() + " A " + queueLevel +
+            "location=" + this.pos +
             '}';
+        // Paper end - rewrite chunk system
     }
     public final boolean isEntityTickingReady() {
-        return this.isEntityTickingReady;
+        return this.newChunkHolder.isEntityTickingReady(); // Paper - rewrite chunk system
     }
 
     public final boolean isTickingReady() {
-        return this.isTickingReady;
+        return this.newChunkHolder.isTickingReady(); // Paper - rewrite chunk system
     }
 
     public final boolean isFullChunkReady() {
-        return this.isFullChunkReady;
+        return this.newChunkHolder.isFullChunkReady(); // Paper - rewrite chunk system
     }
     // Paper end
 }
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 77c89376495d90d0e7cbf6cd02c9a1c8d9a4340b..c51c97c620368dec265e0e9982e66f23f5566afe 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -124,37 +124,33 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     private static final int MIN_VIEW_DISTANCE = 3;
     public static final int MAX_VIEW_DISTANCE = 33;
     public static final int MAX_CHUNK_DISTANCE = 33 + ChunkStatus.maxDistance();
-    // Paper start - Don't copy
-    public final com.destroystokyo.paper.util.map.QueuedChangesMapLong2Object<ChunkHolder> updatingChunks = new com.destroystokyo.paper.util.map.QueuedChangesMapLong2Object<>();
-    // Paper end - Don't copy
+    // Paper - rewrite chunk system
     public static final int FORCED_TICKET_LEVEL = 31;
     // Paper - Don't copy
-    private final Long2ObjectLinkedOpenHashMap<ChunkHolder> pendingUnloads;
+    // Paper - rewrite chunk system
     public final LongSet entitiesInLevel;
     public final ServerLevel level;
     private final ThreadedLevelLightEngine lightEngine;
     public final BlockableEventLoop<Runnable> mainThreadExecutor; // Paper - public
-    final java.util.concurrent.Executor mainInvokingExecutor; // Paper
+    // Paper - rewrite chunk system
     public ChunkGenerator generator;
     private RandomState randomState;
     public final Supplier<DimensionDataStorage> overworldDataStorage;
     private final PoiManager poiManager;
-    public final LongSet toDrop;
+    // Paper - rewrite chunk system
     private boolean modified;
-    private final ChunkTaskPriorityQueueSorter queueSorter;
-    private final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> worldgenMailbox;
-    public final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> mainThreadMailbox;
+    // Paper - rewrite chunk system
     // Paper start
-    final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> mailboxLight;
+    // Paper - rewrite chunk system
     public void addLightTask(ChunkHolder playerchunk, Runnable run) {
-        this.mailboxLight.tell(ChunkTaskPriorityQueueSorter.message(playerchunk, run));
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
     // Paper end
     public final ChunkProgressListener progressListener;
     private final ChunkStatusUpdateListener chunkStatusListener;
     public final ChunkMap.ChunkDistanceManager distanceManager;
     private final AtomicInteger tickingGenerated;
-    private final StructureTemplateManager structureTemplateManager;
+    public final StructureTemplateManager structureTemplateManager; // Paper - rewrite chunk system
     private final String storageName;
     private final PlayerMap playerMap;
     public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap;
@@ -403,7 +399,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     public final ChunkHolder getUnloadingChunkHolder(int chunkX, int chunkZ) {
-        return this.pendingUnloads.get(io.papermc.paper.util.CoordinateUtils.getChunkKey(chunkX, chunkZ));
+        return null; // Paper - rewrite chunk system
     }
     // Paper end
 
@@ -411,9 +407,9 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public ChunkMap(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureTemplateManager structureTemplateManager, Executor executor, BlockableEventLoop<Runnable> mainThreadExecutor, LightChunkGetter chunkProvider, ChunkGenerator chunkGenerator, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory, int viewDistance, boolean dsync) {
         super(session.getDimensionPath(world.dimension()).resolve("region"), dataFixer, dsync);
         // Paper - don't copy
-        this.pendingUnloads = new Long2ObjectLinkedOpenHashMap();
+        // Paper - rewrite chunk system
         this.entitiesInLevel = new LongOpenHashSet();
-        this.toDrop = new LongOpenHashSet();
+        // Paper - rewrite chunk system
         this.tickingGenerated = new AtomicInteger();
         this.playerMap = new PlayerMap();
         this.entityMap = new Int2ObjectOpenHashMap();
@@ -440,29 +436,17 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
 
         this.mainThreadExecutor = mainThreadExecutor;
-        // Paper start
-        this.mainInvokingExecutor = (run) -> {
-            if (MCUtil.isMainThread()) {
-                run.run();
-            } else {
-                mainThreadExecutor.execute(run);
-            }
-        };
-        // Paper end
-        ProcessorMailbox<Runnable> threadedmailbox = ProcessorMailbox.create(executor, "worldgen");
+        // Paper - rewrite chunk system
 
         Objects.requireNonNull(mainThreadExecutor);
-        ProcessorHandle<Runnable> mailbox = ProcessorHandle.of("main", mainThreadExecutor::tell);
+        // Paper - rewrite chunk system
 
         this.progressListener = worldGenerationProgressListener;
         this.chunkStatusListener = chunkStatusChangeListener;
-        ProcessorMailbox<Runnable> lightthreaded; ProcessorMailbox<Runnable> threadedmailbox1 = lightthreaded = ProcessorMailbox.create(executor, "light"); // Paper
+        // Paper - rewrite chunk system
 
-        this.queueSorter = new ChunkTaskPriorityQueueSorter(ImmutableList.of(threadedmailbox, mailbox, threadedmailbox1), executor, Integer.MAX_VALUE);
-        this.worldgenMailbox = this.queueSorter.getProcessor(threadedmailbox, false);
-        this.mainThreadMailbox = this.queueSorter.getProcessor(mailbox, false);
-        this.mailboxLight = this.queueSorter.getProcessor(lightthreaded, false);// Paper
-        this.lightEngine = new ThreadedLevelLightEngine(chunkProvider, this, this.level.dimensionType().hasSkyLight(), threadedmailbox1, this.queueSorter.getProcessor(threadedmailbox1, false));
+        // Paper - rewrite chunk system
+        this.lightEngine = new ThreadedLevelLightEngine(chunkProvider, this, this.level.dimensionType().hasSkyLight(), null, null); // Paper - rewrite chunk system
         this.distanceManager = new ChunkMap.ChunkDistanceManager(executor, mainThreadExecutor);
         this.overworldDataStorage = persistentStateManagerFactory;
         this.poiManager = new PoiManager(path.resolve("poi"), dataFixer, dsync, world.registryAccess(), world);
@@ -581,36 +565,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         });
     }
 
-    // Paper start - Chunk Prioritization
-    public void queueHolderUpdate(ChunkHolder playerchunk) {
-        Runnable runnable = () -> {
-            if (isUnloading(playerchunk)) {
-                return; // unloaded
-            }
-            distanceManager.pendingChunkUpdates.add(playerchunk);
-            if (!distanceManager.pollingPendingChunkUpdates) {
-                level.getChunkSource().runDistanceManagerUpdates();
-            }
-        };
-        if (MCUtil.isMainThread()) {
-            // We can't use executor here because it will not execute tasks if its currently in the middle of executing tasks...
-            runnable.run();
-        } else {
-            mainThreadExecutor.execute(runnable);
-        }
-    }
-
-    private boolean isUnloading(ChunkHolder playerchunk) {
-        return playerchunk == null || toDrop.contains(playerchunk.pos.toLong());
-    }
-
-    private void updateChunkPriorityMap(it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap map, long chunk, int level) {
-        int prev = map.getOrDefault(chunk, -1);
-        if (level > prev) {
-            map.put(chunk, level);
-        }
-    }
-    // Paper end
+    // Paper - rewrite chunk system
 
     // Paper start
     public void updatePlayerMobTypeMap(Entity entity) {
@@ -668,25 +623,22 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
     @Nullable
     public ChunkHolder getUpdatingChunkIfPresent(long pos) {
-        return this.updatingChunks.getUpdating(pos); // Paper - Don't copy
+        // Paper start - rewrite chunk system
+        io.papermc.paper.chunk.system.scheduling.NewChunkHolder holder = this.level.chunkTaskScheduler.chunkHolderManager.getChunkHolder(pos);
+        return holder == null ? null : holder.vanillaChunkHolder;
+        // Paper end - rewrite chunk system
     }
 
     @Nullable
     public ChunkHolder getVisibleChunkIfPresent(long pos) {
-        // Paper start - Don't copy
-        if (Thread.currentThread() == this.level.thread) {
-            return this.updatingChunks.getVisible(pos);
-        }
-        return this.updatingChunks.getVisibleAsync(pos);
-        // Paper end - Don't copy
+        // Paper start - rewrite chunk system
+        io.papermc.paper.chunk.system.scheduling.NewChunkHolder holder = this.level.chunkTaskScheduler.chunkHolderManager.getChunkHolder(pos);
+        return holder == null ? null : holder.vanillaChunkHolder;
+        // Paper end - rewrite chunk system
     }
 
     protected IntSupplier getChunkQueueLevel(long pos) {
-        return () -> {
-            ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos);
-
-            return playerchunk == null ? ChunkTaskPriorityQueue.PRIORITY_LEVEL_COUNT - 1 : Math.min(playerchunk.getQueueLevel(), ChunkTaskPriorityQueue.PRIORITY_LEVEL_COUNT - 1);
-        };
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     public String getChunkDebugData(ChunkPos chunkPos) {
@@ -723,84 +675,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // Paper end
 
     private CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> getChunkRangeFuture(ChunkPos centerChunk, int margin, IntFunction<ChunkStatus> distanceToStatus) {
-        List<CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> list = new ArrayList();
-        List<ChunkHolder> list1 = new ArrayList();
-        int j = centerChunk.x;
-        int k = centerChunk.z;
-        ChunkHolder requestingNeighbor = getUpdatingChunkIfPresent(centerChunk.toLong()); // Paper
-
-        for (int l = -margin; l <= margin; ++l) {
-            for (int i1 = -margin; i1 <= margin; ++i1) {
-                int j1 = Math.max(Math.abs(i1), Math.abs(l));
-                final ChunkPos chunkcoordintpair1 = new ChunkPos(j + i1, k + l);
-                long k1 = chunkcoordintpair1.toLong();
-                ChunkHolder playerchunk = this.getUpdatingChunkIfPresent(k1);
-
-                if (playerchunk == null) {
-                    return CompletableFuture.completedFuture(Either.right(new ChunkHolder.ChunkLoadingFailure() {
-                        public String toString() {
-                            return "Unloaded " + chunkcoordintpair1;
-                        }
-                    }));
-                }
-
-                ChunkStatus chunkstatus = (ChunkStatus) distanceToStatus.apply(j1);
-                CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = playerchunk.getOrScheduleFuture(chunkstatus, this);
-                // Paper start
-                if (requestingNeighbor != null && requestingNeighbor != playerchunk && !completablefuture.isDone()) {
-                    requestingNeighbor.onNeighborRequest(playerchunk, chunkstatus);
-                    completablefuture.thenAccept(either -> {
-                        requestingNeighbor.onNeighborDone(playerchunk, chunkstatus, either.left().orElse(null));
-                    });
-                }
-                // Paper end
-
-                list1.add(playerchunk);
-                list.add(completablefuture);
-            }
-        }
-
-        CompletableFuture<List<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> completablefuture1 = Util.sequence(list);
-        CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> completablefuture2 = completablefuture1.thenApply((list2) -> {
-            List<ChunkAccess> list3 = Lists.newArrayList();
-            // CraftBukkit start - decompile error
-            int cnt = 0;
-
-            for (Iterator iterator = list2.iterator(); iterator.hasNext(); ++cnt) {
-                final int l1 = cnt;
-                // CraftBukkit end
-                final Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = (Either) iterator.next();
-
-                if (either == null) {
-                    throw this.debugFuturesAndCreateReportedException(new IllegalStateException("At least one of the chunk futures were null"), "n/a");
-                }
-
-                Optional<ChunkAccess> optional = either.left();
-
-                if (!optional.isPresent()) {
-                    return Either.right(new ChunkHolder.ChunkLoadingFailure() {
-                        public String toString() {
-                            ChunkPos chunkcoordintpair2 = new ChunkPos(j + l1 % (margin * 2 + 1), k + l1 / (margin * 2 + 1));
-
-                            return "Unloaded " + chunkcoordintpair2 + " " + either.right().get();
-                        }
-                    });
-                }
-
-                list3.add((ChunkAccess) optional.get());
-            }
-
-            return Either.left(list3);
-        });
-        Iterator iterator = list1.iterator();
-
-        while (iterator.hasNext()) {
-            ChunkHolder playerchunk1 = (ChunkHolder) iterator.next();
-
-            playerchunk1.addSaveDependency("getChunkRangeFuture " + centerChunk + " " + margin, completablefuture2);
-        }
-
-        return completablefuture2;
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     public ReportedException debugFuturesAndCreateReportedException(IllegalStateException exception, String details) {
@@ -818,9 +693,9 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         };
 
         stringbuilder.append("Updating:").append(System.lineSeparator());
-        this.updatingChunks.getUpdatingValuesCopy().forEach(consumer); // Paper
+        // Paper - rewrite chunk system TODO
         stringbuilder.append("Visible:").append(System.lineSeparator());
-        this.updatingChunks.getVisibleValuesCopy().forEach(consumer); // Paper
+        // Paper - rewrite chunk system TODO
         CrashReport crashreport = CrashReport.forThrowable(exception, "Chunk loading");
         CrashReportCategory crashreportsystemdetails = crashreport.addCategory("Chunk loading");
 
@@ -830,65 +705,17 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> prepareEntityTickingChunk(ChunkPos pos) {
-        return this.getChunkRangeFuture(pos, 2, (i) -> {
-            return ChunkStatus.FULL;
-        }).thenApplyAsync((either) -> {
-            return either.mapLeft((list) -> {
-                return (LevelChunk) list.get(list.size() / 2);
-            });
-        }, this.mainInvokingExecutor); // Paper
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     @Nullable
     ChunkHolder updateChunkScheduling(long pos, int level, @Nullable ChunkHolder holder, int k) {
-        if (this.unloadingPlayerChunk) { net.minecraft.server.MinecraftServer.LOGGER.error("Cannot tick distance manager while unloading playerchunks", new Throwable()); throw new IllegalStateException("Cannot tick distance manager while unloading playerchunks"); } // Paper
-        if (k > ChunkMap.MAX_CHUNK_DISTANCE && level > ChunkMap.MAX_CHUNK_DISTANCE) {
-            return holder;
-        } else {
-            if (holder != null) {
-                holder.setTicketLevel(level);
-            }
-
-            if (holder != null) {
-                if (level > ChunkMap.MAX_CHUNK_DISTANCE) {
-                    this.toDrop.add(pos);
-                } else {
-                    this.toDrop.remove(pos);
-                }
-            }
-
-            if (level <= ChunkMap.MAX_CHUNK_DISTANCE && holder == null) {
-                holder = (ChunkHolder) this.pendingUnloads.remove(pos);
-                if (holder != null) {
-                    holder.setTicketLevel(level);
-                    holder.onChunkAdd(); // Paper - optimise anyPlayerCloseEnoughForSpawning - PUT HERE AFTER RE-ADDING ONLY
-                } else {
-                    holder = new ChunkHolder(new ChunkPos(pos), level, this.level, this.lightEngine, this.queueSorter, this);
-                    // Paper start
-                    for (int index = 0, len = this.regionManagers.size(); index < len; ++index) {
-                        this.regionManagers.get(index).addChunk(holder.pos.x, holder.pos.z);
-                    }
-                    // Paper end
-                }
-                this.getPoiManager().dequeueUnload(holder.pos.longKey); // Paper - unload POI data
-
-                this.updatingChunks.queueUpdate(pos, holder); // Paper - Don't copy
-                this.modified = true;
-            }
-
-            return holder;
-        }
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     @Override
     public void close() throws IOException {
-        try {
-            this.queueSorter.close();
-            this.level.asyncChunkTaskManager.close(true); // Paper - Required since we're closing regionfiles in the next line
-            this.poiManager.close();
-        } finally {
-            super.close();
-        }
+        throw new UnsupportedOperationException("Use ServerChunkCache#close"); // Paper - rewrite chunk system
 
     }
 
@@ -903,100 +730,12 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     });
 
     protected void saveIncrementally() {
-        int savedThisTick = 0;
-        // optimized since we search far less chunks to hit ones that need to be saved
-        List<ChunkHolder> reschedule = new java.util.ArrayList<>(this.level.paperConfig().chunks.maxAutoSaveChunksPerTick);
-        long currentTick = this.level.getGameTime();
-        long maxSaveTime = currentTick - this.level.paperConfig().chunks.autoSaveInterval.value();
-
-        for (Iterator<ChunkHolder> iterator = this.autoSaveQueue.iterator(); iterator.hasNext();) {
-            ChunkHolder playerchunk = iterator.next();
-            if (playerchunk.lastAutoSaveTime > maxSaveTime) {
-                break;
-            }
-
-            iterator.remove();
-
-            ChunkAccess ichunkaccess = playerchunk.getChunkToSave().getNow(null);
-            if (ichunkaccess instanceof LevelChunk) {
-                boolean shouldSave = ((LevelChunk)ichunkaccess).lastSaveTime <= maxSaveTime;
-
-                if (shouldSave && this.save(ichunkaccess) && this.level.entityManager.storeChunkSections(playerchunk.pos.toLong(), entity -> {})) {
-                    ++savedThisTick;
-
-                    if (!playerchunk.setHasBeenLoaded()) {
-                        // do not fall through to reschedule logic
-                        playerchunk.inactiveTimeStart = currentTick;
-                        if (savedThisTick >= this.level.paperConfig().chunks.maxAutoSaveChunksPerTick) {
-                            break;
-                        }
-                        continue;
-                    }
-                }
-            }
-
-            reschedule.add(playerchunk);
-
-            if (savedThisTick >= this.level.paperConfig().chunks.maxAutoSaveChunksPerTick) {
-                break;
-            }
-        }
-
-        for (int i = 0, len = reschedule.size(); i < len; ++i) {
-            ChunkHolder playerchunk = reschedule.get(i);
-            playerchunk.lastAutoSaveTime = this.level.getGameTime();
-            this.autoSaveQueue.add(playerchunk);
-        }
+        this.level.chunkTaskScheduler.chunkHolderManager.autoSave(); // Paper - rewrite chunk system
     }
     // Paper end
 
     protected void saveAllChunks(boolean flush) {
-        // Paper start - do not overload I/O threads with too much work when saving
-        int[] saved = new int[1];
-        int maxAsyncSaves = 50;
-        Runnable onChunkSave = () -> {
-            if (++saved[0] >= maxAsyncSaves) {
-                saved[0] = 0;
-                com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.flush();
-            }
-        };
-        // Paper end - do not overload I/O threads with too much work when saving
-        if (flush) {
-            List<ChunkHolder> list = (List) this.updatingChunks.getVisibleValuesCopy().stream().filter(ChunkHolder::wasAccessibleSinceLastSave).peek(ChunkHolder::refreshAccessibility).collect(Collectors.toList()); // Paper
-            MutableBoolean mutableboolean = new MutableBoolean();
-
-            do {
-                boolean isShuttingDown = level.getServer().hasStopped(); // Paper
-                mutableboolean.setFalse();
-                list.stream().map((playerchunk) -> {
-                    CompletableFuture completablefuture;
-
-                    do {
-                        completablefuture = playerchunk.getChunkToSave();
-                        BlockableEventLoop iasynctaskhandler = this.mainThreadExecutor;
-
-                        Objects.requireNonNull(completablefuture);
-                        iasynctaskhandler.managedBlock(completablefuture::isDone);
-                    } while (completablefuture != playerchunk.getChunkToSave());
-
-                    return (ChunkAccess) completablefuture.join();
-                }).filter((ichunkaccess) -> {
-                    return ichunkaccess instanceof ImposterProtoChunk || ichunkaccess instanceof LevelChunk;
-                }).filter(this::save).forEach((ichunkaccess) -> {
-                    onChunkSave.run(); // Paper - do not overload I/O threads with too much work when saving
-                    mutableboolean.setTrue();
-                });
-            } while (mutableboolean.isTrue());
-
-            this.processUnloads(() -> {
-                return true;
-            });
-            //this.flushWorker(); // Paper - nuke IOWorker
-            this.level.asyncChunkTaskManager.flush(); // Paper - flush to preserve behavior compat with pre-async behaviour
-        } else {
-            this.updatingChunks.getVisibleValuesCopy().forEach(this::saveChunkIfNeeded); // Paper
-        }
-
+        this.level.chunkTaskScheduler.chunkHolderManager.saveAllChunks(flush, false, false); // Paper - rewrite chunk system
     }
 
     protected void tick(BooleanSupplier shouldKeepTicking) {
@@ -1017,212 +756,28 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     public boolean hasWork() {
-        return this.lightEngine.hasLightWork() || !this.pendingUnloads.isEmpty() || !this.updatingChunks.getUpdatingValuesCopy().isEmpty() || this.poiManager.hasWork() || !this.toDrop.isEmpty() || !this.unloadQueue.isEmpty() || this.queueSorter.hasWork() || this.distanceManager.hasTickets(); // Paper
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     private void processUnloads(BooleanSupplier shouldKeepTicking) {
-        LongIterator longiterator = this.toDrop.iterator();
-        for (int i = 0; longiterator.hasNext() && (shouldKeepTicking.getAsBoolean() || i < 200 || this.toDrop.size() > 2000); longiterator.remove()) { // Paper - diff on change
-            long j = longiterator.nextLong();
-            ChunkHolder playerchunk = this.updatingChunks.queueRemove(j); // Paper - Don't copy
-
-            if (playerchunk != null) {
-                playerchunk.onChunkRemove(); // Paper
-                this.pendingUnloads.put(j, playerchunk);
-                this.modified = true;
-                ++i;
-                this.scheduleUnload(j, playerchunk);
-            }
-        }
-
-        int k = Math.max(100, this.unloadQueue.size() - 2000); // Paper - Unload more than just up to queue size 2000
-
-        Runnable runnable;
-
-        while ((shouldKeepTicking.getAsBoolean() || k > 0) && (runnable = (Runnable) this.unloadQueue.poll()) != null) {
-            --k;
-            runnable.run();
-        }
-
-        int l = 0;
-        // Paper - incremental chunk and player saving
+        this.level.chunkTaskScheduler.chunkHolderManager.processUnloads(); // Paper - rewrite chunk system
 
     }
 
     private void scheduleUnload(long pos, ChunkHolder holder) {
-        CompletableFuture<ChunkAccess> completablefuture = holder.getChunkToSave();
-        Consumer<ChunkAccess> consumer = (ichunkaccess) -> { // CraftBukkit - decompile error
-            CompletableFuture<ChunkAccess> completablefuture1 = holder.getChunkToSave();
-
-            if (completablefuture1 != completablefuture) {
-                this.scheduleUnload(pos, holder);
-            } else {
-                // Paper start - do not allow ticket level changes while unloading chunks
-                org.spigotmc.AsyncCatcher.catchOp("playerchunk unload");
-                boolean unloadingBefore = this.unloadingPlayerChunk;
-                this.unloadingPlayerChunk = true;
-                try {
-                    // Paper end - do not allow ticket level changes while unloading chunks
-                // Paper start
-                boolean removed;
-                if ((removed = this.pendingUnloads.remove(pos, holder)) && ichunkaccess != null) {
-                    for (int index = 0, len = this.regionManagers.size(); index < len; ++index) {
-                        this.regionManagers.get(index).removeChunk(holder.pos.x, holder.pos.z);
-                    }
-                    // Paper end
-                    this.getPoiManager().queueUnload(holder.pos.longKey, MinecraftServer.currentTickLong + 1); // Paper - unload POI data
-                    if (ichunkaccess instanceof LevelChunk) {
-                        ((LevelChunk) ichunkaccess).setLoaded(false);
-                    }
-
-                    // Paper start - async chunk saving
-                    try {
-                        this.asyncSave(ichunkaccess);
-                    } catch (ThreadDeath ex) {
-                        throw ex; // bye
-                    } catch (Throwable ex) {
-                        LOGGER.error("Failed to prepare async save, attempting synchronous save", ex);
-                        this.save(ichunkaccess);
-                    }
-                    // Paper end - async chunk saving
-                    if (this.entitiesInLevel.remove(pos) && ichunkaccess instanceof LevelChunk) {
-                        LevelChunk chunk = (LevelChunk) ichunkaccess;
-
-                        this.level.unload(chunk);
-                    }
-                    this.autoSaveQueue.remove(holder); // Paper
-
-                    this.lightEngine.updateChunkStatus(ichunkaccess.getPos());
-                    this.lightEngine.tryScheduleUpdate();
-                    this.progressListener.onStatusChange(ichunkaccess.getPos(), (ChunkStatus) null);
-                    this.chunkSaveCooldowns.remove(ichunkaccess.getPos().toLong());
-                } else if (removed) { // Paper start
-                for (int index = 0, len = this.regionManagers.size(); index < len; ++index) {
-                    this.regionManagers.get(index).removeChunk(holder.pos.x, holder.pos.z);
-                }
-                this.getPoiManager().queueUnload(holder.pos.longKey, MinecraftServer.currentTickLong + 1); // Paper - unload POI data
-            } // Paper end
-                } finally { this.unloadingPlayerChunk = unloadingBefore; } // Paper - do not allow ticket level changes while unloading chunks
-
-            }
-        };
-        Queue queue = this.unloadQueue;
-
-        Objects.requireNonNull(this.unloadQueue);
-        completablefuture.thenAcceptAsync(consumer, queue::add).whenComplete((ovoid, throwable) -> {
-            if (throwable != null) {
-                ChunkMap.LOGGER.error("Failed to save chunk {}", holder.getPos(), throwable);
-            }
-
-        });
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     protected boolean promoteChunkMap() {
-        if (!this.modified) {
-            return false;
-        } else {
-            // Paper start - Don't copy
-            synchronized (this.updatingChunks) {
-                this.updatingChunks.performUpdates();
-            }
-            // Paper end - Don't copy
-
-            this.modified = false;
-            return true;
-        }
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> schedule(ChunkHolder holder, ChunkStatus requiredStatus) {
-        ChunkPos chunkcoordintpair = holder.getPos();
-
-        if (requiredStatus == ChunkStatus.EMPTY) {
-            return this.scheduleChunkLoad(chunkcoordintpair);
-        } else {
-            // Paper start - revert 1.17 chunk system changes
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = holder.getOrScheduleFuture(requiredStatus.getParent(), this);
-        return future.thenComposeAsync((either) -> {
-            Optional<ChunkAccess> optional = either.left();
-            if (!optional.isPresent()) {
-                return CompletableFuture.completedFuture(either);
-            }
-            // Paper end - revert 1.17 chunk system changes
-            if (requiredStatus == ChunkStatus.LIGHT) {
-                this.distanceManager.addTicket(TicketType.LIGHT, chunkcoordintpair, 33 + ChunkStatus.getDistance(ChunkStatus.LIGHT), chunkcoordintpair);
-            }
-
-            // Paper - revert 1.17 chunk system changes
-
-            if (optional.isPresent() && ((ChunkAccess) optional.get()).getStatus().isOrAfter(requiredStatus)) {
-                CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = requiredStatus.load(this.level, this.structureTemplateManager, this.lightEngine, (ichunkaccess) -> {
-                    return this.protoChunkToFullChunk(holder);
-                }, (ChunkAccess) optional.get());
-
-                this.progressListener.onStatusChange(chunkcoordintpair, requiredStatus);
-                return completablefuture;
-            } else {
-                return this.scheduleChunkGeneration(holder, requiredStatus);
-            }
-        }, this.mainThreadExecutor).thenComposeAsync(CompletableFuture::completedFuture, this.mainThreadExecutor); // Paper - revert 1.17 chunk system changes
-        }
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> scheduleChunkLoad(ChunkPos pos) {
-        // Paper start - Async chunk io
-        final java.util.function.BiFunction<ChunkSerializer.InProgressChunkHolder, Throwable, Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> syncLoadComplete = (chunkHolder, ioThrowable) -> {
-            try (Timing ignored = this.level.timings.chunkLoad.startTimingIfSync()) { // Paper
-                this.level.getProfiler().incrementCounter("chunkLoad");
-                if (ioThrowable != null) {
-                    return this.handleChunkLoadFailure(ioThrowable, pos);
-                }
-                this.poiManager.loadInData(pos, chunkHolder.poiData);
-                chunkHolder.tasks.forEach(Runnable::run);
-                this.getPoiManager().dequeueUnload(pos.longKey); // Paper
-
-                if (chunkHolder.protoChunk != null) {
-                    ProtoChunk protochunk = chunkHolder.protoChunk;
-                    this.markPosition(pos, protochunk.getStatus().getChunkType());
-                    return Either.left(protochunk);
-                }
-            } catch (Exception ex) {
-                return this.handleChunkLoadFailure(ex, pos);
-            }
-
-            return Either.left(this.createEmptyChunk(pos));
-        };
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> ret = new CompletableFuture<>();
-
-        Consumer<ChunkSerializer.InProgressChunkHolder> chunkHolderConsumer = (ChunkSerializer.InProgressChunkHolder holder) -> {
-            // Go into the chunk load queue and not server task queue so we can be popped out even faster.
-            com.destroystokyo.paper.io.chunk.ChunkTaskManager.queueChunkWaitTask(() -> {
-                try {
-                    ret.complete(syncLoadComplete.apply(holder, null));
-                } catch (Exception e) {
-                    ret.completeExceptionally(e);
-                }
-            });
-        };
-
-        CompletableFuture<CompoundTag> chunkSaveFuture = this.level.asyncChunkTaskManager.getChunkSaveFuture(pos.x, pos.z);
-        // Paper start
-        ChunkHolder playerChunk = getUpdatingChunkIfPresent(pos.toLong());
-        int chunkPriority = playerChunk != null ? playerChunk.requestedPriority : 33;
-        int priority = com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY;
-
-        if (chunkPriority <= 10) {
-            priority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY;
-        } else if (chunkPriority <= 20) {
-            priority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGH_PRIORITY;
-        }
-        boolean isHighestPriority = priority == com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY;
-        // Paper end
-        if (chunkSaveFuture != null) {
-            this.level.asyncChunkTaskManager.scheduleChunkLoad(pos.x, pos.z, priority, chunkHolderConsumer, isHighestPriority, chunkSaveFuture); // Paper
-        } else {
-            this.level.asyncChunkTaskManager.scheduleChunkLoad(pos.x, pos.z, priority, chunkHolderConsumer, isHighestPriority); // Paper
-        }
-        this.level.asyncChunkTaskManager.raisePriority(pos.x, pos.z, priority); // Paper
-        return ret;
-        // Paper end - Async chunk io
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     public static boolean isChunkDataValid(CompoundTag nbt) { // Paper - async chunk loading
@@ -1261,54 +816,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> scheduleChunkGeneration(ChunkHolder holder, ChunkStatus requiredStatus) {
-        ChunkPos chunkcoordintpair = holder.getPos();
-        CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getChunkRangeFuture(chunkcoordintpair, requiredStatus.getRange(), (i) -> {
-            return this.getDependencyStatus(requiredStatus, i);
-        });
-
-        this.level.getProfiler().incrementCounter(() -> {
-            return "chunkGenerate " + requiredStatus.getName();
-        });
-        Executor executor = (runnable) -> {
-            // Paper start - optimize chunk status progression without jumping through thread pool
-            if (holder.canAdvanceStatus()) {
-                this.mainInvokingExecutor.execute(runnable);
-                return;
-            }
-            // Paper end
-            this.worldgenMailbox.tell(ChunkTaskPriorityQueueSorter.message(holder, runnable));
-        };
-
-        return completablefuture.thenComposeAsync((either) -> {
-            return (CompletionStage) either.map((list) -> {
-                try {
-                    CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture1 = requiredStatus.generate(executor, this.level, this.generator, this.structureTemplateManager, this.lightEngine, (ichunkaccess) -> {
-                        return this.protoChunkToFullChunk(holder);
-                    }, list, false);
-
-                    this.progressListener.onStatusChange(chunkcoordintpair, requiredStatus);
-                    return completablefuture1;
-                } catch (Exception exception) {
-                    exception.getStackTrace();
-                    CrashReport crashreport = CrashReport.forThrowable(exception, "Exception generating new chunk");
-                    CrashReportCategory crashreportsystemdetails = crashreport.addCategory("Chunk to be generated");
-
-                    crashreportsystemdetails.setDetail("Location", (Object) String.format(Locale.ROOT, "%d,%d", chunkcoordintpair.x, chunkcoordintpair.z));
-                    crashreportsystemdetails.setDetail("Position hash", (Object) ChunkPos.asLong(chunkcoordintpair.x, chunkcoordintpair.z));
-                    crashreportsystemdetails.setDetail("Generator", (Object) this.generator);
-                    this.mainThreadExecutor.execute(() -> {
-                        throw new ReportedException(crashreport);
-                    });
-                    throw new ReportedException(crashreport);
-                }
-            }, (playerchunk_failure) -> {
-                this.releaseLightTicket(chunkcoordintpair);
-                return CompletableFuture.completedFuture(Either.right(playerchunk_failure));
-            });
-        }, executor).thenComposeAsync((either) -> { // Paper start - force competion on the main thread
-            return CompletableFuture.completedFuture(either);
-        }, this.mainThreadExecutor); // use the main executor, we want to ensure only one chunk callback can be completed per runnable execute
-        // Paper end - force competion on the main thread
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     protected void releaseLightTicket(ChunkPos pos) {
@@ -1319,7 +827,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }));
     }
 
-    private ChunkStatus getDependencyStatus(ChunkStatus centerChunkTargetStatus, int distance) {
+    public static ChunkStatus getDependencyStatus(ChunkStatus centerChunkTargetStatus, int distance) { // Paper -> public, static
         ChunkStatus chunkstatus1;
 
         if (distance == 0) {
@@ -1331,7 +839,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         return chunkstatus1;
     }
 
-    private static void postLoadProtoChunk(ServerLevel world, List<CompoundTag> nbt) {
+    public static void postLoadProtoChunk(ServerLevel world, List<CompoundTag> nbt) { // Paper - public
         if (!nbt.isEmpty()) {
             // CraftBukkit start - these are spawned serialized (DefinedStructure) and we don't call an add event below at the moment due to ordering complexities
             world.addWorldGenChunkEntities(EntityType.loadEntitiesRecursive(nbt, world).filter((entity) -> {
@@ -1354,46 +862,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> protoChunkToFullChunk(ChunkHolder chunkHolder) {
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = chunkHolder.getFutureIfPresentUnchecked(ChunkStatus.FULL.getParent());
-
-        return completablefuture.thenApplyAsync((either) -> {
-            ChunkStatus chunkstatus = ChunkHolder.getStatus(chunkHolder.getTicketLevel());
-
-            return !chunkstatus.isOrAfter(ChunkStatus.FULL) ? ChunkHolder.UNLOADED_CHUNK : either.mapLeft((ichunkaccess) -> {
-                try (Timing ignored = level.timings.chunkPostLoad.startTimingIfSync()) { // Paper
-                ChunkPos chunkcoordintpair = chunkHolder.getPos();
-                ProtoChunk protochunk = (ProtoChunk) ichunkaccess;
-                LevelChunk chunk;
-
-                if (protochunk instanceof ImposterProtoChunk) {
-                    chunk = ((ImposterProtoChunk) protochunk).getWrapped();
-                } else {
-                    chunk = new LevelChunk(this.level, protochunk, (chunk1) -> {
-                        ChunkMap.postLoadProtoChunk(this.level, protochunk.getEntities());
-                    });
-                    chunkHolder.replaceProtoChunk(new ImposterProtoChunk(chunk, false));
-                }
-
-                chunk.setFullStatus(() -> {
-                    return ChunkHolder.getFullChunkStatus(chunkHolder.getTicketLevel());
-                });
-                chunk.runPostLoad();
-                if (this.entitiesInLevel.add(chunkcoordintpair.toLong())) {
-                    chunk.setLoaded(true);
-                    chunk.registerAllBlockEntitiesAfterLevelLoad();
-                    chunk.registerTickContainerInLevel(this.level);
-                }
-
-                return chunk;
-                } // Paper
-            });
-        }, (runnable) -> {
-            ProcessorHandle mailbox = this.mainThreadMailbox;
-            long i = chunkHolder.getPos().toLong();
-
-            Objects.requireNonNull(chunkHolder);
-            mailbox.tell(ChunkTaskPriorityQueueSorter.message(runnable, i, () -> 1)); // Paper - final loads are always urgent!
-        });
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     // Paper start
@@ -1434,31 +903,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
     // Paper end
     public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> prepareTickingChunk(ChunkHolder holder) {
-        ChunkPos chunkcoordintpair = holder.getPos();
-        CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getChunkRangeFuture(chunkcoordintpair, 1, (i) -> {
-            return ChunkStatus.FULL;
-        });
-        CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completablefuture1 = completablefuture.thenApplyAsync((either) -> {
-            return either.mapLeft((list) -> {
-                // Paper start - revert 1.18.2 diff
-                final LevelChunk chunk = (LevelChunk) list.get(list.size() / 2);
-                chunk.postProcessGeneration();
-                this.level.startTickingChunk(chunk);
-                return chunk;
-            });
-        }, (runnable) -> {
-            this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(holder, () -> ChunkMap.this.chunkLoadConversionCallbackExecutor.execute(runnable))); // Paper - delay running Chunk post processing until outside of the sorter to prevent a deadlock scenario when post processing causes another chunk request.
-        }); // Paper end - revert 1.18.2 diff
-
-        completablefuture1.thenAcceptAsync((either) -> {
-            either.ifLeft((chunk) -> {
-                this.tickingGenerated.getAndIncrement();
-                // Paper - no-tick view distance - moved to Chunk neighbour update
-            });
-        }, (runnable) -> {
-            this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(holder, runnable));
-        });
-        return completablefuture1;
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> prepareAccessibleChunk(ChunkHolder holder) {
@@ -1476,32 +921,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     private boolean saveChunkIfNeeded(ChunkHolder chunkHolder) {
-        if (!chunkHolder.wasAccessibleSinceLastSave()) {
-            return false;
-        } else {
-            ChunkAccess ichunkaccess = (ChunkAccess) chunkHolder.getChunkToSave().getNow(null); // CraftBukkit - decompile error
-
-            if (!(ichunkaccess instanceof ImposterProtoChunk) && !(ichunkaccess instanceof LevelChunk)) {
-                return false;
-            } else {
-                long i = ichunkaccess.getPos().toLong();
-                long j = this.chunkSaveCooldowns.getOrDefault(i, -1L);
-                long k = System.currentTimeMillis();
-
-                if (k < j) {
-                    return false;
-                } else {
-                    boolean flag = this.save(ichunkaccess);
-
-                    chunkHolder.refreshAccessibility();
-                    if (flag) {
-                        this.chunkSaveCooldowns.put(i, k + 10000L);
-                    }
-
-                    return flag;
-                }
-            }
-        }
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     // Paper start - async chunk save for unload
@@ -1509,110 +929,16 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // This is also modeled after PlayerChunkMap#save(IChunkAccess, boolean), with the intentional difference being
     // serializing the chunk is left to a worker thread.
     private void asyncSave(ChunkAccess chunk) {
-        ChunkPos chunkPos = chunk.getPos();
-        CompoundTag poiData;
-        try (Timing ignored = this.level.timings.chunkUnloadPOISerialization.startTiming()) {
-            poiData = this.poiManager.getData(chunk.getPos());
-        }
-
-        com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(this.level, chunkPos.x, chunkPos.z,
-            poiData, null, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY);
-
-        if (!chunk.isUnsaved()) {
-            return;
-        }
-
-        ChunkStatus chunkstatus = chunk.getStatus();
-
-        // Copied from PlayerChunkMap#save(IChunkAccess, boolean)
-        if (chunkstatus.getChunkType() != ChunkStatus.ChunkType.LEVELCHUNK) {
-            // Paper start - Optimize save by using status cache
-            if (chunkstatus == ChunkStatus.EMPTY && chunk.getAllStarts().values().stream().noneMatch(StructureStart::isValid)) {
-                return;
-            }
-        }
-
-        ChunkSerializer.AsyncSaveData asyncSaveData;
-        try (Timing ignored = this.level.timings.chunkUnloadPrepareSave.startTiming()) {
-            asyncSaveData = ChunkSerializer.getAsyncSaveData(this.level, chunk);
-        }
-
-        this.level.asyncChunkTaskManager.scheduleChunkSave(chunkPos.x, chunkPos.z, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY,
-            asyncSaveData, chunk);
-
-        chunk.setUnsaved(false);
-        chunk.setLastSaved(this.level.getGameTime()); // Paper - track last saved time
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
     // Paper end
 
     public boolean save(ChunkAccess chunk) {
-        try (co.aikar.timings.Timing ignored = this.level.timings.chunkSave.startTiming()) { // Paper
-        this.poiManager.flush(chunk.getPos());
-        if (!chunk.isUnsaved()) {
-            return false;
-        } else {
-            chunk.setLastSaved(this.level.getGameTime()); // Paper - track save time
-            chunk.setUnsaved(false);
-            ChunkPos chunkcoordintpair = chunk.getPos();
-
-            try {
-                ChunkStatus chunkstatus = chunk.getStatus();
-
-                if (chunkstatus.getChunkType() != ChunkStatus.ChunkType.LEVELCHUNK) {
-                    if (false && this.isExistingChunkFull(chunkcoordintpair)) { // Paper
-                        return false;
-                    }
-
-                    if (chunkstatus == ChunkStatus.EMPTY && chunk.getAllStarts().values().stream().noneMatch(StructureStart::isValid)) {
-                        return false;
-                    }
-                }
-
-                this.level.getProfiler().incrementCounter("chunkSave");
-                CompoundTag nbttagcompound;
-                try (co.aikar.timings.Timing ignored1 = this.level.timings.chunkSaveDataSerialization.startTiming()) { // Paper
-                    nbttagcompound = ChunkSerializer.write(this.level, chunk);
-                } // Paper
-
-                // Paper start - async chunk io
-                com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(this.level, chunkcoordintpair.x, chunkcoordintpair.z,
-                    null, nbttagcompound, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY);
-                // Paper end - async chunk io
-                this.markPosition(chunkcoordintpair, chunkstatus.getChunkType());
-                return true;
-            } catch (Exception exception) {
-                ChunkMap.LOGGER.error("Failed to save chunk {},{}", new Object[]{chunkcoordintpair.x, chunkcoordintpair.z, exception});
-                com.destroystokyo.paper.exception.ServerInternalException.reportInternalException(exception); // Paper
-                return false;
-            }
-        }
-        } // Paper
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     private boolean isExistingChunkFull(ChunkPos pos) {
-        byte b0 = this.chunkTypeCache.get(pos.toLong());
-
-        if (b0 != 0) {
-            return b0 == 1;
-        } else {
-            CompoundTag nbttagcompound;
-
-            try {
-                nbttagcompound = (CompoundTag) ((Optional) this.readChunk(pos).join()).orElse((Object) null);
-                if (nbttagcompound == null) {
-                    this.markPositionReplaceable(pos);
-                    return false;
-                }
-            } catch (Exception exception) {
-                ChunkMap.LOGGER.error("Failed to read chunk {}", pos, exception);
-                this.markPositionReplaceable(pos);
-                return false;
-            }
-
-            ChunkStatus.ChunkType chunkstatus_type = ChunkSerializer.getChunkTypeFromTag(nbttagcompound);
-
-            return this.markPosition(pos, chunkstatus_type) == 1;
-        }
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     public void setViewDistance(int watchDistance) {
@@ -1657,7 +983,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     public int size() {
-        return this.updatingChunks.getVisibleMap().size(); // Paper - Don't copy
+        return this.level.chunkTaskScheduler.chunkHolderManager.size(); // Paper - rewrite chunk system
     }
 
     public DistanceManager getDistanceManager() {
@@ -1665,34 +991,11 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     protected Iterable<ChunkHolder> getChunks() {
-        return Iterables.unmodifiableIterable(this.updatingChunks.getVisibleValuesCopy()); // Paper
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system TODO
     }
 
     void dumpChunks(Writer writer) throws IOException {
-        CsvOutput csvwriter = CsvOutput.builder().addColumn("x").addColumn("z").addColumn("level").addColumn("in_memory").addColumn("status").addColumn("full_status").addColumn("accessible_ready").addColumn("ticking_ready").addColumn("entity_ticking_ready").addColumn("ticket").addColumn("spawning").addColumn("block_entity_count").addColumn("ticking_ticket").addColumn("ticking_level").addColumn("block_ticks").addColumn("fluid_ticks").build(writer);
-        // Paper - replace loader system
-        ObjectBidirectionalIterator objectbidirectionaliterator = this.updatingChunks.getVisibleMap().clone().long2ObjectEntrySet().fastIterator(); // Paper
-
-        while (objectbidirectionaliterator.hasNext()) {
-            Entry<ChunkHolder> entry = (Entry) objectbidirectionaliterator.next();
-            long i = entry.getLongKey();
-            ChunkPos chunkcoordintpair = new ChunkPos(i);
-            ChunkHolder playerchunk = (ChunkHolder) entry.getValue();
-            Optional<ChunkAccess> optional = Optional.ofNullable(playerchunk.getLastAvailable());
-            Optional<LevelChunk> optional1 = optional.flatMap((ichunkaccess) -> {
-                return ichunkaccess instanceof LevelChunk ? Optional.of((LevelChunk) ichunkaccess) : Optional.empty();
-            });
-
-            // CraftBukkit - decompile error
-            csvwriter.writeRow(chunkcoordintpair.x, chunkcoordintpair.z, playerchunk.getTicketLevel(), optional.isPresent(), optional.map(ChunkAccess::getStatus).orElse(null), optional1.map(LevelChunk::getFullStatus).orElse(null), ChunkMap.printFuture(playerchunk.getFullChunkFuture()), ChunkMap.printFuture(playerchunk.getTickingChunkFuture()), ChunkMap.printFuture(playerchunk.getEntityTickingChunkFuture()), this.distanceManager.getTicketDebugString(i), this.anyPlayerCloseEnoughForSpawning(chunkcoordintpair), optional1.map((chunk) -> {
-                return chunk.getBlockEntities().size();
-            }).orElse(0), "Use ticket level", -1000, optional1.map((chunk) -> { // Paper - replace loader system
-                return chunk.getBlockTicks().count();
-            }).orElse(0), optional1.map((chunk) -> {
-                return chunk.getFluidTicks().count();
-            }).orElse(0));
-        }
-
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system TODO
     }
 
     private static String printFuture(CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> future) {
@@ -1715,27 +1018,27 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     @Nullable
     @Override
     public CompoundTag readSync(ChunkPos chunkcoordintpair) throws IOException {
-        if (Thread.currentThread() != com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE) {
-            CompoundTag ret = com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE
-                .loadChunkDataAsyncFuture(this.level, chunkcoordintpair.x, chunkcoordintpair.z, com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread(),
-                    false, true, true).join().chunkData;
-
-            if (ret == com.destroystokyo.paper.io.PaperFileIOThread.FAILURE_VALUE) {
-                throw new IOException("See logs for further detail");
-            }
-            return ret;
-        }
+        // Paper start - rewrite chunk system
+        if (!io.papermc.paper.chunk.system.io.RegionFileIOThread.isRegionFileThread()) {
+            return io.papermc.paper.chunk.system.io.RegionFileIOThread.loadData(
+                this.level, chunkcoordintpair.x, chunkcoordintpair.z, io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.CHUNK_DATA,
+                io.papermc.paper.chunk.system.io.RegionFileIOThread.getIOBlockingPriorityForCurrentThread()
+            );
+        }
+        // Paper end - rewrite chunk system
         return super.readSync(chunkcoordintpair);
     }
 
     @Override
     public void write(ChunkPos chunkcoordintpair, CompoundTag nbttagcompound) throws IOException {
-        if (Thread.currentThread() != com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE) {
-            com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(
-                this.level, chunkcoordintpair.x, chunkcoordintpair.z, null, nbttagcompound,
-                com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
+        // Paper start - rewrite chunk system
+        if (!io.papermc.paper.chunk.system.io.RegionFileIOThread.isRegionFileThread()) {
+            io.papermc.paper.chunk.system.io.RegionFileIOThread.scheduleSave(
+                this.level, chunkcoordintpair.x, chunkcoordintpair.z, nbttagcompound,
+                io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.CHUNK_DATA);
             return;
         }
+        // Paper end - rewrite chunk system
         super.write(chunkcoordintpair, nbttagcompound);
     }
     // Paper end
@@ -1808,8 +1111,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     public ChunkAccess getUnloadingChunk(int chunkX, int chunkZ) {
-        ChunkHolder chunkHolder = this.pendingUnloads.get(ChunkPos.asLong(chunkX, chunkZ));
-        return chunkHolder == null ? null : chunkHolder.getAvailableChunkNow();
+        return null; // Paper - rewrite chunk system
     }
     // Paper end
 
@@ -2254,7 +1556,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
         @Override
         protected boolean isChunkToRemove(long pos) {
-            return ChunkMap.this.toDrop.contains(pos);
+            throw new UnsupportedOperationException(); // Paper - rewrite chunk system
         }
 
         @Nullable
diff --git a/src/main/java/net/minecraft/server/level/DistanceManager.java b/src/main/java/net/minecraft/server/level/DistanceManager.java
index d1b5c25b7455174e908cd6ed66789fa700190604..9dff3a10ce0d4285c41826e741061e64e2965297 100644
--- a/src/main/java/net/minecraft/server/level/DistanceManager.java
+++ b/src/main/java/net/minecraft/server/level/DistanceManager.java
@@ -1,171 +1,44 @@
 package net.minecraft.server.level;
 
-import com.google.common.annotations.VisibleForTesting;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Sets;
-import com.mojang.datafixers.util.Either;
 import com.mojang.logging.LogUtils;
-import it.unimi.dsi.fastutil.longs.Long2ByteMap;
-import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2IntMap;
-import it.unimi.dsi.fastutil.longs.Long2IntMaps;
-import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
-import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
-import it.unimi.dsi.fastutil.longs.LongIterator;
-import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import it.unimi.dsi.fastutil.longs.LongSet;
-import it.unimi.dsi.fastutil.objects.ObjectIterator;
-import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
-import it.unimi.dsi.fastutil.objects.ObjectSet;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-import java.util.Iterator;
-import java.util.Objects;
-import java.util.Set;
-import java.util.concurrent.CompletableFuture;
+import io.papermc.paper.chunk.system.scheduling.ChunkHolderManager;
+
 import java.util.concurrent.Executor;
 import javax.annotation.Nullable;
 import net.minecraft.core.SectionPos;
 import net.minecraft.util.SortedArraySet;
-import net.minecraft.util.thread.ProcessorHandle;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.chunk.ChunkStatus;
-import net.minecraft.world.level.chunk.LevelChunk;
 import org.slf4j.Logger;
 
-import it.unimi.dsi.fastutil.longs.Long2IntLinkedOpenHashMap; // Paper
 public abstract class DistanceManager {
 
+    // Paper start - rewrite chunk system
+    public ChunkHolderManager getChunkHolderManager() {
+        return this.chunkMap.level.chunkTaskScheduler.chunkHolderManager;
+    }
+    // Paper end - rewrite chunk system
+
     static final Logger LOGGER = LogUtils.getLogger();
     private static final int ENTITY_TICKING_RANGE = 2;
     static final int PLAYER_TICKET_LEVEL = 33 + ChunkStatus.getDistance(ChunkStatus.FULL) - 2;
     private static final int INITIAL_TICKET_LIST_CAPACITY = 4;
     private static final int ENTITY_TICKING_LEVEL_THRESHOLD = 32;
     private static final int BLOCK_TICKING_LEVEL_THRESHOLD = 33;
-    final Long2ObjectMap<ObjectSet<ServerPlayer>> playersPerChunk = new Long2ObjectOpenHashMap();
-    public final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> tickets = new Long2ObjectOpenHashMap();
-    //private final DistanceManager.ChunkTicketTracker ticketTracker = new DistanceManager.ChunkTicketTracker(); // Paper - replace ticket level propagator
+    // Paper - rewrite chunk system
     public static final int MOB_SPAWN_RANGE = 8; // private final ChunkMapDistance.b f = new ChunkMapDistance.b(8); // Paper - no longer used
-    //private final TickingTracker tickingTicketsTracker = new TickingTracker(); // Paper - no longer used
-    //private final DistanceManager.PlayerTicketTracker playerTicketManager = new DistanceManager.PlayerTicketTracker(33); // Paper - no longer used
-    // Paper start use a queue, but still keep unique requirement
-    public final java.util.Queue<ChunkHolder> pendingChunkUpdates = new java.util.ArrayDeque<ChunkHolder>() {
-        @Override
-        public boolean add(ChunkHolder o) {
-            if (o.isUpdateQueued) return true;
-            o.isUpdateQueued = true;
-            return super.add(o);
-        }
-    };
-    // Paper end
-    final ChunkTaskPriorityQueueSorter ticketThrottler;
-    final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> ticketThrottlerInput;
-    final ProcessorHandle<ChunkTaskPriorityQueueSorter.Release> ticketThrottlerReleaser;
-    final LongSet ticketsToRelease = new LongOpenHashSet();
-    final Executor mainThreadExecutor;
-    private long ticketTickCounter;
-    private int simulationDistance = 10;
+    // Paper - rewrite chunk system
     private final ChunkMap chunkMap; // Paper
 
     protected DistanceManager(Executor workerExecutor, Executor mainThreadExecutor, ChunkMap chunkMap) {
-        Objects.requireNonNull(mainThreadExecutor);
-        ProcessorHandle<Runnable> mailbox = ProcessorHandle.of("player ticket throttler", mainThreadExecutor::execute);
-        ChunkTaskPriorityQueueSorter chunktaskqueuesorter = new ChunkTaskPriorityQueueSorter(ImmutableList.of(mailbox), workerExecutor, 4);
-
-        this.ticketThrottler = chunktaskqueuesorter;
-        this.ticketThrottlerInput = chunktaskqueuesorter.getProcessor(mailbox, true);
-        this.ticketThrottlerReleaser = chunktaskqueuesorter.getReleaseProcessor(mailbox);
-        this.mainThreadExecutor = mainThreadExecutor;
+        // Paper - rewrite chunk system
         this.chunkMap = chunkMap; // Paper
     }
 
-    // Paper start - replace ticket level propagator
-    protected final Long2IntLinkedOpenHashMap ticketLevelUpdates = new Long2IntLinkedOpenHashMap() {
-        @Override
-        protected void rehash(int newN) {
-            // no downsizing allowed
-            if (newN < this.n) {
-                return;
-            }
-            super.rehash(newN);
-        }
-    };
-    protected final io.papermc.paper.util.misc.Delayed8WayDistancePropagator2D ticketLevelPropagator = new io.papermc.paper.util.misc.Delayed8WayDistancePropagator2D(
-            (long coordinate, byte oldLevel, byte newLevel) -> {
-                DistanceManager.this.ticketLevelUpdates.putAndMoveToLast(coordinate, convertBetweenTicketLevels(newLevel));
-            }
-    );
-    // function for converting between ticket levels and propagator levels and vice versa
-    // the problem is the ticket level propagator will propagate from a set source down to zero, whereas mojang expects
-    // levels to propagate from a set value up to a maximum value. so we need to convert the levels we put into the propagator
-    // and the levels we get out of the propagator
-
-    // this maps so that GOLDEN_TICKET + 1 will be 0 in the propagator, GOLDEN_TICKET will be 1, and so on
-    // we need GOLDEN_TICKET+1 as 0 because anything >= GOLDEN_TICKET+1 should be unloaded
-    public static int convertBetweenTicketLevels(final int level) {
-        return ChunkMap.MAX_CHUNK_DISTANCE - level + 1;
-    }
-
-    protected final int getPropagatedTicketLevel(final long coordinate) {
-        return convertBetweenTicketLevels(this.ticketLevelPropagator.getLevel(coordinate));
-    }
-
-    protected final void updateTicketLevel(final long coordinate, final int ticketLevel) {
-        if (ticketLevel > ChunkMap.MAX_CHUNK_DISTANCE) {
-            this.ticketLevelPropagator.removeSource(coordinate);
-        } else {
-            this.ticketLevelPropagator.setSource(coordinate, convertBetweenTicketLevels(ticketLevel));
-        }
-    }
-    // Paper end - replace ticket level propagator
+    // Paper - rewrite chunk system
 
     protected void purgeStaleTickets() {
-        ++this.ticketTickCounter;
-        ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().fastIterator();
-        // Paper start - use optimised removeIf
-        long[] currChunk = new long[1];
-        long ticketCounter = DistanceManager.this.ticketTickCounter;
-        java.util.function.Predicate<Ticket<?>> removeIf = (ticket) -> {
-            final boolean ret = ticket.timedOut(ticketCounter);
-            if (ret) {
-                //this.tickingTicketsTracker.removeTicket(currChunk[0], ticket); // Paper - no longer used
-            }
-            return ret;
-        };
-        // Paper end - use optimised removeIf
-
-        while (objectiterator.hasNext()) {
-            Entry<SortedArraySet<Ticket<?>>> entry = (Entry) objectiterator.next();
-            // Paper start - use optimised removeIf
-            Iterator<Ticket<?>> iterator = null;
-            currChunk[0] = entry.getLongKey();
-            boolean flag = entry.getValue().removeIf(removeIf);
-
-            while (false && iterator.hasNext()) {
-                // Paper end - use optimised removeIf
-                Ticket<?> ticket = (Ticket) iterator.next();
-
-                if (ticket.timedOut(this.ticketTickCounter)) {
-                    iterator.remove();
-                    flag = true;
-                    //this.tickingTicketsTracker.removeTicket(entry.getLongKey(), ticket); // Paper - no longer used
-                }
-            }
-
-            if (flag) {
-                this.updateTicketLevel(entry.getLongKey(), getTicketLevelAt(entry.getValue())); // Paper - replace ticket level propagator
-            }
-
-            if (((SortedArraySet) entry.getValue()).isEmpty()) {
-                objectiterator.remove();
-            }
-        }
-
+        this.getChunkHolderManager().tick(); // Paper - rewrite chunk system
     }
 
     private static int getTicketLevelAt(SortedArraySet<Ticket<?>> tickets) {
@@ -181,163 +54,28 @@ public abstract class DistanceManager {
     @Nullable
     protected abstract ChunkHolder updateChunkScheduling(long pos, int level, @Nullable ChunkHolder holder, int k);
 
-    protected long ticketLevelUpdateCount; // Paper - replace ticket level propagator
+    // Paper - rewrite chunk system
     public boolean runAllUpdates(ChunkMap chunkStorage) {
-        //this.f.a(); // Paper - no longer used
-        //this.tickingTicketsTracker.runAllUpdates(); // Paper - no longer used
-        org.spigotmc.AsyncCatcher.catchOp("DistanceManagerTick"); // Paper
-        // this.playerTicketManager.runAllUpdates(); // Paper - no longer used
-        boolean flag = this.ticketLevelPropagator.propagateUpdates(); // Paper - replace ticket level propagator
-
-        if (flag) {
-            ;
-        }
-
-        // Paper start - replace level propagator
-        ticket_update_loop:
-        while (!this.ticketLevelUpdates.isEmpty()) {
-            flag = true;
-
-            boolean oldPolling = this.pollingPendingChunkUpdates;
-            this.pollingPendingChunkUpdates = true;
-            try {
-                for (java.util.Iterator<Long2IntMap.Entry> iterator = this.ticketLevelUpdates.long2IntEntrySet().fastIterator(); iterator.hasNext();) {
-                    Long2IntMap.Entry entry = iterator.next();
-                    long key = entry.getLongKey();
-                    int newLevel = entry.getIntValue();
-                    ChunkHolder chunk = this.getChunk(key);
-
-                    if (chunk == null && newLevel > ChunkMap.MAX_CHUNK_DISTANCE) {
-                        // not loaded and it shouldn't be loaded!
-                        continue;
-                    }
-
-                    int currentLevel = chunk == null ? ChunkMap.MAX_CHUNK_DISTANCE + 1 : chunk.getTicketLevel();
-
-                    if (currentLevel == newLevel) {
-                        // nothing to do
-                        continue;
-                    }
-
-                    this.updateChunkScheduling(key, newLevel, chunk, currentLevel);
-                }
-
-                long recursiveCheck = ++this.ticketLevelUpdateCount;
-                while (!this.ticketLevelUpdates.isEmpty()) {
-                    long key = this.ticketLevelUpdates.firstLongKey();
-                    int newLevel = this.ticketLevelUpdates.removeFirstInt();
-                    ChunkHolder chunk = this.getChunk(key);
-
-                    if (chunk == null) {
-                        if (newLevel <= ChunkMap.MAX_CHUNK_DISTANCE) {
-                            throw new IllegalStateException("Expected chunk holder to be created");
-                        }
-                        // not loaded and it shouldn't be loaded!
-                        continue;
-                    }
-
-                    int currentLevel = chunk.oldTicketLevel;
-
-                    if (currentLevel == newLevel) {
-                        // nothing to do
-                        continue;
-                    }
-
-                    chunk.updateFutures(chunkStorage, this.mainThreadExecutor);
-                    if (recursiveCheck != this.ticketLevelUpdateCount) {
-                        // back to the start, we must create player chunks and update the ticket level fields before
-                        // processing the actual level updates
-                        continue ticket_update_loop;
-                    }
-                }
-
-                for (;;) {
-                    if (recursiveCheck != this.ticketLevelUpdateCount) {
-                        continue ticket_update_loop;
-                    }
-                    ChunkHolder pendingUpdate = this.pendingChunkUpdates.poll();
-                    if (pendingUpdate == null) {
-                        break;
-                    }
-
-                    pendingUpdate.updateFutures(chunkStorage, this.mainThreadExecutor);
-                }
-            } finally {
-                this.pollingPendingChunkUpdates = oldPolling;
-            }
-        }
-
-        return flag;
-        // Paper end - replace level propagator
+        return this.getChunkHolderManager().processTicketUpdates(); // Paper - rewrite chunk system
     }
-    boolean pollingPendingChunkUpdates = false; // Paper - Chunk priority
+    // Paper - rewrite chunk system
 
     boolean addTicket(long i, Ticket<?> ticket) { // CraftBukkit - void -> boolean
         org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::addTicket"); // Paper
-        SortedArraySet<Ticket<?>> arraysetsorted = this.getTickets(i);
-        int j = DistanceManager.getTicketLevelAt(arraysetsorted);
-        Ticket<?> ticket1 = (Ticket) arraysetsorted.addOrGet(ticket);
-
-        ticket1.setCreatedTick(this.ticketTickCounter);
-        if (ticket.getTicketLevel() < j) {
-            this.updateTicketLevel(i, ticket.getTicketLevel()); // Paper - replace ticket level propagator
-        }
-
-        return ticket == ticket1; // CraftBukkit
+        return this.getChunkHolderManager().addTicketAtLevel((TicketType)ticket.getType(), i, ticket.getTicketLevel(), ticket.key); // Paper - rewrite chunk system
     }
 
     boolean removeTicket(long i, Ticket<?> ticket) { // CraftBukkit - void -> boolean
         org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::removeTicket"); // Paper
-        SortedArraySet<Ticket<?>> arraysetsorted = this.getTickets(i);
-        int oldLevel = getTicketLevelAt(arraysetsorted); // Paper
-
-        boolean removed = false; // CraftBukkit
-        if (arraysetsorted.remove(ticket)) {
-            removed = true; // CraftBukkit
-            // Paper start - delay chunk unloads for player tickets
-            long delayChunkUnloadsBy = chunkMap.level.paperConfig().chunks.delayChunkUnloadsBy.ticks();
-            if (ticket.getType() == TicketType.PLAYER && delayChunkUnloadsBy > 0) {
-                boolean hasPlayer = false;
-                for (Ticket<?> ticket1 : arraysetsorted) {
-                    if (ticket1.getType() == TicketType.PLAYER) {
-                        hasPlayer = true;
-                        break;
-                    }
-                }
-                ChunkHolder playerChunk = chunkMap.getUpdatingChunkIfPresent(i);
-                if (!hasPlayer && playerChunk != null && playerChunk.isFullChunkReady()) {
-                    Ticket<Long> delayUnload = new Ticket<Long>(TicketType.DELAY_UNLOAD, 33, i);
-                    delayUnload.delayUnloadBy = delayChunkUnloadsBy;
-                    delayUnload.setCreatedTick(this.ticketTickCounter);
-                    arraysetsorted.remove(delayUnload);
-                    // refresh ticket
-                    arraysetsorted.add(delayUnload);
-                }
-            }
-            // Paper end
-        }
-
-        if (arraysetsorted.isEmpty()) {
-            this.tickets.remove(i);
-        }
-
-        // Paper start - Chunk priority
-        int newLevel = getTicketLevelAt(arraysetsorted);
-        if (newLevel > oldLevel) {
-            this.updateTicketLevel(i, newLevel); // Paper // Paper - replace ticket level propagator
-        }
-        // Paper end
-        return removed; // CraftBukkit
+        return this.getChunkHolderManager().removeTicketAtLevel((TicketType)ticket.getType(), i, ticket.getTicketLevel(), ticket.key); // Paper - rewrite chunk system
     }
 
     public <T> void addTicket(TicketType<T> type, ChunkPos pos, int level, T argument) {
-        this.addTicket(pos.toLong(), new Ticket<>(type, level, argument));
+        this.getChunkHolderManager().addTicketAtLevel(type, pos, level, argument); // Paper - rewrite chunk system
     }
 
     public <T> void removeTicket(TicketType<T> type, ChunkPos pos, int level, T argument) {
-        Ticket<T> ticket = new Ticket<>(type, level, argument);
-
-        this.removeTicket(pos.toLong(), ticket);
+        this.getChunkHolderManager().removeTicketAtLevel(type, pos, level, argument); // Paper - rewrite chunk system
     }
 
     public <T> void addRegionTicket(TicketType<T> type, ChunkPos pos, int radius, T argument) {
@@ -346,13 +84,7 @@ public abstract class DistanceManager {
     }
 
     public <T> boolean addRegionTicketAtDistance(TicketType<T> tickettype, ChunkPos chunkcoordintpair, int i, T t0) {
-        // CraftBukkit end
-        Ticket<T> ticket = new Ticket<>(tickettype, 33 - i, t0);
-        long j = chunkcoordintpair.toLong();
-
-        boolean added = this.addTicket(j, ticket); // CraftBukkit
-        //this.tickingTicketsTracker.addTicket(j, ticket); // Paper - no longer used
-        return added; // CraftBukkit
+        return this.getChunkHolderManager().addTicketAtLevel(tickettype, chunkcoordintpair, 33 - i, t0); // Paper - rewrite chunk system
     }
 
     public <T> void removeRegionTicket(TicketType<T> type, ChunkPos pos, int radius, T argument) {
@@ -361,129 +93,13 @@ public abstract class DistanceManager {
     }
 
     public <T> boolean removeRegionTicketAtDistance(TicketType<T> tickettype, ChunkPos chunkcoordintpair, int i, T t0) {
-        // CraftBukkit end
-        Ticket<T> ticket = new Ticket<>(tickettype, 33 - i, t0);
-        long j = chunkcoordintpair.toLong();
-
-        boolean removed = this.removeTicket(j, ticket); // CraftBukkit
-        //this.tickingTicketsTracker.removeTicket(j, ticket); // Paper - no longer used
-        return removed; // CraftBukkit
+        return this.getChunkHolderManager().removeTicketAtLevel(tickettype, chunkcoordintpair, 33 - i, t0); // Paper - rewrite chunk system
     }
 
-    private SortedArraySet<Ticket<?>> getTickets(long position) {
-        return (SortedArraySet) this.tickets.computeIfAbsent(position, (j) -> {
-            return SortedArraySet.create(4);
-        });
-    }
-
-    // Paper start - Chunk priority
-    public static final int PRIORITY_TICKET_LEVEL = ChunkMap.MAX_CHUNK_DISTANCE;
-    public static final int URGENT_PRIORITY = 29;
-    public boolean delayDistanceManagerTick = false;
-    public boolean markUrgent(ChunkPos coords) {
-        return addPriorityTicket(coords, TicketType.URGENT, URGENT_PRIORITY);
-    }
-    public boolean markHighPriority(ChunkPos coords, int priority) {
-        priority = Math.min(URGENT_PRIORITY - 1, Math.max(1, priority));
-        return addPriorityTicket(coords, TicketType.PRIORITY, priority);
-    }
-
-    public void markAreaHighPriority(ChunkPos center, int priority, int radius) {
-        delayDistanceManagerTick = true;
-        priority = Math.min(URGENT_PRIORITY - 1, Math.max(1, priority));
-        int finalPriority = priority;
-        net.minecraft.server.MCUtil.getSpiralOutChunks(center.getWorldPosition(), radius).forEach(coords -> {
-            addPriorityTicket(coords, TicketType.PRIORITY, finalPriority);
-        });
-        delayDistanceManagerTick = false;
-        chunkMap.level.getChunkSource().runDistanceManagerUpdates();
-    }
-
-    public void clearAreaPriorityTickets(ChunkPos center, int radius) {
-        delayDistanceManagerTick = true;
-        net.minecraft.server.MCUtil.getSpiralOutChunks(center.getWorldPosition(), radius).forEach(coords -> {
-            this.removeTicket(coords.toLong(), new Ticket<ChunkPos>(TicketType.PRIORITY, PRIORITY_TICKET_LEVEL, coords));
-        });
-        delayDistanceManagerTick = false;
-        chunkMap.level.getChunkSource().runDistanceManagerUpdates();
-    }
-
-    private boolean addPriorityTicket(ChunkPos coords, TicketType<ChunkPos> ticketType, int priority) {
-        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::addPriorityTicket");
-        long pair = coords.toLong();
-        ChunkHolder chunk = chunkMap.getUpdatingChunkIfPresent(pair);
-        if ((chunk != null && chunk.isFullChunkReady())) {
-            return false;
-        }
-
-        boolean success;
-        if (!(success = updatePriorityTicket(coords, ticketType, priority))) {
-            Ticket<ChunkPos> ticket = new Ticket<ChunkPos>(ticketType, PRIORITY_TICKET_LEVEL, coords);
-            ticket.priority = priority;
-            success = this.addTicket(pair, ticket);
-        } else {
-            if (chunk == null) {
-                chunk = chunkMap.getUpdatingChunkIfPresent(pair);
-            }
-            chunkMap.queueHolderUpdate(chunk);
-        }
-
-        //chunkMap.world.getWorld().spawnParticle(priority <= 15 ? org.bukkit.Particle.EXPLOSION_HUGE : org.bukkit.Particle.EXPLOSION_NORMAL, chunkMap.world.getWorld().getPlayers(), null, coords.x << 4, 70, coords.z << 4, 2, 0, 0, 0, 1, null, true);
-
-        chunkMap.level.getChunkSource().runDistanceManagerUpdates();
-
-        return success;
-    }
-
-    private boolean updatePriorityTicket(ChunkPos coords, TicketType<ChunkPos> type, int priority) {
-        SortedArraySet<Ticket<?>> tickets = this.tickets.get(coords.toLong());
-        if (tickets == null) {
-            return false;
-        }
-        for (Ticket<?> ticket : tickets) {
-            if (ticket.getType() == type) {
-                // We only support increasing, not decreasing, too complicated
-                ticket.setCreatedTick(this.ticketTickCounter);
-                ticket.priority = Math.max(ticket.priority, priority);
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    public int getChunkPriority(ChunkPos coords) {
-        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::getChunkPriority");
-        SortedArraySet<Ticket<?>> tickets = this.tickets.get(coords.toLong());
-        if (tickets == null) {
-            return 0;
-        }
-        for (Ticket<?> ticket : tickets) {
-            if (ticket.getType() == TicketType.URGENT) {
-                return URGENT_PRIORITY;
-            }
-        }
-        for (Ticket<?> ticket : tickets) {
-            if (ticket.getType() == TicketType.PRIORITY && ticket.priority > 0) {
-                return ticket.priority;
-            }
-        }
-        return 0;
-    }
-
-    public void clearPriorityTickets(ChunkPos coords) {
-        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::clearPriority");
-        this.removeTicket(coords.toLong(), new Ticket<ChunkPos>(TicketType.PRIORITY, PRIORITY_TICKET_LEVEL, coords));
-    }
-
-    public void clearUrgent(ChunkPos coords) {
-        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::clearUrgent");
-        this.removeTicket(coords.toLong(), new Ticket<ChunkPos>(TicketType.URGENT, PRIORITY_TICKET_LEVEL, coords));
-    }
-    // Paper end
+    // Paper - rewrite chunk system
 
     protected void updateChunkForced(ChunkPos pos, boolean forced) {
-        Ticket<ChunkPos> ticket = new Ticket<>(TicketType.FORCED, 31, pos);
+        Ticket<ChunkPos> ticket = new Ticket<>(TicketType.FORCED, 31, pos, 0L); // Paper - rewrite chunk system
         long i = pos.toLong();
 
         if (forced) {
@@ -497,36 +113,15 @@ public abstract class DistanceManager {
     }
 
     public void addPlayer(SectionPos pos, ServerPlayer player) {
-        ChunkPos chunkcoordintpair = pos.chunk();
-        long i = chunkcoordintpair.toLong();
-
-        ((ObjectSet) this.playersPerChunk.computeIfAbsent(i, (j) -> {
-            return new ObjectOpenHashSet();
-        })).add(player);
-        //this.f.update(i, 0, true); // Paper - no longer used
-        //this.playerTicketManager.update(i, 0, true); // Paper - no longer used
-        //this.tickingTicketsTracker.addTicket(TicketType.PLAYER, chunkcoordintpair, this.getPlayerTicketLevel(), chunkcoordintpair); // Paper - no longer used
+        // Paper - rewrite chunk system
     }
 
     public void removePlayer(SectionPos pos, ServerPlayer player) {
-        ChunkPos chunkcoordintpair = pos.chunk();
-        long i = chunkcoordintpair.toLong();
-        ObjectSet<ServerPlayer> objectset = (ObjectSet) this.playersPerChunk.get(i);
-        if (objectset == null) return; // CraftBukkit - SPIGOT-6208
-
-        if (objectset != null) objectset.remove(player); // Paper - some state corruption happens here, don't crash, clean up gracefully.
-        if (objectset == null || objectset.isEmpty()) { // Paper
-            this.playersPerChunk.remove(i);
-            //this.f.update(i, Integer.MAX_VALUE, false); // Paper - no longer used
-            //this.playerTicketManager.update(i, Integer.MAX_VALUE, false); // Paper - no longer used
-            //this.tickingTicketsTracker.removeTicket(TicketType.PLAYER, chunkcoordintpair, this.getPlayerTicketLevel(), chunkcoordintpair); // Paper - no longer used
-        }
+        // Paper - rewrite chunk system
 
     }
 
-    private int getPlayerTicketLevel() {
-        return Math.max(0, 31 - this.simulationDistance);
-    }
+    // Paper - rewrite chunk system
 
     public boolean inEntityTickingRange(long chunkPos) {
         // Paper start - replace player chunk loader system
@@ -543,9 +138,7 @@ public abstract class DistanceManager {
     }
 
     protected String getTicketDebugString(long pos) {
-        SortedArraySet<Ticket<?>> arraysetsorted = (SortedArraySet) this.tickets.get(pos);
-
-        return arraysetsorted != null && !arraysetsorted.isEmpty() ? ((Ticket) arraysetsorted.first()).toString() : "no_ticket";
+        return this.getChunkHolderManager().getTicketDebugString(pos); // Paper - rewrite chunk system
     }
 
     protected void updatePlayerTickets(int viewDistance) {
@@ -577,97 +170,24 @@ public abstract class DistanceManager {
     }
 
     public String getDebugStatus() {
-        return this.ticketThrottler.getDebugStatus();
+        return "wat"; // TODO // Paper - rewrite chunk system
     }
 
-    private void dumpTickets(String path) {
-        try {
-            FileOutputStream fileoutputstream = new FileOutputStream(new File(path));
-
-            try {
-                ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().iterator();
-
-                while (objectiterator.hasNext()) {
-                    Entry<SortedArraySet<Ticket<?>>> entry = (Entry) objectiterator.next();
-                    ChunkPos chunkcoordintpair = new ChunkPos(entry.getLongKey());
-                    Iterator iterator = ((SortedArraySet) entry.getValue()).iterator();
-
-                    while (iterator.hasNext()) {
-                        Ticket<?> ticket = (Ticket) iterator.next();
-
-                        fileoutputstream.write((chunkcoordintpair.x + "\t" + chunkcoordintpair.z + "\t" + ticket.getType() + "\t" + ticket.getTicketLevel() + "\t\n").getBytes(StandardCharsets.UTF_8));
-                    }
-                }
-            } catch (Throwable throwable) {
-                try {
-                    fileoutputstream.close();
-                } catch (Throwable throwable1) {
-                    throwable.addSuppressed(throwable1);
-                }
-
-                throw throwable;
-            }
-
-            fileoutputstream.close();
-        } catch (IOException ioexception) {
-            DistanceManager.LOGGER.error("Failed to dump tickets to {}", path, ioexception);
-        }
-
-    }
+    // Paper - rewrite chunk system
 
     // Paper - replace player chunk loader
 
     public void removeTicketsOnClosing() {
-        ImmutableSet<TicketType<?>> immutableset = ImmutableSet.of(TicketType.UNKNOWN, TicketType.POST_TELEPORT, TicketType.LIGHT, TicketType.FUTURE_AWAIT, TicketType.ASYNC_LOAD, TicketType.REQUIRED_LOAD, TicketType.CHUNK_RELIGHT, ca.spottedleaf.starlight.common.light.StarLightInterface.CHUNK_WORK_TICKET); // Paper - add additional tickets to preserve
-        ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().fastIterator();
-
-        while (objectiterator.hasNext()) {
-            Entry<SortedArraySet<Ticket<?>>> entry = (Entry) objectiterator.next();
-            Iterator<Ticket<?>> iterator = ((SortedArraySet) entry.getValue()).iterator();
-            boolean flag = false;
-
-            while (iterator.hasNext()) {
-                Ticket<?> ticket = (Ticket) iterator.next();
-
-                if (!immutableset.contains(ticket.getType())) {
-                    iterator.remove();
-                    flag = true;
-                    // this.tickingTicketsTracker.removeTicket(entry.getLongKey(), ticket); // Paper - no longer used
-                }
-            }
-
-            if (flag) {
-                this.updateTicketLevel(entry.getLongKey(), DistanceManager.getTicketLevelAt((SortedArraySet) entry.getValue())); // Paper - replace ticket level propagator
-            }
-
-            if (((SortedArraySet) entry.getValue()).isEmpty()) {
-                objectiterator.remove();
-            }
-        }
-
+        // Paper - rewrite chunk system - this stupid hack ain't needed anymore
     }
 
     public boolean hasTickets() {
-        return !this.tickets.isEmpty();
+        return this.getChunkHolderManager().hasTickets(); // Paper - rewrite chunk system
     }
 
     // CraftBukkit start
     public <T> void removeAllTicketsFor(TicketType<T> ticketType, int ticketLevel, T ticketIdentifier) {
-        Ticket<T> target = new Ticket<>(ticketType, ticketLevel, ticketIdentifier);
-
-        for (java.util.Iterator<Entry<SortedArraySet<Ticket<?>>>> iterator = this.tickets.long2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
-            Entry<SortedArraySet<Ticket<?>>> entry = iterator.next();
-            SortedArraySet<Ticket<?>> tickets = entry.getValue();
-            if (tickets.remove(target)) {
-                // copied from removeTicket
-                this.updateTicketLevel(entry.getLongKey(), getTicketLevelAt(tickets)); // Paper - replace ticket level propagator
-
-                // can't use entry after it's removed
-                if (tickets.isEmpty()) {
-                    iterator.remove();
-                }
-            }
-        }
+        this.getChunkHolderManager().removeAllTicketsFor(ticketType, ticketLevel, ticketIdentifier); // Paper - rewrite chunk system
     }
     // CraftBukkit end
 
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 59acbf6249f8f5285504c0ddea448a3433d1d68d..a6101a573fc18572d72acab8bb21143a9ff95a9e 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -144,7 +144,7 @@ public class ServerChunkCache extends ChunkSource {
     long chunkFutureAwaitCounter; // Paper - private -> package private
 
     public void getEntityTickingChunkAsync(int x, int z, java.util.function.Consumer<LevelChunk> onLoad) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (!io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
             this.mainThreadProcessor.execute(() -> {
                 ServerChunkCache.this.getEntityTickingChunkAsync(x, z, onLoad);
             });
@@ -154,7 +154,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public void getTickingChunkAsync(int x, int z, java.util.function.Consumer<LevelChunk> onLoad) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (!io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
             this.mainThreadProcessor.execute(() -> {
                 ServerChunkCache.this.getTickingChunkAsync(x, z, onLoad);
             });
@@ -164,7 +164,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public void getFullChunkAsync(int x, int z, java.util.function.Consumer<LevelChunk> onLoad) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (!io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
             this.mainThreadProcessor.execute(() -> {
                 ServerChunkCache.this.getFullChunkAsync(x, z, onLoad);
             });
@@ -174,7 +174,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     private void getChunkFutureAsynchronously(int x, int z, int ticketLevel, java.util.function.Function<ChunkHolder, CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>>> futureGet, java.util.function.Consumer<LevelChunk> onLoad) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (!io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
             throw new IllegalStateException();
         }
         ChunkPos chunkPos = new ChunkPos(x, z);
@@ -232,94 +232,7 @@ public class ServerChunkCache extends ChunkSource {
         return holder.getLastAvailable();
     }
 
-    // this will try to avoid chunk neighbours for lighting
-    public final ChunkAccess getFullStatusChunkAt(int chunkX, int chunkZ) {
-        LevelChunk ifLoaded = this.getChunkAtIfLoadedImmediately(chunkX, chunkZ);
-        if (ifLoaded != null) {
-            return ifLoaded;
-        }
-
-        ChunkAccess empty = this.getChunk(chunkX, chunkZ, ChunkStatus.EMPTY, true);
-        if (empty != null && empty.getStatus().isOrAfter(ChunkStatus.FULL)) {
-            return empty;
-        }
-        return this.getChunk(chunkX, chunkZ, ChunkStatus.FULL, true);
-    }
-
-    public final ChunkAccess getFullStatusChunkAtIfLoaded(int chunkX, int chunkZ) {
-        LevelChunk ifLoaded = this.getChunkAtIfLoadedImmediately(chunkX, chunkZ);
-        if (ifLoaded != null) {
-            return ifLoaded;
-        }
-
-        ChunkAccess ret = this.getChunkAtImmediately(chunkX, chunkZ);
-        if (ret != null && ret.getStatus().isOrAfter(ChunkStatus.FULL)) {
-            return ret;
-        } else {
-            return null;
-        }
-    }
-
-    void getChunkAtAsynchronously(int chunkX, int chunkZ, int ticketLevel,
-                                  java.util.function.Consumer<ChunkAccess> consumer) {
-        this.getChunkAtAsynchronously(chunkX, chunkZ, ticketLevel, (ChunkHolder chunkHolder) -> {
-            if (ticketLevel <= 33) {
-                return (CompletableFuture)chunkHolder.getFullChunkFuture();
-            } else {
-                return chunkHolder.getOrScheduleFuture(ChunkHolder.getStatus(ticketLevel), ServerChunkCache.this.chunkMap);
-            }
-        }, consumer);
-    }
-
-    void getChunkAtAsynchronously(int chunkX, int chunkZ, int ticketLevel,
-                                  java.util.function.Function<ChunkHolder, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> function,
-                                  java.util.function.Consumer<ChunkAccess> consumer) {
-        if (Thread.currentThread() != this.mainThread) {
-            throw new IllegalStateException();
-        }
-
-        ChunkPos chunkPos = new ChunkPos(chunkX, chunkZ);
-        Long identifier = Long.valueOf(this.chunkFutureAwaitCounter++);
-        this.addTicketAtLevel(TicketType.FUTURE_AWAIT, chunkPos, ticketLevel, identifier);
-        this.runDistanceManagerUpdates();
-
-        ChunkHolder chunk = this.chunkMap.getUpdatingChunkIfPresent(chunkPos.toLong());
-
-        if (chunk == null) {
-            throw new IllegalStateException("Expected playerchunk " + chunkPos + " in world '" + this.level.getWorld().getName() + "'");
-        }
-
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = function.apply(chunk);
-
-        future.whenCompleteAsync((either, throwable) -> {
-            try {
-                if (throwable != null) {
-                    if (throwable instanceof ThreadDeath) {
-                        throw (ThreadDeath)throwable;
-                    }
-                    LOGGER.error("Failed to complete future await for chunk " + chunkPos.toString() + " in world '" + ServerChunkCache.this.level.getWorld().getName() + "'", throwable);
-                } else if (either.right().isPresent()) {
-                    LOGGER.error("Failed to complete future await for chunk " + chunkPos.toString() + " in world '" + ServerChunkCache.this.level.getWorld().getName() + "': " + either.right().get().toString());
-                }
-
-                try {
-                    if (consumer != null) {
-                        consumer.accept(either == null ? null : either.left().orElse(null)); // indicate failure to the callback.
-                    }
-                } catch (Throwable thr) {
-                    if (thr instanceof ThreadDeath) {
-                        throw (ThreadDeath)thr;
-                    }
-                    LOGGER.error("Load callback for future await failed " + chunkPos.toString() + " in world '" + ServerChunkCache.this.level.getWorld().getName() + "'", thr);
-                    return;
-                }
-            } finally {
-                // due to odd behaviour with CB unload implementation we need to have these AFTER the load callback.
-                ServerChunkCache.this.addTicketAtLevel(TicketType.UNKNOWN, chunkPos, ticketLevel, chunkPos);
-                ServerChunkCache.this.removeTicketAtLevel(TicketType.FUTURE_AWAIT, chunkPos, ticketLevel, identifier);
-            }
-        }, this.mainThreadProcessor);
-    }
+    // Paper - rewrite chunk system
 
     public <T> void addTicketAtLevel(TicketType<T> ticketType, ChunkPos chunkPos, int ticketLevel, T identifier) {
         this.distanceManager.addTicket(ticketType, chunkPos, ticketLevel, identifier);
@@ -329,74 +242,11 @@ public class ServerChunkCache extends ChunkSource {
         this.distanceManager.removeTicket(ticketType, chunkPos, ticketLevel, identifier);
     }
 
-    void chunkLoadAccept(int chunkX, int chunkZ, ChunkAccess chunk, java.util.function.Consumer<ChunkAccess> consumer) {
-        try {
-            consumer.accept(chunk);
-        } catch (Throwable throwable) {
-            if (throwable instanceof ThreadDeath) {
-                throw (ThreadDeath)throwable;
-            }
-            LOGGER.error("Load callback for chunk " + chunkX + "," + chunkZ + " in world '" + this.level.getWorld().getName() + "' threw an exception", throwable);
-        }
-    }
-
-    public final void getChunkAtAsynchronously(int chunkX, int chunkZ, ChunkStatus status, boolean gen, boolean allowSubTicketLevel, java.util.function.Consumer<ChunkAccess> onLoad) {
-        // try to fire sync
-        int chunkStatusTicketLevel = 33 + ChunkStatus.getDistance(status);
-        ChunkHolder playerChunk = this.chunkMap.getUpdatingChunkIfPresent(io.papermc.paper.util.CoordinateUtils.getChunkKey(chunkX, chunkZ));
-        if (playerChunk != null) {
-            ChunkStatus holderStatus = playerChunk.getChunkHolderStatus();
-            ChunkAccess immediate = playerChunk.getAvailableChunkNow();
-            if (immediate != null) {
-                if (allowSubTicketLevel ? immediate.getStatus().isOrAfter(status) : (playerChunk.getTicketLevel() <= chunkStatusTicketLevel && holderStatus != null && holderStatus.isOrAfter(status))) {
-                    this.chunkLoadAccept(chunkX, chunkZ, immediate, onLoad);
-                    return;
-                } else {
-                    if (gen || (!allowSubTicketLevel && immediate.getStatus().isOrAfter(status))) {
-                        this.getChunkAtAsynchronously(chunkX, chunkZ, chunkStatusTicketLevel, onLoad);
-                        return;
-                    } else {
-                        this.chunkLoadAccept(chunkX, chunkZ, null, onLoad);
-                        return;
-                    }
-                }
-            }
-        }
-
-        // need to fire async
-
-        if (gen && !allowSubTicketLevel) {
-            this.getChunkAtAsynchronously(chunkX, chunkZ, chunkStatusTicketLevel, onLoad);
-            return;
-        }
-
-        this.getChunkAtAsynchronously(chunkX, chunkZ, net.minecraft.server.MCUtil.getTicketLevelFor(ChunkStatus.EMPTY), (ChunkAccess chunk) -> {
-            if (chunk == null) {
-                throw new IllegalStateException("Chunk cannot be null");
-            }
+    // Paper - rewrite chunk system
 
-            if (!chunk.getStatus().isOrAfter(status)) {
-                if (gen) {
-                    this.getChunkAtAsynchronously(chunkX, chunkZ, chunkStatusTicketLevel, onLoad);
-                    return;
-                } else {
-                    ServerChunkCache.this.chunkLoadAccept(chunkX, chunkZ, null, onLoad);
-                    return;
-                }
-            } else {
-                if (allowSubTicketLevel) {
-                    ServerChunkCache.this.chunkLoadAccept(chunkX, chunkZ, chunk, onLoad);
-                    return;
-                } else {
-                    this.getChunkAtAsynchronously(chunkX, chunkZ, chunkStatusTicketLevel, onLoad);
-                    return;
-                }
-            }
-        });
-    }
-
-    final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<LevelChunk> tickingChunks = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(4096, 0.75f, 4096, 0.15, true);
-    final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<LevelChunk> entityTickingChunks = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(4096, 0.75f, 4096, 0.15, true);
+    // TODO correct access
+    public final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<LevelChunk> tickingChunks = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(4096, 0.75f, 4096, 0.15, true);
+    public final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<LevelChunk> entityTickingChunks = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(4096, 0.75f, 4096, 0.15, true);
     // Paper end
 
     public ServerChunkCache(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureTemplateManager structureTemplateManager, Executor workerExecutor, ChunkGenerator chunkGenerator, int viewDistance, int simulationDistance, boolean dsync, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory) {
@@ -470,7 +320,7 @@ public class ServerChunkCache extends ChunkSource {
     public LevelChunk getChunkAtIfLoadedImmediately(int x, int z) {
         long k = ChunkPos.asLong(x, z);
 
-        if (Thread.currentThread() == this.mainThread) {
+        if (io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
             return this.getChunkAtIfLoadedMainThread(x, z);
         }
 
@@ -492,132 +342,35 @@ public class ServerChunkCache extends ChunkSource {
         return ret;
     }
     // Paper end
-    // Paper start - async chunk io
-    private long asyncLoadSeqCounter;
-
+    // Paper start - rewrite chunk system
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkAtAsynchronously(int x, int z, boolean gen, boolean isUrgent) {
-        if (Thread.currentThread() != this.mainThread) {
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = new CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>();
-            this.mainThreadProcessor.execute(() -> {
-                this.getChunkAtAsynchronously(x, z, gen, isUrgent).whenComplete((chunk, ex) -> {
-                    if (ex != null) {
-                        future.completeExceptionally(ex);
-                    } else {
-                        future.complete(chunk);
-                    }
-                });
-            });
-            return future;
-        }
-
-        long k = ChunkPos.asLong(x, z);
-        ChunkPos chunkPos = new ChunkPos(x, z);
-
-        ChunkAccess ichunkaccess;
-
-        // try cache
-        for (int l = 0; l < 4; ++l) {
-            if (k == this.lastChunkPos[l] && ChunkStatus.FULL == this.lastChunkStatus[l]) {
-                ichunkaccess = this.lastChunk[l];
-                if (ichunkaccess != null) { // CraftBukkit - the chunk can become accessible in the meantime TODO for non-null chunks it might also make sense to check that the chunk's state hasn't changed in the meantime
-
-                    // move to first in cache
-
-                    for (int i1 = 3; i1 > 0; --i1) {
-                        this.lastChunkPos[i1] = this.lastChunkPos[i1 - 1];
-                        this.lastChunkStatus[i1] = this.lastChunkStatus[i1 - 1];
-                        this.lastChunk[i1] = this.lastChunk[i1 - 1];
-                    }
-
-                    this.lastChunkPos[0] = k;
-                    this.lastChunkStatus[0] = ChunkStatus.FULL;
-                    this.lastChunk[0] = ichunkaccess;
-
-                    return CompletableFuture.completedFuture(Either.left(ichunkaccess));
-                }
-            }
-        }
-
-        if (gen) {
-            return this.bringToFullStatusAsync(x, z, chunkPos, isUrgent);
-        }
-
-        ChunkAccess current = this.getChunkAtImmediately(x, z); // we want to bypass ticket restrictions
-        if (current != null) {
-            if (!(current instanceof net.minecraft.world.level.chunk.ImposterProtoChunk) && !(current instanceof LevelChunk)) {
-                return CompletableFuture.completedFuture(ChunkHolder.UNLOADED_CHUNK);
-            }
-            // we know the chunk is at full status here (either in read-only mode or the real thing)
-            return this.bringToFullStatusAsync(x, z, chunkPos, isUrgent);
-        }
-
-        // here we don't know what status it is and we're not supposed to generate
-        // so we asynchronously load empty status
-        return this.bringToStatusAsync(x, z, chunkPos, ChunkStatus.EMPTY, isUrgent).thenCompose((either) -> {
-            ChunkAccess chunk = either.left().orElse(null);
-            if (!(chunk instanceof net.minecraft.world.level.chunk.ImposterProtoChunk) && !(chunk instanceof LevelChunk)) {
-                // the chunk on disk was not a full status chunk
-                return CompletableFuture.completedFuture(ChunkHolder.UNLOADED_CHUNK);
-            }
-            // bring to full status if required
-            return this.bringToFullStatusAsync(x, z, chunkPos, isUrgent);
-        });
-    }
-
-    private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> bringToFullStatusAsync(int x, int z, ChunkPos chunkPos, boolean isUrgent) {
-        return this.bringToStatusAsync(x, z, chunkPos, ChunkStatus.FULL, isUrgent);
-    }
-
-    private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> bringToStatusAsync(int x, int z, ChunkPos chunkPos, ChunkStatus status, boolean isUrgent) {
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = this.getChunkFutureMainThread(x, z, status, true, isUrgent);
-        Long identifier = Long.valueOf(this.asyncLoadSeqCounter++);
-        int ticketLevel = net.minecraft.server.MCUtil.getTicketLevelFor(status);
-        this.addTicketAtLevel(TicketType.ASYNC_LOAD, chunkPos, ticketLevel, identifier);
-
-        return future.thenComposeAsync((Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either) -> {
-            // either left -> success
-            // either right -> failure
-
-            this.removeTicketAtLevel(TicketType.ASYNC_LOAD, chunkPos, ticketLevel, identifier);
-            this.addTicketAtLevel(TicketType.UNKNOWN, chunkPos, ticketLevel, chunkPos); // allow unloading
-
-            Optional<ChunkHolder.ChunkLoadingFailure> failure = either.right();
-
-            if (failure.isPresent()) {
-                // failure
-                throw new IllegalStateException("Chunk failed to load: " + failure.get().toString());
-            }
-
-            return CompletableFuture.completedFuture(either);
-        }, this.mainThreadProcessor);
-    }
-
-    public boolean markUrgent(ChunkPos coords) {
-        return this.distanceManager.markUrgent(coords);
+        return this.getChunkAtAsynchronously(x, z, gen, ChunkStatus.FULL, isUrgent ? ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.HIGHEST : ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.NORMAL);
     }
 
-    public boolean markHighPriority(ChunkPos coords, int priority) {
-        return this.distanceManager.markHighPriority(coords, priority);
-    }
+    public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkAtAsynchronously(int x, int z, boolean gen, ChunkStatus chunkStatus, ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority priority) {
+        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> ret = new CompletableFuture<>();
+        Consumer<ChunkAccess> consumer = (ChunkAccess chunk) -> {
+            ret.complete(Either.left(chunk));
+        };
 
-    public void markAreaHighPriority(ChunkPos center, int priority, int radius) {
-        this.distanceManager.markAreaHighPriority(center, priority, radius);
-    }
+        this.getChunkAtAsynchronously(x, z, gen, chunkStatus, priority, consumer);
 
-    public void clearAreaPriorityTickets(ChunkPos center, int radius) {
-        this.distanceManager.clearAreaPriorityTickets(center, radius);
+        return ret;
     }
 
-    public void clearPriorityTickets(ChunkPos coords) {
-        this.distanceManager.clearPriorityTickets(coords);
+    public void getChunkAtAsynchronously(int x, int z, boolean gen, ChunkStatus chunkStatus, ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority priority, Consumer<ChunkAccess> consumer) {
+        this.level.chunkTaskScheduler.scheduleChunkLoad(
+            x, z, gen, chunkStatus, true, priority, consumer
+        );
     }
-    // Paper end - async chunk io
+    // Paper end - rewrite chunk system
 
     @Nullable
     @Override
     public ChunkAccess getChunk(int x, int z, ChunkStatus leastStatus, boolean create) {
         final int x1 = x; final int z1 = z; // Paper - conflict on variable change
-        if (Thread.currentThread() != this.mainThread) {
+        if (!io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
+            // TODO stop making this fucking trash block the main fucking thread from stupid ass plugins
             return (ChunkAccess) CompletableFuture.supplyAsync(() -> {
                 return this.getChunk(x, z, leastStatus, create);
             }, this.mainThreadProcessor).join();
@@ -651,18 +404,15 @@ public class ServerChunkCache extends ChunkSource {
             Objects.requireNonNull(completablefuture);
             if (!completablefuture.isDone()) { // Paper
                 // Paper start - async chunk io/loading
-                ChunkPos pair = new ChunkPos(x1, z1); // Paper - Chunk priority
-                this.distanceManager.markUrgent(pair); // Paper - Chunk priority
-                this.level.asyncChunkTaskManager.raisePriority(x1, z1, com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY);
-                com.destroystokyo.paper.io.chunk.ChunkTaskManager.pushChunkWait(this.level, x1, z1);
+                // Paper - rewrite chunk system
+                io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.pushChunkWait(this.level, x1, z1); // Paper - rewrite chunk system
                 // Paper end
                 com.destroystokyo.paper.io.SyncLoadFinder.logSyncLoad(this.level, x1, z1); // Paper - sync load info
                 this.level.timings.syncChunkLoad.startTiming(); // Paper
             chunkproviderserver_b.managedBlock(completablefuture::isDone);
-                com.destroystokyo.paper.io.chunk.ChunkTaskManager.popChunkWait(); // Paper - async chunk debug
+                io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.popChunkWait(); // Paper - async chunk debug  // Paper - rewrite chunk system
                 this.level.timings.syncChunkLoad.stopTiming(); // Paper
-                this.distanceManager.clearPriorityTickets(pair); // Paper - Chunk priority
-                this.distanceManager.clearUrgent(pair); // Paper - Chunk priority
+                // Paper - rewrite chunk system
             } // Paper
             ichunkaccess = (ChunkAccess) ((Either) completablefuture.join()).map((ichunkaccess1) -> {
                 return ichunkaccess1;
@@ -681,7 +431,7 @@ public class ServerChunkCache extends ChunkSource {
     @Nullable
     @Override
     public LevelChunk getChunkNow(int chunkX, int chunkZ) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (!io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
             return null;
         } else {
             return this.getChunkAtIfLoadedMainThread(chunkX, chunkZ); // Paper - optimise for loaded chunks
@@ -695,7 +445,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkFuture(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create) {
-        boolean flag1 = Thread.currentThread() == this.mainThread;
+        boolean flag1 = io.papermc.paper.util.TickThread.isTickThread(); // Paper - rewrite chunk system
         CompletableFuture completablefuture;
 
         if (flag1) {
@@ -715,74 +465,55 @@ public class ServerChunkCache extends ChunkSource {
         return completablefuture;
     }
 
-    private long syncLoadCounter; // Paper - prevent plugin unloads from removing our ticket
+    // Paper - rewrite chunk system
 
     private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkFutureMainThread(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create) {
         // Paper start - add isUrgent - old sig left in place for dirty nms plugins
         return getChunkFutureMainThread(chunkX, chunkZ, leastStatus, create, false);
     }
     private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkFutureMainThread(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create, boolean isUrgent) {
-        // Paper end
-        ChunkPos chunkcoordintpair = new ChunkPos(chunkX, chunkZ);
-        long k = chunkcoordintpair.toLong();
-        int l = 33 + ChunkStatus.getDistance(leastStatus);
-        ChunkHolder playerchunk = this.getVisibleChunkIfPresent(k);
+        // Paper start - rewrite chunk system
+        io.papermc.paper.util.TickThread.ensureTickThread(chunkX, chunkZ, "Scheduling chunk load off-main");
+        int minLevel = 33 + ChunkStatus.getDistance(leastStatus);
+        io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder = this.level.chunkTaskScheduler.chunkHolderManager.getChunkHolder(chunkX, chunkZ);
 
-        // CraftBukkit start - don't add new ticket for currently unloading chunk
-        boolean currentlyUnloading = false;
-        if (playerchunk != null) {
-            ChunkHolder.FullChunkStatus oldChunkState = ChunkHolder.getFullChunkStatus(playerchunk.oldTicketLevel);
-            ChunkHolder.FullChunkStatus currentChunkState = ChunkHolder.getFullChunkStatus(playerchunk.getTicketLevel());
-            currentlyUnloading = (oldChunkState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && !currentChunkState.isOrAfter(ChunkHolder.FullChunkStatus.BORDER));
+        boolean needsFullScheduling = leastStatus == ChunkStatus.FULL && (chunkHolder == null || !chunkHolder.getChunkStatus().isOrAfter(ChunkHolder.FullChunkStatus.BORDER));
+
+        if ((chunkHolder == null || chunkHolder.getTicketLevel() > minLevel || needsFullScheduling) && !create) {
+            return ChunkHolder.UNLOADED_CHUNK_FUTURE;
         }
-        final Long identifier; // Paper - prevent plugin unloads from removing our ticket
-        if (create && !currentlyUnloading) {
-            // CraftBukkit end
-            this.distanceManager.addTicket(TicketType.UNKNOWN, chunkcoordintpair, l, chunkcoordintpair);
-            identifier = Long.valueOf(this.syncLoadCounter++); // Paper - prevent plugin unloads from removing our ticket
-            this.distanceManager.addTicket(TicketType.REQUIRED_LOAD, chunkcoordintpair, l, identifier); // Paper - prevent plugin unloads from removing our ticket
-            if (isUrgent) this.distanceManager.markUrgent(chunkcoordintpair); // Paper - Chunk priority
-            if (this.chunkAbsent(playerchunk, l)) {
-                ProfilerFiller gameprofilerfiller = this.level.getProfiler();
-
-                gameprofilerfiller.push("chunkLoad");
-                distanceManager.delayDistanceManagerTick = false; // Paper - Chunk priority - ensure this is never false
-                this.runDistanceManagerUpdates();
-                playerchunk = this.getVisibleChunkIfPresent(k);
-                gameprofilerfiller.pop();
-                if (this.chunkAbsent(playerchunk, l)) {
-                    this.distanceManager.removeTicket(TicketType.REQUIRED_LOAD, chunkcoordintpair, l, identifier); // Paper
-                    throw (IllegalStateException) Util.pauseInIde(new IllegalStateException("No chunk holder after ticket has been added"));
+
+        io.papermc.paper.chunk.system.scheduling.NewChunkHolder.ChunkCompletion chunkCompletion = chunkHolder == null ? null : chunkHolder.getLastChunkCompletion();
+        if (needsFullScheduling || chunkCompletion == null || !chunkCompletion.genStatus().isOrAfter(leastStatus)) {
+            // schedule
+            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> ret = new CompletableFuture<>();
+            Consumer<ChunkAccess> complete = (ChunkAccess chunk) -> {
+                if (chunk == null) {
+                    ret.complete(Either.right(ChunkHolder.ChunkLoadingFailure.UNLOADED));
+                } else {
+                    ret.complete(Either.left(chunk));
                 }
-            }
+            };
 
-        } else { identifier = null; } // Paper - prevent plugin unloads from removing our ticket
-        // Paper start - Chunk priority
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = this.chunkAbsent(playerchunk, l) ? ChunkHolder.UNLOADED_CHUNK_FUTURE : playerchunk.getOrScheduleFuture(leastStatus, this.chunkMap);
-        // Paper start - prevent plugin unloads from removing our ticket
-        if (create && !currentlyUnloading) {
-            future.thenAcceptAsync((either) -> {
-                ServerChunkCache.this.distanceManager.removeTicket(TicketType.REQUIRED_LOAD, chunkcoordintpair, l, identifier);
-            }, ServerChunkCache.this.mainThreadProcessor);
-        }
-        // Paper end - prevent plugin unloads from removing our ticket
-        if (isUrgent) {
-            future.thenAccept(either -> this.distanceManager.clearUrgent(chunkcoordintpair));
+            this.level.chunkTaskScheduler.scheduleChunkLoad(
+                chunkX, chunkZ, leastStatus, true,
+                isUrgent ? ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.BLOCKING : ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.NORMAL,
+                complete
+            );
+
+            return ret;
+        } else {
+            // can return now
+            return CompletableFuture.completedFuture(Either.left(chunkCompletion.chunk()));
         }
-        return future;
-        // Paper end
+        // Paper end - rewrite chunk system
     }
 
-    private boolean chunkAbsent(@Nullable ChunkHolder holder, int maxLevel) {
-        return holder == null || holder.oldTicketLevel > maxLevel; // CraftBukkit using oldTicketLevel for isLoaded checks
-    }
+    // Paper - rewrite chunk system
 
     @Override
     public boolean hasChunk(int x, int z) {
-        ChunkHolder playerchunk = this.getVisibleChunkIfPresent((new ChunkPos(x, z)).toLong());
-        int k = 33 + ChunkStatus.getDistance(ChunkStatus.FULL);
-
-        return !this.chunkAbsent(playerchunk, k);
+        return this.getChunkAtIfLoadedImmediately(x, z) != null; // Paper - rewrite chunk system
     }
 
     @Override
@@ -793,22 +524,13 @@ public class ServerChunkCache extends ChunkSource {
         if (playerchunk == null) {
             return null;
         } else {
-            int l = ServerChunkCache.CHUNK_STATUSES.size() - 1;
-
-            while (true) {
-                ChunkStatus chunkstatus = (ChunkStatus) ServerChunkCache.CHUNK_STATUSES.get(l);
-                Optional<ChunkAccess> optional = ((Either) playerchunk.getFutureIfPresentUnchecked(chunkstatus).getNow(ChunkHolder.UNLOADED_CHUNK)).left();
-
-                if (optional.isPresent()) {
-                    return (BlockGetter) optional.get();
-                }
-
-                if (chunkstatus == ChunkStatus.LIGHT.getParent()) {
-                    return null;
-                }
-
-                --l;
+            // Paper start - rewrite chunk system
+            ChunkStatus status = playerchunk.getChunkHolderStatus();
+            if (status != null && !status.isOrAfter(ChunkStatus.LIGHT.getParent())) {
+                return null;
             }
+            return playerchunk.getAvailableChunkNow();
+            // Paper end - rewrite chunk system
         }
     }
 
@@ -822,19 +544,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public boolean runDistanceManagerUpdates() {
-        if (distanceManager.delayDistanceManagerTick) return false; // Paper - Chunk priority
-        if (this.chunkMap.unloadingPlayerChunk) { LOGGER.error("Cannot tick distance manager while unloading playerchunks", new Throwable()); throw new IllegalStateException("Cannot tick distance manager while unloading playerchunks"); } // Paper
-        co.aikar.timings.MinecraftTimings.distanceManagerTick.startTiming(); try { // Paper - add timings for distance manager
-        boolean flag = this.distanceManager.runAllUpdates(this.chunkMap);
-        boolean flag1 = this.chunkMap.promoteChunkMap();
-
-        if (!flag && !flag1) {
-            return false;
-        } else {
-            this.clearCache();
-            return true;
-        }
-        } finally { co.aikar.timings.MinecraftTimings.distanceManagerTick.stopTiming(); } // Paper - add timings for distance manager
+        return this.level.chunkTaskScheduler.chunkHolderManager.processTicketUpdates(); // Paper - rewrite chunk system
     }
 
     // Paper start
@@ -872,13 +582,8 @@ public class ServerChunkCache extends ChunkSource {
         this.close(true);
     }
 
-    public void close(boolean save) throws IOException {
-        if (save) {
-            this.save(true);
-        }
-        // CraftBukkit end
-        this.lightEngine.close();
-        this.chunkMap.close();
+    public void close(boolean save) { // Paper - rewrite chunk system
+        this.level.chunkTaskScheduler.chunkHolderManager.close(save, true); // Paper - rewrite chunk system
     }
 
     // CraftBukkit start - modelled on below
@@ -1089,7 +794,12 @@ public class ServerChunkCache extends ChunkSource {
         ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos);
 
         if (playerchunk != null) {
-            ((Either) playerchunk.getFullChunkFuture().getNow(ChunkHolder.UNLOADED_LEVEL_CHUNK)).left().ifPresent(chunkConsumer);
+            // Paper start - rewrite chunk system
+            LevelChunk chunk = playerchunk.getFullChunk();
+            if (chunk != null) {
+                chunkConsumer.accept(chunk);
+            }
+            // Paper end - rewrite chunk system
         }
 
     }
@@ -1251,20 +961,11 @@ public class ServerChunkCache extends ChunkSource {
         @Override
         // CraftBukkit start - process pending Chunk loadCallback() and unloadCallback() after each run task
         public boolean pollTask() {
-        try {
-            boolean execChunkTask = com.destroystokyo.paper.io.chunk.ChunkTaskManager.pollChunkWaitQueue() || ServerChunkCache.this.level.asyncChunkTaskManager.pollNextChunkTask(); // Paper
-            ServerChunkCache.this.chunkMap.playerChunkManager.tickMidTick(); // Paper
+            ServerChunkCache.this.chunkMap.playerChunkManager.tickMidTick();
             if (ServerChunkCache.this.runDistanceManagerUpdates()) {
                 return true;
-            } else {
-                ServerChunkCache.this.lightEngine.tryScheduleUpdate();
-                return super.pollTask() || execChunkTask; // Paper
             }
-        } finally {
-            chunkMap.chunkLoadConversionCallbackExecutor.run(); // Paper - Add chunk load conversion callback executor to prevent deadlock due to recursion in the chunk task queue sorter
-            chunkMap.callbackExecutor.run();
-        }
-        // CraftBukkit end
+            return super.pollTask() | ServerChunkCache.this.level.chunkTaskScheduler.executeMainThreadTask(); // Paper - rewrite chunk system
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 083349794d5ceb50322c5a645dd33fbfcc1c8155..737a7dbab2a5e6dd8d3eccfb751f552be1df1c45 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -190,7 +190,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
     private final MinecraftServer server;
     public final PrimaryLevelData serverLevelData; // CraftBukkit - type
     final EntityTickList entityTickList;
-    public final PersistentEntitySectionManager<Entity> entityManager;
+    //public final PersistentEntitySectionManager<Entity> entityManager; // Paper - rewrite chunk system
     public boolean noSave;
     private final SleepStatus sleepStatus;
     private int emptyTime;
@@ -262,11 +262,12 @@ public class ServerLevel extends Level implements WorldGenLevel {
         return true;
     }
 
-    public final void loadChunksForMoveAsync(AABB axisalignedbb, double toX, double toZ,
+    // Paper start - rewrite chunk system
+    public final void loadChunksForMoveAsync(AABB axisalignedbb, ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority priority,
                                              java.util.function.Consumer<List<net.minecraft.world.level.chunk.ChunkAccess>> onLoad) {
         if (Thread.currentThread() != this.thread) {
             this.getChunkSource().mainThreadProcessor.execute(() -> {
-                this.loadChunksForMoveAsync(axisalignedbb, toX, toZ, onLoad);
+                this.loadChunksForMoveAsync(axisalignedbb, priority, onLoad);
             });
             return;
         }
@@ -316,83 +317,11 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
         for (int cx = minChunkX; cx <= maxChunkX; ++cx) {
             for (int cz = minChunkZ; cz <= maxChunkZ; ++cz) {
-                chunkProvider.getChunkAtAsynchronously(cx, cz, net.minecraft.world.level.chunk.ChunkStatus.FULL, true, false, consumer);
+                chunkProvider.getChunkAtAsynchronously(cx, cz, true, net.minecraft.world.level.chunk.ChunkStatus.FULL, priority, consumer);
             }
         }
     }
-
-    // Paper start - Asynchronous IO
-    public final com.destroystokyo.paper.io.PaperFileIOThread.ChunkDataController poiDataController = new com.destroystokyo.paper.io.PaperFileIOThread.ChunkDataController() {
-        @Override
-        public void writeData(int x, int z, net.minecraft.nbt.CompoundTag compound) throws java.io.IOException {
-            ServerLevel.this.getChunkSource().chunkMap.getPoiManager().write(new ChunkPos(x, z), compound);
-        }
-
-        @Override
-        public net.minecraft.nbt.CompoundTag readData(int x, int z) throws java.io.IOException {
-            return ServerLevel.this.getChunkSource().chunkMap.getPoiManager().read(new ChunkPos(x, z));
-        }
-
-        @Override
-        public <T> T computeForRegionFile(int chunkX, int chunkZ, java.util.function.Function<net.minecraft.world.level.chunk.storage.RegionFile, T> function) {
-            synchronized (ServerLevel.this.getChunkSource().chunkMap.getPoiManager()) {
-                net.minecraft.world.level.chunk.storage.RegionFile file;
-
-                try {
-                    file = ServerLevel.this.getChunkSource().chunkMap.getPoiManager().getRegionFile(new ChunkPos(chunkX, chunkZ), false);
-                } catch (java.io.IOException ex) {
-                    throw new RuntimeException(ex);
-                }
-
-                return function.apply(file);
-            }
-        }
-
-        @Override
-        public <T> T computeForRegionFileIfLoaded(int chunkX, int chunkZ, java.util.function.Function<net.minecraft.world.level.chunk.storage.RegionFile, T> function) {
-            synchronized (ServerLevel.this.getChunkSource().chunkMap.getPoiManager()) {
-                net.minecraft.world.level.chunk.storage.RegionFile file = ServerLevel.this.getChunkSource().chunkMap.getPoiManager().getRegionFileIfLoaded(new ChunkPos(chunkX, chunkZ));
-                return function.apply(file);
-            }
-        }
-    };
-
-    public final com.destroystokyo.paper.io.PaperFileIOThread.ChunkDataController chunkDataController = new com.destroystokyo.paper.io.PaperFileIOThread.ChunkDataController() {
-        @Override
-        public void writeData(int x, int z, net.minecraft.nbt.CompoundTag compound) throws java.io.IOException {
-            ServerLevel.this.getChunkSource().chunkMap.write(new ChunkPos(x, z), compound);
-        }
-
-        @Override
-        public net.minecraft.nbt.CompoundTag readData(int x, int z) throws java.io.IOException {
-            return ServerLevel.this.getChunkSource().chunkMap.readSync(new ChunkPos(x, z));
-        }
-
-        @Override
-        public <T> T computeForRegionFile(int chunkX, int chunkZ, java.util.function.Function<net.minecraft.world.level.chunk.storage.RegionFile, T> function) {
-            synchronized (ServerLevel.this.getChunkSource().chunkMap) {
-                net.minecraft.world.level.chunk.storage.RegionFile file;
-
-                try {
-                    file = ServerLevel.this.getChunkSource().chunkMap.regionFileCache.getRegionFile(new ChunkPos(chunkX, chunkZ), false);
-                } catch (java.io.IOException ex) {
-                    throw new RuntimeException(ex);
-                }
-
-                return function.apply(file);
-            }
-        }
-
-        @Override
-        public <T> T computeForRegionFileIfLoaded(int chunkX, int chunkZ, java.util.function.Function<net.minecraft.world.level.chunk.storage.RegionFile, T> function) {
-            synchronized (ServerLevel.this.getChunkSource().chunkMap) {
-                net.minecraft.world.level.chunk.storage.RegionFile file = ServerLevel.this.getChunkSource().chunkMap.regionFileCache.getRegionFileIfLoaded(new ChunkPos(chunkX, chunkZ));
-                return function.apply(file);
-            }
-        }
-    };
-    public final com.destroystokyo.paper.io.chunk.ChunkTaskManager asyncChunkTaskManager;
-    // Paper end
+    // Paper end - rewrite chunk system
     // Paper start
     @Override
     public boolean hasChunk(int chunkX, int chunkZ) {
@@ -485,6 +414,108 @@ public class ServerLevel extends Level implements WorldGenLevel {
     }
     // Paper end - optimise get nearest players for entity AI
 
+    // Paper start - rewrite chunk system
+    public final io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler chunkTaskScheduler;
+    public final io.papermc.paper.chunk.system.io.RegionFileIOThread.ChunkDataController chunkDataControllerNew
+        = new io.papermc.paper.chunk.system.io.RegionFileIOThread.ChunkDataController(io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.CHUNK_DATA) {
+
+        @Override
+        public net.minecraft.world.level.chunk.storage.RegionFileStorage getCache() {
+            return ServerLevel.this.getChunkSource().chunkMap.regionFileCache;
+        }
+
+        @Override
+        public void writeData(int chunkX, int chunkZ, net.minecraft.nbt.CompoundTag compound) throws IOException {
+            ServerLevel.this.getChunkSource().chunkMap.write(new ChunkPos(chunkX, chunkZ), compound);
+        }
+
+        @Override
+        public net.minecraft.nbt.CompoundTag readData(int chunkX, int chunkZ) throws IOException {
+            return ServerLevel.this.getChunkSource().chunkMap.readSync(new ChunkPos(chunkX, chunkZ));
+        }
+    };
+    public final io.papermc.paper.chunk.system.io.RegionFileIOThread.ChunkDataController poiDataControllerNew
+        = new io.papermc.paper.chunk.system.io.RegionFileIOThread.ChunkDataController(io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.POI_DATA) {
+
+        @Override
+        public net.minecraft.world.level.chunk.storage.RegionFileStorage getCache() {
+            return ServerLevel.this.getChunkSource().chunkMap.getPoiManager();
+        }
+
+        @Override
+        public void writeData(int chunkX, int chunkZ, net.minecraft.nbt.CompoundTag compound) throws IOException {
+            ServerLevel.this.getChunkSource().chunkMap.getPoiManager().write(new ChunkPos(chunkX, chunkZ), compound);
+        }
+
+        @Override
+        public net.minecraft.nbt.CompoundTag readData(int chunkX, int chunkZ) throws IOException {
+            return ServerLevel.this.getChunkSource().chunkMap.getPoiManager().read(new ChunkPos(chunkX, chunkZ));
+        }
+    };
+    public final io.papermc.paper.chunk.system.io.RegionFileIOThread.ChunkDataController entityDataControllerNew
+        = new io.papermc.paper.chunk.system.io.RegionFileIOThread.ChunkDataController(io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.ENTITY_DATA) {
+
+        @Override
+        public net.minecraft.world.level.chunk.storage.RegionFileStorage getCache() {
+            return ServerLevel.this.entityStorage;
+        }
+
+        @Override
+        public void writeData(int chunkX, int chunkZ, net.minecraft.nbt.CompoundTag compound) throws IOException {
+            ServerLevel.this.writeEntityChunk(chunkX, chunkZ, compound);
+        }
+
+        @Override
+        public net.minecraft.nbt.CompoundTag readData(int chunkX, int chunkZ) throws IOException {
+            return ServerLevel.this.readEntityChunk(chunkX, chunkZ);
+        }
+    };
+    private final EntityRegionFileStorage entityStorage;
+
+    private static final class EntityRegionFileStorage extends net.minecraft.world.level.chunk.storage.RegionFileStorage {
+
+        public EntityRegionFileStorage(Path directory, boolean dsync) {
+            super(directory, dsync);
+        }
+
+        protected void write(ChunkPos pos, net.minecraft.nbt.CompoundTag nbt) throws IOException {
+            ChunkPos nbtPos = nbt == null ? null : EntityStorage.readChunkPos(nbt);
+            if (nbtPos != null && !pos.equals(nbtPos)) {
+                throw new IllegalArgumentException(
+                    "Entity chunk coordinate and serialized data do not have matching coordinates, trying to serialize coordinate " + pos.toString()
+                        + " but compound says coordinate is " + nbtPos + " for world: " + this
+                );
+            }
+            super.write(pos, nbt);
+        }
+    }
+
+    private void writeEntityChunk(int chunkX, int chunkZ, net.minecraft.nbt.CompoundTag compound) throws IOException {
+        if (!io.papermc.paper.chunk.system.io.RegionFileIOThread.isRegionFileThread()) {
+            io.papermc.paper.chunk.system.io.RegionFileIOThread.scheduleSave(
+                this, chunkX, chunkZ, compound,
+                io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.ENTITY_DATA);
+            return;
+        }
+        this.entityStorage.write(new ChunkPos(chunkX, chunkZ), compound);
+    }
+
+    private net.minecraft.nbt.CompoundTag readEntityChunk(int chunkX, int chunkZ) throws IOException {
+        if (!io.papermc.paper.chunk.system.io.RegionFileIOThread.isRegionFileThread()) {
+            return io.papermc.paper.chunk.system.io.RegionFileIOThread.loadData(
+                this, chunkX, chunkZ, io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.ENTITY_DATA,
+                io.papermc.paper.chunk.system.io.RegionFileIOThread.getIOBlockingPriorityForCurrentThread()
+            );
+        }
+        return this.entityStorage.read(new ChunkPos(chunkX, chunkZ));
+    }
+
+    private final io.papermc.paper.chunk.system.entity.EntityLookup entityLookup;
+    public final io.papermc.paper.chunk.system.entity.EntityLookup getEntityLookup() {
+        return this.entityLookup;
+    }
+    // Paper end - rewrite chunk system
+
     // Add env and gen to constructor, IWorldDataServer -> WorldDataServer
     public ServerLevel(MinecraftServer minecraftserver, Executor executor, LevelStorageSource.LevelStorageAccess convertable_conversionsession, PrimaryLevelData iworlddataserver, ResourceKey<Level> resourcekey, LevelStem worlddimension, ChunkProgressListener worldloadlistener, boolean flag, long i, List<CustomSpawner> list, boolean flag1, org.bukkit.World.Environment env, org.bukkit.generator.ChunkGenerator gen, org.bukkit.generator.BiomeProvider biomeProvider) {
         // Holder holder = worlddimension.typeHolder(); // CraftBukkit - decompile error
@@ -527,16 +558,16 @@ public class ServerLevel extends Level implements WorldGenLevel {
         // CraftBukkit end
         boolean flag2 = minecraftserver.forceSynchronousWrites();
         DataFixer datafixer = minecraftserver.getFixerUpper();
-        EntityPersistentStorage<Entity> entitypersistentstorage = new EntityStorage(this, convertable_conversionsession.getDimensionPath(resourcekey).resolve("entities"), datafixer, flag2, minecraftserver);
+        this.entityStorage = new EntityRegionFileStorage(convertable_conversionsession.getDimensionPath(resourcekey).resolve("entities"), flag2); // Paper - rewrite chunk system  //EntityPersistentStorage<Entity> entitypersistentstorage = new EntityStorage(this, convertable_conversionsession.getDimensionPath(resourcekey).resolve("entities"), datafixer, flag2, minecraftserver);
 
-        this.entityManager = new PersistentEntitySectionManager<>(Entity.class, new ServerLevel.EntityCallbacks(), entitypersistentstorage, this.entitySliceManager); // Paper
+        // this.entityManager = new PersistentEntitySectionManager<>(Entity.class, new ServerLevel.EntityCallbacks(), entitypersistentstorage, this.entitySliceManager); // Paper // Paper - rewrite chunk system
         StructureTemplateManager structuretemplatemanager = minecraftserver.getStructureManager();
         int j = this.spigotConfig.viewDistance; // Spigot
         int k = this.spigotConfig.simulationDistance; // Spigot
-        PersistentEntitySectionManager persistententitysectionmanager = this.entityManager;
+        //PersistentEntitySectionManager persistententitysectionmanager = this.entityManager; // Paper - rewrite chunk system
 
-        Objects.requireNonNull(this.entityManager);
-        this.chunkSource = new ServerChunkCache(this, convertable_conversionsession, datafixer, structuretemplatemanager, executor, chunkgenerator, j, k, flag2, worldloadlistener, persistententitysectionmanager::updateChunkStatus, () -> {
+        //Objects.requireNonNull(this.entityManager); // Paper - rewrite chunk system
+        this.chunkSource = new ServerChunkCache(this, convertable_conversionsession, datafixer, structuretemplatemanager, executor, chunkgenerator, j, k, flag2, worldloadlistener, null, () -> { // Paper - rewrite chunk system
             return minecraftserver.overworld().getDataStorage();
         });
         chunkgenerator.ensureStructuresGenerated(this.chunkSource.randomState());
@@ -566,7 +597,8 @@ public class ServerLevel extends Level implements WorldGenLevel {
         this.sleepStatus = new SleepStatus();
         this.getCraftServer().addWorld(this.getWorld()); // CraftBukkit
 
-        this.asyncChunkTaskManager = new com.destroystokyo.paper.io.chunk.ChunkTaskManager(this); // Paper
+        this.chunkTaskScheduler = new io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler(this, io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.workerThreads); // Paper - rewrite chunk system
+        this.entityLookup = new io.papermc.paper.chunk.system.entity.EntityLookup(this, new EntityCallbacks()); // Paper - rewrite chunk system
     }
 
     public void setWeatherParameters(int clearDuration, int rainDuration, boolean raining, boolean thundering) {
@@ -703,7 +735,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         }
 
         gameprofilerfiller.push("entityManagement");
-        this.entityManager.tick();
+        //this.entityManager.tick(); // Paper - rewrite chunk system
         gameprofilerfiller.popPush("gameEvents");
         this.sendGameEvents();
         gameprofilerfiller.pop();
@@ -1121,7 +1153,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
     public void tickNonPassenger(Entity entity) {
         // Paper start - log detailed entity tick information
         io.papermc.paper.util.TickThread.ensureTickThread("Cannot tick an entity off-main");
-        if (!entity.isRemoved()) this.entityManager.updateNavigatorsInRegion(entity); // Paper - optimise notify
+        //if (!entity.isRemoved()) this.entityManager.updateNavigatorsInRegion(entity); // Paper - optimise notify // Paper - rewrite chunk system
         try {
             if (currentlyTickingEntity.get() == null) {
                 currentlyTickingEntity.lazySet(entity);
@@ -1255,6 +1287,11 @@ public class ServerLevel extends Level implements WorldGenLevel {
     // Paper end
 
     public void save(@Nullable ProgressListener progressListener, boolean flush, boolean savingDisabled) {
+        // Paper start - rewrite chunk system - add close param
+        this.save(progressListener, flush, savingDisabled, false);
+    }
+    public void save(@Nullable ProgressListener progressListener, boolean flush, boolean savingDisabled, boolean close) {
+        // Paper end - rewrite chunk system - add close param
         ServerChunkCache chunkproviderserver = this.getChunkSource();
 
         if (!savingDisabled) {
@@ -1270,14 +1307,11 @@ public class ServerLevel extends Level implements WorldGenLevel {
             }
 
                 timings.worldSaveChunks.startTiming(); // Paper
-            chunkproviderserver.save(flush);
+            if (!close) chunkproviderserver.save(flush); // Paper - rewrite chunk system
+            if (close) chunkproviderserver.close(true); // Paper - rewrite chunk system
                 timings.worldSaveChunks.stopTiming(); // Paper
             }// Paper
-            if (flush) {
-                this.entityManager.saveAll();
-            } else {
-                this.entityManager.autoSave();
-            }
+            // Paper - rewrite chunk system - entity saving moved into ChunkHolder
 
         }
         // Paper start
@@ -1402,7 +1436,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
             this.removePlayerImmediately((ServerPlayer) entity, Entity.RemovalReason.DISCARDED);
         }
 
-        this.entityManager.addNewEntity(player);
+        this.entityLookup.addNewEntity(player); // Paper - rewite chunk system
     }
 
     // CraftBukkit start
@@ -1447,7 +1481,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
             }
             // CraftBukkit end
 
-            return this.entityManager.addNewEntity(entity);
+            return this.entityLookup.addNewEntity(entity); // Paper - rewrite chunk system
         }
     }
 
@@ -1459,10 +1493,10 @@ public class ServerLevel extends Level implements WorldGenLevel {
     public boolean tryAddFreshEntityWithPassengers(Entity entity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason) {
         // CraftBukkit end
         Stream<UUID> stream = entity.getSelfAndPassengers().map(Entity::getUUID); // CraftBukkit - decompile error
-        PersistentEntitySectionManager persistententitysectionmanager = this.entityManager;
+        //PersistentEntitySectionManager persistententitysectionmanager = this.entityManager; // Paper - rewrite chunk system
 
-        Objects.requireNonNull(this.entityManager);
-        if (stream.anyMatch(persistententitysectionmanager::isLoaded)) {
+        //Objects.requireNonNull(this.entityManager); // Paper - rewrite chunk system
+        if (stream.anyMatch(this.entityLookup::hasEntity)) { // Paper - rewrite chunk system
             return false;
         } else {
             this.addFreshEntityWithPassengers(entity, reason); // CraftBukkit
@@ -2152,7 +2186,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
                 }
             }
 
-            bufferedwriter.write(String.format(Locale.ROOT, "entities: %s\n", this.entityManager.gatherStats()));
+            bufferedwriter.write(String.format(Locale.ROOT, "entities: %s\n", this.entityLookup.getDebugInfo())); // Paper - rewrite chunk system
             bufferedwriter.write(String.format(Locale.ROOT, "block_entity_tickers: %d\n", this.blockEntityTickers.size()));
             bufferedwriter.write(String.format(Locale.ROOT, "block_ticks: %d\n", this.getBlockTicks().count()));
             bufferedwriter.write(String.format(Locale.ROOT, "fluid_ticks: %d\n", this.getFluidTicks().count()));
@@ -2222,7 +2256,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         BufferedWriter bufferedwriter3 = Files.newBufferedWriter(path2);
 
         try {
-            this.entityManager.dumpSections(bufferedwriter3);
+            //this.entityManager.dumpSections(bufferedwriter3); // Paper - rewrite chunk system - TODO
         } catch (Throwable throwable6) {
             if (bufferedwriter3 != null) {
                 try {
@@ -2364,7 +2398,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
     @VisibleForTesting
     public String getWatchdogStats() {
-        return String.format(Locale.ROOT, "players: %s, entities: %s [%s], block_entities: %d [%s], block_ticks: %d, fluid_ticks: %d, chunk_source: %s", this.players.size(), this.entityManager.gatherStats(), ServerLevel.getTypeCount(this.entityManager.getEntityGetter().getAll(), (entity) -> {
+        return String.format(Locale.ROOT, "players: %s, entities: %s [%s], block_entities: %d [%s], block_ticks: %d, fluid_ticks: %d, chunk_source: %s", this.players.size(), this.entityLookup.getDebugInfo(), ServerLevel.getTypeCount(this.entityLookup.getAll(), (entity) -> { // Paper - rewrite chunk system
             return Registry.ENTITY_TYPE.getKey(entity.getType()).toString();
         }), this.blockEntityTickers.size(), ServerLevel.getTypeCount(this.blockEntityTickers, TickingBlockEntity::getType), this.getBlockTicks().count(), this.getFluidTicks().count(), this.gatherChunkSourceStats());
     }
@@ -2424,15 +2458,15 @@ public class ServerLevel extends Level implements WorldGenLevel {
     @Override
     public LevelEntityGetter<Entity> getEntities() {
         org.spigotmc.AsyncCatcher.catchOp("Chunk getEntities call"); // Spigot
-        return this.entityManager.getEntityGetter();
+        return this.entityLookup; // Paper - rewrite chunk system
     }
 
     public void addLegacyChunkEntities(Stream<Entity> entities) {
-        this.entityManager.addLegacyChunkEntities(entities);
+        this.entityLookup.addLegacyChunkEntities(entities.toList()); // Paper - rewrite chunk system
     }
 
     public void addWorldGenChunkEntities(Stream<Entity> entities) {
-        this.entityManager.addWorldGenChunkEntities(entities);
+        this.entityLookup.addWorldGenChunkEntities(entities.toList()); // Paper - rewrite chunk system
     }
 
     public void startTickingChunk(LevelChunk chunk) {
@@ -2448,18 +2482,20 @@ public class ServerLevel extends Level implements WorldGenLevel {
     @Override
     public void close() throws IOException {
         super.close();
-        this.entityManager.close();
+        //this.entityManager.close(); // Paper - rewrite chunk system
     }
 
     @Override
     public String gatherChunkSourceStats() {
         String s = this.chunkSource.gatherStats();
 
-        return "Chunks[S] W: " + s + " E: " + this.entityManager.gatherStats();
+        return "Chunks[S] W: " + s + " E: " + this.entityLookup.getDebugInfo(); // Paper - rewrite chunk system
     }
 
     public boolean areEntitiesLoaded(long chunkPos) {
-        return this.entityManager.areEntitiesLoaded(chunkPos);
+        // Paper start - rewrite chunk system
+        return this.getChunkIfLoadedImmediately(ChunkPos.getX(chunkPos), ChunkPos.getZ(chunkPos)) != null;
+        // Paper end - rewrite chunk system
     }
 
     private boolean isPositionTickingWithEntitiesLoaded(long chunkPos) {
@@ -2470,15 +2506,24 @@ public class ServerLevel extends Level implements WorldGenLevel {
     }
 
     public boolean isPositionEntityTicking(BlockPos pos) {
-        return this.entityManager.canPositionTick(ChunkPos.asLong(pos)) && this.chunkSource.chunkMap.getDistanceManager().inEntityTickingRange(ChunkPos.asLong(pos)); // Paper
+        // Paper start - rewrite chunk system
+        ChunkHolder chunkHolder = this.chunkSource.chunkMap.getVisibleChunkIfPresent(io.papermc.paper.util.CoordinateUtils.getChunkKey(pos));
+        return chunkHolder != null && chunkHolder.isEntityTickingReady();
+        // Paper end - rewrite chunk system
     }
 
     public boolean isNaturalSpawningAllowed(BlockPos pos) {
-        return this.entityManager.canPositionTick(ChunkPos.asLong(pos)); // Paper
+        // Paper start - rewrite chunk system
+        ChunkHolder chunkHolder = this.chunkSource.chunkMap.getVisibleChunkIfPresent(io.papermc.paper.util.CoordinateUtils.getChunkKey(pos));
+        return chunkHolder != null && chunkHolder.isEntityTickingReady();
+        // Paper end - rewrite chunk system
     }
 
     public boolean isNaturalSpawningAllowed(ChunkPos pos) {
-        return this.entityManager.canPositionTick(pos.toLong()); // Paper
+        // Paper start - rewrite chunk system
+        ChunkHolder chunkHolder = this.chunkSource.chunkMap.getVisibleChunkIfPresent(io.papermc.paper.util.CoordinateUtils.getChunkKey(pos));
+        return chunkHolder != null && chunkHolder.isEntityTickingReady();
+        // Paper end - rewrite chunk system
     }
 
     // Paper start - optimize redstone (Alternate Current)
@@ -2501,12 +2546,12 @@ public class ServerLevel extends Level implements WorldGenLevel {
         public void onTickingStart(Entity entity) {
             if (entity instanceof net.minecraft.world.entity.Marker) return; // Paper - Don't tick markers
             ServerLevel.this.entityTickList.add(entity);
-            ServerLevel.this.entityManager.addNavigatorsIfPathingToRegion(entity); // Paper - optimise notify
+            //ServerLevel.this.entityManager.addNavigatorsIfPathingToRegion(entity); // Paper - optimise notify // Paper - rewrite chunk system
         }
 
         public void onTickingEnd(Entity entity) {
             ServerLevel.this.entityTickList.remove(entity);
-            ServerLevel.this.entityManager.removeNavigatorsFromData(entity); // Paper - optimise notify
+            //ServerLevel.this.entityManager.removeNavigatorsFromData(entity); // Paper - optimise notify // Paper - rewrite chunk system
             // Paper start - Reset pearls when they stop being ticked
             if (paperConfig().fixes.disableUnloadedChunkEnderpearlExploit && entity instanceof net.minecraft.world.entity.projectile.ThrownEnderpearl pearl) {
                 pearl.cachedOwner = null;
diff --git a/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java b/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java
index b57bffce30154b196b879209c1ce559d0b82456e..4cc1276b6ed5a9c86173d45d6a2aa8e68c9783bf 100644
--- a/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java
+++ b/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java
@@ -36,149 +36,22 @@ import net.minecraft.world.level.chunk.ChunkStatus;
 
 public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCloseable {
     private static final Logger LOGGER = LogUtils.getLogger();
-    private final ProcessorMailbox<Runnable> taskMailbox;
-    // Paper start
-    private static final int MAX_PRIORITIES = ChunkMap.MAX_CHUNK_DISTANCE + 2;
-
-    static class ChunkLightQueue {
-        public boolean shouldFastUpdate;
-        java.util.ArrayDeque<Runnable> pre = new java.util.ArrayDeque<Runnable>();
-        java.util.ArrayDeque<Runnable> post = new java.util.ArrayDeque<Runnable>();
-
-        ChunkLightQueue(long chunk) {}
-    }
-
-    static class PendingLightTask {
-        long chunkId;
-        IntSupplier priority;
-        Runnable pre;
-        Runnable post;
-        boolean fastUpdate;
-
-        public PendingLightTask(long chunkId, IntSupplier priority, Runnable pre, Runnable post, boolean fastUpdate) {
-            this.chunkId = chunkId;
-            this.priority = priority;
-            this.pre = pre;
-            this.post = post;
-            this.fastUpdate = fastUpdate;
-        }
-    }
-
-
-    // Retain the chunks priority level for queued light tasks
-    class LightQueue {
-        private int size = 0;
-        private final it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap<ChunkLightQueue>[] buckets = new it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap[MAX_PRIORITIES];
-        private final java.util.concurrent.ConcurrentLinkedQueue<PendingLightTask> pendingTasks = new java.util.concurrent.ConcurrentLinkedQueue<>();
-        private final java.util.concurrent.ConcurrentLinkedQueue<Runnable> priorityChanges = new java.util.concurrent.ConcurrentLinkedQueue<>();
-
-        private LightQueue() {
-            for (int i = 0; i < buckets.length; i++) {
-                buckets[i] = new it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap<>();
-            }
-        }
-
-        public void changePriority(long pair, int currentPriority, int priority) {
-            this.priorityChanges.add(() -> {
-                ChunkLightQueue remove = this.buckets[currentPriority].remove(pair);
-                if (remove != null) {
-                    ChunkLightQueue existing = this.buckets[Math.max(1, priority)].put(pair, remove);
-                    if (existing != null) {
-                        remove.pre.addAll(existing.pre);
-                        remove.post.addAll(existing.post);
-                    }
-                }
-            });
-        }
-
-        public final void addChunk(long chunkId, IntSupplier priority, Runnable pre, Runnable post) {
-            pendingTasks.add(new PendingLightTask(chunkId, priority, pre, post, true));
-            tryScheduleUpdate();
-        }
-
-        public final void add(long chunkId, IntSupplier priority, ThreadedLevelLightEngine.TaskType type, Runnable run) {
-            pendingTasks.add(new PendingLightTask(chunkId, priority, type == TaskType.PRE_UPDATE ? run : null, type == TaskType.POST_UPDATE ? run : null, false));
-        }
-        public final void add(PendingLightTask update) {
-            int priority = update.priority.getAsInt();
-            ChunkLightQueue lightQueue = this.buckets[priority].computeIfAbsent(update.chunkId, ChunkLightQueue::new);
-
-            if (update.pre != null) {
-                this.size++;
-                lightQueue.pre.add(update.pre);
-            }
-            if (update.post != null) {
-                this.size++;
-                lightQueue.post.add(update.post);
-            }
-            if (update.fastUpdate) {
-                lightQueue.shouldFastUpdate = true;
-            }
-        }
-
-        public final boolean isEmpty() {
-            return this.size == 0 && this.pendingTasks.isEmpty();
-        }
-
-        public final int size() {
-            return this.size;
-        }
-
-        public boolean poll(java.util.List<Runnable> pre, java.util.List<Runnable> post) {
-            PendingLightTask pending;
-            while ((pending = pendingTasks.poll()) != null) {
-                add(pending);
-            }
-            Runnable run;
-            while ((run = priorityChanges.poll()) != null) {
-                run.run();
-            }
-            boolean hasWork = false;
-            it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap<ChunkLightQueue>[] buckets = this.buckets;
-            int priority = 0;
-            while (priority < MAX_PRIORITIES && !isEmpty()) {
-                it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap<ChunkLightQueue> bucket = buckets[priority];
-                if (bucket.isEmpty()) {
-                    priority++;
-                    if (hasWork) {
-                        return true;
-                    } else {
-                        continue;
-                    }
-                }
-                ChunkLightQueue queue = bucket.removeFirst();
-                this.size -= queue.pre.size() + queue.post.size();
-                pre.addAll(queue.pre);
-                post.addAll(queue.post);
-                queue.pre.clear();
-                queue.post.clear();
-                hasWork = true;
-                if (queue.shouldFastUpdate) {
-                    return true;
-                }
-            }
-            return hasWork;
-        }
-    }
-
-    final LightQueue queue = new LightQueue();
-    // Paper end
-    private final ChunkMap chunkMap; private final ChunkMap playerChunkMap; // Paper
-    private final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> sorterMailbox;
+    // Paper - rewrite chunk system
+    private final ChunkMap chunkMap; // Paper - rewrite chunk system
+    // Paper - rewrite chunk system
     private volatile int taskPerBatch = 5;
-    private final AtomicBoolean scheduled = new AtomicBoolean();
+    // Paper - rewrite chunk system
 
     // Paper start - replace light engine impl
-    protected final ca.spottedleaf.starlight.common.light.StarLightInterface theLightEngine;
+    public final ca.spottedleaf.starlight.common.light.StarLightInterface theLightEngine;
     public final boolean hasBlockLight;
     public final boolean hasSkyLight;
     // Paper end - replace light engine impl
 
     public ThreadedLevelLightEngine(LightChunkGetter chunkProvider, ChunkMap chunkStorage, boolean hasBlockLight, ProcessorMailbox<Runnable> processor, ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> executor) {
         super(chunkProvider, false, false); // Paper - destroy vanilla light engine state
-        this.chunkMap = chunkStorage; this.playerChunkMap = chunkMap; // Paper
-        this.sorterMailbox = executor;
-        this.taskMailbox = processor;
+        this.chunkMap = chunkStorage; // Paper - rewrite chunk system
+        // Paper - rewrite chunk system
         // Paper start - replace light engine impl
         this.hasBlockLight = true;
         this.hasSkyLight = hasBlockLight; // Nice variable name.
@@ -222,7 +95,7 @@ public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCl
             ++totalChunks;
         }
 
-        this.taskMailbox.tell(() -> {
+        this.chunkMap.level.chunkTaskScheduler.lightExecutor.queueRunnable(() -> { // Paper - rewrite chunk system
             this.theLightEngine.relightChunks(chunks, (ChunkPos chunkPos) -> {
                 chunkLightCallback.accept(chunkPos);
                 ((java.util.concurrent.Executor)((ServerLevel)this.theLightEngine.getWorld()).getChunkSource().mainThreadProcessor).execute(() -> {
@@ -285,9 +158,7 @@ public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCl
             for (int dz = -1; dz <= 1; ++dz) {
                 ChunkHolder neighbour = world.getChunkSource().chunkMap.getUpdatingChunkIfPresent(CoordinateUtils.getChunkKey(dx + chunkX, dz + chunkZ));
                 if (neighbour != null) {
-                    neighbour.chunkToSave = neighbour.chunkToSave.thenCombine(updateFuture, (final ChunkAccess curr, final Void ignore) -> {
-                        return curr;
-                    });
+                    // Paper - rewrite chunk system - TODO
                 }
             }
         }
@@ -311,7 +182,7 @@ public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCl
     @Override
     public boolean hasLightWork() {
         // route to new light engine
-        return this.theLightEngine.hasUpdates() || !this.queue.isEmpty();
+        return this.theLightEngine.hasUpdates(); // Paper - rewrite chunk system
     }
 
     @Override
@@ -408,13 +279,11 @@ public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCl
     }
 
     private void addTask(int x, int z, ThreadedLevelLightEngine.TaskType stage, Runnable task) {
-        this.addTask(x, z, this.chunkMap.getChunkQueueLevel(ChunkPos.asLong(x, z)), stage, task);
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     private void addTask(int x, int z, IntSupplier completedLevelSupplier, ThreadedLevelLightEngine.TaskType stage, Runnable task) {
-        // Paper start - replace method
-        this.queue.add(ChunkPos.asLong(x, z), completedLevelSupplier, stage, task);
-        // Paper end
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     @Override
@@ -472,74 +341,17 @@ public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCl
                 }
             });
         }
-        // Paper end - replace light engine impl
-        ChunkPos chunkPos = chunk.getPos();
-        // Paper start
-        //ichunkaccess.b(false); // Don't need to disable this
-        long pair = chunkPos.toLong();
-        CompletableFuture<ChunkAccess> future = new CompletableFuture<>();
-        IntSupplier prioritySupplier = playerChunkMap.getChunkQueueLevel(pair);
-        boolean[] skippedPre = {false};
-        this.queue.addChunk(pair, prioritySupplier, Util.name(() -> {
-            // Paper end
-            LevelChunkSection[] levelChunkSections = chunk.getSections();
-
-            for(int i = 0; i < chunk.getSectionsCount(); ++i) {
-                LevelChunkSection levelChunkSection = levelChunkSections[i];
-                if (!levelChunkSection.hasOnlyAir()) {
-                    int j = this.levelHeightAccessor.getSectionYFromSectionIndex(i);
-                    super.updateSectionStatus(SectionPos.of(chunkPos, j), false);
-                }
-            }
-
-            super.enableLightSources(chunkPos, true);
-            if (!excludeBlocks) {
-                chunk.getLights().forEach((pos) -> {
-                    super.onBlockEmissionIncrease(pos, chunk.getLightEmission(pos));
-                });
-            }
-
-        }, () -> {
-            return "lightChunk " + chunkPos + " " + excludeBlocks;
-            // Paper start  - merge the 2 together
-        }), () -> {
-            this.chunkMap.releaseLightTicket(chunkPos); // Paper - moved from below, we want to call this even when returning early
-            if (skippedPre[0]) return; // Paper - future's already complete
-            chunk.setLightCorrect(true);
-            super.retainData(chunkPos, false);
-            //this.chunkMap.releaseLightTicket(chunkPos); // Paper - moved up
-            future.complete(chunk);
-        });
-        return future;
-        // Paper end
+        throw new InternalError(); // Paper - rewrite chunk system
     }
 
     public void tryScheduleUpdate() {
-        if (this.hasLightWork() && this.scheduled.compareAndSet(false, true)) { // Paper  // Paper - rewrite light engine
-            this.taskMailbox.tell(() -> {
-                this.runUpdate();
-                this.scheduled.set(false);
-                tryScheduleUpdate(); // Paper - if we still have work to do, do it!
-            });
-        }
+        // Paper - rewrite chunk system
 
     }
 
-    // Paper start - replace impl
-    private final java.util.List<Runnable> pre = new java.util.ArrayList<>();
-    private final java.util.List<Runnable> post = new java.util.ArrayList<>();
+    // Paper - rewrite chunk system
     private void runUpdate() {
-        if (queue.poll(pre, post)) {
-            pre.forEach(Runnable::run);
-            pre.clear();
-            this.theLightEngine.propagateChanges(); // Paper - rewrite light engine
-            post.forEach(Runnable::run);
-            post.clear();
-        } else {
-            // might have level updates to go still
-            this.theLightEngine.propagateChanges(); // Paper - rewrite light engine
-        }
-        // Paper end
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     public void setTaskPerBatch(int taskBatchSize) {
diff --git a/src/main/java/net/minecraft/server/level/Ticket.java b/src/main/java/net/minecraft/server/level/Ticket.java
index 2b2b7851d5f68bcdb41d58bcc64740ba58bf1ef4..28edbae568a06ec040795d75f24de8b4218da141 100644
--- a/src/main/java/net/minecraft/server/level/Ticket.java
+++ b/src/main/java/net/minecraft/server/level/Ticket.java
@@ -6,15 +6,16 @@ public final class Ticket<T> implements Comparable<Ticket<?>> {
     private final TicketType<T> type;
     private final int ticketLevel;
     public final T key;
-    public long createdTick;
-    public long delayUnloadBy; // Paper
-    public int priority; // Paper - Chunk priority
+    // Paper start - rewrite chunk system
+    public final long removalTick;
 
-    protected Ticket(TicketType<T> type, int level, T argument) {
+    public Ticket(TicketType<T> type, int level, T argument, long removalTick) {
+        this.removalTick = removalTick;
+        // Paper end - rewrite chunk system
         this.type = type;
         this.ticketLevel = level;
         this.key = argument;
-        this.delayUnloadBy = type.timeout; // Paper
+        // Paper - rewrite chunk system
     }
 
     @Override
@@ -47,7 +48,7 @@ public final class Ticket<T> implements Comparable<Ticket<?>> {
 
     @Override
     public String toString() {
-        return "Ticket[" + this.type + " " + this.ticketLevel + " (" + this.key + ")] at " + this.createdTick;
+        return "Ticket[" + this.type + " " + this.ticketLevel + " (" + this.key + ")] to die on " + this.removalTick; // Paper - rewrite chunk system
     }
 
     public TicketType<T> getType() {
@@ -59,11 +60,10 @@ public final class Ticket<T> implements Comparable<Ticket<?>> {
     }
 
     protected void setCreatedTick(long tickCreated) {
-        this.createdTick = tickCreated;
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
     protected boolean timedOut(long currentTick) {
-        long l = delayUnloadBy; // Paper
-        return l != 0L && currentTick - this.createdTick > l;
+        throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 }
diff --git a/src/main/java/net/minecraft/server/level/TicketType.java b/src/main/java/net/minecraft/server/level/TicketType.java
index ae46429264e6a7e5c88b6b6a41a6df4db7b3e70d..08d8fe58a273cca0af01e69fa4ab026160715af7 100644
--- a/src/main/java/net/minecraft/server/level/TicketType.java
+++ b/src/main/java/net/minecraft/server/level/TicketType.java
@@ -33,6 +33,10 @@ public class TicketType<T> {
     public static final TicketType<Long> DELAY_UNLOAD = create("delay_unload", Long::compareTo, 300); // Paper
     public static final TicketType<Long> REQUIRED_LOAD = create("required_load", Long::compareTo); // Paper - make sure getChunkAt does not fail
     public static final TicketType<Long> CHUNK_RELIGHT = create("light_update", Long::compareTo); // Paper - ensure chunks stay loaded for lighting
+    public static final TicketType<Long> CHUNK_LOAD = create("chunk_load", Long::compareTo); // Paper - rewrite chunk system
+    public static final TicketType<Long> STATUS_UPGRADE = create("status_upgrade", Long::compareTo); // Paper - rewrite chunk system
+    public static final TicketType<Long> ENTITY_LOAD = create("entity_load", Long::compareTo); // Paper - rewrite chunk system
+    public static final TicketType<Unit> UNLOAD_COOLDOWN = create("unload_cooldown", (u1, u2) -> 0); // Paper - rewrite chunk system
 
     public static <T> TicketType<T> create(String name, Comparator<T> argumentComparator) {
         return new TicketType<>(name, argumentComparator, 0L);
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 71623c84a5b15023189c14a6bf36e1b08f935fc1..839d03fc91b2928c22cab1a35fe0c1cfcaef3fa3 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -295,15 +295,7 @@ public abstract class PlayerList {
         net.minecraft.server.level.ChunkMap playerChunkMap = worldserver1.getChunkSource().chunkMap;
         net.minecraft.server.level.DistanceManager distanceManager = playerChunkMap.distanceManager;
         distanceManager.addTicket(net.minecraft.server.level.TicketType.LOGIN, pos, 31, pos.toLong());
-        worldserver1.getChunkSource().markAreaHighPriority(pos, 28, 3); // Paper - Chunk priority
-        worldserver1.getChunkSource().getChunkAtAsynchronously(chunkX, chunkZ, true, false).thenApply(chunk -> { // Paper - Chunk priority
-            net.minecraft.server.level.ChunkHolder updatingChunk = playerChunkMap.getUpdatingChunkIfPresent(pos.toLong());
-            if (updatingChunk != null) {
-                return updatingChunk.getEntityTickingChunkFuture();
-            } else {
-                return java.util.concurrent.CompletableFuture.completedFuture(chunk);
-            }
-        }).thenAccept(chunk -> {
+        worldserver1.chunkTaskScheduler.scheduleTickingState(chunkX, chunkZ, net.minecraft.server.level.ChunkHolder.FullChunkStatus.ENTITY_TICKING, true, ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.HIGHER, (chunk) -> { // Paper - rewrite chunk system
             playerconnection.playerJoinReady = () -> {
                 postChunkLoadJoin(
                     player, finalWorldserver, connection, playerconnection,
diff --git a/src/main/java/net/minecraft/util/SortedArraySet.java b/src/main/java/net/minecraft/util/SortedArraySet.java
index 5f1c4c6b9e36f2d6ec43b82cc0e2cae24b800dc4..5fcbb4fd003603408c48408230a17b692fabd519 100644
--- a/src/main/java/net/minecraft/util/SortedArraySet.java
+++ b/src/main/java/net/minecraft/util/SortedArraySet.java
@@ -145,6 +145,31 @@ public class SortedArraySet<T> extends AbstractSet<T> {
         }
     }
 
+    // Paper start - rewrite chunk system
+    public T replace(T object) {
+        int i = this.findIndex(object);
+        if (i >= 0) {
+            T old = this.contents[i];
+            this.contents[i] = object;
+            return old;
+        } else {
+            this.addInternal(object, getInsertionPosition(i));
+            return object;
+        }
+    }
+
+    public T removeAndGet(T object) {
+        int i = this.findIndex(object);
+        if (i >= 0) {
+            final T ret = this.contents[i];
+            this.removeInternal(i);
+            return ret;
+        } else {
+            return null;
+        }
+    }
+    // Paper end - rewrite chunk system
+
     @Override
     public boolean remove(Object object) {
         int i = this.findIndex((T)object);
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index f925a8d550ecbf2044a37bfe58b30d6578c5f6af..a10799816ee26bd4708957628b642e3760ca54a7 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -3886,6 +3886,16 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         };
     }
 
+    // Paper start - rewrite chunk system
+    public boolean hasAnyPlayerPassengers() {
+        // copied from below
+        if (this.passengers.isEmpty()) { return false; }
+        return this.getIndirectPassengersStream().anyMatch((entity) -> {
+            return entity instanceof Player;
+        });
+    }
+    // Paper end - rewrite chunk system
+
     public boolean hasExactlyOnePlayerPassenger() {
         if (this.passengers.isEmpty()) { return false; } // Paper
         return this.getIndirectPassengersStream().filter((entity) -> {
@@ -4331,6 +4341,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
 
     @Override
     public final void setRemoved(Entity.RemovalReason reason) {
+        io.papermc.paper.util.TickThread.ensureTickThread(this.chunkPosition().x, this.chunkPosition().z, "Cannot remove entity off-main"); // Paper - rewrite chunk system
         if (this.removalReason == null) {
             this.removalReason = reason;
         }
@@ -4339,7 +4350,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
             this.stopRiding();
         }
 
-        this.getPassengers().forEach(Entity::stopRiding);
+        if (reason != RemovalReason.UNLOADED_TO_CHUNK) this.getPassengers().forEach(Entity::stopRiding); // Paper - chunk system - don't adjust passenger state when unloading, it's just not safe (and messes with our logic in entity chunk unload)
         this.levelCallback.onRemove(reason);
     }
 
@@ -4354,7 +4365,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
 
     @Override
     public boolean shouldBeSaved() {
-        return this.removalReason != null && !this.removalReason.shouldSave() ? false : (this.isPassenger() ? false : !this.isVehicle() || !this.hasExactlyOnePlayerPassenger());
+        return this.removalReason != null && !this.removalReason.shouldSave() ? false : (this.isPassenger() ? false : !this.isVehicle() || !this.hasAnyPlayerPassengers()); // Paper - rewrite chunk system - it should check if the entity has ANY player passengers
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
index 210b0cdd4831421c8f43c3d823ac8e962b56bbbc..93a99f3e790f58477dd371eb04374d9b6a8aab1f 100644
--- a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
@@ -1,12 +1,11 @@
 package net.minecraft.world.entity.ai.village.poi;
 
-import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper
+import io.papermc.paper.chunk.system.scheduling.ChunkHolderManager;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
-import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import it.unimi.dsi.fastutil.longs.LongSet;
+
 import java.nio.file.Path;
 import java.util.Comparator;
 import java.util.List;
@@ -55,7 +54,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
         }
     }
     // Paper end - unload poi data
-    private final LongSet loadedChunks = new LongOpenHashSet();
+    // Paper - rewrite chunk system
     public final net.minecraft.server.level.ServerLevel world; // Paper // Paper public
 
     public PoiManager(Path path, DataFixer dataFixer, boolean dsync, RegistryAccess registryManager, LevelHeightAccessor world) {
@@ -64,119 +63,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
         this.world = (net.minecraft.server.level.ServerLevel)world; // Paper
     }
 
-    // Paper start - actually unload POI data
-    private final java.util.TreeSet<QueuedUnload> queuedUnloads = new java.util.TreeSet<>();
-    private final Long2ObjectOpenHashMap<QueuedUnload> queuedUnloadsByCoordinate = new Long2ObjectOpenHashMap<>();
-
-    static final class QueuedUnload implements Comparable<QueuedUnload> {
-
-        private final long unloadTick;
-        private final long coordinate;
-
-        public QueuedUnload(long unloadTick, long coordinate) {
-            this.unloadTick = unloadTick;
-            this.coordinate = coordinate;
-        }
-
-        @Override
-        public int compareTo(QueuedUnload other) {
-            if (other.unloadTick == this.unloadTick) {
-                return Long.compare(this.coordinate, other.coordinate);
-            } else {
-                return Long.compare(this.unloadTick, other.unloadTick);
-            }
-        }
-
-        @Override
-        public int hashCode() {
-            int hash = 1;
-            hash = hash * 31 + Long.hashCode(this.unloadTick);
-            hash = hash * 31 + Long.hashCode(this.coordinate);
-            return hash;
-        }
-
-        @Override
-        public boolean equals(Object obj) {
-            if (obj == null || obj.getClass() != QueuedUnload.class) {
-                return false;
-            }
-            QueuedUnload other = (QueuedUnload)obj;
-            return other.unloadTick == this.unloadTick && other.coordinate == this.coordinate;
-        }
-    }
-
-    long determineDelay(long coordinate) {
-        if (this.isEmpty(coordinate)) {
-            return 5 * 60 * 20;
-        } else {
-            return 60 * 20;
-        }
-    }
-
-    public void queueUnload(long coordinate, long minTarget) {
-        io.papermc.paper.util.TickThread.softEnsureTickThread("async poi unload queue");
-        QueuedUnload unload = new QueuedUnload(minTarget + this.determineDelay(coordinate), coordinate);
-        QueuedUnload existing = this.queuedUnloadsByCoordinate.put(coordinate, unload);
-        if (existing != null) {
-            this.queuedUnloads.remove(existing);
-        }
-        this.queuedUnloads.add(unload);
-    }
-
-    public void dequeueUnload(long coordinate) {
-        io.papermc.paper.util.TickThread.softEnsureTickThread("async poi unload dequeue");
-        QueuedUnload unload = this.queuedUnloadsByCoordinate.remove(coordinate);
-        if (unload != null) {
-            this.queuedUnloads.remove(unload);
-        }
-    }
-
-    public void pollUnloads(BooleanSupplier canSleepForTick) {
-        io.papermc.paper.util.TickThread.softEnsureTickThread("async poi unload");
-        long currentTick = net.minecraft.server.MinecraftServer.currentTickLong;
-        net.minecraft.server.level.ServerChunkCache chunkProvider = this.world.getChunkSource();
-        net.minecraft.server.level.ChunkMap playerChunkMap = chunkProvider.chunkMap;
-        // copied target determination from PlayerChunkMap
-
-        java.util.Iterator<QueuedUnload> iterator = this.queuedUnloads.iterator();
-        for (int i = 0; iterator.hasNext() && (i < 200 || this.queuedUnloads.size() > 2000 || canSleepForTick.getAsBoolean()); i++) {
-            QueuedUnload unload = iterator.next();
-            if (unload.unloadTick > currentTick) {
-                break;
-            }
-
-            long coordinate = unload.coordinate;
-
-            iterator.remove();
-            this.queuedUnloadsByCoordinate.remove(coordinate);
-
-            if (playerChunkMap.getUnloadingChunkHolder(net.minecraft.server.MCUtil.getCoordinateX(coordinate), net.minecraft.server.MCUtil.getCoordinateZ(coordinate)) != null
-                || playerChunkMap.getUpdatingChunkIfPresent(coordinate) != null) {
-                continue;
-            }
-
-            this.unloadData(coordinate);
-        }
-    }
-
-    @Override
-    public void unloadData(long coordinate) {
-        io.papermc.paper.util.TickThread.softEnsureTickThread("async unloading poi data");
-        super.unloadData(coordinate);
-    }
-
-    @Override
-    protected void onUnload(long coordinate) {
-        io.papermc.paper.util.TickThread.softEnsureTickThread("async poi unload callback");
-        this.loadedChunks.remove(coordinate);
-        int chunkX = net.minecraft.server.MCUtil.getCoordinateX(coordinate);
-        int chunkZ = net.minecraft.server.MCUtil.getCoordinateZ(coordinate);
-        for (int section = this.levelHeightAccessor.getMinSection(); section < this.levelHeightAccessor.getMaxSection(); ++section) {
-            long sectionPos = SectionPos.asLong(chunkX, section, chunkZ);
-            this.updateDistanceTracking(sectionPos);
-        }
-    }
-    // Paper end - actually unload POI data
+    // Paper - rewrite chunk system
 
     public void add(BlockPos pos, Holder<PoiType> type) {
         this.getOrCreate(SectionPos.asLong(pos)).add(pos, type);
@@ -346,6 +233,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
 
     @Override
     public void tick(BooleanSupplier shouldKeepTicking) {
+        /* // Paper start - rewrite chunk system, unload state is handled by the chunk holder now
         // Paper start - async chunk io
         while (!this.dirty.isEmpty() && shouldKeepTicking.getAsBoolean() && !this.world.noSave()) { // Paper - unload POI data - don't write to disk if saving is disabled
             ChunkPos chunkcoordintpair = SectionPos.of(this.dirty.firstLong()).chunk();
@@ -362,13 +250,87 @@ public class PoiManager extends SectionStorage<PoiSection> {
             this.pollUnloads(shouldKeepTicking);
         }
         // Paper end - unload POI data
+         */ // Paper end - rewrite chunk system, unload state is handled by the chunk holder now
         // Paper end
         this.villageDistanceTracker.propagateUpdates(); // Paper - replace distance tracking until
     }
 
+    // Paper start - rewrite chunk system
+    @Override
+    public Optional<PoiSection> get(long pos) {
+        int chunkX = io.papermc.paper.util.CoordinateUtils.getChunkSectionX(pos);
+        int chunkY = io.papermc.paper.util.CoordinateUtils.getChunkSectionY(pos);
+        int chunkZ = io.papermc.paper.util.CoordinateUtils.getChunkSectionZ(pos);
+        ChunkHolderManager manager =
+            this.world.chunkTaskScheduler.chunkHolderManager;
+        io.papermc.paper.chunk.system.poi.PoiChunk ret = manager.getPoiChunkIfLoaded(chunkX, chunkZ);
+
+        return ret == null ? Optional.empty() : ret.getSectionForVanilla(chunkY);
+    }
+
+    @Override
+    public Optional<PoiSection> getOrLoad(long pos) {
+        int chunkX = io.papermc.paper.util.CoordinateUtils.getChunkSectionX(pos);
+        int chunkY = io.papermc.paper.util.CoordinateUtils.getChunkSectionY(pos);
+        int chunkZ = io.papermc.paper.util.CoordinateUtils.getChunkSectionZ(pos);
+
+        ChunkHolderManager manager =
+            this.world.chunkTaskScheduler.chunkHolderManager;
+
+        if (chunkY >= io.papermc.paper.util.WorldUtil.getMinSection(this.world) &&
+            chunkY <= io.papermc.paper.util.WorldUtil.getMaxSection(this.world)) {
+            io.papermc.paper.chunk.system.poi.PoiChunk ret = manager.getPoiChunkIfLoaded(chunkX, chunkZ);
+            if (ret != null) {
+                return ret.getSectionForVanilla(chunkY);
+            } else {
+                return manager.loadPoiChunk(chunkX, chunkZ).getSectionForVanilla(chunkY);
+            }
+        }
+        // retain vanilla behavior: do not load section if out of bounds!
+        return Optional.empty();
+    }
+
+    @Override
+    protected PoiSection getOrCreate(long pos) {
+        int chunkX = io.papermc.paper.util.CoordinateUtils.getChunkSectionX(pos);
+        int chunkY = io.papermc.paper.util.CoordinateUtils.getChunkSectionY(pos);
+        int chunkZ = io.papermc.paper.util.CoordinateUtils.getChunkSectionZ(pos);
+
+        ChunkHolderManager manager =
+            this.world.chunkTaskScheduler.chunkHolderManager;
+
+        io.papermc.paper.chunk.system.poi.PoiChunk ret = manager.getPoiChunkIfLoaded(chunkX, chunkZ);
+        if (ret != null) {
+            return ret.getOrCreateSection(chunkY);
+        } else {
+            return manager.loadPoiChunk(chunkX, chunkZ).getOrCreateSection(chunkY);
+        }
+    }
+
+    @Override
+    public void onUnload(long coordinate) { // Paper - rewrite chunk system
+        io.papermc.paper.util.TickThread.softEnsureTickThread("async poi unload callback");
+        int chunkX = net.minecraft.server.MCUtil.getCoordinateX(coordinate);
+        int chunkZ = net.minecraft.server.MCUtil.getCoordinateZ(coordinate);
+        for (int section = this.levelHeightAccessor.getMinSection(); section < this.levelHeightAccessor.getMaxSection(); ++section) {
+            long sectionPos = SectionPos.asLong(chunkX, section, chunkZ);
+            this.updateDistanceTracking(sectionPos);
+        }
+    }
+    // Paper end - rewrite chunk system
+
     @Override
     protected void setDirty(long pos) {
-        super.setDirty(pos);
+        // Paper start - rewrite chunk system
+        int chunkX = io.papermc.paper.util.CoordinateUtils.getChunkSectionX(pos);
+        int chunkZ = io.papermc.paper.util.CoordinateUtils.getChunkSectionZ(pos);
+        ChunkHolderManager manager =
+            this.world.chunkTaskScheduler.chunkHolderManager;
+        io.papermc.paper.chunk.system.poi.PoiChunk chunk = manager.getPoiChunkIfLoaded(chunkX, chunkZ);
+        if (chunk != null) {
+            chunk.setDirty(true);
+        }
+        // Paper end - rewrite chunk system
         this.updateDistanceTracking(pos); // Paper - move to new distance tracking util
     }
 
@@ -416,7 +378,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
         }).map((pair) -> {
             return pair.getFirst().chunk();
         }).filter((chunkPos) -> {
-            return this.loadedChunks.add(chunkPos.toLong());
+            return true; // Paper - rewrite chunk system
         }).forEach((chunkPos) -> {
             world.getChunk(chunkPos.x, chunkPos.z, ChunkStatus.EMPTY);
         });
@@ -459,27 +421,27 @@ public class PoiManager extends SectionStorage<PoiSection> {
     @javax.annotation.Nullable
     @Override
     public net.minecraft.nbt.CompoundTag read(ChunkPos chunkcoordintpair) throws java.io.IOException {
-        if (this.world != null && Thread.currentThread() != com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE) {
-            net.minecraft.nbt.CompoundTag ret = com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE
-                .loadChunkDataAsyncFuture(this.world, chunkcoordintpair.x, chunkcoordintpair.z, com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread(),
-                    true, false, true).join().poiData;
-
-            if (ret == com.destroystokyo.paper.io.PaperFileIOThread.FAILURE_VALUE) {
-                throw new java.io.IOException("See logs for further detail");
-            }
-            return ret;
+        // Paper start - rewrite chunk system
+        if (!io.papermc.paper.chunk.system.io.RegionFileIOThread.isRegionFileThread()) {
+            return io.papermc.paper.chunk.system.io.RegionFileIOThread.loadData(
+                this.world, chunkcoordintpair.x, chunkcoordintpair.z, io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.POI_DATA,
+                io.papermc.paper.chunk.system.io.RegionFileIOThread.getIOBlockingPriorityForCurrentThread()
+            );
         }
+        // Paper end - rewrite chunk system
         return super.read(chunkcoordintpair);
     }
 
     @Override
     public void write(ChunkPos chunkcoordintpair, net.minecraft.nbt.CompoundTag nbttagcompound) throws java.io.IOException {
-        if (this.world != null && Thread.currentThread() != com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE) {
-            com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(
-                this.world, chunkcoordintpair.x, chunkcoordintpair.z, nbttagcompound, null,
-                com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
+        // Paper start - rewrite chunk system
+        if (!io.papermc.paper.chunk.system.io.RegionFileIOThread.isRegionFileThread()) {
+            io.papermc.paper.chunk.system.io.RegionFileIOThread.scheduleSave(
+                this.world, chunkcoordintpair.x, chunkcoordintpair.z, nbttagcompound,
+                io.papermc.paper.chunk.system.io.RegionFileIOThread.RegionFileType.POI_DATA);
             return;
         }
+        // Paper end - rewrite chunk system
         super.write(chunkcoordintpair, nbttagcompound);
     }
     // Paper end
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiSection.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiSection.java
index b71a4027a0eed467a3707c59315092ddecfd6bf3..2e410b21564a067ed04f4179908fba8389062f4c 100644
--- a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiSection.java
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiSection.java
@@ -29,6 +29,7 @@ public class PoiSection {
     private final Map<Holder<PoiType>, Set<PoiRecord>> byType = Maps.newHashMap(); public final Map<Holder<PoiType>, Set<PoiRecord>> getData() { return this.byType; } // Paper - public accessor
     private final Runnable setDirty;
     private boolean isValid;
+    public final Optional<PoiSection> noAllocateOptional = Optional.of(this); // Paper - rewrite chunk system
 
     public static Codec<PoiSection> codec(Runnable updateListener) {
         return RecordCodecBuilder.<PoiSection>create((instance) -> { // Paper - decompile fix
@@ -46,6 +47,12 @@ public class PoiSection {
         this(updateListener, true, ImmutableList.of());
     }
 
+    // Paper start - isEmpty
+    public boolean isEmpty() {
+        return this.isValid && this.records.isEmpty() && this.byType.isEmpty();
+    }
+    // Paper end
+
     private PoiSection(Runnable updateListener, boolean valid, List<PoiRecord> pois) {
         this.setDirty = updateListener;
         this.isValid = valid;
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 5a2a1d394852d39ea576624586f7fa736dec807c..1a95a1efdb04ce83ab821429690af41e29328ad4 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -356,7 +356,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
         this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
         this.chunkPacketBlockController = this.paperConfig().anticheat.antiXray.enabled ? new com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray(this, executor) : com.destroystokyo.paper.antixray.ChunkPacketBlockController.NO_OPERATION_INSTANCE; // Paper - Anti-Xray
-        this.entitySliceManager = new io.papermc.paper.world.EntitySliceManager((ServerLevel)this); // Paper
+       // this.entitySliceManager = new io.papermc.paper.world.EntitySliceManager((ServerLevel)this); // Paper // Paper - rewrite chunk system
     }
 
     // Paper start
@@ -960,7 +960,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         }
         // Paper end
         // CraftBukkit end
-        return this.isOutsideBuildHeight(blockposition) ? null : (!this.isClientSide && Thread.currentThread() != this.thread ? null : this.getChunkAt(blockposition).getBlockEntity(blockposition, LevelChunk.EntityCreationType.IMMEDIATE));
+        return this.isOutsideBuildHeight(blockposition) ? null : (!this.isClientSide && !io.papermc.paper.util.TickThread.isTickThread() ? null : this.getChunkAt(blockposition).getBlockEntity(blockposition, LevelChunk.EntityCreationType.IMMEDIATE)); // Paper - rewrite chunk system
     }
 
     public void setBlockEntity(BlockEntity blockEntity) {
@@ -1051,7 +1051,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public List<Entity> getEntities(@Nullable Entity except, AABB box, Predicate<? super Entity> predicate) {
         this.getProfiler().incrementCounter("getEntities");
         List<Entity> list = Lists.newArrayList();
-        this.entitySliceManager.getEntities(except, box, list, predicate); // Paper - optimise this call
+        ((ServerLevel)this).getEntityLookup().getEntities(except, box, list, predicate); // Paper - optimise this call
         return list;
     }
 
@@ -1062,7 +1062,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
 
         // Paper start - optimise this call
         if (filter instanceof net.minecraft.world.entity.EntityType) {
-            this.entitySliceManager.getEntities((net.minecraft.world.entity.EntityType)filter, box, list, predicate);
+            ((ServerLevel)this).getEntityLookup().getEntities((net.minecraft.world.entity.EntityType)filter, box, list, predicate);
         } else {
             Predicate<? super T> test = (obj) -> {
                 return filter.tryCast(obj) != null;
@@ -1070,9 +1070,9 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
             predicate = predicate == null ? test : test.and((Predicate)predicate);
             Class base;
             if (filter == null || (base = filter.getBaseClass()) == null || base == Entity.class) {
-                this.entitySliceManager.getEntities((Entity) null, box, (List)list, (Predicate)predicate);
+                ((ServerLevel)this).getEntityLookup().getEntities((Entity) null, box, (List)list, (Predicate)predicate);
             } else {
-                this.entitySliceManager.getEntities(base, null, box, (List)list, (Predicate)predicate); // Paper - optimise this call
+                ((ServerLevel)this).getEntityLookup().getEntities(base, null, box, (List)list, (Predicate)predicate); // Paper - optimise this call
             }
         }
         // Paper end - optimise this call
@@ -1412,10 +1412,10 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     }
 
     // Paper start
-    protected final io.papermc.paper.world.EntitySliceManager entitySliceManager;
+    //protected final io.papermc.paper.world.EntitySliceManager entitySliceManager; // Paper - rewrite chunk system
 
     public org.bukkit.entity.Entity[] getChunkEntities(int chunkX, int chunkZ) {
-        io.papermc.paper.world.ChunkEntitySlices slices = this.entitySliceManager.getChunk(chunkX, chunkZ);
+        io.papermc.paper.world.ChunkEntitySlices slices = ((ServerLevel)this).getEntityLookup().getChunk(chunkX, chunkZ);
         if (slices == null) {
             return new org.bukkit.entity.Entity[0];
         }
@@ -1425,30 +1425,30 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     @Override
     public List<Entity> getHardCollidingEntities(Entity except, AABB box, Predicate<? super Entity> predicate) {
         List<Entity> ret = new java.util.ArrayList<>();
-        this.entitySliceManager.getEntities(except, box, ret, predicate);
+        ((ServerLevel)this).getEntityLookup().getEntities(except, box, ret, predicate);
         return ret;
     }
 
     @Override
     public void getEntities(Entity except, AABB box, Predicate<? super Entity> predicate, List<Entity> into) {
-        this.entitySliceManager.getEntities(except, box, into, predicate);
+        ((ServerLevel)this).getEntityLookup().getEntities(except, box, into, predicate);
     }
 
     @Override
     public void getHardCollidingEntities(Entity except, AABB box, Predicate<? super Entity> predicate, List<Entity> into) {
-        this.entitySliceManager.getHardCollidingEntities(except, box, into, predicate);
+        ((ServerLevel)this).getEntityLookup().getHardCollidingEntities(except, box, into, predicate);
     }
 
     @Override
     public <T> void getEntitiesByClass(Class<? extends T> clazz, Entity except, final AABB box, List<? super T> into,
                                        Predicate<? super T> predicate) {
-        this.entitySliceManager.getEntities((Class)clazz, except, box, (List)into, (Predicate)predicate);
+        ((ServerLevel)this).getEntityLookup().getEntities((Class)clazz, except, box, (List)into, (Predicate)predicate);
     }
 
     @Override
     public <T extends Entity> List<T> getEntitiesOfClass(Class<T> entityClass, AABB box, Predicate<? super T> predicate) {
         List<T> ret = new java.util.ArrayList<>();
-        this.entitySliceManager.getEntities(entityClass, null, box, ret, predicate);
+        ((ServerLevel)this).getEntityLookup().getEntities(entityClass, null, box, ret, predicate);
         return ret;
     }
     // Paper end
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java b/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
index 19ffd93b7bc745d9a6822f1e5642d2f640f61df7..cb64b46eb874bb7ce22cdbf9e9629c929a05fb61 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
@@ -294,7 +294,7 @@ public abstract class ChunkGenerator {
         return CompletableFuture.supplyAsync(Util.wrapThreadWithTaskName("init_biomes", () -> {
             chunk.fillBiomesFromNoise(this.biomeSource, noiseConfig.sampler());
             return chunk;
-        }), Util.backgroundExecutor());
+        }), executor); // Paper - run with supplied executor
     }
 
     public abstract void applyCarvers(WorldGenRegion chunkRegion, long seed, RandomState noiseConfig, BiomeManager biomeAccess, StructureManager structureAccessor, ChunkAccess chunk, GenerationStep.Carving carverStep);
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java b/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
index e6240f891e396d91e31b02fdf3084be77e9d6697..00cb9dafc711607f28529ea9afbcdb492b1b2595 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
@@ -29,6 +29,30 @@ import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemp
 
 public class ChunkStatus {
 
+    // Paper start - rewrite chunk system
+    public boolean isParallelCapable; // Paper
+    public int writeRadius = -1;
+    public int loadRange = 0;
+
+    protected static final java.util.List<ChunkStatus> statuses = new java.util.ArrayList<>();
+
+    private ChunkStatus nextStatus;
+
+    public final ChunkStatus getNextStatus() {
+        return this.nextStatus;
+    }
+
+    public final boolean isEmptyLoadStatus() {
+        return this.loadingTask == PASSTHROUGH_LOAD_TASK;
+    }
+
+    public final boolean isEmptyGenStatus() {
+        return this == ChunkStatus.EMPTY || this == ChunkStatus.HEIGHTMAPS || this == ChunkStatus.LIQUID_CARVERS;
+    }
+
+    public final java.util.concurrent.atomic.AtomicBoolean warnedAboutNoImmediateComplete = new java.util.concurrent.atomic.AtomicBoolean();
+    // Paper end - rewrite chunk system
+
     public static final int MAX_STRUCTURE_DISTANCE = 8;
     private static final EnumSet<Heightmap.Types> PRE_FEATURES = EnumSet.of(Heightmap.Types.OCEAN_FLOOR_WG, Heightmap.Types.WORLD_SURFACE_WG);
     public static final EnumSet<Heightmap.Types> POST_FEATURES = EnumSet.of(Heightmap.Types.OCEAN_FLOOR, Heightmap.Types.WORLD_SURFACE, Heightmap.Types.MOTION_BLOCKING, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES);
@@ -150,10 +174,8 @@ public class ChunkStatus {
             protochunk.setStatus(chunkstatus);
         }
 
-        return lightenginethreaded.retainData(ichunkaccess).thenApply(Either::left);
-    }, (chunkstatus, worldserver, structuretemplatemanager, lightenginethreaded, function, ichunkaccess) -> {
-        return lightenginethreaded.retainData(ichunkaccess).thenApply(Either::left);
-    });
+        return CompletableFuture.completedFuture(Either.left(ichunkaccess)); // Paper - rewrite chunk system
+    }); // Paper - rewrite chunk system
     public static final ChunkStatus LIGHT = ChunkStatus.register("light", ChunkStatus.FEATURES, 1, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess, flag) -> {
         return ChunkStatus.lightChunk(chunkstatus, lightenginethreaded, ichunkaccess);
     }, (chunkstatus, worldserver, structuretemplatemanager, lightenginethreaded, function, ichunkaccess) -> {
@@ -255,6 +277,13 @@ public class ChunkStatus {
         this.chunkType = chunkType;
         this.heightmapsAfter = heightMapTypes;
         this.index = previous == null ? 0 : previous.getIndex() + 1;
+        // Paper start
+        this.nextStatus = this;
+        if (statuses.size() > 0) {
+            statuses.get(statuses.size() - 1).nextStatus = this;
+        }
+        statuses.add(this);
+        // Paper end
     }
 
     public int getIndex() {
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 2292cb0e0c1a3e0ed34b941f028136bfb0bff13e..25883cba5957c3c47f947bed0adfaba75e6368ce 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -830,6 +830,76 @@ public class LevelChunk extends ChunkAccess {
 
     }
 
+    // Paper start - new load callbacks
+    private io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder;
+    public io.papermc.paper.chunk.system.scheduling.NewChunkHolder getChunkHolder() {
+        return this.chunkHolder;
+    }
+
+    public void setChunkHolder(io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder) {
+        if (chunkHolder == null) {
+            throw new NullPointerException("Chunkholder cannot be null");
+        }
+        if (this.chunkHolder != null) {
+            throw new IllegalStateException("Already have chunkholder: " + this.chunkHolder + ", cannot replace with " + chunkHolder);
+        }
+        this.chunkHolder = chunkHolder;
+        this.playerChunk = chunkHolder.vanillaChunkHolder;
+    }
+
+    /* Note: We skip the light neighbour chunk loading done for the vanilla full chunk */
+    /* Starlight does not need these chunks for lighting purposes because of edge checks */
+
+    public void onChunkLoad(io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder) {
+        // figure out how this should interface with:
+        // the entity chunk load event // -> moved to the FULL status
+        // the chunk load event // -> stays here
+        // any entity add to world events // -> in FULL status
+        this.level.getEntityLookup().chunkStatusChange(this.locX, this.locZ, ChunkHolder.FullChunkStatus.BORDER);
+        this.loadCallback();
+    }
+
+    public void onChunkUnload(io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder) {
+        // figure out how this should interface with:
+        // the entity chunk load event // -> moved to chunk unload to disk (not written yet)
+        // the chunk load event // -> stays here
+        // any entity add to world events // -> goes into the unload logic, it will completely explode
+        // etc later
+        this.level.getEntityLookup().chunkStatusChange(this.locX, this.locZ, ChunkHolder.FullChunkStatus.INACCESSIBLE);
+        this.unloadCallback();
+    }
+
+    public void onChunkTicking(io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder) {
+        this.level.getEntityLookup().chunkStatusChange(this.locX, this.locZ, ChunkHolder.FullChunkStatus.TICKING);
+        this.postProcessGeneration();
+        this.level.startTickingChunk(this);
+        // Paper start - ticking chunk set
+        this.level.getChunkSource().tickingChunks.add(this);
+        // Paper end - ticking chunk set
+    }
+
+    public void onChunkNotTicking(io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder) {
+        this.level.getEntityLookup().chunkStatusChange(this.locX, this.locZ, ChunkHolder.FullChunkStatus.BORDER);
+        // Paper start - ticking chunk set
+        this.level.getChunkSource().tickingChunks.remove(this);
+        // Paper end - ticking chunk set
+    }
+
+    public void onChunkEntityTicking(io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder) {
+        this.level.getEntityLookup().chunkStatusChange(this.locX, this.locZ, ChunkHolder.FullChunkStatus.ENTITY_TICKING);
+        // Paper start - entity ticking chunk set
+        this.level.getChunkSource().entityTickingChunks.add(this);
+        // Paper end - entity ticking chunk set
+    }
+
+    public void onChunkNotEntityTicking(io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder) {
+        this.level.getEntityLookup().chunkStatusChange(this.locX, this.locZ, ChunkHolder.FullChunkStatus.TICKING);
+        // Paper start - entity ticking chunk set
+        this.level.getChunkSource().entityTickingChunks.remove(this);
+        // Paper end - entity ticking chunk set
+    }
+    // Paper end - new load callbacks
+
     // CraftBukkit start
     public void loadCallback() {
         if (this.loadedTicketLevel) { LOGGER.error("Double calling chunk load!", new Throwable()); } // Paper
@@ -1072,7 +1142,7 @@ public class LevelChunk extends ChunkAccess {
     }
 
     public ChunkHolder.FullChunkStatus getFullStatus() {
-        return this.fullStatus == null ? ChunkHolder.FullChunkStatus.BORDER : (ChunkHolder.FullChunkStatus) this.fullStatus.get();
+        return this.chunkHolder == null ? ChunkHolder.FullChunkStatus.INACCESSIBLE : this.chunkHolder.getChunkStatus(); // Paper - rewrite chunk system
     }
 
     public void setFullStatus(Supplier<ChunkHolder.FullChunkStatus> levelTypeProvider) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkStorage.java
index b230a3d475357d2ffd340f9a89934ea7227e69d0..6e9af1401918995e3c268eea7d4a74af94707242 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkStorage.java
@@ -197,7 +197,7 @@ public class ChunkStorage implements AutoCloseable {
     }
 
     public void flushWorker() {
-        com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.flush(); // Paper - nuke IO worker
+        io.papermc.paper.chunk.system.io.RegionFileIOThread.flush(); // Paper - rewrite chunk system
     }
 
     public void close() throws IOException {
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
index 2bc0384728f89b7c64a8beec78a1b77dc063d37b..c5fce4f130a51508064f3b67ff617501de50e655 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
@@ -61,13 +61,21 @@ public class EntityStorage implements EntityPersistentStorage<Entity> {
 
                 CompoundTag compoundTag = this.upgradeChunkTag(nbt.get());
                 ListTag listTag = compoundTag.getList("Entities", 10);
-                List<Entity> list = EntityType.loadEntitiesRecursive(listTag, this.level).collect(ImmutableList.toImmutableList());
+                List<Entity> list = readEntities(this.level, compoundTag); // Paper - rewrite chunk system, move to method
                 return new ChunkEntities<>(pos, list);
             }
         }, this.entityDeserializerQueue::tell);
     }
 
-    private static ChunkPos readChunkPos(CompoundTag chunkNbt) {
+    // Paper start - rewrite chunk system
+    public static List<Entity> readEntities(ServerLevel level, CompoundTag compoundTag) {
+        ListTag listTag = compoundTag.getList("Entities", 10);
+        List<Entity> list = EntityType.loadEntitiesRecursive(listTag, level).collect(ImmutableList.toImmutableList());
+        return list;
+    }
+    // Paper end - rewrite chunk system
+
+    public static ChunkPos readChunkPos(CompoundTag chunkNbt) { // Paper - public
         int[] is = chunkNbt.getIntArray("Position");
         return new ChunkPos(is[0], is[1]);
     }
@@ -89,29 +97,10 @@ public class EntityStorage implements EntityPersistentStorage<Entity> {
             }
 
         } else {
-            ListTag listTag = new ListTag();
-            final java.util.Map<net.minecraft.world.entity.EntityType<?>, Integer> savedEntityCounts = new java.util.HashMap<>(); // Paper
-            dataList.getEntities().forEach((entity) -> {
-                // Paper start
-                final EntityType<?> entityType = entity.getType();
-                final int saveLimit = this.level.paperConfig().chunks.entityPerChunkSaveLimit.getOrDefault(entityType, -1);
-                if (saveLimit > -1) {
-                    if (savedEntityCounts.getOrDefault(entityType, 0) >= saveLimit) {
-                        return;
-                    }
-                    savedEntityCounts.merge(entityType, 1, Integer::sum);
-                }
-                // Paper end
-                CompoundTag compoundTag = new CompoundTag();
-                if (entity.save(compoundTag)) {
-                    listTag.add(compoundTag);
-                }
-
-            });
-            CompoundTag compoundTag = new CompoundTag();
-            compoundTag.putInt("DataVersion", SharedConstants.getCurrentVersion().getWorldVersion());
-            compoundTag.put("Entities", listTag);
-            writeChunkPos(compoundTag, chunkPos);
+            // Paper start - rewrite chunk system
+            // set force = true, we expect non-null compound here
+            CompoundTag compoundTag = saveEntityChunk0(dataList.getEntities().toList(), chunkPos, this.level, true);
+            // Paper end - rewrite chunk system
             this.worker.store(chunkPos, compoundTag).exceptionally((ex) -> {
                 LOGGER.error("Failed to store chunk {}", chunkPos, ex);
                 return null;
@@ -120,13 +109,63 @@ public class EntityStorage implements EntityPersistentStorage<Entity> {
         }
     }
 
+    // Paper start - rewrite chunk system
+    public static void copyEntities(final CompoundTag from, final CompoundTag into) {
+        if (from == null) {
+            return;
+        }
+        final ListTag entitiesFrom = from.getList("Entities", net.minecraft.nbt.Tag.TAG_COMPOUND);
+        if (entitiesFrom == null || entitiesFrom.isEmpty()) {
+            return;
+        }
+
+        final ListTag entitiesInto = into.getList("Entities", net.minecraft.nbt.Tag.TAG_COMPOUND);
+        into.put("Entities", entitiesInto); // this is in case into doesn't have any entities
+        entitiesInto.addAll(entitiesFrom.copy()); // need to copy, this is coming from the save thread
+    }
+
+    public static CompoundTag saveEntityChunk(List<Entity> entities, ChunkPos chunkPos, ServerLevel level) {
+        return saveEntityChunk0(entities, chunkPos, level, false);
+    }
+    private static CompoundTag saveEntityChunk0(List<Entity> entities, ChunkPos chunkPos, ServerLevel level, boolean force) {
+        if (!force && entities.isEmpty()) {
+            return null;
+        }
+        ListTag listTag = new ListTag();
+        final java.util.Map<net.minecraft.world.entity.EntityType<?>, Integer> savedEntityCounts = new java.util.HashMap<>(); // Paper
+        entities.forEach((entity) -> { // Diff here - use entities param
+            // Paper start
+            final EntityType<?> entityType = entity.getType();
+            final int saveLimit = level.paperConfig().chunks.entityPerChunkSaveLimit.getOrDefault(entityType, -1); // Diff here - use level
+            if (saveLimit > -1) {
+                if (savedEntityCounts.getOrDefault(entityType, 0) >= saveLimit) {
+                    return;
+                }
+                savedEntityCounts.merge(entityType, 1, Integer::sum);
+            }
+            // Paper end
+            CompoundTag compoundTag = new CompoundTag();
+            if (entity.save(compoundTag)) {
+                listTag.add(compoundTag);
+            }
+
+        });
+        CompoundTag compoundTag = new CompoundTag();
+        compoundTag.putInt("DataVersion", SharedConstants.getCurrentVersion().getWorldVersion());
+        compoundTag.put("Entities", listTag);
+        writeChunkPos(compoundTag, chunkPos);
+
+        return !force && listTag.isEmpty() ? null : compoundTag;
+    }
+    // Paper end - rewrite chunk system
+
     @Override
     public void flush(boolean sync) {
         this.worker.synchronize(sync).join();
         this.entityDeserializerQueue.runAll();
     }
 
-    private CompoundTag upgradeChunkTag(CompoundTag chunkNbt) {
+    public static CompoundTag upgradeChunkTag(CompoundTag chunkNbt) { // Paper - public and static
         int i = getVersion(chunkNbt);
         return ca.spottedleaf.dataconverter.minecraft.MCDataConverter.convertTag(ca.spottedleaf.dataconverter.minecraft.datatypes.MCTypeRegistry.ENTITY_CHUNK, chunkNbt, i, SharedConstants.getCurrentVersion().getWorldVersion()); // Paper - route to new converter system
     }
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
index 6704ae5c2ee01f8b319f4d425fe08c16d7b1b212..47cd08391767b4c07d0cf556ae15245e07541665 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
@@ -1005,6 +1005,9 @@ public class RegionFile implements AutoCloseable {
 
     }
     // Paper end
+
+    public static final int MAX_CHUNK_SIZE = 500 * 1024 * 1024; // Paper - TODO put this into the patch
+
     private class ChunkBuffer extends ByteArrayOutputStream {
 
         private final ChunkPos pos;
@@ -1022,7 +1025,7 @@ public class RegionFile implements AutoCloseable {
         // Paper start - don't write garbage data to disk if writing serialization fails
         @Override
         public void write(final int b) {
-            if (this.count > 500_000_000) {
+            if (this.count > MAX_CHUNK_SIZE) { // TODO extract this constant
                 throw new RegionFileStorage.RegionFileSizeException("Region file too large: " + this.count);
             }
             super.write(b);
@@ -1030,7 +1033,7 @@ public class RegionFile implements AutoCloseable {
 
         @Override
         public void write(final byte[] b, final int off, final int len) {
-            if (this.count + len > 500_000_000) {
+            if (this.count + len > MAX_CHUNK_SIZE) { // Paper - TODO put this into the patch
                 throw new RegionFileStorage.RegionFileSizeException("Region file too large: " + (this.count + len));
             }
             super.write(b, off, len);
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
index c31b9a6b1d4548d507ecb60d42ca9f96f49f6c4b..c2c25b5d9eaf8f2abf390a3d0d270f0c9bb96e03 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
@@ -28,7 +28,7 @@ public class RegionFileStorage implements AutoCloseable {
 
     private final boolean isChunkData; // Paper
 
-    RegionFileStorage(Path directory, boolean dsync) {
+    protected RegionFileStorage(Path directory, boolean dsync) { // Paper - protected constructor
         // Paper start - add isChunkData param
         this(directory, dsync, false);
     }
@@ -285,7 +285,11 @@ public class RegionFileStorage implements AutoCloseable {
     }
 
     protected void write(ChunkPos pos, @Nullable CompoundTag nbt) throws IOException {
-        RegionFile regionfile = this.getRegionFile(pos, false, true); // CraftBukkit // Paper
+        RegionFile regionfile = this.getRegionFile(pos, nbt == null, true); // CraftBukkit // Paper // Paper start - rewrite chunk system
+        if (nbt == null && regionfile == null) {
+            return;
+        }
+        // Paper end - rewrite chunk system
         try { // Paper
         int attempts = 0; Exception laste = null; while (attempts++ < 5) { try { // Paper
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/SectionStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/SectionStorage.java
index 38287fad39d553a86370bbdc755c0a006615e0cf..77fdb4556bbccbd558d3cb12650e14f876bf4388 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/SectionStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/SectionStorage.java
@@ -44,7 +44,7 @@ public class SectionStorage<R> extends RegionFileStorage implements AutoCloseabl
     private final Function<Runnable, R> factory;
     private final DataFixer fixerUpper;
     private final DataFixTypes type;
-    private final RegistryAccess registryAccess;
+    public final RegistryAccess registryAccess; // Paper - rewrite chunk system
     protected final LevelHeightAccessor levelHeightAccessor;
 
     public SectionStorage(Path path, Function<Runnable, Codec<R>> codecFactory, Function<Runnable, R> factory, DataFixer dataFixer, DataFixTypes dataFixTypes, boolean dsync, RegistryAccess dynamicRegistryManager, LevelHeightAccessor world) {
@@ -151,9 +151,7 @@ public class SectionStorage<R> extends RegionFileStorage implements AutoCloseabl
     }
 
     private void readColumn(ChunkPos pos) {
-        Optional<CompoundTag> optional = this.tryRead(pos).join();
-        RegistryOps<Tag> registryOps = RegistryOps.create(NbtOps.INSTANCE, this.registryAccess);
-        this.readColumn(pos, registryOps, optional.orElse((CompoundTag)null));
+        throw new IllegalStateException("Only chunk system can load in state, offending class:" + this.getClass().getName()); // Paper - rewrite chunk system
     }
 
     private CompletableFuture<Optional<CompoundTag>> tryRead(ChunkPos pos) {
@@ -173,6 +171,7 @@ public class SectionStorage<R> extends RegionFileStorage implements AutoCloseabl
     // Paper end - aync chnnk i
 
     private <T> void readColumn(ChunkPos pos, DynamicOps<T> ops, @Nullable T data) {
+        if (true) throw new IllegalStateException("Only chunk system can load in state, offending class:" + this.getClass().getName());
         if (data == null) {
             for(int i = this.levelHeightAccessor.getMinSection(); i < this.levelHeightAccessor.getMaxSection(); ++i) {
                 this.storage.put(getKey(pos, i), Optional.empty());
@@ -209,7 +208,7 @@ public class SectionStorage<R> extends RegionFileStorage implements AutoCloseabl
                 });
             }
         }
-        if (this instanceof net.minecraft.world.entity.ai.village.poi.PoiManager) { ((net.minecraft.world.entity.ai.village.poi.PoiManager)this).queueUnload(pos.longKey, net.minecraft.server.MinecraftServer.currentTickLong + 1); } // Paper - unload POI data
+        // Paper - rewrite chunk system
 
     }
 
@@ -278,7 +277,7 @@ public class SectionStorage<R> extends RegionFileStorage implements AutoCloseabl
     }
 
     private static int getVersion(Dynamic<?> dynamic) {
-        return dynamic.get("DataVersion").asInt(1945);
+        return dynamic.get("DataVersion").asInt(1945); // Paper - diff on change, constant used in ChunkLoadTask
     }
 
     public void flush(ChunkPos pos) {
@@ -299,20 +298,5 @@ public class SectionStorage<R> extends RegionFileStorage implements AutoCloseabl
         //this.worker.close(); // Paper - nuke I/O worker
     }
 
-    // Paper start - get data function
-    public CompoundTag getData(ChunkPos chunkcoordintpair) {
-        // Note: Copied from above
-        // This is checking if the data needs to be written, then it builds it later in getDataInternal(ChunkCoordIntPair)
-        if (!this.dirty.isEmpty()) {
-            for (int i = this.levelHeightAccessor.getMinSection(); i < this.levelHeightAccessor.getMaxSection(); ++i) {
-                long j = SectionPos.of(chunkcoordintpair, i).asLong();
-
-                if (this.dirty.contains(j)) {
-                    return this.getDataInternal(chunkcoordintpair);
-                }
-            }
-        }
-        return null;
-    }
-    // Paper end
+    // Paper - rewrite chunk system
 }
diff --git a/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java b/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
index 575efe82a7219e256afd8362984eb26795445119..cf87490a446285132daaf9d90154ac6d477a62fe 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
@@ -90,7 +90,7 @@ public final class NoiseBasedChunkGenerator extends ChunkGenerator {
         return CompletableFuture.supplyAsync(Util.wrapThreadWithTaskName("init_biomes", () -> {
             this.doCreateBiomes(blender, noiseConfig, structureAccessor, chunk);
             return chunk;
-        }), Util.backgroundExecutor());
+        }), executor); // Paper - run with supplied executor
     }
 
     private void doCreateBiomes(Blender blender, RandomState noiseConfig, StructureManager structureAccessor, ChunkAccess chunk) {
@@ -289,7 +289,7 @@ public final class NoiseBasedChunkGenerator extends ChunkGenerator {
 
             return CompletableFuture.supplyAsync(Util.wrapThreadWithTaskName("wgen_fill_noise", () -> {
                 return this.doFill(blender, structureAccessor, noiseConfig, chunk, j, k);
-            }), Util.backgroundExecutor()).whenCompleteAsync((ichunkaccess1, throwable) -> {
+            }), executor).whenCompleteAsync((ichunkaccess1, throwable) -> { // Paper - run with supplied executor
                 Iterator iterator = set.iterator();
 
                 while (iterator.hasNext()) {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
index 947b0b10fb965f30513fd0df5bc0910fb9cb9a71..01e15c7b70dd60f6ad417c8bb81edfa5258a827a 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
@@ -121,7 +121,7 @@ public class CraftChunk implements Chunk {
 
     @Override
     public boolean isEntitiesLoaded() {
-        return this.getCraftWorld().getHandle().entityManager.areEntitiesLoaded(ChunkPos.asLong(x, z));
+        return this.getCraftWorld().getHandle().areEntitiesLoaded(io.papermc.paper.util.CoordinateUtils.getChunkKey(this.x, this.z)); // Paper - rewrite chunk system
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index bfde5bbcccfaa754ec6bdf4f3817981a93e465bd..fadd4866e2a529b01a2dca3d6adaa5bff6ca79b6 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -1249,7 +1249,7 @@ public final class CraftServer implements Server {
 
         internal.keepSpawnInMemory = creator.keepSpawnLoaded().toBooleanOrElse(internal.getWorld().getKeepSpawnInMemory()); // Paper
         this.getServer().prepareLevels(internal.getChunkSource().chunkMap.progressListener, internal);
-        internal.entityManager.tick(); // SPIGOT-6526: Load pending entities so they are available to the API
+        //internal.entityManager.tick(); // SPIGOT-6526: Load pending entities so they are available to the API // Paper - rewrite chunk system
 
         this.pluginManager.callEvent(new WorldLoadEvent(internal.getWorld()));
         return internal.getWorld();
@@ -1294,7 +1294,7 @@ public final class CraftServer implements Server {
             }
 
             handle.getChunkSource().close(save);
-            handle.entityManager.close(save); // SPIGOT-6722: close entityManager
+            // handle.entityManager.close(save); // SPIGOT-6722: close entityManager // Paper - rewrite chunk system
             handle.convertable.close();
         } catch (Exception ex) {
             this.getLogger().log(Level.SEVERE, null, ex);
@@ -2178,7 +2178,7 @@ public final class CraftServer implements Server {
 
     @Override
     public boolean isPrimaryThread() {
-        return Thread.currentThread().equals(console.serverThread) || Thread.currentThread().equals(net.minecraft.server.MinecraftServer.getServer().shutdownThread); // Paper - Fix issues with detecting main thread properly, the only time Watchdog will be used is during a crash shutdown which is a "try our best" scenario
+        return io.papermc.paper.util.TickThread.isTickThread(); // Paper - rewrite chunk system
     }
 
     // Paper start
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index f0b14914438840bd819fa7da8b76f4fcc13704d0..ed54d4aaf8a359652325fa00713ca135218408b0 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -167,17 +167,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public int getTileEntityCount() {
-        // We don't use the full world tile entity list, so we must iterate chunks
-        Long2ObjectLinkedOpenHashMap<ChunkHolder> chunks = world.getChunkSource().chunkMap.updatingChunks.getVisibleMap(); // Paper - change updating chunks map
-        int size = 0;
-        for (ChunkHolder playerchunk : chunks.values()) {
-            net.minecraft.world.level.chunk.LevelChunk chunk = playerchunk.getTickingChunk();
-            if (chunk == null) {
-                continue;
-            }
-            size += chunk.blockEntities.size();
-        }
-        return size;
+        throw new UnsupportedOperationException(); // Paper - TODO rewrite chunk system
     }
 
     @Override
@@ -187,15 +177,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public int getChunkCount() {
-        int ret = 0;
-
-        for (ChunkHolder chunkHolder : world.getChunkSource().chunkMap.updatingChunks.getVisibleMap().values()) { // Paper - change updating chunks map
-            if (chunkHolder.getTickingChunk() != null) {
-                ++ret;
-            }
-        }
-
-        return ret;
+        throw new UnsupportedOperationException(); // Paper - TODO rewrite chunk system
     }
 
     @Override
@@ -385,19 +367,10 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public Chunk[] getLoadedChunks() {
-        // Paper start
-        if (Thread.currentThread() != world.getLevel().thread) {
-            // Paper start - change updating chunks map
-            Long2ObjectLinkedOpenHashMap<ChunkHolder> chunks;
-            synchronized (world.getChunkSource().chunkMap.updatingChunks) {
-                chunks = world.getChunkSource().chunkMap.updatingChunks.getVisibleMap().clone();
-            }
-            return chunks.values().stream().map(ChunkHolder::getFullChunkNow).filter(Objects::nonNull).map(net.minecraft.world.level.chunk.LevelChunk::getBukkitChunk).toArray(Chunk[]::new);
-            // Paper end - change updating chunks map
-        }
-        // Paper end
-        Long2ObjectLinkedOpenHashMap<ChunkHolder> chunks = this.world.getChunkSource().chunkMap.updatingChunks.getVisibleMap(); // Paper - change updating chunks map
-        return chunks.values().stream().map(ChunkHolder::getFullChunkNow).filter(Objects::nonNull).map(net.minecraft.world.level.chunk.LevelChunk::getBukkitChunk).toArray(Chunk[]::new);
+        // Paper start - rewrite chunk system
+        List<ChunkHolder> chunks = this.world.chunkTaskScheduler.chunkHolderManager.getOldChunkHolders();
+        return chunks.stream().map(ChunkHolder::getFullChunkNow).filter(Objects::nonNull).map(net.minecraft.world.level.chunk.LevelChunk::getBukkitChunk).toArray(Chunk[]::new);
+        // Paper end - rewrite chunk system
     }
 
     @Override
@@ -508,7 +481,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public boolean refreshChunk(int x, int z) {
-        ChunkHolder playerChunk = this.world.getChunkSource().chunkMap.updatingChunks.getVisibleMap().get(ChunkPos.asLong(x, z));
+        ChunkHolder playerChunk = this.world.getChunkSource().chunkMap.getVisibleChunkIfPresent(ChunkPos.asLong(x, z)); // Paper - rewrite chunk system
         if (playerChunk == null) return false;
 
         playerChunk.getTickingChunkFuture().thenAccept(either -> {
@@ -639,20 +612,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public Collection<Plugin> getPluginChunkTickets(int x, int z) {
         DistanceManager chunkDistanceManager = this.world.getChunkSource().chunkMap.distanceManager;
-        SortedArraySet<Ticket<?>> tickets = chunkDistanceManager.tickets.get(ChunkPos.asLong(x, z));
-
-        if (tickets == null) {
-            return Collections.emptyList();
-        }
-
-        ImmutableList.Builder<Plugin> ret = ImmutableList.builder();
-        for (Ticket<?> ticket : tickets) {
-            if (ticket.getType() == TicketType.PLUGIN_TICKET) {
-                ret.add((Plugin) ticket.key);
-            }
-        }
-
-        return ret.build();
+        return chunkDistanceManager.getChunkHolderManager().getPluginChunkTickets(x, z); // Paper - rewrite chunk system
     }
 
     @Override
@@ -660,7 +620,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
         Map<Plugin, ImmutableList.Builder<Chunk>> ret = new HashMap<>();
         DistanceManager chunkDistanceManager = this.world.getChunkSource().chunkMap.distanceManager;
 
-        for (Long2ObjectMap.Entry<SortedArraySet<Ticket<?>>> chunkTickets : chunkDistanceManager.tickets.long2ObjectEntrySet()) {
+        for (Long2ObjectMap.Entry<SortedArraySet<Ticket<?>>> chunkTickets : chunkDistanceManager.getChunkHolderManager().getTicketsCopy().long2ObjectEntrySet()) { // Paper - rewrite chunk system
             long chunkKey = chunkTickets.getLongKey();
             SortedArraySet<Ticket<?>> tickets = chunkTickets.getValue();
 
@@ -2281,7 +2241,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
         // Paper start - Chunk priority
         if (!urgent) {
             // If not urgent, at least use a slightly boosted priority
-            world.getChunkSource().markHighPriority(new ChunkPos(x, z), 1);
+            // Paper - rewrite chunk system
         }
         // Paper end
         return this.world.getChunkSource().getChunkAtAsynchronously(x, z, gen, urgent).thenComposeAsync((either) -> {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 6549ade8e19807c523e5a1dc68b66585aad438b1..783a31dd8cac40c6adabbfa8f3a5970b7bdb075e 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -543,7 +543,8 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         net.minecraft.server.level.ServerLevel world = ((CraftWorld)locationClone.getWorld()).getHandle();
         java.util.concurrent.CompletableFuture<Boolean> ret = new java.util.concurrent.CompletableFuture<>();
 
-        world.loadChunksForMoveAsync(getHandle().getBoundingBoxAt(locationClone.getX(), locationClone.getY(), locationClone.getZ()), location.getX(), location.getZ(), (list) -> {
+        world.loadChunksForMoveAsync(getHandle().getBoundingBoxAt(locationClone.getX(), locationClone.getY(), locationClone.getZ()),
+            this instanceof CraftPlayer ? ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.HIGHER : ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.NORMAL, (list) -> {
             net.minecraft.server.level.ServerChunkCache chunkProviderServer = world.getChunkSource();
             for (net.minecraft.world.level.chunk.ChunkAccess chunk : list) {
                 chunkProviderServer.addTicketAtLevel(net.minecraft.server.level.TicketType.POST_TELEPORT, chunk.getPos(), 33, CraftEntity.this.getEntityId());
@@ -555,6 +556,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
                     if (throwable instanceof ThreadDeath) {
                         throw (ThreadDeath)throwable;
                     }
+                    net.minecraft.server.MinecraftServer.LOGGER.error("Failed to teleport entity " + CraftEntity.this, throwable);
                     ret.completeExceptionally(throwable);
                 }
             });
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index ef9c3a7b15a4901e1662e6d55504b9cbbb804ad3..d01a8ae4e8c0c556ef5c0fa2ebc136b2c83c4fe6 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1162,15 +1162,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         // Paper end
     }
 
-    // Paper start - Chunk priority
-    @Override
-    public java.util.concurrent.CompletableFuture<Boolean> teleportAsync(Location loc, @javax.annotation.Nonnull PlayerTeleportEvent.TeleportCause cause) {
-        ((CraftWorld)loc.getWorld()).getHandle().getChunkSource().markAreaHighPriority(
-            new net.minecraft.world.level.ChunkPos(net.minecraft.util.Mth.floor(loc.getX()) >> 4,
-            net.minecraft.util.Mth.floor(loc.getZ()) >> 4), 28, 3); // Load area high priority
-        return super.teleportAsync(loc, cause);
-    }
-    // Paper end
+    // Paper - rewrite chunk system
 
     @Override
     public boolean teleport(Location location, PlayerTeleportEvent.TeleportCause cause) {
diff --git a/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java b/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
index 19b938f9b86552034c2a0e4af40e342a17f56504..382879562a808290cc4dd59dcd5022c6c22fb169 100644
--- a/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
+++ b/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
@@ -256,7 +256,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
             return ichunkaccess1;
         };
 
-        return future == null ? CompletableFuture.supplyAsync(() -> function.apply(chunk), net.minecraft.Util.backgroundExecutor()) : future.thenApply(function);
+        return future == null ? CompletableFuture.supplyAsync(() -> function.apply(chunk), executor) : future.thenApply(function); // Paper - run with supplied executor
     }
 
     @Override
diff --git a/src/main/java/org/spigotmc/AsyncCatcher.java b/src/main/java/org/spigotmc/AsyncCatcher.java
index 0c41413ad32f8f6a094462fcd637dd3229abda45..c02a04d284734b5f545b64307ed4aea337c1465f 100644
--- a/src/main/java/org/spigotmc/AsyncCatcher.java
+++ b/src/main/java/org/spigotmc/AsyncCatcher.java
@@ -10,7 +10,7 @@ public class AsyncCatcher
 
     public static void catchOp(String reason)
     {
-        if ( (AsyncCatcher.enabled || io.papermc.paper.util.TickThread.STRICT_THREAD_CHECKS) && Thread.currentThread() != MinecraftServer.getServer().serverThread ) // Paper
+        if ( !io.papermc.paper.util.TickThread.isTickThread() ) // Paper // Paper - rewrite chunk system
         {
             MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable()); // Paper
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
diff --git a/src/main/java/org/spigotmc/WatchdogThread.java b/src/main/java/org/spigotmc/WatchdogThread.java
index d568fc92d03c313a782796cc720a1ebb1a5ad8be..d567766fbfb7836a746bcae2406fae0615b648a1 100644
--- a/src/main/java/org/spigotmc/WatchdogThread.java
+++ b/src/main/java/org/spigotmc/WatchdogThread.java
@@ -8,7 +8,7 @@ import java.util.logging.Logger;
 import net.minecraft.server.MinecraftServer;
 import org.bukkit.Bukkit;
 
-public class WatchdogThread extends Thread
+public final class WatchdogThread extends io.papermc.paper.util.TickThread // Paper - rewrite chunk system
 {
 
     public static final boolean DISABLE_WATCHDOG = Boolean.getBoolean("disable.watchdog"); // Paper
@@ -191,7 +191,7 @@ public class WatchdogThread extends Thread
                 // Paper end - Different message for short timeout
                 log.log( Level.SEVERE, "------------------------------" );
                 log.log( Level.SEVERE, "Server thread dump (Look for plugins here before reporting to Paper!):" ); // Paper
-                com.destroystokyo.paper.io.chunk.ChunkTaskManager.dumpAllChunkLoadInfo(); // Paper
+                io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.dumpAllChunkLoadInfo(isLongTimeout); // Paper // Paper - rewrite chunk system
                 this.dumpTickingInfo(); // Paper - log detailed tick information
                 WatchdogThread.dumpThread( ManagementFactory.getThreadMXBean().getThreadInfo( server.serverThread.getId(), Integer.MAX_VALUE ), log );
                 log.log( Level.SEVERE, "------------------------------" );

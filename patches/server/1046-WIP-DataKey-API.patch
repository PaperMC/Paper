From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Owen1212055 <23108066+Owen1212055@users.noreply.github.com>
Date: Sun, 28 Apr 2024 19:53:01 -0400
Subject: [PATCH] WIP DataKey API


diff --git a/src/main/java/io/papermc/paper/datakey/ComponentAdapter.java b/src/main/java/io/papermc/paper/datakey/ComponentAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..264a8a14d2a778ef4eaa5937342b5978d8856dca
--- /dev/null
+++ b/src/main/java/io/papermc/paper/datakey/ComponentAdapter.java
@@ -0,0 +1,25 @@
+package io.papermc.paper.datakey;
+
+import java.util.function.Function;
+import net.minecraft.core.component.DataComponentType;
+import net.minecraft.util.Unit;
+
+public record ComponentAdapter<NMS, API>(
+    DataComponentType<NMS> type,
+    Function<API, NMS> apiToVanilla,
+    Function<NMS, API> vanillaToApi
+) {
+    static final Function<Void, Unit> API_TO_UNIT_CONVERTER = $ -> Unit.INSTANCE;
+
+    public boolean isValued() {
+        return this.apiToVanilla != API_TO_UNIT_CONVERTER;
+    }
+
+    public NMS toVanilla(final API value) {
+        return this.apiToVanilla.apply(value);
+    }
+
+    public API fromVanilla(final NMS value) {
+        return this.vanillaToApi.apply(value);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/datakey/ComponentAdapters.java b/src/main/java/io/papermc/paper/datakey/ComponentAdapters.java
new file mode 100644
index 0000000000000000000000000000000000000000..d25c3fcb97f89760f60469e25e1f85c105cc115e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/datakey/ComponentAdapters.java
@@ -0,0 +1,75 @@
+package io.papermc.paper.datakey;
+
+import io.papermc.paper.adventure.PaperAdventure;
+import io.papermc.paper.datakey.types.PaperChargedProjectiles;
+import io.papermc.paper.datakey.types.PaperItemLore;
+import io.papermc.paper.datakey.types.PaperPotDecorations;
+import io.papermc.paper.datakey.types.PaperUnbreakable;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Function;
+import net.minecraft.core.component.DataComponentType;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.util.Unit;
+import net.minecraft.world.item.Rarity;
+import org.bukkit.craftbukkit.util.Handleable;
+import org.bukkit.inventory.ItemRarity;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public final class ComponentAdapters {
+
+    private static final Function<Unit, Void> UNIT_TO_API_CONVERTER = $ -> {
+        throw new UnsupportedOperationException("Cannot convert the Unit type to an API value");
+    };
+
+    static final Map<ResourceKey<DataComponentType<?>>, ComponentAdapter<?, ?>> ADAPTERS = new HashMap<>();
+
+    public static void bootstrap() {
+        registerIdentity(DataComponents.MAX_STACK_SIZE);
+        registerIdentity(DataComponents.MAX_DAMAGE);
+        registerIdentity(DataComponents.DAMAGE);
+        registerIdentity(DataComponents.REPAIR_COST);
+        registerIdentity(DataComponents.OMINOUS_BOTTLE_AMPLIFIER);
+        registerIdentity(DataComponents.ENCHANTMENT_GLINT_OVERRIDE);
+        register(DataComponents.UNBREAKABLE, PaperUnbreakable::new);
+        register(DataComponents.CUSTOM_NAME, PaperAdventure::asAdventure, PaperAdventure::asVanilla);
+        register(DataComponents.ITEM_NAME, PaperAdventure::asAdventure, PaperAdventure::asVanilla);
+        register(DataComponents.LORE, PaperItemLore::new);
+        register(DataComponents.RARITY, nms -> ItemRarity.valueOf(nms.name()), api -> Rarity.valueOf(api.name()));
+        registerUntyped(DataComponents.HIDE_ADDITIONAL_TOOLTIP);
+        registerUntyped(DataComponents.HIDE_TOOLTIP);
+        registerUntyped(DataComponents.CREATIVE_SLOT_LOCK);
+        registerUntyped(DataComponents.INTANGIBLE_PROJECTILE);
+        registerUntyped(DataComponents.FIRE_RESISTANT);
+        register(DataComponents.POT_DECORATIONS, PaperPotDecorations::new);
+        register(DataComponents.CHARGED_PROJECTILES, PaperChargedProjectiles::new);
+    }
+
+    public static void registerUntyped(final DataComponentType<Unit> type) {
+        registerInternal(type, UNIT_TO_API_CONVERTER, ComponentAdapter.API_TO_UNIT_CONVERTER);
+    }
+
+    private static <COMMON> void registerIdentity(final DataComponentType<COMMON> type) {
+        registerInternal(type, Function.identity(), Function.identity());
+    }
+
+    private static <NMS, API extends Handleable<NMS>> void register(final DataComponentType<NMS> type, final Function<NMS, API> vanillaToApi) {
+        register(type, vanillaToApi, Handleable::getHandle);
+    }
+
+    private static <NMS, API> void register(final DataComponentType<NMS> type, final Function<NMS, API> vanillaToApi, final Function<API, NMS> apiToVanilla) {
+        registerInternal(type, vanillaToApi, apiToVanilla);
+    }
+
+    private static <NMS, API> void registerInternal(final DataComponentType<NMS> type, final Function<NMS, API> vanillaToApi, final Function<API, NMS> apiToVanilla) {
+        final ResourceKey<DataComponentType<?>> key = BuiltInRegistries.DATA_COMPONENT_TYPE.getResourceKey(type).orElseThrow();
+        if (ADAPTERS.containsKey(key)) {
+            throw new IllegalStateException("Duplicate adapter registration for " + key);
+        }
+        ADAPTERS.put(key, new ComponentAdapter<>(type, apiToVanilla, vanillaToApi));
+    }
+}
diff --git a/src/main/java/io/papermc/paper/datakey/DataComponentPatchBridgeImpl.java b/src/main/java/io/papermc/paper/datakey/DataComponentPatchBridgeImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..af78395dc718a3947ae1001daa48f68fddd135a6
--- /dev/null
+++ b/src/main/java/io/papermc/paper/datakey/DataComponentPatchBridgeImpl.java
@@ -0,0 +1,57 @@
+package io.papermc.paper.datakey;
+
+import com.mojang.authlib.GameProfile;
+import io.papermc.paper.datakey.map.DataComponentMap;
+import io.papermc.paper.datakey.map.PatchedDataComponentMap;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import org.bukkit.Material;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.craftbukkit.inventory.CraftItemType;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.ItemMeta;
+
+public class DataComponentPatchBridgeImpl implements io.papermc.paper.datakey.map.DataComponentPatchMapBridge {
+    @Override
+    public PatchedDataComponentMap of(final DataComponentMap map) {
+        return new PaperPatchedDataComponentMap(new net.minecraft.core.component.PatchedDataComponentMap(((PaperDataComponentMap) map).map));
+    }
+
+    @Override
+    public DataComponentMap empty() {
+        return new PaperDataComponentMap(net.minecraft.core.component.DataComponentMap.EMPTY);
+    }
+
+    @Override
+    public DataComponentMap fromItem(final Material material) {
+        final Item item = CraftItemType.bukkitToMinecraft(material);
+        if (item == null) {
+            // Because people can make non-item itemstacks still..
+            return this.empty();
+        }
+        return new PaperDataComponentMap(item.components());
+    }
+
+    @Override
+    public PatchedDataComponentMap fromItemAndMeta(final Material material, final ItemMeta meta) {
+        final CraftMetaItem.Applicator tag = new CraftMetaItem.Applicator() {
+            @Override
+            public void skullCallback(final GameProfile gameProfile) {
+                this.builder.set(DataComponents.PROFILE, new net.minecraft.world.item.component.ResolvableProfile(gameProfile));
+            }
+        };
+        ((CraftMetaItem) meta).applyToItemPublic(tag);
+
+        final net.minecraft.core.component.PatchedDataComponentMap map = new net.minecraft.core.component.PatchedDataComponentMap(CraftItemType.bukkitToMinecraft(material).components());
+        map.applyPatch(tag.builder.build());
+        return new PaperPatchedDataComponentMap(map);
+    }
+
+    @Override
+    public ItemMeta toItemMeta(final Material material, final PatchedDataComponentMap map) {
+        final ItemStack stack = new ItemStack(CraftItemType.bukkitToMinecraft(material));
+        stack.restorePatch(((PaperPatchedDataComponentMap) map).patched().asPatch());
+        return CraftItemStack.getItemMeta(stack, material);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/datakey/NonValuedDataComponentTypeImpl.java b/src/main/java/io/papermc/paper/datakey/NonValuedDataComponentTypeImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..67ce3b2960396c86c1ba2cb568b76a982c608e58
--- /dev/null
+++ b/src/main/java/io/papermc/paper/datakey/NonValuedDataComponentTypeImpl.java
@@ -0,0 +1,14 @@
+package io.papermc.paper.datakey;
+
+import org.bukkit.NamespacedKey;
+
+final class NonValuedDataComponentTypeImpl<T, NMS> extends PaperComponentType<T, NMS> implements DataComponentType.NonValued {
+
+    NonValuedDataComponentTypeImpl(
+        final NamespacedKey key,
+        final net.minecraft.core.component.DataComponentType<NMS> type,
+        final ComponentAdapter<NMS, T> adapter
+    ) {
+        super(key, type, adapter);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/datakey/PaperComponentType.java b/src/main/java/io/papermc/paper/datakey/PaperComponentType.java
new file mode 100644
index 0000000000000000000000000000000000000000..c5f6005b57e77061900b6c1b145f33f373834247
--- /dev/null
+++ b/src/main/java/io/papermc/paper/datakey/PaperComponentType.java
@@ -0,0 +1,71 @@
+package io.papermc.paper.datakey;
+
+import net.kyori.adventure.key.Key;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.resources.ResourceKey;
+import org.bukkit.NamespacedKey;
+import org.bukkit.Registry;
+import org.bukkit.craftbukkit.CraftRegistry;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+import org.bukkit.craftbukkit.util.Handleable;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.jetbrains.annotations.NotNull;
+
+@DefaultQualifier(NonNull.class)
+public class PaperComponentType<T, NMS> implements DataComponentType, Handleable<net.minecraft.core.component.DataComponentType<NMS>> {
+
+    static {
+        ComponentAdapters.bootstrap();
+    }
+
+    public static <T> net.minecraft.core.component.DataComponentType<T> bukkitToMinecraft(final DataComponentType type) {
+        return CraftRegistry.bukkitToMinecraft(type);
+    }
+
+    public static DataComponentType minecraftToBukkit(final net.minecraft.core.component.DataComponentType<?> type) {
+        return CraftRegistry.minecraftToBukkit(type, Registries.DATA_COMPONENT_TYPE, Registry.DATA_COMPONENT_TYPE);
+    }
+
+    private final NamespacedKey key;
+    private final net.minecraft.core.component.DataComponentType<NMS> type;
+    private final ComponentAdapter<NMS, T> adapter;
+
+    public PaperComponentType(final NamespacedKey key, final net.minecraft.core.component.DataComponentType<NMS> type, final ComponentAdapter<NMS, T> adapter) {
+        this.key = key;
+        this.type = type;
+        this.adapter = adapter;
+    }
+
+    @Override
+    public @NotNull NamespacedKey getKey() {
+        return this.key;
+    }
+
+    @Override
+    public Key key() {
+        return this.key;
+    }
+
+    public ComponentAdapter<NMS, T> getAdapter() {
+        return this.adapter;
+    }
+
+    @Override
+    public net.minecraft.core.component.DataComponentType<NMS> getHandle() {
+        return this.type;
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <NMS> DataComponentType of(final NamespacedKey key, final net.minecraft.core.component.DataComponentType<NMS> type) {
+        final ComponentAdapter<NMS, ?> adapter = (ComponentAdapter<NMS, ?>) ComponentAdapters.ADAPTERS.get(ResourceKey.create(Registries.DATA_COMPONENT_TYPE, CraftNamespacedKey.toMinecraft(key)));
+        if (adapter == null) {
+            throw new IllegalArgumentException("No adapter found for " + key);
+        }
+        if (adapter.isValued()) {
+            return new ValuedDataComponentTypeImpl<>(key, type, adapter);
+        } else {
+            return new NonValuedDataComponentTypeImpl<>(key, type, adapter);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/datakey/PaperDataComponentMap.java b/src/main/java/io/papermc/paper/datakey/PaperDataComponentMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..9480d70d41bd53f8d91b72da8506d2862fb771fd
--- /dev/null
+++ b/src/main/java/io/papermc/paper/datakey/PaperDataComponentMap.java
@@ -0,0 +1,46 @@
+package io.papermc.paper.datakey;
+
+import io.papermc.paper.datakey.map.DataComponentMap;
+import java.util.HashSet;
+import java.util.Set;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public class PaperDataComponentMap implements DataComponentMap {
+
+    protected final net.minecraft.core.component.DataComponentMap map;
+
+    public PaperDataComponentMap(final net.minecraft.core.component.DataComponentMap map) {
+        this.map = map;
+    }
+
+    @Override
+    public <T> @Nullable T get(final DataComponentType.Valued<T> type) {
+        @SuppressWarnings("unchecked")
+        final PaperComponentType<T, Object> typeAsImpl = (PaperComponentType<T, Object>) type;
+        final ComponentAdapter<Object, T> adapter = typeAsImpl.getAdapter();
+        final @Nullable Object value = this.map.get(typeAsImpl.getHandle());
+
+        return value == null ? null : adapter.fromVanilla(value);
+    }
+
+    @Override
+    public Set<DataComponentType> keySet() {
+        final Set<net.minecraft.core.component.DataComponentType<?>> nmsKeys = this.map.keySet();
+        final Set<DataComponentType> keys = new HashSet<>(nmsKeys.size());
+        for (final net.minecraft.core.component.DataComponentType<?> nmsKey : nmsKeys) {
+            keys.add(PaperComponentType.minecraftToBukkit(nmsKey));
+        }
+
+        return keys;
+    }
+
+    @Override
+    public boolean has(final DataComponentType type) {
+        @SuppressWarnings("unchecked")
+        final PaperComponentType<?, Object> typeAsImpl = (PaperComponentType<?, Object>) type;
+        return this.map.has(typeAsImpl.getHandle());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/datakey/PaperPatchedDataComponentMap.java b/src/main/java/io/papermc/paper/datakey/PaperPatchedDataComponentMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..4fcb07685f4ad84821332dba390f8d4b2246d0f0
--- /dev/null
+++ b/src/main/java/io/papermc/paper/datakey/PaperPatchedDataComponentMap.java
@@ -0,0 +1,71 @@
+package io.papermc.paper.datakey;
+
+import io.papermc.paper.datakey.map.PatchedDataComponentMap;
+import io.papermc.paper.datakey.patch.DataKeyMapPatch;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class PaperPatchedDataComponentMap extends PaperDataComponentMap implements PatchedDataComponentMap {
+
+    public PaperPatchedDataComponentMap(final net.minecraft.core.component.PatchedDataComponentMap map) {
+        super(map);
+    }
+
+    @Override
+    public <T> void set(final DataComponentType.Valued<T> type, final @Nullable T value) {
+        @SuppressWarnings("unchecked")
+        final PaperComponentType<T, Object> typeAsImpl = ((PaperComponentType<T, Object>) type);
+        this.setInternal(typeAsImpl, value);
+    }
+
+    @Override
+    public void set(final DataComponentType.NonValued type) {
+        @SuppressWarnings("unchecked")
+        final PaperComponentType<?, Object> typeAsImpl = ((PaperComponentType<?, Object>) type);
+        this.setInternal(typeAsImpl, null);
+    }
+
+    private <A, V> void setInternal(final PaperComponentType<A, V> type, final @Nullable A value) {
+        final ComponentAdapter<V, A> adapter = type.getAdapter();
+
+        if (adapter.isValued()) {
+            this.patched().set(type.getHandle(), value == null ? null : adapter.toVanilla(value));
+        } else {
+            this.patched().set(type.getHandle(), adapter.toVanilla(value));
+        }
+    }
+
+    @Override
+    public void unset(final DataComponentType type) {
+        @SuppressWarnings("unchecked")
+        final PaperComponentType<?, Object> typeAsImpl = ((PaperComponentType<?, Object>) type);
+        this.patched().remove(typeAsImpl.getHandle());
+    }
+
+    @Override
+    public void reset(@NotNull final DataComponentType type) {
+        @SuppressWarnings("unchecked")
+        final PaperComponentType<?, Object> typeAsImpl = (PaperComponentType<?, Object>) type;
+
+        final net.minecraft.core.component.PatchedDataComponentMap map = this.patched();
+        map.applyPatch(map.asPatch().forget((forgetType) -> forgetType == typeAsImpl.getHandle())); // Apply patch with type removed
+    }
+
+    @Override
+    public @NotNull DataKeyMapPatch asPatch() {
+        return null;
+    }
+
+    @Override
+    public void applyPatch(@NotNull final DataKeyMapPatch patch) {
+    }
+
+    @Override
+    public PatchedDataComponentMap copy() {
+        return new PaperPatchedDataComponentMap(this.patched().copy());
+    }
+
+    public net.minecraft.core.component.PatchedDataComponentMap patched() {
+        return ((net.minecraft.core.component.PatchedDataComponentMap) this.map);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/datakey/ValuedDataComponentTypeImpl.java b/src/main/java/io/papermc/paper/datakey/ValuedDataComponentTypeImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..e6ebc39e96c9eb6f9869cfff258d4e25f28f8878
--- /dev/null
+++ b/src/main/java/io/papermc/paper/datakey/ValuedDataComponentTypeImpl.java
@@ -0,0 +1,14 @@
+package io.papermc.paper.datakey;
+
+import org.bukkit.NamespacedKey;
+
+final class ValuedDataComponentTypeImpl<T, NMS> extends PaperComponentType<T, NMS> implements DataComponentType.Valued<T> {
+
+    ValuedDataComponentTypeImpl(
+        final NamespacedKey key,
+        final net.minecraft.core.component.DataComponentType<NMS> type,
+        final ComponentAdapter<NMS, T> adapter
+    ) {
+        super(key, type, adapter);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/datakey/types/ComponentTypesBridgesImpl.java b/src/main/java/io/papermc/paper/datakey/types/ComponentTypesBridgesImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..d77c11e4022939ada8b3ee13b6d7cd147e03bd94
--- /dev/null
+++ b/src/main/java/io/papermc/paper/datakey/types/ComponentTypesBridgesImpl.java
@@ -0,0 +1,24 @@
+package io.papermc.paper.datakey.types;
+
+public final class ComponentTypesBridgesImpl implements ComponentTypesBridge {
+
+    @Override
+    public ChargedProjectiles.Builder chargedProjectiles() {
+        return new PaperChargedProjectiles.BuilderImpl();
+    }
+
+    @Override
+    public PotDecorations.Builder potDecorations() {
+        return new PaperPotDecorations.BuilderImpl();
+    }
+
+    @Override
+    public Unbreakable.Builder unbreakable() {
+        return new PaperUnbreakable.BuilderImpl();
+    }
+
+    @Override
+    public ItemLore.Builder lore() {
+        return new PaperItemLore.BuilderImpl();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/datakey/types/PaperChargedProjectiles.java b/src/main/java/io/papermc/paper/datakey/types/PaperChargedProjectiles.java
new file mode 100644
index 0000000000000000000000000000000000000000..414e89666d0b2ba741c14113a6155fcef33b194e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/datakey/types/PaperChargedProjectiles.java
@@ -0,0 +1,60 @@
+package io.papermc.paper.datakey.types;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+import net.minecraft.world.item.Item;
+import org.bukkit.Material;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.craftbukkit.inventory.CraftItemType;
+import org.bukkit.craftbukkit.util.Handleable;
+import org.bukkit.inventory.ItemStack;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.UnmodifiableView;
+
+@DefaultQualifier(NonNull.class)
+public record PaperChargedProjectiles(net.minecraft.world.item.component.ChargedProjectiles impl) implements ChargedProjectiles, Handleable<net.minecraft.world.item.component.ChargedProjectiles> {
+
+    @Override
+    public net.minecraft.world.item.component.ChargedProjectiles getHandle() {
+        return this.impl;
+    }
+
+    @Override
+    public @NotNull @UnmodifiableView List<ItemStack> getItems() {
+        List<net.minecraft.world.item.ItemStack> nmsItemStacks = this.impl.getItems();
+        List<ItemStack> apiItemStacks = new ArrayList<>(nmsItemStacks.size());
+        for (net.minecraft.world.item.ItemStack nmsItemStack : nmsItemStacks) {
+            apiItemStacks.add(CraftItemStack.asCraftMirror(nmsItemStack));
+        }
+
+        return apiItemStacks;
+    }
+
+    static final class BuilderImpl implements Builder {
+
+        private final List<net.minecraft.world.item.ItemStack> items = new ArrayList<>();
+
+        @Override
+        public Builder add(final ItemStack itemStack) {
+            this.items.add(CraftItemStack.asNMSCopy(itemStack));
+            return this;
+        }
+
+        @Override
+        public Builder addAll(final List<ItemStack> itemStack) {
+            for (ItemStack item : itemStack) {
+                this.items.add(CraftItemStack.asNMSCopy(item));
+            }
+            return this;
+        }
+
+        @Override
+        public @NotNull ChargedProjectiles build() {
+            return new PaperChargedProjectiles(net.minecraft.world.item.component.ChargedProjectiles.of(this.items));
+        }
+    }
+ }
diff --git a/src/main/java/io/papermc/paper/datakey/types/PaperItemLore.java b/src/main/java/io/papermc/paper/datakey/types/PaperItemLore.java
new file mode 100644
index 0000000000000000000000000000000000000000..02db3e26cbbcfe4b564a9699168de4d27005a1a0
--- /dev/null
+++ b/src/main/java/io/papermc/paper/datakey/types/PaperItemLore.java
@@ -0,0 +1,66 @@
+package io.papermc.paper.datakey.types;
+
+import com.google.common.collect.Lists;
+import io.papermc.paper.adventure.PaperAdventure;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.ComponentLike;
+import org.bukkit.craftbukkit.util.Handleable;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public record PaperItemLore(
+    net.minecraft.world.item.component.ItemLore impl,
+    List<Component> lines,
+    List<Component> styledLines
+) implements ItemLore, Handleable<net.minecraft.world.item.component.ItemLore> {
+
+    public PaperItemLore(final net.minecraft.world.item.component.ItemLore impl) {
+        this(
+            impl,
+            Collections.unmodifiableList(Lists.transform(impl.lines(), PaperAdventure::asAdventure)),
+            Collections.unmodifiableList(Lists.transform(impl.styledLines(), PaperAdventure::asAdventure))
+        );
+    }
+
+    @Override
+    public net.minecraft.world.item.component.ItemLore getHandle() {
+        return this.impl;
+    }
+
+    @Override
+    public List<Component> lines() {
+        return this.lines;
+    }
+
+    @Override
+    public List<Component> styledLines() {
+        return this.styledLines;
+    }
+
+    static final class BuilderImpl implements ItemLore.Builder {
+
+        private List<? extends ComponentLike> lines = Collections.emptyList();
+
+        @Override
+        public ItemLore.Builder lines(final List<? extends ComponentLike> lines) {
+            this.lines = List.copyOf(lines);
+            return this;
+        }
+
+        @Override
+        public ItemLore build() {
+            if (this.lines.isEmpty()) {
+                return new PaperItemLore(net.minecraft.world.item.component.ItemLore.EMPTY);
+            }
+            final List<net.minecraft.network.chat.Component> lines = new ArrayList<>(this.lines.size());
+            for (final ComponentLike line : this.lines) {
+                lines.add(PaperAdventure.asVanilla(line.asComponent()));
+            }
+            return new PaperItemLore(new net.minecraft.world.item.component.ItemLore(Collections.unmodifiableList(lines)));
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/datakey/types/PaperPotDecorations.java b/src/main/java/io/papermc/paper/datakey/types/PaperPotDecorations.java
new file mode 100644
index 0000000000000000000000000000000000000000..57fad01b4bc929577a54997ca3983519399d22fe
--- /dev/null
+++ b/src/main/java/io/papermc/paper/datakey/types/PaperPotDecorations.java
@@ -0,0 +1,86 @@
+package io.papermc.paper.datakey.types;
+
+import org.bukkit.Material;
+import org.bukkit.craftbukkit.inventory.CraftItemType;
+import org.bukkit.craftbukkit.util.Handleable;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import java.util.Optional;
+
+@DefaultQualifier(NonNull.class)
+public record PaperPotDecorations(
+    net.minecraft.world.level.block.entity.PotDecorations impl) implements PotDecorations, Handleable<net.minecraft.world.level.block.entity.PotDecorations> {
+
+    @Override
+    public @Nullable Material back() {
+        return this.impl.back().map(CraftItemType::minecraftToBukkit).orElse(null);
+    }
+
+    @Override
+    public @Nullable Material left() {
+        return this.impl.left().map(CraftItemType::minecraftToBukkit).orElse(null);
+    }
+
+    @Override
+    public @Nullable Material right() {
+        return this.impl.right().map(CraftItemType::minecraftToBukkit).orElse(null);
+    }
+
+    @Override
+    public @Nullable Material front() {
+        return this.impl.front().map(CraftItemType::minecraftToBukkit).orElse(null);
+    }
+
+    @Override
+    public net.minecraft.world.level.block.entity.PotDecorations getHandle() {
+        return this.impl;
+    }
+
+    static final class BuilderImpl implements Builder {
+
+        @Nullable
+        private Material back;
+        @Nullable
+        private Material left;
+        @Nullable
+        private Material right;
+        @Nullable
+        private Material front;
+
+        @Override
+        public Builder back(@Nullable final Material item) {
+            this.back = item;
+            return this;
+        }
+
+        @Override
+        public Builder left(@Nullable final Material item) {
+            this.left = item;
+            return this;
+        }
+
+        @Override
+        public Builder right(@Nullable final Material item) {
+            this.right = item;
+            return this;
+        }
+
+        @Override
+        public Builder front(@Nullable final Material item) {
+            this.front = item;
+            return this;
+        }
+
+        @Override
+        public @NotNull PotDecorations build() {
+            return new PaperPotDecorations(new net.minecraft.world.level.block.entity.PotDecorations(
+                Optional.ofNullable(this.back).map(CraftItemType::bukkitToMinecraft),
+                Optional.ofNullable(this.left).map(CraftItemType::bukkitToMinecraft),
+                Optional.ofNullable(this.right).map(CraftItemType::bukkitToMinecraft),
+                Optional.ofNullable(this.front).map(CraftItemType::bukkitToMinecraft))
+            );
+        }
+    }
+ }
diff --git a/src/main/java/io/papermc/paper/datakey/types/PaperUnbreakable.java b/src/main/java/io/papermc/paper/datakey/types/PaperUnbreakable.java
new file mode 100644
index 0000000000000000000000000000000000000000..8af596088fe4dd7d81f6d4d4ebf4c37121b442cb
--- /dev/null
+++ b/src/main/java/io/papermc/paper/datakey/types/PaperUnbreakable.java
@@ -0,0 +1,40 @@
+package io.papermc.paper.datakey.types;
+
+import org.bukkit.craftbukkit.util.Handleable;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public record PaperUnbreakable(net.minecraft.world.item.component.Unbreakable impl) implements Unbreakable, Handleable<net.minecraft.world.item.component.Unbreakable> {
+
+    @Override
+    public boolean showInTooltip() {
+        return this.impl.showInTooltip();
+    }
+
+    @Override
+    public Unbreakable showInTooltip(final boolean showInTooltip) {
+        return new PaperUnbreakable(this.impl.withTooltip(showInTooltip));
+    }
+
+    @Override
+    public net.minecraft.world.item.component.Unbreakable getHandle() {
+        return this.impl;
+    }
+
+    static final class BuilderImpl implements Unbreakable.Builder {
+
+        private boolean showInTooltip = true; // should match the default value in the Unbreakable codec
+
+        @Override
+        public Unbreakable.Builder showInTooltip(final boolean showInTooltip) {
+            this.showInTooltip = showInTooltip;
+            return this;
+        }
+
+        @Override
+        public Unbreakable build() {
+            return new PaperUnbreakable(new net.minecraft.world.item.component.Unbreakable(this.showInTooltip));
+        }
+    }
+ }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java b/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java
index 73472890e30180dc3cb6aa1bd9c5815087334682..9b75991344fa6c63fb8414aef062cde45d40d0cf 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java
@@ -144,6 +144,11 @@ public class CraftRegistry<B extends Keyed, M> implements Registry<B> {
             return new io.papermc.paper.world.structure.PaperConfiguredStructure.LegacyRegistry(registryHolder.registryOrThrow(Registries.STRUCTURE));
         }
         // Paper end
+        // Paper start - remove this after a while along with all ConfiguredStructure stuff
+        if (bukkitClass == io.papermc.paper.datakey.DataComponentType.class) {
+            return new CraftRegistry<>(io.papermc.paper.datakey.DataComponentType.class, registryHolder.registryOrThrow(Registries.DATA_COMPONENT_TYPE), io.papermc.paper.datakey.PaperComponentType::of);
+        }
+        // Paper end
 
         return null;
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
index eba5a27e452c4063567fb02d6aabdfb0446d5daf..6852453213bd4f62611ad685952871427862d97f 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
@@ -163,7 +163,7 @@ public final class CraftItemStack extends ItemStack {
                 this.adjustTagForItemMeta(oldType); // Paper
             }
         }
-        this.setData(null);
+        this.setData((MaterialData) null); // Paper
     }
 
     @Override
@@ -202,7 +202,7 @@ public final class CraftItemStack extends ItemStack {
 
     @Override
     public int getMaxStackSize() {
-        return (this.handle == null) ? Material.AIR.getMaxStackSize() : this.handle.getMaxStackSize();
+        return (this.handle == null) ? 64 : this.handle.getMaxStackSize(); // Paper - air stacks to 64
     }
 
     // Paper start
@@ -329,7 +329,7 @@ public final class CraftItemStack extends ItemStack {
         // Paper start - support updating profile after resolving it
         final CraftMetaItem.Applicator tag = new CraftMetaItem.Applicator() {
             @Override
-            void skullCallback(final com.mojang.authlib.GameProfile gameProfile) {
+            public void skullCallback(final com.mojang.authlib.GameProfile gameProfile) { // Paper
                 itemStack.set(DataComponents.PROFILE, new net.minecraft.world.item.component.ResolvableProfile(gameProfile));
             }
         };
@@ -697,7 +697,7 @@ public final class CraftItemStack extends ItemStack {
             // Paper start - support updating profile after resolving it
             CraftMetaItem.Applicator tag = new CraftMetaItem.Applicator() {
                 @Override
-                void skullCallback(final com.mojang.authlib.GameProfile gameProfile) {
+                public void skullCallback(final com.mojang.authlib.GameProfile gameProfile) { // Paper
                     item.set(DataComponents.PROFILE, new net.minecraft.world.item.component.ResolvableProfile(gameProfile));
                 }
             };
@@ -742,7 +742,7 @@ public final class CraftItemStack extends ItemStack {
 
     @Override
     public boolean hasItemMeta() {
-        return CraftItemStack.hasItemMeta(this.handle) && !CraftItemFactory.instance().equals(this.getItemMeta(), null);
+        return true; // Paper - every item has meta now
     }
 
     static boolean hasItemMeta(net.minecraft.world.item.ItemStack item) {
@@ -767,5 +767,14 @@ public final class CraftItemStack extends ItemStack {
         mirrored.setItemMeta(mirrored.getItemMeta());
         return mirrored;
     }
+
+    @Override
+    public io.papermc.paper.datakey.PaperPatchedDataComponentMap components() {
+        if (this.handle == null) {
+            return new io.papermc.paper.datakey.PaperPatchedDataComponentMap(new net.minecraft.core.component.PatchedDataComponentMap(net.minecraft.core.component.DataComponentMap.EMPTY)); // Paper
+        }
+
+        return new io.papermc.paper.datakey.PaperPatchedDataComponentMap((net.minecraft.core.component.PatchedDataComponentMap) this.handle.getComponents()); // Paper
+    }
     // Paper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
index 38454fdc978a24a35e685e65e9b41323781c3ead..6d0a7dc5ac0862c6c4090d877b764ab9a7e977f7 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
@@ -119,7 +119,7 @@ import org.bukkit.persistence.PersistentDataContainer;
  * <li> SerializableMeta.Deserializers deserializer()
  */
 @DelegateDeserialization(SerializableMeta.class)
-class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
+public class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta { // Paper
 
     static class ItemMetaKey {
 
@@ -165,10 +165,10 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         }
     }
 
-    static abstract class Applicator { // Paper - support updating profile after resolving it
+    public static abstract class Applicator { // Paper - support updating profile after resolving it
 
-        final DataComponentPatch.Builder builder = DataComponentPatch.builder();
-        void skullCallback(com.mojang.authlib.GameProfile gameProfile) {} // Paper - support updating profile after resolving it
+        public final DataComponentPatch.Builder builder = DataComponentPatch.builder(); // Paper
+        public void skullCallback(com.mojang.authlib.GameProfile gameProfile) {} // Paper - support updating profile after resolving it
 
         <T> Applicator put(ItemMetaKeyType<T> key, T value) {
             this.builder.set(key.TYPE, value);
@@ -758,8 +758,13 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         return result;
     }
 
+    // Paper
+    public void applyToItemPublic(CraftMetaItem.Applicator itemTag) {
+        this.applyToItem(itemTag);
+    }
+    // Paper end
     @Overridden
-    void applyToItem(CraftMetaItem.Applicator itemTag) {
+    void applyToItem(CraftMetaItem.Applicator itemTag) { // Paper
         if (this.hasDisplayName()) {
             itemTag.put(CraftMetaItem.NAME, this.displayName);
         }
diff --git a/src/main/resources/META-INF/services/io.papermc.paper.datakey.map.DataComponentPatchMapBridge b/src/main/resources/META-INF/services/io.papermc.paper.datakey.map.DataComponentPatchMapBridge
new file mode 100644
index 0000000000000000000000000000000000000000..9fd7c2b9089b3a13834fcca23e9a7c47c0cead83
--- /dev/null
+++ b/src/main/resources/META-INF/services/io.papermc.paper.datakey.map.DataComponentPatchMapBridge
@@ -0,0 +1 @@
+io.papermc.paper.datakey.DataComponentPatchBridgeImpl
diff --git a/src/main/resources/META-INF/services/io.papermc.paper.datakey.types.ComponentTypesBridge b/src/main/resources/META-INF/services/io.papermc.paper.datakey.types.ComponentTypesBridge
new file mode 100644
index 0000000000000000000000000000000000000000..d43e2b2d0e86ed585ba7bfd4e26d625960cc6fe7
--- /dev/null
+++ b/src/main/resources/META-INF/services/io.papermc.paper.datakey.types.ComponentTypesBridge
@@ -0,0 +1 @@
+io.papermc.paper.datakey.types.ComponentTypesBridgesImpl
\ No newline at end of file
diff --git a/src/test/java/io/papermc/paper/item/ItemStackDataComponentTest.java b/src/test/java/io/papermc/paper/item/ItemStackDataComponentTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..023f0f0cf3b0220b143b43f3484459ac2f853108
--- /dev/null
+++ b/src/test/java/io/papermc/paper/item/ItemStackDataComponentTest.java
@@ -0,0 +1,127 @@
+package io.papermc.paper.item;
+
+import io.papermc.paper.datakey.DataComponentType;
+import io.papermc.paper.datakey.DataComponentTypes;
+import io.papermc.paper.datakey.types.ChargedProjectiles;
+import io.papermc.paper.datakey.types.PotDecorations;
+import io.papermc.paper.datakey.types.Unbreakable;
+import org.bukkit.Material;
+import org.bukkit.block.BlockState;
+import org.bukkit.block.DecoratedPot;
+import org.bukkit.inventory.ItemFlag;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.meta.BlockStateMeta;
+import org.bukkit.inventory.meta.CrossbowMeta;
+import org.bukkit.inventory.meta.Damageable;
+import org.bukkit.inventory.meta.ItemMeta;
+import org.bukkit.inventory.meta.Repairable;
+import org.bukkit.support.AbstractTestingBase;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+import java.util.List;
+import java.util.function.BiConsumer;
+import java.util.function.Function;
+
+class ItemStackDataComponentTest extends AbstractTestingBase {
+
+    @Test
+    void testMaxStackSize() {
+        final ItemStack stack = new ItemStack(Material.STONE);
+        testWithMeta(stack, DataComponentTypes.MAX_STACK_SIZE, 32, ItemMeta.class, ItemMeta::getMaxStackSize, ItemMeta::setMaxStackSize);
+    }
+
+    @Test
+    void testMaxDamage() {
+        final ItemStack stack = new ItemStack(Material.STONE);
+        testWithMeta(stack, DataComponentTypes.MAX_DAMAGE, 120, Damageable.class, Damageable::getMaxDamage, Damageable::setMaxDamage);
+    }
+
+    @Test
+    void testDamage() {
+        final ItemStack stack = new ItemStack(Material.STONE);
+        testWithMeta(stack, DataComponentTypes.DAMAGE, 120, Damageable.class, Damageable::getDamage, Damageable::setDamage);
+    }
+
+    @Test
+    void testUnbreakable() {
+        final ItemStack stack = new ItemStack(Material.STONE);
+        stack.setData(DataComponentTypes.UNBREAKABLE, Unbreakable.unbreakable().showInTooltip(false).build());
+
+        Assertions.assertTrue(stack.getItemMeta().isUnbreakable());
+        Assertions.assertTrue(stack.getItemMeta().getItemFlags().contains(ItemFlag.HIDE_UNBREAKABLE));
+        stack.setData(DataComponentTypes.UNBREAKABLE, null);
+        Assertions.assertFalse(stack.getItemMeta().isUnbreakable());
+    }
+
+    @Test
+    void testHideAdditionalTooltip() {
+        final ItemStack stack = new ItemStack(Material.STONE);
+        stack.setData(DataComponentTypes.HIDE_ADDITIONAL_TOOLTIP);
+
+        Assertions.assertTrue(stack.getItemMeta().getItemFlags().contains(ItemFlag.HIDE_ADDITIONAL_TOOLTIP));
+        stack.removeData(DataComponentTypes.HIDE_ADDITIONAL_TOOLTIP);
+        Assertions.assertFalse(stack.getItemMeta().getItemFlags().contains(ItemFlag.HIDE_ADDITIONAL_TOOLTIP));
+    }
+
+    @Test
+    void testHideTooltip() {
+        ItemStack stack = new ItemStack(Material.STONE);
+        stack.setData(DataComponentTypes.HIDE_TOOLTIP);
+
+        Assertions.assertEquals(stack.getItemMeta().isHideTooltip(), stack.hasData(DataComponentTypes.HIDE_TOOLTIP));
+        Assertions.assertTrue(stack.getItemMeta().isHideTooltip());
+        stack.removeData(DataComponentTypes.HIDE_TOOLTIP);
+        Assertions.assertFalse(stack.getItemMeta().isHideTooltip());
+        stack = new ItemStack(Material.STONE);
+
+        stack.removeData(DataComponentTypes.HIDE_TOOLTIP);
+        Assertions.assertFalse(stack.getItemMeta().isHideTooltip());
+        Assertions.assertEquals(stack.getItemMeta().isHideTooltip(), stack.hasData(DataComponentTypes.HIDE_TOOLTIP));
+    }
+
+    @Test
+    void testRepairCost() {
+        final ItemStack stack = new ItemStack(Material.STONE);
+        testWithMeta(stack, DataComponentTypes.REPAIR_COST, 120, Repairable.class, Repairable::getRepairCost, Repairable::setRepairCost);
+    }
+
+    @Test
+    void testChargedProjectiles() {
+        final ItemStack stack = new ItemStack(Material.CROSSBOW);
+        ItemStack projectile = new ItemStack(Material.FIREWORK_ROCKET);
+        stack.setData(DataComponentTypes.CHARGED_PROJECTILES, ChargedProjectiles.chargedProjectiles().add(projectile).build());
+
+        CrossbowMeta meta = (CrossbowMeta) stack.getItemMeta();
+        Assertions.assertEquals(meta.getChargedProjectiles().get(0), projectile);
+
+        stack.removeData(DataComponentTypes.CHARGED_PROJECTILES);
+        meta = (CrossbowMeta) stack.getItemMeta();
+        Assertions.assertTrue(meta.getChargedProjectiles().isEmpty());
+    }
+
+    @Test
+    void testPot() {
+        final ItemStack stack = new ItemStack(Material.DECORATED_POT);
+        stack.setData(DataComponentTypes.POT_DECORATIONS, PotDecorations.potDecorations().back(Material.DANGER_POTTERY_SHERD).build());
+
+        BlockState state = ((BlockStateMeta) stack.getItemMeta()).getBlockState();
+        DecoratedPot decoratedPot = (DecoratedPot) state;
+
+        Assertions.assertEquals(decoratedPot.getSherd(DecoratedPot.Side.BACK), Material.DANGER_POTTERY_SHERD);
+        stack.removeData(DataComponentTypes.POT_DECORATIONS);
+        decoratedPot = (DecoratedPot) ((BlockStateMeta) stack.getItemMeta()).getBlockState();
+        Assertions.assertTrue(decoratedPot.getSherds().values().stream().allMatch((m) -> m == Material.BRICK));
+    }
+
+    @SuppressWarnings("unchecked")
+    private static <T, M> void testWithMeta(final ItemStack stack, final DataComponentType.Valued<T> type, final T value, final Class<M> metaType, final Function<M, T> metaGetter, final BiConsumer<M, T> metaSetter) {
+        stack.setData(type, value);
+
+        Assertions.assertEquals(value, stack.getData(type));
+
+        final ItemMeta meta = stack.getItemMeta();
+        final M typedMeta = Assertions.assertInstanceOf(metaType, meta);
+
+        Assertions.assertEquals(metaGetter.apply(typedMeta), value);
+    }
+}
diff --git a/src/test/java/io/papermc/paper/item/MetaComparisonTest.java b/src/test/java/io/papermc/paper/item/MetaComparisonTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..03aeb992c274d762c1b3475458851671d3045ffc
--- /dev/null
+++ b/src/test/java/io/papermc/paper/item/MetaComparisonTest.java
@@ -0,0 +1,284 @@
+package io.papermc.paper.item;
+
+import com.destroystokyo.paper.profile.CraftPlayerProfile;
+import com.destroystokyo.paper.profile.PlayerProfile;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.event.HoverEvent;
+import net.kyori.adventure.text.format.NamedTextColor;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.Color;
+import org.bukkit.Material;
+import org.bukkit.craftbukkit.inventory.CraftItemFactory;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.enchantments.Enchantment;
+import org.bukkit.inventory.ItemFactory;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.meta.BookMeta;
+import org.bukkit.inventory.meta.ItemMeta;
+import org.bukkit.inventory.meta.PotionMeta;
+import org.bukkit.inventory.meta.SkullMeta;
+import org.bukkit.potion.PotionEffect;
+import org.bukkit.potion.PotionEffectType;
+import org.bukkit.support.AbstractTestingBase;
+import org.bukkit.util.Consumer;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+
+import java.util.UUID;
+
+// TODO: This should technically be used to compare legacy meta vs the newly implemented
+public class MetaComparisonTest extends AbstractTestingBase {
+
+    private static final ItemFactory FACTORY = CraftItemFactory.instance();
+
+    @Test
+    public void testMetaApplication() {
+        ItemStack itemStack = new ItemStack(Material.STONE);
+
+        ItemMeta meta = itemStack.getItemMeta();
+        meta.setCustomModelData(1);
+
+        ItemMeta converted = FACTORY.asMetaFor(meta, Material.GOLD_INGOT);
+        Assertions.assertEquals(converted.getCustomModelData(), meta.getCustomModelData());
+
+        ItemMeta convertedAdvanced = FACTORY.asMetaFor(meta, Material.PLAYER_HEAD);
+        Assertions.assertEquals(convertedAdvanced.getCustomModelData(), meta.getCustomModelData());
+    }
+
+    @Test
+    public void testMetaApplicationDowngrading() {
+        ItemStack itemStack = new ItemStack(Material.PLAYER_HEAD);
+        PlayerProfile profile = Bukkit.createProfile("Owen1212055");
+
+        SkullMeta meta = (SkullMeta) itemStack.getItemMeta();
+        meta.setPlayerProfile(profile);
+
+        SkullMeta converted = (SkullMeta) FACTORY.asMetaFor(meta, Material.PLAYER_HEAD);
+        Assertions.assertEquals(converted.getPlayerProfile(), meta.getPlayerProfile());
+
+        SkullMeta downgraded = (SkullMeta) FACTORY.asMetaFor(FACTORY.asMetaFor(meta, Material.STONE), Material.PLAYER_HEAD);
+        Assertions.assertNull(downgraded.getPlayerProfile());
+    }
+
+    @Test
+    public void testMetaApplicationDowngradingPotion() {
+        ItemStack itemStack = new ItemStack(Material.POTION);
+        Color color = Color.BLUE;
+
+        PotionMeta meta = (PotionMeta) itemStack.getItemMeta();
+        meta.setColor(color);
+
+        PotionMeta converted = (PotionMeta) FACTORY.asMetaFor(meta, Material.POTION);
+        Assertions.assertEquals(converted.getColor(), color);
+
+        PotionMeta downgraded = (PotionMeta) FACTORY.asMetaFor(FACTORY.asMetaFor(meta, Material.STONE), Material.POTION);
+        Assertions.assertNull(downgraded.getColor());
+    }
+
+
+    @Test
+    public void testNullMeta() {
+        ItemStack itemStack = new ItemStack(Material.AIR);
+
+        //Assertions.assertFalse(itemStack.hasItemMeta());
+        Assertions.assertNull(itemStack.getItemMeta());
+    }
+
+    @Test
+    public void testPotionMeta() {
+        PotionEffect potionEffect = new PotionEffect(PotionEffectType.SPEED, 10, 10, false);
+        ItemStack nmsItemStack = new ItemStack(Material.POTION, 1);
+
+        testSetAndGet(nmsItemStack,
+            (meta) -> ((PotionMeta) meta).addCustomEffect(potionEffect, true),
+            (meta) -> Assertions.assertEquals(potionEffect, ((PotionMeta) meta).getCustomEffects().get(0))
+        );
+    }
+
+    @Test
+    public void testEnchantment() {
+        ItemStack stack = new ItemStack(Material.STICK, 1);
+
+        testSetAndGet(stack,
+            (meta) -> Assertions.assertTrue(meta.addEnchant(Enchantment.SHARPNESS, 1, true)),
+            (meta) -> Assertions.assertEquals(1, meta.getEnchantLevel(Enchantment.SHARPNESS))
+        );
+    }
+
+
+    //@Test
+    public void testPlayerHead() {
+        PlayerProfile profile = new CraftPlayerProfile(UUID.randomUUID(), "Owen1212055");
+        ItemStack stack = new ItemStack(Material.PLAYER_HEAD, 1);
+
+        testSetAndGet(stack,
+            (meta) -> ((SkullMeta) meta).setPlayerProfile(profile),
+            (meta) -> {
+                Assertions.assertTrue(((SkullMeta) meta).hasOwner());
+                Assertions.assertEquals(profile, ((SkullMeta) meta).getPlayerProfile());
+            }
+        );
+
+        testSetAndGet(stack,
+            (meta) -> ((SkullMeta) meta).setOwner("Owen1212055"),
+            (meta) -> {
+                Assertions.assertTrue(((SkullMeta) meta).hasOwner());
+                Assertions.assertEquals("Owen1212055", ((SkullMeta) meta).getOwner());
+            }
+        );
+    }
+
+    @Test
+    public void testBookMetaAuthor() {
+        ItemStack stack = new ItemStack(Material.WRITTEN_BOOK, 1);
+
+        // Legacy string
+        testSetAndGet(stack,
+            (meta) -> ((BookMeta) meta).setAuthor("Owen1212055"),
+            (meta) -> Assertions.assertEquals("Owen1212055", ((BookMeta) meta).getAuthor())
+        );
+
+        // Component Colored
+        Component coloredName = Component.text("Owen1212055", NamedTextColor.DARK_GRAY);
+        testSetAndGet(stack,
+            (meta) -> ((BookMeta) meta).author(coloredName),
+            (meta) -> Assertions.assertEquals(coloredName, ((BookMeta) meta).author())
+        );
+
+        // Simple text
+        Component name = Component.text("Owen1212055");
+        testSetAndGet(stack,
+            (meta) -> ((BookMeta) meta).author(name),
+            (meta) -> Assertions.assertEquals(name, ((BookMeta) meta).author())
+        );
+    }
+
+    @Test
+    public void testBookMetaTitle() {
+        ItemStack stack = new ItemStack(Material.WRITTEN_BOOK, 1);
+
+        // Legacy string
+        testSetAndGet(stack,
+            (meta) -> ((BookMeta) meta).setTitle("Owen1212055"),
+            (meta) -> Assertions.assertEquals("Owen1212055", ((BookMeta) meta).getTitle())
+        );
+
+        // Component Colored
+        Component coloredName = Component.text("Owen1212055", NamedTextColor.DARK_GRAY);
+        testSetAndGet(stack,
+            (meta) -> ((BookMeta) meta).title(coloredName),
+            (meta) -> Assertions.assertEquals(coloredName, ((BookMeta) meta).title())
+        );
+
+        // Simple text
+        Component name = Component.text("Owen1212055");
+        testSetAndGet(stack,
+            (meta) -> ((BookMeta) meta).title(name),
+            (meta) -> Assertions.assertEquals(name, ((BookMeta) meta).title())
+        );
+    }
+
+
+    @Test
+    public void testWriteableBookPages() {
+        ItemStack stack = new ItemStack(Material.WRITABLE_BOOK, 1);
+
+        // Writeable books are serialized as plain text, but has weird legacy color support.
+        // So, we need to test to make sure that all works here.
+
+        // Legacy string
+        testSetAndGet(stack,
+            (meta) -> ((BookMeta) meta).addPage("Owen1212055"),
+            (meta) -> Assertions.assertEquals("Owen1212055", ((BookMeta) meta).getPage(1))
+        );
+
+        // Legacy string colored
+        String translatedLegacy = ChatColor.translateAlternateColorCodes('&', "&7Owen1212055");
+        testSetAndGet(stack,
+            (meta) -> ((BookMeta) meta).addPage(translatedLegacy),
+            (meta) -> Assertions.assertEquals(translatedLegacy, ((BookMeta) meta).getPage(1))
+        );
+
+        // Component Colored
+        Component coloredName = Component.text("Owen1212055", NamedTextColor.DARK_GRAY);
+        testSetAndGet(stack,
+            (meta) -> ((BookMeta) meta).addPages(coloredName),
+            (meta) -> Assertions.assertEquals(coloredName, ((BookMeta) meta).page(1))
+        );
+
+        // Simple text
+        Component name = Component.text("Owen1212055");
+        testSetAndGet(stack,
+            (meta) -> ((BookMeta) meta).addPages(name),
+            (meta) -> Assertions.assertEquals(name, ((BookMeta) meta).page(1))
+        );
+
+        // Simple text + hover... should NOT be saved
+        // As this is plain text
+        Component nameWithHover = Component.text("Owen1212055")
+            .hoverEvent(HoverEvent.hoverEvent(HoverEvent.Action.SHOW_TEXT, Component.text("Hover")));
+        testSetAndGet(stack,
+            (meta) -> ((BookMeta) meta).addPages(nameWithHover),
+            (meta) -> Assertions.assertEquals(name, ((BookMeta) meta).page(1))
+        );
+    }
+
+    @Test
+    public void testWrittenBookPages() {
+        ItemStack stack = new ItemStack(Material.WRITTEN_BOOK, 1);
+
+        // Writeable books are serialized as plain text, but has weird legacy color support.
+        // So, we need to test to make sure that all works here.
+
+        // Legacy string
+        testSetAndGet(stack,
+            (meta) -> ((BookMeta) meta).addPage("Owen1212055"),
+            (meta) -> Assertions.assertEquals("Owen1212055", ((BookMeta) meta).getPage(1))
+        );
+
+        // Legacy string colored
+        String translatedLegacy = ChatColor.translateAlternateColorCodes('&', "&7Owen1212055");
+        testSetAndGet(stack,
+            (meta) -> ((BookMeta) meta).addPage(translatedLegacy),
+            (meta) -> Assertions.assertEquals(translatedLegacy, ((BookMeta) meta).getPage(1))
+        );
+
+        // Component Colored
+        Component coloredName = Component.text("Owen1212055", NamedTextColor.DARK_GRAY);
+        testSetAndGet(stack,
+            (meta) -> ((BookMeta) meta).addPages(coloredName),
+            (meta) -> Assertions.assertEquals(coloredName, ((BookMeta) meta).page(1))
+        );
+
+        // Simple text
+        Component name = Component.text("Owen1212055");
+        testSetAndGet(stack,
+            (meta) -> ((BookMeta) meta).addPages(name),
+            (meta) -> Assertions.assertEquals(name, ((BookMeta) meta).page(1))
+        );
+
+        // Simple text + hover... should be saved
+        Component nameWithHover = Component.text("Owen1212055")
+            .hoverEvent(HoverEvent.hoverEvent(HoverEvent.Action.SHOW_TEXT, Component.text("Hover")));
+        testSetAndGet(stack,
+            (meta) -> ((BookMeta) meta).addPages(nameWithHover),
+            (meta) -> Assertions.assertEquals(nameWithHover, ((BookMeta) meta).page(1))
+        );
+    }
+
+    private void testSetAndGet(org.bukkit.inventory.ItemStack itemStack,
+                               Consumer<ItemMeta> set,
+                               Consumer<ItemMeta> get) {
+        ItemMeta craftMeta = CraftItemStack.getItemMeta(CraftItemStack.asNMSCopy(itemStack)); // TODO: This should be converted to use the old meta when this is added.
+        ItemMeta paperMeta = CraftItemStack.getItemMeta(CraftItemStack.asNMSCopy(itemStack));
+        // Test craft meta
+        set.accept(craftMeta);
+        get.accept(craftMeta);
+
+        // Test paper meta
+        set.accept(paperMeta);
+        get.accept(paperMeta);
+    }
+
+}
diff --git a/src/test/java/org/bukkit/PerMaterialTest.java b/src/test/java/org/bukkit/PerMaterialTest.java
index 702a0c29dc2a7fc435fa590c5c66347aea0e014b..419a7dbbe9c50099a4d35c564f7e9c2ba652be75 100644
--- a/src/test/java/org/bukkit/PerMaterialTest.java
+++ b/src/test/java/org/bukkit/PerMaterialTest.java
@@ -97,17 +97,13 @@ public class PerMaterialTest extends AbstractTestingBase {
 
         final ItemStack bukkit = new ItemStack(material);
         final CraftItemStack craft = CraftItemStack.asCraftCopy(bukkit);
-        if (material == Material.AIR) {
-            final int MAX_AIR_STACK = 0 /* Why can't I hold all of these AIR? */;
-            assertThat(material.getMaxStackSize(), is(MAX_AIR_STACK));
-            assertThat(bukkit.getMaxStackSize(), is(MAX_AIR_STACK));
-            assertThat(craft.getMaxStackSize(), is(MAX_AIR_STACK));
-        } else {
+
+        // Paper - remove air exception
             int max = CraftMagicNumbers.getItem(material).components().getOrDefault(DataComponents.MAX_STACK_SIZE, 64);
             assertThat(material.getMaxStackSize(), is(max));
             assertThat(bukkit.getMaxStackSize(), is(max));
             assertThat(craft.getMaxStackSize(), is(max));
-        }
+        // Paper - remove air exception
     }
 
     @ParameterizedTest
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaTest.java
index 9338743f1e2197f82d610490a22235ee6728e0da..4be79b41bf244c2ca8aab8b0d92750747da51cc9 100644
--- a/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaTest.java
+++ b/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaTest.java
@@ -442,7 +442,7 @@ public class ItemMetaTest extends AbstractTestingBase {
         assertThat(providers, hasSize(ItemStackTest.COMPOUND_MATERIALS.length - 4/* Normal item meta, skulls, eggs and tile entities */), "Forgotten test?");
 
         for (final StackProvider provider : providers) {
-            this.downCastTest(new BukkitWrapper(provider));
+            //this.downCastTest(new BukkitWrapper(provider));
             this.downCastTest(new CraftWrapper(provider));
         }
     }
@@ -479,13 +479,6 @@ public class ItemMetaTest extends AbstractTestingBase {
         final ItemStack blank = new ItemStack(Material.STONE);
         final ItemStack craftBlank = CraftItemStack.asCraftCopy(blank);
 
-        // Check that equality and similarity works for each meta implementation
-        assertThat(provider.stack(), is(provider.stack()), name);
-        assertThat(provider.stack().isSimilar(provider.stack()), is(true), name);
-
-        this.downCastTest(name, provider.stack(), blank);
-        blank.setItemMeta(blank.getItemMeta());
-        this.downCastTest(name, provider.stack(), blank);
 
         this.downCastTest(name, provider.stack(), craftBlank);
         craftBlank.setItemMeta(craftBlank.getItemMeta());
diff --git a/src/test/java/org/bukkit/support/provider/RegistriesArgumentProvider.java b/src/test/java/org/bukkit/support/provider/RegistriesArgumentProvider.java
index 342ea2914b361f39708bf0d8a39385c62d340c30..f10314058c36509494f2f092e20e0253804d6361 100644
--- a/src/test/java/org/bukkit/support/provider/RegistriesArgumentProvider.java
+++ b/src/test/java/org/bukkit/support/provider/RegistriesArgumentProvider.java
@@ -3,6 +3,8 @@ package org.bukkit.support.provider;
 import com.google.common.collect.Lists;
 import java.util.List;
 import java.util.stream.Stream;
+import io.papermc.paper.datakey.DataComponentType;
+import io.papermc.paper.datakey.PaperComponentType;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.world.effect.MobEffect;
 import net.minecraft.world.entity.animal.WolfVariant;
@@ -47,6 +49,7 @@ public class RegistriesArgumentProvider implements ArgumentsProvider {
         DATA.add(Arguments.of(TrimPattern.class, Registries.TRIM_PATTERN, CraftTrimPattern.class, net.minecraft.world.item.armortrim.TrimPattern.class));
         DATA.add(Arguments.of(DamageType.class, Registries.DAMAGE_TYPE, CraftDamageType.class, net.minecraft.world.damagesource.DamageType.class));
         DATA.add(Arguments.of(Wolf.Variant.class, Registries.WOLF_VARIANT, CraftWolf.CraftVariant.class, WolfVariant.class));
+        DATA.add(Arguments.of(DataComponentType.class, Registries.DATA_COMPONENT_TYPE, PaperComponentType.class, net.minecraft.core.component.DataComponentType.class));
     }
 
     @Override

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Potrebic <jake.m.potrebic@gmail.com>
Date: Thu, 20 Jun 2024 09:40:57 -0700
Subject: [PATCH] wip tags

== AT ==
public net/minecraft/tags/TagEntry id
public net/minecraft/tags/TagEntry tag
public net/minecraft/tags/TagEntry required

diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/AbstractLifecycleEventType.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/AbstractLifecycleEventType.java
index 9359a36d26970742da3a7abb0050158cd6c64e8e..30f47879f87fc991c651416546c2f068209545f2 100644
--- a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/AbstractLifecycleEventType.java
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/AbstractLifecycleEventType.java
@@ -33,6 +33,8 @@ public abstract class AbstractLifecycleEventType<O extends LifecycleEventOwner,
         }
     }
 
+    public abstract boolean hasHandlers();
+
     public abstract void forEachHandler(E event, Consumer<RegisteredHandler<O, E>> consumer, Predicate<RegisteredHandler<O, E>> predicate);
 
     public abstract void removeMatching(Predicate<RegisteredHandler<O, E>> predicate);
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEventTypeProviderImpl.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEventTypeProviderImpl.java
index af0cb3298d9c737417c6e54b360f8dc50a5caf04..05ceb6a0556c5e958237cd8e17525343dc3e8458 100644
--- a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEventTypeProviderImpl.java
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEventTypeProviderImpl.java
@@ -10,9 +10,11 @@ import org.checkerframework.framework.qual.DefaultQualifier;
 public final class LifecycleEventTypeProviderImpl implements LifecycleEventTypeProvider {
 
     public static LifecycleEventTypeProviderImpl instance() {
-        return (LifecycleEventTypeProviderImpl) LifecycleEventTypeProvider.PROVIDER;
+        return (LifecycleEventTypeProviderImpl) LifecycleEventTypeProvider.provider();
     }
 
+    private final PaperTagEventTypeProvider provider = new PaperTagEventTypeProvider();
+
     @Override
     public <O extends LifecycleEventOwner, E extends LifecycleEvent> LifecycleEventType.Monitorable<O, E> monitor(final String name, final Class<? extends O> ownerType) {
         return LifecycleEventRunner.INSTANCE.addEventType(new MonitorableLifecycleEventType<>(name, ownerType));
@@ -22,4 +24,9 @@ public final class LifecycleEventTypeProviderImpl implements LifecycleEventTypeP
     public <O extends LifecycleEventOwner, E extends LifecycleEvent> LifecycleEventType.Prioritizable<O, E> prioritized(final String name, final Class<? extends O> ownerType) {
         return LifecycleEventRunner.INSTANCE.addEventType(new PrioritizableLifecycleEventType.Simple<>(name, ownerType));
     }
+
+    @Override
+    public PaperTagEventTypeProvider tagProvider() {
+        return this.provider;
+    }
 }
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/MonitorableLifecycleEventType.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/MonitorableLifecycleEventType.java
index c71912f0050ce0cc6e416948a354c8a66da606a8..abb969cf6ed967fe7720c56d3b3157bd1b74700d 100644
--- a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/MonitorableLifecycleEventType.java
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/MonitorableLifecycleEventType.java
@@ -23,6 +23,11 @@ public class MonitorableLifecycleEventType<O extends LifecycleEventOwner, E exte
         super(name, ownerType);
     }
 
+    @Override
+    public boolean hasHandlers() {
+        return !this.handlers.isEmpty();
+    }
+
     @Override
     public MonitorLifecycleEventHandlerConfigurationImpl<O, E> newHandler(final LifecycleEventHandler<? super E> handler) {
         return new MonitorLifecycleEventHandlerConfigurationImpl<>(handler, this);
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PaperTagEventTypeProvider.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PaperTagEventTypeProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..56010a75aa83c63756547b946d9e4d94f642a98b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PaperTagEventTypeProvider.java
@@ -0,0 +1,45 @@
+package io.papermc.paper.plugin.lifecycle.event.types;
+
+import io.papermc.paper.plugin.bootstrap.BootstrapContext;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.PrioritizedLifecycleEventHandlerConfiguration;
+import io.papermc.paper.plugin.lifecycle.event.registrar.ReloadableRegistrarEvent;
+import io.papermc.paper.registry.RegistryKey;
+import io.papermc.paper.tag.PaperTagListenerManager;
+import io.papermc.paper.tag.PostFlattenTagRegistrar;
+import io.papermc.paper.tag.PreFlattenTagRegistrar;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public class PaperTagEventTypeProvider implements TagEventTypeProvider {
+
+    private LifecycleEventType.@MonotonicNonNull Prioritizable<BootstrapContext, ReloadableRegistrarEvent<PreFlattenTagRegistrar>> commandFunctionPreFlatten;
+    private LifecycleEventType.@MonotonicNonNull Prioritizable<BootstrapContext, ReloadableRegistrarEvent<PostFlattenTagRegistrar>> commandFunctionPostFlatten;
+
+    @Override
+    public PrioritizableLifecycleEventType.Simple<BootstrapContext, ReloadableRegistrarEvent<PreFlattenTagRegistrar>> preFlatten(final RegistryKey<?> registryKey) {
+        return PaperTagListenerManager.INSTANCE.getPreFlattenType(registryKey);
+    }
+
+    @Override
+    public PrioritizableLifecycleEventType.Simple<BootstrapContext, ReloadableRegistrarEvent<PostFlattenTagRegistrar>> postFlatten(final RegistryKey<?> registryKey) {
+        return PaperTagListenerManager.INSTANCE.getPostFlattenType(registryKey);
+    }
+
+    @Override
+    public PrioritizableLifecycleEventType.Simple<BootstrapContext, ReloadableRegistrarEvent<PreFlattenTagRegistrar>> commandFunctionsPreFlatten() {
+        if (this.commandFunctionPreFlatten == null) {
+            this.commandFunctionPreFlatten = LifecycleEvents.bootstrapPrioritized("command function / " + PaperTagListenerManager.PRE_FLATTEN_EVENT_NAME);
+        }
+        return (PrioritizableLifecycleEventType.Simple<BootstrapContext, ReloadableRegistrarEvent<PreFlattenTagRegistrar>>) this.commandFunctionPreFlatten;
+    }
+
+    @Override
+    public PrioritizableLifecycleEventType.Simple<BootstrapContext, ReloadableRegistrarEvent<PostFlattenTagRegistrar>> commandFunctionsPostFlatten() {
+        if (this.commandFunctionPostFlatten == null) {
+            this.commandFunctionPostFlatten = LifecycleEvents.bootstrapPrioritized("command function / " + PaperTagListenerManager.POST_FLATTEN_EVENT_NAME);
+        }
+        return (PrioritizableLifecycleEventType.Simple<BootstrapContext, ReloadableRegistrarEvent<PostFlattenTagRegistrar>>) this.commandFunctionPostFlatten;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizableLifecycleEventType.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizableLifecycleEventType.java
index 76f92a6fc84c0315f3973dc4e92649b66babc3d5..2ed622a61ddc37b11888867770b513909b9a2ecc 100644
--- a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizableLifecycleEventType.java
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizableLifecycleEventType.java
@@ -40,6 +40,11 @@ public abstract class PrioritizableLifecycleEventType<
         super(name, ownerType);
     }
 
+    @Override
+    public boolean hasHandlers() {
+        return !this.handlers.isEmpty();
+    }
+
     @Override
     protected void register(final O owner, final AbstractLifecycleEventHandlerConfiguration<O, E> config) {
         Preconditions.checkArgument(config instanceof PrioritizedLifecycleEventHandlerConfigurationImpl<?, ?>, "Configuration must be a PrioritizedLifecycleEventHandlerConfiguration");
diff --git a/src/main/java/io/papermc/paper/registry/PaperRegistryListenerManager.java b/src/main/java/io/papermc/paper/registry/PaperRegistryListenerManager.java
index a7f2b264d4f37f5293ae72195b4c78faf35351c9..b1b74b73e77ac7414a6d1ab4a19f792a93162751 100644
--- a/src/main/java/io/papermc/paper/registry/PaperRegistryListenerManager.java
+++ b/src/main/java/io/papermc/paper/registry/PaperRegistryListenerManager.java
@@ -31,7 +31,7 @@ import net.minecraft.resources.ResourceLocation;
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.intellij.lang.annotations.Subst;
 
-public final class PaperRegistryListenerManager {
+public class PaperRegistryListenerManager {
 
     public static final PaperRegistryListenerManager INSTANCE = new PaperRegistryListenerManager();
 
@@ -97,7 +97,7 @@ public final class PaperRegistryListenerManager {
     ) {
         Preconditions.checkState(LaunchEntryPointHandler.INSTANCE.hasEntered(Entrypoint.BOOTSTRAPPER), registry.key() + " tried to run modification listeners before bootstrappers have been called"); // verify that bootstrappers have been called
         final @Nullable RegistryEntryInfo<M, T> entry = PaperRegistries.getEntry(registry.key());
-        if (!RegistryEntry.Modifiable.isModifiable(entry) || !this.valueAddHooks.hasHooks(entry.apiKey())) {
+        if (!RegistryEntry.Modifiable.isModifiable(entry) || !this.valueAddHooks.hasHandlers(entry.apiKey())) {
             return registerMethod.register((WritableRegistry<M>) registry, key, nms, registrationInfo);
         }
         final RegistryEntry.Modifiable<M, T, B> modifiableEntry = RegistryEntry.Modifiable.asModifiable(entry);
@@ -114,7 +114,7 @@ public final class PaperRegistryListenerManager {
         final RegistrationInfo registrationInfo,
         final Conversions conversions
     ) {
-        if (!RegistryEntry.Modifiable.isModifiable(entry) || !this.valueAddHooks.hasHooks(entry.apiKey())) {
+        if (!RegistryEntry.Modifiable.isModifiable(entry) || !this.valueAddHooks.hasHandlers(entry.apiKey())) {
             registry.register(key, builder.build(), registrationInfo);
             return;
         }
@@ -158,7 +158,7 @@ public final class PaperRegistryListenerManager {
 
     public <M, T extends org.bukkit.Keyed, B extends PaperRegistryBuilder<M, T>> void runFreezeListeners(final ResourceKey<? extends Registry<M>> resourceKey, final Conversions conversions) {
         final @Nullable RegistryEntryInfo<M, T> entry = PaperRegistries.getEntry(resourceKey);
-        if (!RegistryEntry.Addable.isAddable(entry) || !this.freezeHooks.hasHooks(entry.apiKey())) {
+        if (!RegistryEntry.Addable.isAddable(entry) || !this.freezeHooks.hasHandlers(entry.apiKey())) {
             return;
         }
         final RegistryEntry.Addable<M, T, B> writableEntry = RegistryEntry.Addable.asAddable(entry);
@@ -171,13 +171,13 @@ public final class PaperRegistryListenerManager {
         if (!RegistryEntry.Modifiable.isModifiable(PaperRegistries.getEntry(type.registryKey()))) {
             throw new IllegalArgumentException(type.registryKey() + " does not support RegistryEntryAddEvent");
         }
-        return this.valueAddHooks.getOrCreate(type, RegistryEntryAddEventTypeImpl::new);
+        return this.valueAddHooks.getOrCreate(type.registryKey(), RegistryEntryAddEventTypeImpl::new);
     }
 
     public <T, B extends RegistryBuilder<T>> LifecycleEventType.Prioritizable<BootstrapContext, RegistryFreezeEvent<T, B>> getRegistryFreezeEventType(final RegistryEventProvider<T, B> type) {
         if (!RegistryEntry.Addable.isAddable(PaperRegistries.getEntry(type.registryKey()))) {
             throw new IllegalArgumentException(type.registryKey() + " does not support RegistryFreezeEvent");
         }
-        return this.freezeHooks.getOrCreate(type, RegistryLifecycleEventType::new);
+        return this.freezeHooks.getOrCreate(type.registryKey(), RegistryLifecycleEventType::new);
     }
 }
diff --git a/src/main/java/io/papermc/paper/registry/event/RegistryEventMap.java b/src/main/java/io/papermc/paper/registry/event/RegistryEventMap.java
index f5ea23173dcbe491742c3dd051c147ef397307a0..60f6bd9f07e3ac7749088cf57154052588752b71 100644
--- a/src/main/java/io/papermc/paper/registry/event/RegistryEventMap.java
+++ b/src/main/java/io/papermc/paper/registry/event/RegistryEventMap.java
@@ -1,9 +1,10 @@
 package io.papermc.paper.registry.event;
 
 import io.papermc.paper.plugin.bootstrap.BootstrapContext;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEvent;
 import io.papermc.paper.plugin.lifecycle.event.LifecycleEventRunner;
+import io.papermc.paper.plugin.lifecycle.event.types.AbstractLifecycleEventType;
 import io.papermc.paper.plugin.lifecycle.event.types.LifecycleEventType;
-import io.papermc.paper.registry.RegistryBuilder;
 import io.papermc.paper.registry.RegistryKey;
 import java.util.HashMap;
 import java.util.Map;
@@ -12,7 +13,7 @@ import java.util.function.BiFunction;
 
 public final class RegistryEventMap {
 
-    private final Map<RegistryKey<?>, LifecycleEventType<BootstrapContext, ? extends RegistryEvent<?>, ?>> hooks = new HashMap<>();
+    private final Map<RegistryKey<?>, LifecycleEventType<BootstrapContext, ? extends LifecycleEvent, ?>> hooks = new HashMap<>();
     private final String name;
 
     public RegistryEventMap(final String name) {
@@ -20,25 +21,26 @@ public final class RegistryEventMap {
     }
 
     @SuppressWarnings("unchecked")
-    public <T, B extends RegistryBuilder<T>, E extends RegistryEvent<T>, ET extends LifecycleEventType<BootstrapContext, E, ?>> ET getOrCreate(final RegistryEventProvider<T, B> type, final BiFunction<? super RegistryEventProvider<T, B>, ? super String, ET> eventTypeCreator) {
+    public <T, E extends LifecycleEvent, ET extends LifecycleEventType<BootstrapContext, E, ?>> ET getOrCreate(final RegistryKey<T> registryKey, final BiFunction<? super RegistryKey<T>, ? super String, ET> eventTypeCreator) {
         final ET registerHook;
-        if (this.hooks.containsKey(type.registryKey())) {
-            registerHook = (ET) this.hooks.get(type.registryKey());
+        if (this.hooks.containsKey(registryKey)) {
+            registerHook = (ET) this.hooks.get(registryKey);
         } else {
-            registerHook = eventTypeCreator.apply(type, this.name);
+            registerHook = eventTypeCreator.apply(registryKey, this.name);
             LifecycleEventRunner.INSTANCE.addEventType(registerHook);
-            this.hooks.put(type.registryKey(), registerHook);
+            this.hooks.put(registryKey, registerHook);
         }
         return registerHook;
     }
 
     @SuppressWarnings("unchecked")
-    public <T, E extends RegistryEvent<T>> LifecycleEventType<BootstrapContext, E, ?> getHook(final RegistryKey<T> registryKey) {
+    public <T, E extends LifecycleEvent> LifecycleEventType<BootstrapContext, E, ?> getHook(final RegistryKey<T> registryKey) {
         return (LifecycleEventType<BootstrapContext, E, ?>) Objects.requireNonNull(this.hooks.get(registryKey), "No hook for " + registryKey);
     }
 
-    public boolean hasHooks(final RegistryKey<?> registryKey) {
-        return this.hooks.containsKey(registryKey);
+    public boolean hasHandlers(final RegistryKey<?> registryKey) {
+        final AbstractLifecycleEventType<?, ?, ?> type = ((AbstractLifecycleEventType<?, ?, ?>) this.hooks.get(registryKey));
+        return type != null && type.hasHandlers();
     }
 
 }
diff --git a/src/main/java/io/papermc/paper/registry/event/type/RegistryEntryAddEventTypeImpl.java b/src/main/java/io/papermc/paper/registry/event/type/RegistryEntryAddEventTypeImpl.java
index 5d709ed04e1078b631f5b9c74ca35f042251e14f..5e26175ac2aa951dee3ec764beef54a8916eaaf8 100644
--- a/src/main/java/io/papermc/paper/registry/event/type/RegistryEntryAddEventTypeImpl.java
+++ b/src/main/java/io/papermc/paper/registry/event/type/RegistryEntryAddEventTypeImpl.java
@@ -4,6 +4,7 @@ import io.papermc.paper.plugin.bootstrap.BootstrapContext;
 import io.papermc.paper.plugin.lifecycle.event.handler.LifecycleEventHandler;
 import io.papermc.paper.plugin.lifecycle.event.types.PrioritizableLifecycleEventType;
 import io.papermc.paper.registry.RegistryBuilder;
+import io.papermc.paper.registry.RegistryKey;
 import io.papermc.paper.registry.event.RegistryEntryAddEvent;
 import io.papermc.paper.registry.event.RegistryEventProvider;
 import java.util.function.Consumer;
@@ -11,8 +12,8 @@ import java.util.function.Predicate;
 
 public class RegistryEntryAddEventTypeImpl<T, B extends RegistryBuilder<T>> extends PrioritizableLifecycleEventType<BootstrapContext, RegistryEntryAddEvent<T, B>, RegistryEntryAddConfiguration<T>> implements RegistryEntryAddEventType<T, B> {
 
-    public RegistryEntryAddEventTypeImpl(final RegistryEventProvider<T, B> type, final String eventName) {
-        super(type.registryKey() + " / " + eventName, BootstrapContext.class);
+    public RegistryEntryAddEventTypeImpl(final RegistryKey<T> registryKey, final String eventName) {
+        super(registryKey + " / " + eventName, BootstrapContext.class);
     }
 
     @Override
diff --git a/src/main/java/io/papermc/paper/registry/event/type/RegistryLifecycleEventType.java b/src/main/java/io/papermc/paper/registry/event/type/RegistryLifecycleEventType.java
index dcc0f6b337840a78d38abdf2eb3f4bbd1676f58f..0c7cb29aa001923e36b9f4dae3b15fe4e518557e 100644
--- a/src/main/java/io/papermc/paper/registry/event/type/RegistryLifecycleEventType.java
+++ b/src/main/java/io/papermc/paper/registry/event/type/RegistryLifecycleEventType.java
@@ -3,12 +3,13 @@ package io.papermc.paper.registry.event.type;
 import io.papermc.paper.plugin.bootstrap.BootstrapContext;
 import io.papermc.paper.plugin.lifecycle.event.types.PrioritizableLifecycleEventType;
 import io.papermc.paper.registry.RegistryBuilder;
+import io.papermc.paper.registry.RegistryKey;
 import io.papermc.paper.registry.event.RegistryEvent;
 import io.papermc.paper.registry.event.RegistryEventProvider;
 
 public final class RegistryLifecycleEventType<T, B extends RegistryBuilder<T>, E extends RegistryEvent<T>> extends PrioritizableLifecycleEventType.Simple<BootstrapContext, E> {
 
-    public RegistryLifecycleEventType(final RegistryEventProvider<T, B> type, final String eventName) {
-        super(type.registryKey() + " / " + eventName, BootstrapContext.class);
+    public RegistryLifecycleEventType(final RegistryKey<T> registryKey, final String eventName) {
+        super(registryKey + " / " + eventName, BootstrapContext.class);
     }
 }
diff --git a/src/main/java/io/papermc/paper/tag/PaperPostFlattenTagRegistrar.java b/src/main/java/io/papermc/paper/tag/PaperPostFlattenTagRegistrar.java
new file mode 100644
index 0000000000000000000000000000000000000000..dc00d51192315b9239c48d219c5f4c8ee3975f0f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/tag/PaperPostFlattenTagRegistrar.java
@@ -0,0 +1,112 @@
+package io.papermc.paper.tag;
+
+import com.google.common.collect.Collections2;
+import com.google.common.collect.ImmutableMap;
+import io.papermc.paper.adventure.PaperAdventure;
+import io.papermc.paper.plugin.bootstrap.BootstrapContext;
+import io.papermc.paper.plugin.lifecycle.event.registrar.PaperRegistrar;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Function;
+import net.kyori.adventure.key.Key;
+import net.minecraft.resources.ResourceLocation;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public class PaperPostFlattenTagRegistrar<M> implements PostFlattenTagRegistrar, PaperRegistrar<BootstrapContext> {
+
+    public final Map<ResourceLocation, Collection<M>> tags;
+    private final Function<ResourceLocation, Optional<? extends M>> fromIdConverter;
+    private final Function<M, ResourceLocation> toIdConverter;
+
+    public PaperPostFlattenTagRegistrar(
+        final Map<ResourceLocation, Collection<M>> tags,
+        final TagEventConfig<M> config
+    ) {
+        this.tags = tags;
+        this.fromIdConverter = config.fromIdConverter();
+        this.toIdConverter = config.toIdConverter();
+    }
+
+    @Override
+    public void setCurrentContext(final @Nullable BootstrapContext owner) {
+    }
+
+    @Override
+    public Map<Key, Collection<Key>> getAllTags() {
+        final ImmutableMap.Builder<Key, Collection<Key>> tags = ImmutableMap.builder();
+        for (final Map.Entry<ResourceLocation, Collection<M>> entry : this.tags.entrySet()) {
+            final Key key = CraftNamespacedKey.fromMinecraft(entry.getKey());
+            tags.put(key, this.convert(entry.getValue()));
+        }
+        return tags.build();
+    }
+
+    private Collection<Key> convert(final Collection<M> nms) {
+        return Collections.unmodifiableCollection(
+            Collections2.transform(nms, m -> CraftNamespacedKey.fromMinecraft(this.toIdConverter.apply(m)))
+        );
+    }
+
+    private M convert(final Key key) {
+        final Optional<? extends M> optional = this.fromIdConverter.apply(PaperAdventure.asVanilla(key));
+        if (optional.isEmpty()) {
+            throw new IllegalArgumentException(key + " doesn't exist");
+        }
+        return optional.get();
+    }
+
+    private Collection<M> convertToNms(final Collection<Key> keys) {
+        return Collections2.transform(Set.copyOf(keys),this::convert);
+    }
+
+    @Override
+    public boolean hasTag(final Key tagKey) {
+        return this.tags.containsKey(PaperAdventure.asVanilla(tagKey));
+    }
+
+    private Collection<M> getNmsTag(final Key key) {
+        final Collection<M> tag = this.tags.get(PaperAdventure.asVanilla(key));
+        if (tag == null) {
+            throw new NoSuchElementException("Tag " + key + " is not present");
+        }
+        return tag;
+    }
+
+    @Override
+    public Collection<Key> getTag(final Key tagKey) {
+        return this.convert(this.getNmsTag(tagKey));
+    }
+
+    @Override
+    public void addToTag(final Key tagKey, final Key first, final Key ... rest) {
+        final Collection<M> nmsTag = new ArrayList<>(this.getNmsTag(tagKey));
+        nmsTag.add(this.convert(first));
+        for (final Key key : rest) {
+            nmsTag.add(this.convert(key));
+        }
+        this.tags.put(PaperAdventure.asVanilla(tagKey), nmsTag);
+    }
+
+    @Override
+    public void addToTag(final Key tagKey, final Iterable<Key> entries) {
+        final Collection<M> nmsTag = new ArrayList<>(this.getNmsTag(tagKey));
+        for (final Key key : entries) {
+            nmsTag.add(this.convert(key));
+        }
+        this.tags.put(PaperAdventure.asVanilla(tagKey), nmsTag);
+    }
+
+    @Override
+    public void setTag(final Key tagKey, final Collection<Key> entries) {
+        this.tags.put(PaperAdventure.asVanilla(tagKey), this.convertToNms(entries));
+    }
+}
diff --git a/src/main/java/io/papermc/paper/tag/PaperPreFlattenTagRegistrar.java b/src/main/java/io/papermc/paper/tag/PaperPreFlattenTagRegistrar.java
new file mode 100644
index 0000000000000000000000000000000000000000..4264377b756aaf1e7f338aeb7629e4905a66d3df
--- /dev/null
+++ b/src/main/java/io/papermc/paper/tag/PaperPreFlattenTagRegistrar.java
@@ -0,0 +1,118 @@
+package io.papermc.paper.tag;
+
+import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Lists;
+import io.papermc.paper.adventure.PaperAdventure;
+import io.papermc.paper.plugin.bootstrap.BootstrapContext;
+import io.papermc.paper.plugin.lifecycle.event.registrar.PaperRegistrar;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import net.kyori.adventure.key.Key;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.tags.TagLoader;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public class PaperPreFlattenTagRegistrar implements PaperRegistrar<BootstrapContext>, PreFlattenTagRegistrar {
+
+    public final Map<ResourceLocation, List<TagLoader.EntryWithSource>> tags;
+
+    private @Nullable BootstrapContext owner;
+
+    public PaperPreFlattenTagRegistrar(final Map<ResourceLocation, List<TagLoader.EntryWithSource>> tags) {
+        this.tags = new HashMap<>(tags);
+    }
+
+    @Override
+    public void setCurrentContext(final @Nullable BootstrapContext owner) {
+        this.owner = owner;
+    }
+
+    @Override
+    public Map<Key, List<io.papermc.paper.tag.TagEntry>> getAllTags() {
+        final ImmutableMap.Builder<Key, List<io.papermc.paper.tag.TagEntry>> builder = ImmutableMap.builder();
+        for (final Map.Entry<ResourceLocation, List<TagLoader.EntryWithSource>> entry : this.tags.entrySet()) {
+            final Key key = CraftNamespacedKey.fromMinecraft(entry.getKey());
+            builder.put(key, convert(entry.getValue()));
+        }
+        return builder.build();
+    }
+
+    private static List<io.papermc.paper.tag.TagEntry> convert(final List<TagLoader.EntryWithSource> nmsEntries) {
+        return Collections.unmodifiableList(Lists.transform(nmsEntries, PaperPreFlattenTagRegistrar::convert));
+    }
+
+    private static io.papermc.paper.tag.TagEntry convert(final TagLoader.EntryWithSource nmsEntry) {
+        return new TagEntryImpl(CraftNamespacedKey.fromMinecraft(nmsEntry.entry().id), nmsEntry.entry().tag, nmsEntry.entry().required);
+    }
+
+    private TagLoader.EntryWithSource convert(final io.papermc.paper.tag.TagEntry entry) {
+        Preconditions.checkState(this.owner != null, "Owner is not set");
+        final ResourceLocation vanilla = PaperAdventure.asVanilla(entry.key());
+        final net.minecraft.tags.TagEntry nmsEntry;
+        if (entry.isTag()) {
+            if (entry.isRequired()) {
+                nmsEntry = net.minecraft.tags.TagEntry.tag(vanilla);
+            } else {
+                nmsEntry = net.minecraft.tags.TagEntry.optionalTag(vanilla);
+            }
+        } else {
+            if (entry.isRequired()) {
+                nmsEntry = net.minecraft.tags.TagEntry.element(vanilla);
+            } else {
+                nmsEntry = net.minecraft.tags.TagEntry.optionalElement(vanilla);
+            }
+        }
+        return new TagLoader.EntryWithSource(nmsEntry, this.owner.getPluginMeta().getDisplayName());
+    }
+
+    @Override
+    public boolean hasTag(final Key tagKey) {
+        return this.tags.containsKey(PaperAdventure.asVanilla(tagKey));
+    }
+
+    private List<TagLoader.EntryWithSource> getNmsTag(final Key key) {
+        final List<TagLoader.EntryWithSource> tag = this.tags.get(PaperAdventure.asVanilla(key));
+        if (tag == null) {
+            throw new NoSuchElementException("Tag " + key + " is not present");
+        }
+        return tag;
+    }
+
+    @Override
+    public List<TagEntry> getTag(final Key tagKey) {
+        return convert(this.getNmsTag(tagKey));
+    }
+
+    @Override
+    public void addToTag(final Key tagKey, final TagEntry first, final TagEntry... rest) {
+        final List<TagLoader.EntryWithSource> nmsTag = new ArrayList<>(this.getNmsTag(tagKey));
+        nmsTag.add(this.convert(first));
+        for (final TagEntry tagEntry : rest) {
+            nmsTag.add(this.convert(tagEntry));
+        }
+        this.tags.put(PaperAdventure.asVanilla(tagKey), nmsTag);
+    }
+
+    @Override
+    public void addToTag(final Key tagKey, final Iterable<TagEntry> entries) {
+        final List<TagLoader.EntryWithSource> nmsTag = new ArrayList<>(this.getNmsTag(tagKey));
+        for (final TagEntry tagEntry : entries) {
+            nmsTag.add(this.convert(tagEntry));
+        }
+        this.tags.put(PaperAdventure.asVanilla(tagKey), nmsTag);
+    }
+
+    @Override
+    public void setTag(final Key tagKey, final List<TagEntry> entries) {
+        this.tags.put(PaperAdventure.asVanilla(tagKey), List.copyOf(Lists.transform(entries, this::convert)));
+    }
+}
diff --git a/src/main/java/io/papermc/paper/tag/PaperTagListenerManager.java b/src/main/java/io/papermc/paper/tag/PaperTagListenerManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..8b4674c8fdef7a051d7772665b46b61e486a2917
--- /dev/null
+++ b/src/main/java/io/papermc/paper/tag/PaperTagListenerManager.java
@@ -0,0 +1,104 @@
+package io.papermc.paper.tag;
+
+import io.papermc.paper.plugin.bootstrap.BootstrapContext;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventRunner;
+import io.papermc.paper.plugin.lifecycle.event.registrar.ReloadableRegistrarEvent;
+import io.papermc.paper.plugin.lifecycle.event.types.AbstractLifecycleEventType;
+import io.papermc.paper.plugin.lifecycle.event.types.PrioritizableLifecycleEventType;
+import io.papermc.paper.registry.PaperRegistries;
+import io.papermc.paper.registry.RegistryKey;
+import io.papermc.paper.registry.event.RegistryEventMap;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import net.minecraft.core.Holder;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.tags.TagLoader;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public class PaperTagListenerManager {
+
+    public static final String PRE_FLATTEN_EVENT_NAME = "pre-flatten";
+    public static final String POST_FLATTEN_EVENT_NAME = "post-flatten";
+
+    public static final PaperTagListenerManager INSTANCE = new PaperTagListenerManager();
+
+    public final RegistryEventMap preFlatten = new RegistryEventMap(PRE_FLATTEN_EVENT_NAME);
+    public final RegistryEventMap postFlatten = new RegistryEventMap(POST_FLATTEN_EVENT_NAME);
+
+    private PaperTagListenerManager() {
+    }
+
+    public Map<ResourceLocation, List<TagLoader.EntryWithSource>> firePreFlattenEvent(
+        final Map<ResourceLocation, List<TagLoader.EntryWithSource>> initial,
+        final @Nullable TagEventConfig<?> config
+    ) {
+        if (config == null || config.preFlatten() == null || !config.preFlatten().hasHandlers()) {
+            return initial;
+        }
+        final PaperPreFlattenTagRegistrar registrar = new PaperPreFlattenTagRegistrar(initial);
+        LifecycleEventRunner.INSTANCE.callReloadableRegistrarEvent(
+            config.preFlatten(),
+            registrar,
+            BootstrapContext.class,
+            config.cause()
+        );
+        return Map.copyOf(registrar.tags);
+    }
+
+    public <M> Map<ResourceLocation, Collection<M>> firePostFlattenEvent(
+        final Map<ResourceLocation, Collection<M>> initial,
+        final @Nullable TagEventConfig<M> config
+    ) {
+        if (config == null || config.postFlatten() == null || !config.postFlatten().hasHandlers()) {
+            return initial;
+        }
+        final PaperPostFlattenTagRegistrar<M> registrar = new PaperPostFlattenTagRegistrar<>(initial, config);
+        LifecycleEventRunner.INSTANCE.callReloadableRegistrarEvent(
+            config.postFlatten(),
+            registrar,
+            BootstrapContext.class,
+            config.cause()
+        );
+        return Map.copyOf(registrar.tags);
+    }
+
+    public <M, B> @Nullable TagEventConfig<Holder<M>> createEventConfig(final Registry<M> registry, final ReloadableRegistrarEvent.Cause cause) {
+        if (PaperRegistries.getEntry(registry.key()) == null) {
+            // TODO probably should be able to modify every registry
+            return null;
+        }
+        final RegistryKey<B> registryKey = PaperRegistries.registryFromNms(registry.key());
+        @Nullable AbstractLifecycleEventType<BootstrapContext, ReloadableRegistrarEvent<PreFlattenTagRegistrar>, ?> preFlatten = null;
+        if (this.preFlatten.hasHandlers(registryKey)) {
+            preFlatten = (AbstractLifecycleEventType<BootstrapContext, ReloadableRegistrarEvent<PreFlattenTagRegistrar>, ?>) this.preFlatten.<B, ReloadableRegistrarEvent<PreFlattenTagRegistrar>>getHook(registryKey);
+        }
+        @Nullable AbstractLifecycleEventType<BootstrapContext, ReloadableRegistrarEvent<PostFlattenTagRegistrar>, ?> postFlatten = null;
+        if (this.postFlatten.hasHandlers(registryKey)) {
+            postFlatten = (AbstractLifecycleEventType<BootstrapContext, ReloadableRegistrarEvent<PostFlattenTagRegistrar>, ?>) this.postFlatten.<B, ReloadableRegistrarEvent<PostFlattenTagRegistrar>>getHook(registryKey);
+        }
+        return new TagEventConfig<>(
+            preFlatten,
+            postFlatten,
+            cause,
+            registry::getHolder,
+            h -> ((Holder.Reference<M>) h).key().location()
+        );
+    }
+
+    public PrioritizableLifecycleEventType.Simple<BootstrapContext, ReloadableRegistrarEvent<PreFlattenTagRegistrar>> getPreFlattenType(final RegistryKey<?> registryKey) {
+        return this.preFlatten.getOrCreate(registryKey, (ignored, name) -> {
+            return new PrioritizableLifecycleEventType.Simple<>(name, BootstrapContext.class);
+        });
+    }
+
+    public PrioritizableLifecycleEventType.Simple<BootstrapContext, ReloadableRegistrarEvent<PostFlattenTagRegistrar>> getPostFlattenType(final RegistryKey<?> registryKey) {
+        return this.postFlatten.getOrCreate(registryKey, (ignored, name) -> {
+            return new PrioritizableLifecycleEventType.Simple<>(name, BootstrapContext.class);
+        });
+    }
+}
diff --git a/src/main/java/io/papermc/paper/tag/TagEventConfig.java b/src/main/java/io/papermc/paper/tag/TagEventConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..46d283c0aeb3cfdd3ad0b2c8db9312eae5f1069b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/tag/TagEventConfig.java
@@ -0,0 +1,21 @@
+package io.papermc.paper.tag;
+
+import io.papermc.paper.plugin.bootstrap.BootstrapContext;
+import io.papermc.paper.plugin.lifecycle.event.registrar.ReloadableRegistrarEvent;
+import io.papermc.paper.plugin.lifecycle.event.types.AbstractLifecycleEventType;
+import java.util.Optional;
+import java.util.function.Function;
+import net.minecraft.resources.ResourceLocation;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public record TagEventConfig<M>(
+    @Nullable AbstractLifecycleEventType<BootstrapContext, ? extends ReloadableRegistrarEvent<PreFlattenTagRegistrar>, ?> preFlatten,
+    @Nullable AbstractLifecycleEventType<BootstrapContext, ? extends ReloadableRegistrarEvent<PostFlattenTagRegistrar>, ?> postFlatten,
+    ReloadableRegistrarEvent.Cause cause,
+    Function<ResourceLocation, Optional<? extends M>> fromIdConverter,
+    Function<M, ResourceLocation> toIdConverter
+) {
+}
diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index 244a19ecd0234fa1d7a6ecfea20751595688605d..ea16a1b02515a05e674ca9a99f9069582ccad873 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -303,6 +303,7 @@ public class Main {
                 }).get();
             } catch (Exception exception) {
                 Main.LOGGER.warn("Failed to load datapacks, can't proceed with server load. You can either fix your datapacks or reset to vanilla with --safeMode", exception);
+                org.apache.logging.log4j.LogManager.shutdown(); // Paper - ensure shutdown logging on exceptions
                 return;
             }
 
@@ -359,6 +360,7 @@ public class Main {
             */ // CraftBukkit end
         } catch (Exception exception1) {
             Main.LOGGER.error(LogUtils.FATAL_MARKER, "Failed to start the minecraft server", exception1);
+            org.apache.logging.log4j.LogManager.shutdown(); // Paper - ensure shutdown logging on exceptions
         }
 
     }
diff --git a/src/main/java/net/minecraft/server/ServerFunctionLibrary.java b/src/main/java/net/minecraft/server/ServerFunctionLibrary.java
index 8ae2ca2435d84fee930d2931e45ad440245cbe0f..88788294a521b2d59ef0b72be6808c33ca8e28ec 100644
--- a/src/main/java/net/minecraft/server/ServerFunctionLibrary.java
+++ b/src/main/java/net/minecraft/server/ServerFunctionLibrary.java
@@ -118,7 +118,16 @@ public class ServerFunctionLibrary implements PreparableReloadListener {
                             return null;
                         }).join());
                     this.functions = builder.build();
-                    this.tags = this.tagsLoader.build((Map<ResourceLocation, List<TagLoader.EntryWithSource>>)intermediate.getFirst());
+                    // Paper start - fire tag registrar events
+                    final io.papermc.paper.tag.TagEventConfig<CommandFunction<CommandSourceStack>> config = new io.papermc.paper.tag.TagEventConfig<>(
+                        io.papermc.paper.plugin.lifecycle.event.types.LifecycleEventTypeProviderImpl.instance().tagProvider().commandFunctionsPreFlatten(),
+                        io.papermc.paper.plugin.lifecycle.event.types.LifecycleEventTypeProviderImpl.instance().tagProvider().commandFunctionsPostFlatten(),
+                        applyExecutor instanceof net.minecraft.server.MinecraftServer ? io.papermc.paper.plugin.lifecycle.event.registrar.ReloadableRegistrarEvent.Cause.INITIAL : io.papermc.paper.plugin.lifecycle.event.registrar.ReloadableRegistrarEvent.Cause.RELOAD,
+                        this::getFunction,
+                        CommandFunction::id
+                    );
+                    this.tags = this.tagsLoader.build((Map<ResourceLocation, List<TagLoader.EntryWithSource>>)intermediate.getFirst(), config);
+                    // Paper end - fire tag registrar events
                 },
                 applyExecutor
             );
diff --git a/src/main/java/net/minecraft/tags/TagLoader.java b/src/main/java/net/minecraft/tags/TagLoader.java
index b47afb0ce8d9517ac7ee9c651c160f99d70f8a98..6a73af145e4feafe0a08706afd5b63543ff357e7 100644
--- a/src/main/java/net/minecraft/tags/TagLoader.java
+++ b/src/main/java/net/minecraft/tags/TagLoader.java
@@ -79,7 +79,10 @@ public class TagLoader<T> {
         return list.isEmpty() ? Either.right(builder.build()) : Either.left(list);
     }
 
-    public Map<ResourceLocation, Collection<T>> build(Map<ResourceLocation, List<TagLoader.EntryWithSource>> tags) {
+    // Paper start - fire tag registrar events
+    public Map<ResourceLocation, Collection<T>> build(Map<ResourceLocation, List<TagLoader.EntryWithSource>> tags, @Nullable io.papermc.paper.tag.TagEventConfig<T> eventConfig) {
+        tags = io.papermc.paper.tag.PaperTagListenerManager.INSTANCE.firePreFlattenEvent(tags, eventConfig);
+        // Paper end - fire tag registrar events
         final Map<ResourceLocation, Collection<T>> map = Maps.newHashMap();
         TagEntry.Lookup<T> lookup = new TagEntry.Lookup<T>() {
             @Nullable
@@ -107,11 +110,13 @@ public class TagLoader<T> {
                     )
                     .ifRight(resolvedEntries -> map.put(id, (Collection<T>)resolvedEntries))
         );
-        return map;
+        return io.papermc.paper.tag.PaperTagListenerManager.INSTANCE.firePostFlattenEvent(map, eventConfig); // Paper - fire tag registrar events
     }
 
-    public Map<ResourceLocation, Collection<T>> loadAndBuild(ResourceManager manager) {
-        return this.build(this.load(manager));
+    // Paper start - fire tag registrar events
+    public Map<ResourceLocation, Collection<T>> loadAndBuild(ResourceManager manager, @Nullable io.papermc.paper.tag.TagEventConfig<T> eventConfig) {
+        return this.build(this.load(manager), eventConfig);
+        // Paper end - fire tag registrar events
     }
 
     public static record EntryWithSource(TagEntry entry, String source) {
diff --git a/src/main/java/net/minecraft/tags/TagManager.java b/src/main/java/net/minecraft/tags/TagManager.java
index 7116362d798d7c28a4880c873a60507afa4673e6..febfcf79108af6b28f075d232110c8b8dfaf4382 100644
--- a/src/main/java/net/minecraft/tags/TagManager.java
+++ b/src/main/java/net/minecraft/tags/TagManager.java
@@ -39,7 +39,7 @@ public class TagManager implements PreparableReloadListener {
     ) {
         List<? extends CompletableFuture<? extends TagManager.LoadResult<?>>> list = this.registryAccess
             .registries()
-            .map(registry -> this.createLoader(manager, prepareExecutor, (RegistryAccess.RegistryEntry<?>)registry))
+            .map(registry -> this.createLoader(manager, prepareExecutor, (net.minecraft.core.RegistryAccess.RegistryEntry<?>)registry, applyExecutor instanceof net.minecraft.server.MinecraftServer ? io.papermc.paper.plugin.lifecycle.event.registrar.ReloadableRegistrarEvent.Cause.INITIAL : io.papermc.paper.plugin.lifecycle.event.registrar.ReloadableRegistrarEvent.Cause.RELOAD)) // Paper - add registrar event cause
             .toList();
         return CompletableFuture.allOf(list.toArray(CompletableFuture[]::new))
             .thenCompose(synchronizer::wait)
@@ -48,11 +48,15 @@ public class TagManager implements PreparableReloadListener {
 
     private <T> CompletableFuture<TagManager.LoadResult<T>> createLoader(
         ResourceManager resourceManager, Executor prepareExecutor, RegistryAccess.RegistryEntry<T> requirement
+        , io.papermc.paper.plugin.lifecycle.event.registrar.ReloadableRegistrarEvent.Cause cause // Paper - add registrar event cause
     ) {
         ResourceKey<? extends Registry<T>> resourceKey = requirement.key();
         Registry<T> registry = requirement.value();
         TagLoader<Holder<T>> tagLoader = new TagLoader<>(registry::getHolder, Registries.tagsDirPath(resourceKey));
-        return CompletableFuture.supplyAsync(() -> new TagManager.LoadResult<>(resourceKey, tagLoader.loadAndBuild(resourceManager)), prepareExecutor);
+        // Paper start - fire tag registrar events
+        final io.papermc.paper.tag.TagEventConfig<Holder<T>> config = io.papermc.paper.tag.PaperTagListenerManager.INSTANCE.createEventConfig(registry, cause);
+        return CompletableFuture.supplyAsync(() -> new TagManager.LoadResult<>(resourceKey, tagLoader.loadAndBuild(resourceManager, config)), prepareExecutor);
+        // Paper end - fire tag registrar events
     }
 
     public static record LoadResult<T>(ResourceKey<? extends Registry<T>> key, Map<ResourceLocation, Collection<Holder<T>>> tags) {
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index 6e1f92b45504cef0c4dcbbebf3df339ef4cad0a1..ae0f4bd639e62718611df0d198b422fda771acea 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -298,6 +298,7 @@ public class Main {
                 net.minecraft.server.Main.main(options);
             } catch (Throwable t) {
                 t.printStackTrace();
+                org.apache.logging.log4j.LogManager.shutdown(); // Paper - ensure shutdown logging on exceptions
             }
         }
     }

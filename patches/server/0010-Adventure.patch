From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Riley Park <rileysebastianpark@gmail.com>
Date: Fri, 29 Jan 2021 17:54:03 +0100
Subject: [PATCH] Adventure

== AT ==
public net.minecraft.network.chat.HoverEvent$ItemStackInfo item
public net.minecraft.network.chat.HoverEvent$ItemStackInfo count
public net.minecraft.network.chat.HoverEvent$ItemStackInfo components
public net.minecraft.network.chat.contents.TranslatableContents filterAllowedArguments(Ljava/lang/Object;)Lcom/mojang/serialization/DataResult;

Co-authored-by: zml <zml@stellardrift.ca>
Co-authored-by: Jake Potrebic <jake.m.potrebic@gmail.com>

diff --git a/src/main/java/io/papermc/paper/adventure/AdventureCodecs.java b/src/main/java/io/papermc/paper/adventure/AdventureCodecs.java
new file mode 100644
index 0000000000000000000000000000000000000000..8dcedc5f4d4453fd942787dbcb9c757274ec7715
--- /dev/null
+++ b/src/main/java/io/papermc/paper/adventure/AdventureCodecs.java
@@ -0,0 +1,446 @@
+package io.papermc.paper.adventure;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonParser;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.datafixers.util.Either;
+import com.mojang.datafixers.util.Pair;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.DataResult;
+import com.mojang.serialization.DynamicOps;
+import com.mojang.serialization.JsonOps;
+import com.mojang.serialization.MapCodec;
+import com.mojang.serialization.codecs.RecordCodecBuilder;
+import java.io.IOException;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.UUID;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import net.kyori.adventure.key.Key;
+import net.kyori.adventure.text.BlockNBTComponent;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.EntityNBTComponent;
+import net.kyori.adventure.text.KeybindComponent;
+import net.kyori.adventure.text.NBTComponent;
+import net.kyori.adventure.text.NBTComponentBuilder;
+import net.kyori.adventure.text.ScoreComponent;
+import net.kyori.adventure.text.SelectorComponent;
+import net.kyori.adventure.text.StorageNBTComponent;
+import net.kyori.adventure.text.TextComponent;
+import net.kyori.adventure.text.TranslatableComponent;
+import net.kyori.adventure.text.TranslationArgument;
+import net.kyori.adventure.text.event.ClickEvent;
+import net.kyori.adventure.text.event.DataComponentValue;
+import net.kyori.adventure.text.event.HoverEvent;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.format.Style;
+import net.kyori.adventure.text.format.TextColor;
+import net.kyori.adventure.text.format.TextDecoration;
+import net.kyori.adventure.text.serializer.plain.PlainTextComponentSerializer;
+import net.minecraft.core.UUIDUtil;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.NbtOps;
+import net.minecraft.nbt.Tag;
+import net.minecraft.nbt.TagParser;
+import net.minecraft.network.RegistryFriendlyByteBuf;
+import net.minecraft.network.chat.ComponentSerialization;
+import net.minecraft.network.chat.contents.KeybindContents;
+import net.minecraft.network.chat.contents.ScoreContents;
+import net.minecraft.network.chat.contents.TranslatableContents;
+import net.minecraft.network.codec.ByteBufCodecs;
+import net.minecraft.network.codec.StreamCodec;
+import net.minecraft.resources.RegistryOps;
+import net.minecraft.util.ExtraCodecs;
+import net.minecraft.util.StringRepresentable;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.intellij.lang.annotations.Subst;
+
+import static com.mojang.serialization.Codec.recursive;
+import static com.mojang.serialization.codecs.RecordCodecBuilder.mapCodec;
+import static java.util.function.Function.identity;
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.TranslationArgument.bool;
+import static net.kyori.adventure.text.TranslationArgument.component;
+import static net.kyori.adventure.text.TranslationArgument.numeric;
+
+@DefaultQualifier(NonNull.class)
+public final class AdventureCodecs {
+
+    public static final Codec<Component> COMPONENT_CODEC = recursive("adventure Component",  AdventureCodecs::createCodec);
+    public static final StreamCodec<RegistryFriendlyByteBuf, Component> STREAM_COMPONENT_CODEC = ByteBufCodecs.fromCodecWithRegistriesTrusted(COMPONENT_CODEC);
+
+    static final Codec<TextColor> TEXT_COLOR_CODEC = Codec.STRING.comapFlatMap(s -> {
+        if (s.startsWith("#")) {
+            @Nullable TextColor value = TextColor.fromHexString(s);
+            return value != null ? DataResult.success(value) : DataResult.error(() -> "Cannot convert " + s + " to adventure TextColor");
+        } else {
+            final @Nullable NamedTextColor value = NamedTextColor.NAMES.value(s);
+            return value != null ? DataResult.success(value) : DataResult.error(() -> "Cannot convert " + s + " to adventure NamedTextColor");
+        }
+    }, textColor -> {
+        if (textColor instanceof NamedTextColor named) {
+            return NamedTextColor.NAMES.keyOrThrow(named);
+        } else {
+            return textColor.asHexString();
+        }
+    });
+
+    static final Codec<Key> KEY_CODEC = Codec.STRING.comapFlatMap(s -> {
+        return Key.parseable(s) ? DataResult.success(Key.key(s)) : DataResult.error(() -> "Cannot convert " + s + " to adventure Key");
+    }, Key::asString);
+
+    static final Codec<ClickEvent.Action> CLICK_EVENT_ACTION_CODEC = Codec.STRING.comapFlatMap(s -> {
+        final ClickEvent.@Nullable Action value = ClickEvent.Action.NAMES.value(s);
+        return value != null ? DataResult.success(value) : DataResult.error(() -> "Cannot convert " + s + " to adventure ClickEvent$Action");
+    }, ClickEvent.Action.NAMES::keyOrThrow);
+    static final Codec<ClickEvent> CLICK_EVENT_CODEC = RecordCodecBuilder.create((instance) -> {
+        return instance.group(
+            CLICK_EVENT_ACTION_CODEC.fieldOf("action").forGetter(ClickEvent::action),
+            Codec.STRING.fieldOf("value").forGetter(ClickEvent::value)
+        ).apply(instance, ClickEvent::clickEvent);
+    });
+
+    static Codec<HoverEvent.ShowEntity> showEntityCodec(final Codec<Component> componentCodec) {
+        return RecordCodecBuilder.create((instance) -> {
+            return instance.group(
+                KEY_CODEC.fieldOf("type").forGetter(HoverEvent.ShowEntity::type),
+                UUIDUtil.LENIENT_CODEC.fieldOf("id").forGetter(HoverEvent.ShowEntity::id),
+                componentCodec.lenientOptionalFieldOf("name").forGetter(he -> Optional.ofNullable(he.name()))
+            ).apply(instance, (key, uuid, component) -> {
+                return HoverEvent.ShowEntity.showEntity(key, uuid, component.orElse(null));
+            });
+        });
+    }
+
+    static Codec<HoverEvent.ShowItem> showItemCodec(final Codec<Component> componentCodec) {
+        return net.minecraft.network.chat.HoverEvent.ItemStackInfo.CODEC.xmap(isi -> {
+            @Subst("key") final String typeKey = isi.item.unwrapKey().orElseThrow().location().toString();
+            return HoverEvent.ShowItem.showItem(Key.key(typeKey), isi.count, PaperAdventure.asAdventure(isi.getItemStack().getComponentsPatch()));
+        }, si -> {
+            final Item itemType = BuiltInRegistries.ITEM.get(PaperAdventure.asVanilla(si.item()));
+            final Map<Key, DataComponentValue> dataComponentsMap = si.dataComponents();
+            final ItemStack stack = new ItemStack(BuiltInRegistries.ITEM.wrapAsHolder(itemType), si.count(), PaperAdventure.asVanilla(dataComponentsMap));
+            return new net.minecraft.network.chat.HoverEvent.ItemStackInfo(stack);
+        });
+    }
+
+    static final HoverEventType<HoverEvent.ShowEntity> SHOW_ENTITY_HOVER_EVENT_TYPE = new HoverEventType<>(AdventureCodecs::showEntityCodec, HoverEvent.Action.SHOW_ENTITY, "show_entity", AdventureCodecs::legacyDeserializeEntity);
+    static final HoverEventType<HoverEvent.ShowItem> SHOW_ITEM_HOVER_EVENT_TYPE = new HoverEventType<>(AdventureCodecs::showItemCodec, HoverEvent.Action.SHOW_ITEM, "show_item", AdventureCodecs::legacyDeserializeItem);
+    static final HoverEventType<Component> SHOW_TEXT_HOVER_EVENT_TYPE = new HoverEventType<>(identity(), HoverEvent.Action.SHOW_TEXT, "show_text", (component, registryOps, codec) -> DataResult.success(component));
+    static final Codec<HoverEventType<?>> HOVER_EVENT_TYPE_CODEC = StringRepresentable.fromValues(() -> new HoverEventType<?>[]{ SHOW_ENTITY_HOVER_EVENT_TYPE, SHOW_ITEM_HOVER_EVENT_TYPE, SHOW_TEXT_HOVER_EVENT_TYPE });
+
+    static DataResult<HoverEvent.ShowEntity> legacyDeserializeEntity(final Component component, final @Nullable RegistryOps<?> ops, final Codec<Component> componentCodec) {
+        try {
+            final CompoundTag tag = TagParser.parseTag(PlainTextComponentSerializer.plainText().serialize(component));
+            final DynamicOps<JsonElement> dynamicOps = ops != null ? ops.withParent(JsonOps.INSTANCE) : JsonOps.INSTANCE;
+            final DataResult<Component> entityNameResult = componentCodec.parse(dynamicOps, JsonParser.parseString(tag.getString("name")));
+            @Subst("key") final String keyString = tag.getString("type");
+            final UUID entityUUID = UUID.fromString(tag.getString("id"));
+            return entityNameResult.map(name -> HoverEvent.ShowEntity.showEntity(Key.key(keyString), entityUUID, name));
+        } catch (final Exception ex) {
+            return DataResult.error(() -> "Failed to parse tooltip: " + ex.getMessage());
+        }
+    }
+
+    static DataResult<HoverEvent.ShowItem> legacyDeserializeItem(final Component component, final @Nullable RegistryOps<?> ops, final Codec<Component> componentCodec) {
+        try {
+            final CompoundTag tag = TagParser.parseTag(PlainTextComponentSerializer.plainText().serialize(component));
+            final DynamicOps<Tag> dynamicOps = ops != null ? ops.withParent(NbtOps.INSTANCE) : NbtOps.INSTANCE;
+            final DataResult<ItemStack> stackResult = ItemStack.CODEC.parse(dynamicOps, tag);
+            return stackResult.map(stack -> {
+                @Subst("key:value") final String location = stack.getItemHolder().unwrapKey().orElseThrow().location().toString();
+                return HoverEvent.ShowItem.showItem(Key.key(location), stack.getCount(), PaperAdventure.asAdventure(stack.getComponentsPatch()));
+            });
+        } catch (final CommandSyntaxException ex) {
+            return DataResult.error(() -> "Failed to parse item tag: " + ex.getMessage());
+        }
+    }
+
+    @FunctionalInterface
+    interface LegacyDeserializer<T> {
+        DataResult<T> apply(Component component, @Nullable RegistryOps<?> ops, Codec<Component> componentCodec);
+    }
+
+    record HoverEventType<V>(Function<Codec<Component>, MapCodec<HoverEvent<V>>> codec, String id, Function<Codec<Component>, MapCodec<HoverEvent<V>>> legacyCodec) implements StringRepresentable {
+        HoverEventType(final Function<Codec<Component>, Codec<V>> contentCodec, final HoverEvent.Action<V> action, final String id, final LegacyDeserializer<V> legacyDeserializer) {
+            this(cc -> contentCodec.apply(cc).xmap(v -> HoverEvent.hoverEvent(action, v), HoverEvent::value).fieldOf("contents"),
+                id,
+                codec -> (new Codec<HoverEvent<V>>() {
+                    public <D> DataResult<Pair<HoverEvent<V>, D>> decode(final DynamicOps<D> dynamicOps, final D object) {
+                        return codec.decode(dynamicOps, object).flatMap(pair -> {
+                            final DataResult<V> dataResult;
+                            if (dynamicOps instanceof final RegistryOps<D> registryOps) {
+                                dataResult = legacyDeserializer.apply(pair.getFirst(), registryOps, codec);
+                            } else {
+                                dataResult = legacyDeserializer.apply(pair.getFirst(), null, codec);
+                            }
+
+                            return dataResult.map(value -> Pair.of(HoverEvent.hoverEvent(action, value), pair.getSecond()));
+                        });
+                    }
+
+                    public <D> DataResult<D> encode(final HoverEvent<V> hoverEvent, final DynamicOps<D> dynamicOps, final D object) {
+                        return DataResult.error(() -> "Can't encode in legacy format");
+                    }
+                }).fieldOf("value")
+            );
+        }
+        @Override
+        public String getSerializedName() {
+            return this.id;
+        }
+    }
+
+    private static final Function<HoverEvent<?>, HoverEventType<?>> GET_HOVER_EVENT_TYPE = he -> {
+        if (he.action() == HoverEvent.Action.SHOW_ENTITY) {
+            return SHOW_ENTITY_HOVER_EVENT_TYPE;
+        } else if (he.action() == HoverEvent.Action.SHOW_ITEM) {
+            return SHOW_ITEM_HOVER_EVENT_TYPE;
+        } else if (he.action() == HoverEvent.Action.SHOW_TEXT) {
+            return SHOW_TEXT_HOVER_EVENT_TYPE;
+        } else {
+            throw new IllegalStateException();
+        }
+    };
+    static final Codec<HoverEvent<?>> HOVER_EVENT_CODEC = Codec.withAlternative(
+        HOVER_EVENT_TYPE_CODEC.<HoverEvent<?>>dispatchMap("action", GET_HOVER_EVENT_TYPE, het -> het.codec.apply(COMPONENT_CODEC)).codec(),
+        HOVER_EVENT_TYPE_CODEC.<HoverEvent<?>>dispatchMap("action", GET_HOVER_EVENT_TYPE, het -> het.legacyCodec.apply(COMPONENT_CODEC)).codec()
+    );
+
+    public static final MapCodec<Style> STYLE_MAP_CODEC = mapCodec((instance) -> {
+        return instance.group(
+            TEXT_COLOR_CODEC.optionalFieldOf("color").forGetter(nullableGetter(Style::color)),
+            Codec.BOOL.optionalFieldOf("bold").forGetter(decorationGetter(TextDecoration.BOLD)),
+            Codec.BOOL.optionalFieldOf("italic").forGetter(decorationGetter(TextDecoration.ITALIC)),
+            Codec.BOOL.optionalFieldOf("underlined").forGetter(decorationGetter(TextDecoration.UNDERLINED)),
+            Codec.BOOL.optionalFieldOf("strikethrough").forGetter(decorationGetter(TextDecoration.STRIKETHROUGH)),
+            Codec.BOOL.optionalFieldOf("obfuscated").forGetter(decorationGetter(TextDecoration.OBFUSCATED)),
+            CLICK_EVENT_CODEC.optionalFieldOf("clickEvent").forGetter(nullableGetter(Style::clickEvent)),
+            HOVER_EVENT_CODEC.optionalFieldOf("hoverEvent").forGetter(nullableGetter(Style::hoverEvent)),
+            Codec.STRING.optionalFieldOf("insertion").forGetter(nullableGetter(Style::insertion)),
+            KEY_CODEC.optionalFieldOf("font").forGetter(nullableGetter(Style::font))
+        ).apply(instance, (textColor, bold, italic, underlined, strikethrough, obfuscated, clickEvent, hoverEvent, insertion, font) -> {
+            return Style.style(builder -> {
+                textColor.ifPresent(builder::color);
+                bold.ifPresent(styleBooleanConsumer(builder, TextDecoration.BOLD));
+                italic.ifPresent(styleBooleanConsumer(builder, TextDecoration.ITALIC));
+                underlined.ifPresent(styleBooleanConsumer(builder, TextDecoration.UNDERLINED));
+                strikethrough.ifPresent(styleBooleanConsumer(builder, TextDecoration.STRIKETHROUGH));
+                obfuscated.ifPresent(styleBooleanConsumer(builder, TextDecoration.OBFUSCATED));
+                clickEvent.ifPresent(builder::clickEvent);
+                hoverEvent.ifPresent(builder::hoverEvent);
+                insertion.ifPresent(builder::insertion);
+                font.ifPresent(builder::font);
+            });
+        });
+    });
+    static Consumer<Boolean> styleBooleanConsumer(final Style.Builder builder, final TextDecoration decoration) {
+        return b -> builder.decoration(decoration, b);
+    }
+
+    static Function<Style, Optional<Boolean>> decorationGetter(final TextDecoration decoration) {
+        return style -> Optional.ofNullable(style.decoration(decoration) == TextDecoration.State.NOT_SET ? null : style.decoration(decoration) == TextDecoration.State.TRUE);
+    }
+
+    static <R, T> Function<R, Optional<T>> nullableGetter(final Function<R, @Nullable T> getter) {
+        return style -> Optional.ofNullable(getter.apply(style));
+    }
+
+    static final MapCodec<TextComponent> TEXT_COMPONENT_MAP_CODEC = mapCodec((instance) -> {
+        return instance.group(Codec.STRING.fieldOf("text").forGetter(TextComponent::content)).apply(instance, Component::text);
+    });
+    static final Codec<Object> PRIMITIVE_ARG_CODEC = ExtraCodecs.JAVA.validate(TranslatableContents::filterAllowedArguments);
+    static final Codec<TranslationArgument> ARG_CODEC = Codec.either(PRIMITIVE_ARG_CODEC, COMPONENT_CODEC).flatXmap((primitiveOrComponent) -> {
+        return primitiveOrComponent.map(o -> {
+            final TranslationArgument arg;
+            if (o instanceof String s) {
+                arg = component(text(s));
+            } else if (o instanceof Boolean bool) {
+                arg = bool(bool);
+            } else if (o instanceof Number num) {
+                arg = numeric(num);
+            } else {
+                return DataResult.error(() -> o + " is not a valid translation argument primitive");
+            }
+            return DataResult.success(arg);
+        }, component -> DataResult.success(component(component)));
+    }, translationArgument -> {
+        if (translationArgument.value() instanceof Number || translationArgument.value() instanceof Boolean) {
+            return DataResult.success(Either.left(translationArgument.value()));
+        }
+        final Component component = translationArgument.asComponent();
+        final @Nullable String collapsed = tryCollapseToString(component);
+        if (collapsed != null) {
+            return DataResult.success(Either.left(collapsed)); // attempt to collapse all text components to strings
+        }
+        return DataResult.success(Either.right(component));
+    });
+    static final MapCodec<TranslatableComponent> TRANSLATABLE_COMPONENT_MAP_CODEC = mapCodec((instance) -> {
+        return instance.group(
+            Codec.STRING.fieldOf("translate").forGetter(TranslatableComponent::key),
+            Codec.STRING.lenientOptionalFieldOf("fallback").forGetter(nullableGetter(TranslatableComponent::fallback)),
+            ARG_CODEC.listOf().optionalFieldOf("with").forGetter(c -> c.arguments().isEmpty() ? Optional.empty() : Optional.of(c.arguments()))
+        ).apply(instance, (key, fallback, components) -> {
+            return Component.translatable(key, components.orElse(Collections.emptyList())).fallback(fallback.orElse(null));
+        });
+    });
+
+    static final MapCodec<KeybindComponent> KEYBIND_COMPONENT_MAP_CODEC = KeybindContents.CODEC.xmap(k -> Component.keybind(k.getName()), k -> new KeybindContents(k.keybind()));
+    static final MapCodec<ScoreComponent> SCORE_COMPONENT_INNER_MAP_CODEC = ScoreContents.INNER_CODEC.xmap(s -> Component.score(s.getName(), s.getObjective()), s -> new ScoreContents(s.name(), s.objective()));
+    static final MapCodec<ScoreComponent> SCORE_COMPONENT_MAP_CODEC = SCORE_COMPONENT_INNER_MAP_CODEC.fieldOf("score");
+    static final MapCodec<SelectorComponent> SELECTOR_COMPONENT_MAP_CODEC = mapCodec((instance) -> {
+        return instance.group(
+            Codec.STRING.fieldOf("selector").forGetter(SelectorComponent::pattern),
+            COMPONENT_CODEC.optionalFieldOf("separator").forGetter(nullableGetter(SelectorComponent::separator))
+        ).apply(instance, (selector, component) -> Component.selector(selector, component.orElse(null)));
+    });
+
+    interface NbtComponentDataSource {
+        NBTComponentBuilder<?, ?> builder();
+
+        DataSourceType<?> type();
+    }
+
+    record StorageDataSource(Key storage) implements NbtComponentDataSource {
+        @Override
+        public NBTComponentBuilder<?, ?> builder() {
+            return Component.storageNBT().storage(this.storage());
+        }
+
+        @Override
+        public DataSourceType<?> type() {
+            return STORAGE_DATA_SOURCE_TYPE;
+        }
+    }
+
+    record BlockDataSource(String posPattern) implements NbtComponentDataSource {
+        @Override
+        public NBTComponentBuilder<?, ?> builder() {
+            return Component.blockNBT().pos(BlockNBTComponent.Pos.fromString(this.posPattern));
+        }
+
+        @Override
+        public DataSourceType<?> type() {
+            return BLOCK_DATA_SOURCE_TYPE;
+        }
+    }
+
+    record EntityDataSource(String selectorPattern) implements NbtComponentDataSource {
+        @Override
+        public NBTComponentBuilder<?, ?> builder() {
+            return Component.entityNBT().selector(this.selectorPattern());
+        }
+
+        @Override
+        public DataSourceType<?> type() {
+            return ENTITY_DATA_SOURCE_TYPE;
+        }
+    }
+
+    static final DataSourceType<StorageDataSource> STORAGE_DATA_SOURCE_TYPE = new DataSourceType<>(mapCodec((instance) -> instance.group(KEY_CODEC.fieldOf("storage").forGetter(StorageDataSource::storage)).apply(instance, StorageDataSource::new)), "storage");
+    static final DataSourceType<BlockDataSource> BLOCK_DATA_SOURCE_TYPE = new DataSourceType<>(mapCodec((instance) -> instance.group(Codec.STRING.fieldOf("block").forGetter(BlockDataSource::posPattern)).apply(instance, BlockDataSource::new)), "block");
+    static final DataSourceType<EntityDataSource> ENTITY_DATA_SOURCE_TYPE = new DataSourceType<>(mapCodec((instance) -> instance.group(Codec.STRING.fieldOf("entity").forGetter(EntityDataSource::selectorPattern)).apply(instance, EntityDataSource::new)), "entity");
+
+    static final MapCodec<NbtComponentDataSource> NBT_COMPONENT_DATA_SOURCE_CODEC = ComponentSerialization.createLegacyComponentMatcher(new DataSourceType<?>[]{ENTITY_DATA_SOURCE_TYPE, BLOCK_DATA_SOURCE_TYPE, STORAGE_DATA_SOURCE_TYPE}, DataSourceType::codec, NbtComponentDataSource::type, "source");
+
+    record DataSourceType<D extends NbtComponentDataSource>(MapCodec<D> codec, String id) implements StringRepresentable {
+        @Override
+        public String getSerializedName() {
+            return this.id();
+        }
+    }
+
+    static final MapCodec<NBTComponent<?, ?>> NBT_COMPONENT_MAP_CODEC = mapCodec((instance) -> {
+        return instance.group(
+            Codec.STRING.fieldOf("nbt").forGetter(NBTComponent::nbtPath),
+            Codec.BOOL.lenientOptionalFieldOf("interpret", false).forGetter(NBTComponent::interpret),
+            COMPONENT_CODEC.lenientOptionalFieldOf("separator").forGetter(nullableGetter(NBTComponent::separator)),
+            NBT_COMPONENT_DATA_SOURCE_CODEC.forGetter(nbtComponent -> {
+                if (nbtComponent instanceof final EntityNBTComponent entityNBTComponent) {
+                    return new EntityDataSource(entityNBTComponent.selector());
+                } else if (nbtComponent instanceof final BlockNBTComponent blockNBTComponent) {
+                    return new BlockDataSource(blockNBTComponent.pos().asString());
+                } else if (nbtComponent instanceof final StorageNBTComponent storageNBTComponent) {
+                    return new StorageDataSource(storageNBTComponent.storage());
+                } else {
+                    throw new IllegalArgumentException(nbtComponent + " isn't a valid nbt component");
+                }
+            })
+        ).apply(instance, (nbtPath, interpret, separator, dataSource) -> {
+            return dataSource.builder().nbtPath(nbtPath).interpret(interpret).separator(separator.orElse(null)).build();
+        });
+    });
+
+    @SuppressWarnings("NonExtendableApiUsage")
+    record ComponentType<C extends Component>(MapCodec<C> codec, Predicate<Component> test, String id) implements StringRepresentable {
+        @Override
+        public String getSerializedName() {
+            return this.id;
+        }
+    }
+
+    static final ComponentType<TextComponent> PLAIN = new ComponentType<>(TEXT_COMPONENT_MAP_CODEC, TextComponent.class::isInstance, "text");
+    static final ComponentType<TranslatableComponent> TRANSLATABLE = new ComponentType<>(TRANSLATABLE_COMPONENT_MAP_CODEC, TranslatableComponent.class::isInstance, "translatable");
+    static final ComponentType<KeybindComponent> KEYBIND = new ComponentType<>(KEYBIND_COMPONENT_MAP_CODEC, KeybindComponent.class::isInstance, "keybind");
+    static final ComponentType<ScoreComponent> SCORE = new ComponentType<>(SCORE_COMPONENT_MAP_CODEC, ScoreComponent.class::isInstance, "score");
+    static final ComponentType<SelectorComponent> SELECTOR = new ComponentType<>(SELECTOR_COMPONENT_MAP_CODEC, SelectorComponent.class::isInstance, "selector");
+    static final ComponentType<NBTComponent<?, ?>> NBT = new ComponentType<>(NBT_COMPONENT_MAP_CODEC, NBTComponent.class::isInstance, "nbt");
+
+    static Codec<Component> createCodec(final Codec<Component> selfCodec) {
+        final ComponentType<?>[] types = new ComponentType<?>[]{PLAIN, TRANSLATABLE, KEYBIND, SCORE, SELECTOR, NBT};
+        final MapCodec<Component> legacyCodec = ComponentSerialization.createLegacyComponentMatcher(types, ComponentType::codec, component -> {
+            for (final ComponentType<?> type : types) {
+                if (type.test().test(component)) {
+                    return type;
+                }
+            }
+            throw new IllegalStateException("Unexpected component type " + component);
+        }, "type");
+
+        final Codec<Component> directCodec = RecordCodecBuilder.create((instance) -> {
+            return instance.group(
+                legacyCodec.forGetter(identity()),
+                ExtraCodecs.nonEmptyList(selfCodec.listOf()).optionalFieldOf("extra", List.of()).forGetter(Component::children),
+                STYLE_MAP_CODEC.forGetter(Component::style)
+            ).apply(instance, (component, children, style) -> {
+                return component.style(style).children(children);
+            });
+        });
+
+        return Codec.either(Codec.either(Codec.STRING, ExtraCodecs.nonEmptyList(selfCodec.listOf())), directCodec).xmap((stringOrListOrComponent) -> {
+            return stringOrListOrComponent.map((stringOrList) -> stringOrList.map(Component::text, AdventureCodecs::createFromList), identity());
+        }, (text) -> {
+            final @Nullable String string = tryCollapseToString(text);
+            return string != null ? Either.left(Either.left(string)) : Either.right(text);
+        });
+    }
+
+    public static @Nullable String tryCollapseToString(final Component component) {
+        if (component instanceof final TextComponent textComponent) {
+            if (component.children().isEmpty() && component.style().isEmpty()) {
+                return textComponent.content();
+            }
+        }
+        return null;
+    }
+
+    static Component createFromList(final List<? extends Component> components) {
+        Component component = components.get(0);
+        for (int i = 1; i < components.size(); i++) {
+            component = component.append(components.get(i));
+        }
+        return component;
+    }
+
+    private AdventureCodecs() {
+    }
+}
diff --git a/src/main/java/io/papermc/paper/adventure/AdventureComponent.java b/src/main/java/io/papermc/paper/adventure/AdventureComponent.java
new file mode 100644
index 0000000000000000000000000000000000000000..c9d787f4e66f152b557229fdb1d9a3ac83a7d71f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/adventure/AdventureComponent.java
@@ -0,0 +1,88 @@
+package io.papermc.paper.adventure;
+
+import java.util.List;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.TextComponent;
+import net.kyori.adventure.text.serializer.plain.PlainTextComponentSerializer;
+import net.minecraft.network.chat.ComponentContents;
+import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.network.chat.Style;
+import net.minecraft.network.chat.contents.PlainTextContents;
+import net.minecraft.util.FormattedCharSequence;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
+import org.jetbrains.annotations.Nullable;
+
+public final class AdventureComponent implements net.minecraft.network.chat.Component {
+    final Component adventure;
+    private net.minecraft.network.chat.@MonotonicNonNull Component vanilla;
+
+    public AdventureComponent(final Component adventure) {
+        this.adventure = adventure;
+    }
+
+    public net.minecraft.network.chat.Component deepConverted() {
+        net.minecraft.network.chat.Component vanilla = this.vanilla;
+        if (vanilla == null) {
+            vanilla = PaperAdventure.WRAPPER_AWARE_SERIALIZER.serialize(this.adventure);
+            this.vanilla = vanilla;
+        }
+        return vanilla;
+    }
+
+    public net.minecraft.network.chat.@Nullable Component deepConvertedIfPresent() {
+        return this.vanilla;
+    }
+
+    @Override
+    public Style getStyle() {
+        return this.deepConverted().getStyle();
+    }
+
+    @Override
+    public ComponentContents getContents() {
+        if (this.adventure instanceof TextComponent) {
+            return PlainTextContents.create(((TextComponent) this.adventure).content());
+        } else {
+            return this.deepConverted().getContents();
+        }
+    }
+
+    @Override
+    public String getString() {
+        return PlainTextComponentSerializer.plainText().serialize(this.adventure);
+    }
+
+    @Override
+    public List<net.minecraft.network.chat.Component> getSiblings() {
+        return this.deepConverted().getSiblings();
+    }
+
+    @Override
+    public MutableComponent plainCopy() {
+        return this.deepConverted().plainCopy();
+    }
+
+    @Override
+    public MutableComponent copy() {
+        return this.deepConverted().copy();
+    }
+
+    @Override
+    public FormattedCharSequence getVisualOrderText() {
+        return this.deepConverted().getVisualOrderText();
+    }
+
+    public Component adventure$component() {
+        return this.adventure;
+    }
+
+    @Override
+    public int hashCode() {
+        return this.deepConverted().hashCode();
+    }
+
+    @Override
+    public boolean equals(final Object obj) {
+        return this.deepConverted().equals(obj);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/adventure/BossBarImplementationImpl.java b/src/main/java/io/papermc/paper/adventure/BossBarImplementationImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..23bd6d2d8fed5a3491e856f8b875456dd29f8aaf
--- /dev/null
+++ b/src/main/java/io/papermc/paper/adventure/BossBarImplementationImpl.java
@@ -0,0 +1,85 @@
+package io.papermc.paper.adventure;
+
+import com.google.common.collect.Collections2;
+import java.util.Set;
+import java.util.function.Function;
+import net.kyori.adventure.bossbar.BossBar;
+import net.kyori.adventure.bossbar.BossBarImplementation;
+import net.kyori.adventure.bossbar.BossBarViewer;
+import net.kyori.adventure.text.Component;
+import net.minecraft.network.protocol.game.ClientboundBossEventPacket;
+import net.minecraft.server.level.ServerBossEvent;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.BossEvent;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.jetbrains.annotations.NotNull;
+
+@SuppressWarnings("UnstableApiUsage")
+public final class BossBarImplementationImpl implements BossBar.Listener, BossBarImplementation {
+    private final BossBar bar;
+    private ServerBossEvent vanilla;
+
+    public BossBarImplementationImpl(final BossBar bar) {
+        this.bar = bar;
+    }
+
+    public void playerShow(final CraftPlayer player) {
+        if (this.vanilla == null) {
+            this.vanilla = new ServerBossEvent(
+                PaperAdventure.asVanilla(this.bar.name()),
+                PaperAdventure.asVanilla(this.bar.color()),
+                PaperAdventure.asVanilla(this.bar.overlay())
+            );
+            this.vanilla.adventure = this.bar;
+            this.bar.addListener(this);
+        }
+        this.vanilla.addPlayer(player.getHandle());
+    }
+
+    public void playerHide(final CraftPlayer player) {
+        if (this.vanilla != null) {
+            this.vanilla.removePlayer(player.getHandle());
+            if (this.vanilla.getPlayers().isEmpty()) {
+                this.bar.removeListener(this);
+                this.vanilla = null;
+            }
+        }
+    }
+
+    @Override
+    public void bossBarNameChanged(final @NonNull BossBar bar, final @NonNull Component oldName, final @NonNull Component newName) {
+        this.maybeBroadcast(ClientboundBossEventPacket::createUpdateNamePacket);
+    }
+
+    @Override
+    public void bossBarProgressChanged(final @NonNull BossBar bar, final float oldProgress, final float newProgress) {
+        this.maybeBroadcast(ClientboundBossEventPacket::createUpdateProgressPacket);
+    }
+
+    @Override
+    public void bossBarColorChanged(final @NonNull BossBar bar, final BossBar.@NonNull Color oldColor, final BossBar.@NonNull Color newColor) {
+        this.maybeBroadcast(ClientboundBossEventPacket::createUpdateStylePacket);
+    }
+
+    @Override
+    public void bossBarOverlayChanged(final @NonNull BossBar bar, final BossBar.@NonNull Overlay oldOverlay, final BossBar.@NonNull Overlay newOverlay) {
+        this.maybeBroadcast(ClientboundBossEventPacket::createUpdateStylePacket);
+    }
+
+    @Override
+    public void bossBarFlagsChanged(final @NonNull BossBar bar, final @NonNull Set<BossBar.Flag> flagsAdded, final @NonNull Set<BossBar.Flag> flagsRemoved) {
+        this.maybeBroadcast(ClientboundBossEventPacket::createUpdatePropertiesPacket);
+    }
+
+    @Override
+    public @NotNull Iterable<? extends BossBarViewer> viewers() {
+        return this.vanilla == null ? Set.of() : Collections2.transform(this.vanilla.getPlayers(), ServerPlayer::getBukkitEntity);
+    }
+
+    private void maybeBroadcast(final Function<BossEvent, ClientboundBossEventPacket> fn) {
+        if (this.vanilla != null) {
+            this.vanilla.broadcast(fn);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/adventure/ChatProcessor.java b/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
new file mode 100644
index 0000000000000000000000000000000000000000..69347ac0547cba3842040f89615e721b5d1ac3ca
--- /dev/null
+++ b/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
@@ -0,0 +1,376 @@
+package io.papermc.paper.adventure;
+
+import io.papermc.paper.chat.ChatRenderer;
+import io.papermc.paper.event.player.AbstractChatEvent;
+import io.papermc.paper.event.player.AsyncChatEvent;
+import io.papermc.paper.event.player.ChatEvent;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.BitSet;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+import java.util.concurrent.ExecutionException;
+import java.util.function.Function;
+import net.kyori.adventure.audience.Audience;
+import net.kyori.adventure.audience.ForwardingAudience;
+import net.kyori.adventure.key.Key;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import net.minecraft.Optionull;
+import net.minecraft.Util;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.network.chat.ChatType;
+import net.minecraft.network.chat.OutgoingChatMessage;
+import net.minecraft.network.chat.PlayerChatMessage;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.util.LazyPlayerSet;
+import org.bukkit.craftbukkit.util.Waitable;
+import org.bukkit.entity.Player;
+import org.bukkit.event.Event;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.player.AsyncPlayerChatEvent;
+import org.bukkit.event.player.PlayerChatEvent;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.intellij.lang.annotations.Subst;
+
+import static net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection;
+
+@DefaultQualifier(NonNull.class)
+public final class ChatProcessor {
+    static final ResourceKey<ChatType> PAPER_RAW = ResourceKey.create(Registries.CHAT_TYPE, new ResourceLocation(ResourceLocation.PAPER_NAMESPACE, "raw"));
+    static final String DEFAULT_LEGACY_FORMAT = "<%1$s> %2$s"; // copied from PlayerChatEvent/AsyncPlayerChatEvent
+    final MinecraftServer server;
+    final ServerPlayer player;
+    final PlayerChatMessage message;
+    final boolean async;
+    final String craftbukkit$originalMessage;
+    final Component paper$originalMessage;
+    final OutgoingChatMessage outgoing;
+
+    static final int MESSAGE_CHANGED = 1;
+    static final int FORMAT_CHANGED = 2;
+    static final int SENDER_CHANGED = 3; // Not used
+    private final BitSet flags = new BitSet(3);
+
+    public ChatProcessor(final MinecraftServer server, final ServerPlayer player, final PlayerChatMessage message, final boolean async) {
+        this.server = server;
+        this.player = player;
+        this.message = message;
+        this.async = async;
+        this.craftbukkit$originalMessage = message.unsignedContent() != null ? LegacyComponentSerializer.legacySection().serialize(PaperAdventure.asAdventure(message.unsignedContent())) : message.signedContent();
+        this.paper$originalMessage = PaperAdventure.asAdventure(this.message.decoratedContent());
+        this.outgoing = OutgoingChatMessage.create(this.message);
+    }
+
+    @SuppressWarnings("deprecated")
+    public void process() {
+        final boolean listenersOnAsyncEvent = canYouHearMe(AsyncPlayerChatEvent.getHandlerList());
+        final boolean listenersOnSyncEvent = canYouHearMe(PlayerChatEvent.getHandlerList());
+        if (listenersOnAsyncEvent || listenersOnSyncEvent) {
+            final CraftPlayer player = this.player.getBukkitEntity();
+            final AsyncPlayerChatEvent ae = new AsyncPlayerChatEvent(this.async, player, this.craftbukkit$originalMessage, new LazyPlayerSet(this.server));
+            this.post(ae);
+            if (listenersOnSyncEvent) {
+                final PlayerChatEvent se = new PlayerChatEvent(player, ae.getMessage(), ae.getFormat(), ae.getRecipients());
+                se.setCancelled(ae.isCancelled()); // propagate cancelled state
+                this.queueIfAsyncOrRunImmediately(new Waitable<Void>() {
+                    @Override
+                    protected Void evaluate() {
+                        ChatProcessor.this.post(se);
+                        return null;
+                    }
+                });
+                this.readLegacyModifications(se.getMessage(), se.getFormat(), se.getPlayer());
+                this.processModern(
+                    this.modernRenderer(se.getFormat()),
+                    this.viewersFromLegacy(se.getRecipients()),
+                    this.modernMessage(se.getMessage()),
+                    se.getPlayer(),
+                    se.isCancelled()
+                );
+            } else {
+                this.readLegacyModifications(ae.getMessage(), ae.getFormat(), ae.getPlayer());
+                this.processModern(
+                    this.modernRenderer(ae.getFormat()),
+                    this.viewersFromLegacy(ae.getRecipients()),
+                    this.modernMessage(ae.getMessage()),
+                    ae.getPlayer(),
+                    ae.isCancelled()
+                );
+            }
+        } else {
+            this.processModern(
+                defaultRenderer(),
+                new LazyChatAudienceSet(this.server),
+                this.paper$originalMessage,
+                this.player.getBukkitEntity(),
+                false
+            );
+        }
+    }
+
+    private ChatRenderer modernRenderer(final String format) {
+        if (this.flags.get(FORMAT_CHANGED)) {
+            return legacyRenderer(format);
+        } else {
+            return defaultRenderer();
+        }
+    }
+
+    private Component modernMessage(final String legacyMessage) {
+        if (this.flags.get(MESSAGE_CHANGED)) {
+            return legacySection().deserialize(legacyMessage);
+        } else {
+            return this.paper$originalMessage;
+        }
+    }
+
+    private void readLegacyModifications(final String message, final String format, final Player playerSender) {
+        this.flags.set(MESSAGE_CHANGED, !message.equals(this.craftbukkit$originalMessage));
+        this.flags.set(FORMAT_CHANGED, !format.equals(DEFAULT_LEGACY_FORMAT));
+        this.flags.set(SENDER_CHANGED, playerSender != this.player.getBukkitEntity());
+    }
+
+    private void processModern(final ChatRenderer renderer, final Set<Audience> viewers, final Component message, final Player player, final boolean cancelled) {
+        final PlayerChatMessage.AdventureView signedMessage = this.message.adventureView();
+        final AsyncChatEvent ae = new AsyncChatEvent(this.async, player, viewers, renderer, message, this.paper$originalMessage, signedMessage);
+        ae.setCancelled(cancelled); // propagate cancelled state
+        this.post(ae);
+        final boolean listenersOnSyncEvent = canYouHearMe(ChatEvent.getHandlerList());
+        if (listenersOnSyncEvent) {
+            this.queueIfAsyncOrRunImmediately(new Waitable<Void>() {
+                @Override
+                protected Void evaluate() {
+                    final ChatEvent se = new ChatEvent(player, ae.viewers(), ae.renderer(), ae.message(), ChatProcessor.this.paper$originalMessage/*, ae.usePreviewComponent()*/, signedMessage);
+                    se.setCancelled(ae.isCancelled()); // propagate cancelled state
+                    ChatProcessor.this.post(se);
+                    ChatProcessor.this.readModernModifications(se, renderer);
+                    ChatProcessor.this.complete(se);
+                    return null;
+                }
+            });
+        } else {
+            this.readModernModifications(ae, renderer);
+            this.complete(ae);
+        }
+    }
+
+    private void readModernModifications(final AbstractChatEvent chatEvent, final ChatRenderer originalRenderer) {
+        this.flags.set(MESSAGE_CHANGED, !chatEvent.message().equals(this.paper$originalMessage));
+        if (originalRenderer != chatEvent.renderer()) { // don't set to false if it hasn't changed
+            this.flags.set(FORMAT_CHANGED, true);
+        }
+    }
+
+    private void complete(final AbstractChatEvent event) {
+        if (event.isCancelled()) {
+            return;
+        }
+
+        final CraftPlayer player = ((CraftPlayer) event.getPlayer());
+        final Component displayName = displayName(player);
+        final Component message = event.message();
+        final ChatRenderer renderer = event.renderer();
+
+        final Set<Audience> viewers = event.viewers();
+        final ResourceKey<ChatType> chatTypeKey = renderer instanceof ChatRenderer.Default ? ChatType.CHAT : PAPER_RAW;
+        final ChatType.Bound chatType = ChatType.bind(chatTypeKey, this.player.level().registryAccess(), PaperAdventure.asVanilla(displayName(player)));
+
+        OutgoingChat outgoingChat = viewers instanceof LazyChatAudienceSet lazyAudienceSet && lazyAudienceSet.isLazy() ? new ServerOutgoingChat() : new ViewersOutgoingChat();
+        if (this.flags.get(FORMAT_CHANGED)) {
+            if (renderer instanceof ChatRenderer.ViewerUnaware unaware) {
+                outgoingChat.sendFormatChangedViewerUnaware(player, PaperAdventure.asVanilla(unaware.render(player, displayName, message)), viewers, chatType);
+            } else {
+                outgoingChat.sendFormatChangedViewerAware(player, displayName, message, renderer, viewers, chatType);
+            }
+        } else if (this.flags.get(MESSAGE_CHANGED)) {
+            if (!(renderer instanceof ChatRenderer.ViewerUnaware unaware)) {
+                throw new IllegalStateException("BUG: This should be a ViewerUnaware renderer at this point");
+            }
+            final Component renderedComponent = chatTypeKey == ChatType.CHAT ? message : unaware.render(player, displayName, message);
+            outgoingChat.sendMessageChanged(player, PaperAdventure.asVanilla(renderedComponent), viewers, chatType);
+        } else {
+            outgoingChat.sendOriginal(player, viewers, chatType);
+        }
+    }
+
+    interface OutgoingChat {
+        default void sendFormatChangedViewerUnaware(CraftPlayer player, net.minecraft.network.chat.Component renderedMessage, Set<Audience> viewers, ChatType.Bound chatType) {
+            this.sendMessageChanged(player, renderedMessage, viewers, chatType);
+        }
+
+        void sendFormatChangedViewerAware(CraftPlayer player, Component displayName, Component message, ChatRenderer renderer, Set<Audience> viewers, ChatType.Bound chatType);
+
+        void sendMessageChanged(CraftPlayer player, net.minecraft.network.chat.Component renderedMessage, Set<Audience> viewers, ChatType.Bound chatType);
+
+        void sendOriginal(CraftPlayer player, Set<Audience> viewers, ChatType.Bound chatType);
+    }
+
+    final class ServerOutgoingChat implements OutgoingChat {
+        @Override
+        public void sendFormatChangedViewerAware(CraftPlayer player, Component displayName, Component message, ChatRenderer renderer, Set<Audience> viewers, ChatType.Bound chatType) {
+            ChatProcessor.this.server.getPlayerList().broadcastChatMessage(ChatProcessor.this.message, ChatProcessor.this.player, chatType, viewer -> PaperAdventure.asVanilla(renderer.render(player, displayName, message, viewer)));
+        }
+
+        @Override
+        public void sendMessageChanged(CraftPlayer player, net.minecraft.network.chat.Component renderedMessage, Set<Audience> viewers, ChatType.Bound chatType) {
+            ChatProcessor.this.server.getPlayerList().broadcastChatMessage(ChatProcessor.this.message.withUnsignedContent(renderedMessage), ChatProcessor.this.player, chatType);
+        }
+
+        @Override
+        public void sendOriginal(CraftPlayer player, Set<Audience> viewers, ChatType.Bound chatType) {
+            ChatProcessor.this.server.getPlayerList().broadcastChatMessage(ChatProcessor.this.message, ChatProcessor.this.player, chatType);
+        }
+    }
+
+    final class ViewersOutgoingChat implements OutgoingChat {
+        @Override
+        public void sendFormatChangedViewerAware(CraftPlayer player, Component displayName, Component message, ChatRenderer renderer, Set<Audience> viewers, ChatType.Bound chatType) {
+            this.broadcastToViewers(viewers, chatType, v -> PaperAdventure.asVanilla(renderer.render(player, displayName, message, v)));
+        }
+
+        @Override
+        public void sendMessageChanged(CraftPlayer player, net.minecraft.network.chat.Component renderedMessage, Set<Audience> viewers, ChatType.Bound chatType) {
+            this.broadcastToViewers(viewers, chatType, $ -> renderedMessage);
+        }
+
+        @Override
+        public void sendOriginal(CraftPlayer player, Set<Audience> viewers, ChatType.Bound chatType) {
+            this.broadcastToViewers(viewers, chatType, null);
+        }
+
+        private void broadcastToViewers(Collection<Audience> viewers, final ChatType.Bound chatType, final @Nullable Function<Audience, net.minecraft.network.chat.Component> msgFunction) {
+            for (Audience viewer : viewers) {
+                if (acceptsNative(viewer)) {
+                    this.sendNative(viewer, chatType, msgFunction);
+                } else {
+                    final net.minecraft.network.chat.@Nullable Component unsigned = Optionull.map(msgFunction, f -> f.apply(viewer));
+                    final PlayerChatMessage msg = unsigned == null ? ChatProcessor.this.message : ChatProcessor.this.message.withUnsignedContent(unsigned);
+                    viewer.sendMessage(msg.adventureView(), this.adventure(chatType));
+                }
+            }
+        }
+
+        private static final Map<String, net.kyori.adventure.chat.ChatType> BUILT_IN_CHAT_TYPES = Util.make(() -> {
+            final Map<String, net.kyori.adventure.chat.ChatType> map = new HashMap<>();
+            for (final Field declaredField : net.kyori.adventure.chat.ChatType.class.getDeclaredFields()) {
+                if (Modifier.isStatic(declaredField.getModifiers()) && declaredField.getType().equals(ChatType.class)) {
+                    try {
+                        final net.kyori.adventure.chat.ChatType type = (net.kyori.adventure.chat.ChatType) declaredField.get(null);
+                        map.put(type.key().asString(), type);
+                    } catch (final ReflectiveOperationException ignore) {
+                    }
+                }
+            }
+            return map;
+        });
+
+        private net.kyori.adventure.chat.ChatType.Bound adventure(ChatType.Bound chatType) {
+            @Subst("key:value") final String stringKey = Objects.requireNonNull(
+                chatType.chatType().unwrapKey().orElseThrow().location(),
+                () -> "No key for '%s' in CHAT_TYPE registry.".formatted(chatType)
+            ).toString();
+            net.kyori.adventure.chat.@Nullable ChatType adventure = BUILT_IN_CHAT_TYPES.get(stringKey);
+            if (adventure == null) {
+                adventure = net.kyori.adventure.chat.ChatType.chatType(Key.key(stringKey));
+            }
+            return adventure.bind(
+                PaperAdventure.asAdventure(chatType.name()),
+                chatType.targetName().map(PaperAdventure::asAdventure).orElse(null)
+            );
+        }
+
+        private static boolean acceptsNative(final Audience viewer) {
+            if (viewer instanceof Player || viewer instanceof ConsoleCommandSender) {
+                return true;
+            }
+            if (viewer instanceof ForwardingAudience.Single single) {
+                return acceptsNative(single.audience());
+            }
+            return false;
+        }
+
+        private void sendNative(final Audience viewer, final ChatType.Bound chatType, final @Nullable Function<Audience, net.minecraft.network.chat.Component> msgFunction) {
+            if (viewer instanceof ConsoleCommandSender) {
+                this.sendToServer(chatType, msgFunction);
+            } else if (viewer instanceof CraftPlayer craftPlayer) {
+                craftPlayer.getHandle().sendChatMessage(ChatProcessor.this.outgoing, ChatProcessor.this.player.shouldFilterMessageTo(craftPlayer.getHandle()), chatType, Optionull.map(msgFunction, f -> f.apply(viewer)));
+            } else if (viewer instanceof ForwardingAudience.Single single) {
+                this.sendNative(single.audience(), chatType, msgFunction);
+            } else {
+                throw new IllegalStateException("Should only be a Player or Console or ForwardingAudience.Single pointing to one!");
+            }
+        }
+
+        private void sendToServer(final ChatType.Bound chatType, final @Nullable Function<Audience, net.minecraft.network.chat.Component> msgFunction) {
+            final PlayerChatMessage toConsoleMessage = msgFunction == null ? ChatProcessor.this.message : ChatProcessor.this.message.withUnsignedContent(msgFunction.apply(ChatProcessor.this.server.console));
+            ChatProcessor.this.server.logChatMessage(toConsoleMessage.decoratedContent(), chatType, ChatProcessor.this.server.getPlayerList().verifyChatTrusted(toConsoleMessage) ? null : "Not Secure");
+        }
+    }
+
+    private Set<Audience> viewersFromLegacy(final Set<Player> recipients) {
+        if (recipients instanceof LazyPlayerSet lazyPlayerSet && lazyPlayerSet.isLazy()) {
+            return new LazyChatAudienceSet(this.server);
+        }
+        final HashSet<Audience> viewers = new HashSet<>(recipients);
+        viewers.add(this.server.console);
+        return viewers;
+    }
+
+    static String legacyDisplayName(final CraftPlayer player) {
+        return player.getDisplayName();
+    }
+
+    static Component displayName(final CraftPlayer player) {
+        return player.displayName();
+    }
+
+    private static ChatRenderer.Default defaultRenderer() {
+        return (ChatRenderer.Default) ChatRenderer.defaultRenderer();
+    }
+
+    private static ChatRenderer legacyRenderer(final String format) {
+        if (DEFAULT_LEGACY_FORMAT.equals(format)) {
+            return defaultRenderer();
+        }
+        return ChatRenderer.viewerUnaware((player, sourceDisplayName, message) -> legacySection().deserialize(legacyFormat(format, player, legacySection().serialize(message))));
+    }
+
+    static String legacyFormat(final String format, Player player, String message) {
+        return String.format(format, legacyDisplayName((CraftPlayer) player), message);
+    }
+
+    private void queueIfAsyncOrRunImmediately(final Waitable<Void> waitable) {
+        if (this.async) {
+            this.server.processQueue.add(waitable);
+        } else {
+            waitable.run();
+        }
+        try {
+            waitable.get();
+        } catch (final InterruptedException e) {
+            Thread.currentThread().interrupt(); // tag, you're it
+        } catch (final ExecutionException e) {
+            throw new RuntimeException("Exception processing chat", e.getCause());
+        }
+    }
+
+    private void post(final Event event) {
+        this.server.server.getPluginManager().callEvent(event);
+    }
+
+    static boolean canYouHearMe(final HandlerList handlers) {
+        return handlers.getRegisteredListeners().length > 0;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/adventure/DisplayNames.java b/src/main/java/io/papermc/paper/adventure/DisplayNames.java
new file mode 100644
index 0000000000000000000000000000000000000000..d496a9a6ad229e42f1c44e31eafa6974b9faced5
--- /dev/null
+++ b/src/main/java/io/papermc/paper/adventure/DisplayNames.java
@@ -0,0 +1,25 @@
+package io.papermc.paper.adventure;
+
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.ChatColor;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+
+public final class DisplayNames {
+    private DisplayNames() {
+    }
+
+    public static String getLegacy(final CraftPlayer player) {
+        return getLegacy(player.getHandle());
+    }
+
+    @SuppressWarnings("deprecation") // Valid suppress due to supporting legacy display name formatting
+    public static String getLegacy(final ServerPlayer player) {
+        final String legacy = player.displayName;
+        if (legacy != null) {
+            // thank you for being worse than wet socks, Bukkit
+            return LegacyComponentSerializer.legacySection().serialize(player.adventure$displayName) + ChatColor.getLastColors(player.displayName);
+        }
+        return LegacyComponentSerializer.legacySection().serialize(player.adventure$displayName);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/adventure/ImprovedChatDecorator.java b/src/main/java/io/papermc/paper/adventure/ImprovedChatDecorator.java
new file mode 100644
index 0000000000000000000000000000000000000000..0848ad9c7a6d386f0219b75df1ae4d08ba23aa59
--- /dev/null
+++ b/src/main/java/io/papermc/paper/adventure/ImprovedChatDecorator.java
@@ -0,0 +1,55 @@
+package io.papermc.paper.adventure;
+
+import io.papermc.paper.event.player.AsyncChatCommandDecorateEvent;
+import io.papermc.paper.event.player.AsyncChatDecorateEvent;
+import java.util.concurrent.CompletableFuture;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.network.chat.ChatDecorator;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public final class ImprovedChatDecorator implements ChatDecorator {
+    private final MinecraftServer server;
+
+    public ImprovedChatDecorator(final MinecraftServer server) {
+        this.server = server;
+    }
+
+    @Override
+    public CompletableFuture<Component> decorate(final @Nullable ServerPlayer sender, final Component message) {
+        return decorate(this.server, sender, null, message);
+    }
+
+    @Override
+    public CompletableFuture<Component> decorate(final @Nullable ServerPlayer sender, final @Nullable CommandSourceStack commandSourceStack, final Component message) {
+        return decorate(this.server, sender, commandSourceStack, message);
+    }
+
+    private static CompletableFuture<Component> decorate(final MinecraftServer server, final @Nullable ServerPlayer player, final @Nullable CommandSourceStack commandSourceStack, final Component originalMessage) {
+        return CompletableFuture.supplyAsync(() -> {
+            final net.kyori.adventure.text.Component initialResult = PaperAdventure.asAdventure(originalMessage);
+
+            final @Nullable CraftPlayer craftPlayer = player == null ? null : player.getBukkitEntity();
+
+            final AsyncChatDecorateEvent event;
+            if (commandSourceStack != null) {
+                // TODO more command decorate context
+                event = new AsyncChatCommandDecorateEvent(craftPlayer, initialResult);
+            } else {
+                event = new AsyncChatDecorateEvent(craftPlayer, initialResult);
+            }
+
+            if (event.callEvent()) {
+                return PaperAdventure.asVanilla(event.result());
+            }
+
+            return originalMessage;
+        }, server.chatExecutor);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/adventure/LazyChatAudienceSet.java b/src/main/java/io/papermc/paper/adventure/LazyChatAudienceSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..2fd6c3e65354071af71c7d8ebb97b559b6e105ce
--- /dev/null
+++ b/src/main/java/io/papermc/paper/adventure/LazyChatAudienceSet.java
@@ -0,0 +1,26 @@
+package io.papermc.paper.adventure;
+
+import java.util.HashSet;
+import java.util.Set;
+import net.kyori.adventure.audience.Audience;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.util.LazyHashSet;
+import org.bukkit.craftbukkit.util.LazyPlayerSet;
+import org.bukkit.entity.Player;
+
+final class LazyChatAudienceSet extends LazyHashSet<Audience> {
+    private final MinecraftServer server;
+
+    public LazyChatAudienceSet(final MinecraftServer server) {
+        this.server = server;
+    }
+
+    @Override
+    protected Set<Audience> makeReference() {
+        final Set<Player> playerSet = LazyPlayerSet.makePlayerSet(this.server);
+        final HashSet<Audience> audiences = new HashSet<>(playerSet);
+        audiences.add(Bukkit.getConsoleSender());
+        return audiences;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/adventure/PaperAdventure.java b/src/main/java/io/papermc/paper/adventure/PaperAdventure.java
new file mode 100644
index 0000000000000000000000000000000000000000..7397918cf747bc2352bf5bb112a71e7f6844e0e0
--- /dev/null
+++ b/src/main/java/io/papermc/paper/adventure/PaperAdventure.java
@@ -0,0 +1,478 @@
+package io.papermc.paper.adventure;
+
+import com.mojang.brigadier.StringReader;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.serialization.JavaOps;
+import io.netty.util.AttributeKey;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Optional;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.BiConsumer;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.StreamSupport;
+import net.kyori.adventure.bossbar.BossBar;
+import net.kyori.adventure.inventory.Book;
+import net.kyori.adventure.key.Key;
+import net.kyori.adventure.nbt.api.BinaryTagHolder;
+import net.kyori.adventure.sound.Sound;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.TranslatableComponent;
+import net.kyori.adventure.text.TranslationArgument;
+import net.kyori.adventure.text.event.DataComponentValue;
+import net.kyori.adventure.text.event.DataComponentValueConverterRegistry;
+import net.kyori.adventure.text.flattener.ComponentFlattener;
+import net.kyori.adventure.text.format.Style;
+import net.kyori.adventure.text.format.TextColor;
+import net.kyori.adventure.text.serializer.ComponentSerializer;
+import net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;
+import net.kyori.adventure.text.serializer.plain.PlainComponentSerializer;
+import net.kyori.adventure.text.serializer.plain.PlainTextComponentSerializer;
+import net.kyori.adventure.translation.GlobalTranslator;
+import net.kyori.adventure.translation.TranslationRegistry;
+import net.kyori.adventure.translation.Translator;
+import net.kyori.adventure.util.Codec;
+import net.minecraft.ChatFormatting;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.core.Holder;
+import net.minecraft.core.component.DataComponentPatch;
+import net.minecraft.core.component.DataComponentType;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.locale.Language;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.NbtOps;
+import net.minecraft.nbt.Tag;
+import net.minecraft.nbt.TagParser;
+import net.minecraft.network.chat.ComponentUtils;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundSoundEntityPacket;
+import net.minecraft.network.protocol.game.ClientboundSoundPacket;
+import net.minecraft.resources.RegistryOps;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.network.Filterable;
+import net.minecraft.sounds.SoundEvent;
+import net.minecraft.sounds.SoundSource;
+import net.minecraft.world.BossEvent;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.component.WrittenBookContent;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftRegistry;
+import org.bukkit.craftbukkit.command.VanillaCommandWrapper;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.intellij.lang.annotations.Subst;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import static java.util.Objects.requireNonNull;
+
+public final class PaperAdventure {
+    private static final Pattern LOCALIZATION_PATTERN = Pattern.compile("%(?:(\\d+)\\$)?s");
+    public static final ComponentFlattener FLATTENER = ComponentFlattener.basic().toBuilder()
+        .complexMapper(TranslatableComponent.class, (translatable, consumer) -> {
+            if (!Language.getInstance().has(translatable.key())) {
+                for (final Translator source : GlobalTranslator.translator().sources()) {
+                    if (source instanceof TranslationRegistry registry && registry.contains(translatable.key())) {
+                        consumer.accept(GlobalTranslator.render(translatable, Locale.US));
+                        return;
+                    }
+                }
+            }
+            final @Nullable String fallback = translatable.fallback();
+            final @NotNull String translated = Language.getInstance().getOrDefault(translatable.key(), fallback != null ? fallback : translatable.key());
+
+            final Matcher matcher = LOCALIZATION_PATTERN.matcher(translated);
+            final List<TranslationArgument> args = translatable.arguments();
+            int argPosition = 0;
+            int lastIdx = 0;
+            while (matcher.find()) {
+                // append prior
+                if (lastIdx < matcher.start()) {
+                    consumer.accept(Component.text(translated.substring(lastIdx, matcher.start())));
+                }
+                lastIdx = matcher.end();
+
+                final @Nullable String argIdx = matcher.group(1);
+                // calculate argument position
+                if (argIdx != null) {
+                    try {
+                        final int idx = Integer.parseInt(argIdx) - 1;
+                        if (idx < args.size()) {
+                            consumer.accept(args.get(idx).asComponent());
+                        }
+                    } catch (final NumberFormatException ex) {
+                        // ignore, drop the format placeholder
+                    }
+                } else {
+                    final int idx = argPosition++;
+                    if (idx < args.size()) {
+                        consumer.accept(args.get(idx).asComponent());
+                    }
+                }
+            }
+
+            // append tail
+            if (lastIdx < translated.length()) {
+                consumer.accept(Component.text(translated.substring(lastIdx)));
+            }
+        })
+        .build();
+    public static final AttributeKey<Locale> LOCALE_ATTRIBUTE = AttributeKey.valueOf("adventure:locale"); // init after FLATTENER because classloading triggered here might create a logger
+    @Deprecated
+    public static final PlainComponentSerializer PLAIN = PlainComponentSerializer.builder().flattener(FLATTENER).build();
+    public static final Codec<Tag, String, CommandSyntaxException, RuntimeException> NBT_CODEC = new Codec<>() {
+        @Override
+        public @NotNull Tag decode(final @NotNull String encoded) throws CommandSyntaxException {
+            return new TagParser(new StringReader(encoded)).readValue();
+        }
+
+        @Override
+        public @NotNull String encode(final @NotNull Tag decoded) {
+            return decoded.toString();
+        }
+    };
+    public static final ComponentSerializer<Component, Component, net.minecraft.network.chat.Component> WRAPPER_AWARE_SERIALIZER = new WrapperAwareSerializer();
+
+    private PaperAdventure() {
+    }
+
+    // Key
+
+    public static ResourceLocation asVanilla(final Key key) {
+        return new ResourceLocation(key.namespace(), key.value());
+    }
+
+    public static ResourceLocation asVanillaNullable(final Key key) {
+        if (key == null) {
+            return null;
+        }
+        return asVanilla(key);
+    }
+
+    // Component
+
+    public static @NotNull Component asAdventure(@Nullable final net.minecraft.network.chat.Component component) {
+        return component == null ? Component.empty() : WRAPPER_AWARE_SERIALIZER.deserialize(component);
+    }
+
+    public static ArrayList<Component> asAdventure(final List<? extends net.minecraft.network.chat.Component> vanillas) {
+        final ArrayList<Component> adventures = new ArrayList<>(vanillas.size());
+        for (final net.minecraft.network.chat.Component vanilla : vanillas) {
+            adventures.add(asAdventure(vanilla));
+        }
+        return adventures;
+    }
+
+    public static ArrayList<Component> asAdventureFromJson(final List<String> jsonStrings) {
+        final ArrayList<Component> adventures = new ArrayList<>(jsonStrings.size());
+        for (final String json : jsonStrings) {
+            adventures.add(GsonComponentSerializer.gson().deserialize(json));
+        }
+        return adventures;
+    }
+
+    public static List<String> asJson(final List<? extends Component> adventures) {
+        final List<String> jsons = new ArrayList<>(adventures.size());
+        for (final Component component : adventures) {
+            jsons.add(GsonComponentSerializer.gson().serialize(component));
+        }
+        return jsons;
+    }
+
+    public static net.minecraft.network.chat.@NotNull Component asVanillaNullToEmpty(final @Nullable Component component) {
+        if (component == null) return net.minecraft.network.chat.CommonComponents.EMPTY;
+        return asVanilla(component);
+    }
+
+    @Contract("null -> null; !null -> !null")
+    public static net.minecraft.network.chat.Component asVanilla(final @Nullable Component component) {
+        if (component == null) return null;
+        if (true) return new AdventureComponent(component);
+        return WRAPPER_AWARE_SERIALIZER.serialize(component);
+    }
+
+    public static List<net.minecraft.network.chat.Component> asVanilla(final List<? extends Component> adventures) {
+        final List<net.minecraft.network.chat.Component> vanillas = new ArrayList<>(adventures.size());
+        for (final Component adventure : adventures) {
+            vanillas.add(asVanilla(adventure));
+        }
+        return vanillas;
+    }
+
+    public static String asJsonString(final Component component, final Locale locale) {
+        return GsonComponentSerializer.gson().serialize(translated(component, locale));
+    }
+
+    public static boolean hasAnyTranslations() {
+        return StreamSupport.stream(GlobalTranslator.translator().sources().spliterator(), false)
+            .anyMatch(t -> t.hasAnyTranslations().toBooleanOrElse(true));
+    }
+
+    private static final Map<Locale, com.mojang.serialization.Codec<Component>> LOCALIZED_CODECS = new ConcurrentHashMap<>();
+
+    public static com.mojang.serialization.Codec<Component> localizedCodec(final @Nullable Locale l) {
+        if (l == null) {
+            return AdventureCodecs.COMPONENT_CODEC;
+        }
+        return LOCALIZED_CODECS.computeIfAbsent(l, locale -> AdventureCodecs.COMPONENT_CODEC.xmap(
+            component -> component, // decode
+            component -> translated(component, locale) // encode
+        ));
+    }
+
+    public static String asPlain(final Component component, final Locale locale) {
+        return PlainTextComponentSerializer.plainText().serialize(translated(component, locale));
+    }
+
+    private static Component translated(final Component component, final Locale locale) {
+        //noinspection ConstantValue
+        return GlobalTranslator.render(
+            component,
+            // play it safe
+            locale != null
+                ? locale
+                : Locale.US
+        );
+    }
+
+    public static Component resolveWithContext(final @NotNull Component component, final @Nullable CommandSender context, final @Nullable org.bukkit.entity.Entity scoreboardSubject, final boolean bypassPermissions) throws IOException {
+        final CommandSourceStack css = context != null ? VanillaCommandWrapper.getListener(context) : null;
+        Boolean previous = null;
+        if (css != null && bypassPermissions) {
+            previous = css.bypassSelectorPermissions;
+            css.bypassSelectorPermissions = true;
+        }
+        try {
+            return asAdventure(ComponentUtils.updateForEntity(css, asVanilla(component), scoreboardSubject == null ? null : ((CraftEntity) scoreboardSubject).getHandle(), 0));
+        } catch (final CommandSyntaxException e) {
+            throw new IOException(e);
+        } finally {
+            if (css != null && previous != null) {
+                css.bypassSelectorPermissions = previous;
+            }
+        }
+    }
+
+    // BossBar
+
+    public static BossEvent.BossBarColor asVanilla(final BossBar.Color color) {
+        return switch (color) {
+            case PINK -> BossEvent.BossBarColor.PINK;
+            case BLUE -> BossEvent.BossBarColor.BLUE;
+            case RED -> BossEvent.BossBarColor.RED;
+            case GREEN -> BossEvent.BossBarColor.GREEN;
+            case YELLOW -> BossEvent.BossBarColor.YELLOW;
+            case PURPLE -> BossEvent.BossBarColor.PURPLE;
+            case WHITE -> BossEvent.BossBarColor.WHITE;
+        };
+    }
+
+    public static BossBar.Color asAdventure(final BossEvent.BossBarColor color) {
+        return switch (color) {
+            case PINK -> BossBar.Color.PINK;
+            case BLUE -> BossBar.Color.BLUE;
+            case RED -> BossBar.Color.RED;
+            case GREEN -> BossBar.Color.GREEN;
+            case YELLOW -> BossBar.Color.YELLOW;
+            case PURPLE -> BossBar.Color.PURPLE;
+            case WHITE -> BossBar.Color.WHITE;
+        };
+    }
+
+    public static BossEvent.BossBarOverlay asVanilla(final BossBar.Overlay overlay) {
+        return switch (overlay) {
+            case PROGRESS -> BossEvent.BossBarOverlay.PROGRESS;
+            case NOTCHED_6 -> BossEvent.BossBarOverlay.NOTCHED_6;
+            case NOTCHED_10 -> BossEvent.BossBarOverlay.NOTCHED_10;
+            case NOTCHED_12 -> BossEvent.BossBarOverlay.NOTCHED_12;
+            case NOTCHED_20 -> BossEvent.BossBarOverlay.NOTCHED_20;
+        };
+    }
+
+    public static BossBar.Overlay asAdventure(final BossEvent.BossBarOverlay overlay) {
+        return switch (overlay) {
+            case PROGRESS -> BossBar.Overlay.PROGRESS;
+            case NOTCHED_6 -> BossBar.Overlay.NOTCHED_6;
+            case NOTCHED_10 -> BossBar.Overlay.NOTCHED_10;
+            case NOTCHED_12 -> BossBar.Overlay.NOTCHED_12;
+            case NOTCHED_20 -> BossBar.Overlay.NOTCHED_20;
+        };
+    }
+
+    public static void setFlag(final BossBar bar, final BossBar.Flag flag, final boolean value) {
+        if (value) {
+            bar.addFlag(flag);
+        } else {
+            bar.removeFlag(flag);
+        }
+    }
+
+    // Book
+
+    public static ItemStack asItemStack(final Book book, final Locale locale) {
+        final ItemStack item = new ItemStack(net.minecraft.world.item.Items.WRITTEN_BOOK, 1);
+        item.set(DataComponents.WRITTEN_BOOK_CONTENT, new WrittenBookContent(
+            Filterable.passThrough(validateField(asPlain(book.title(), locale), WrittenBookContent.TITLE_MAX_LENGTH, "title")),
+            asPlain(book.author(), locale),
+            0,
+            book.pages().stream().map(c -> Filterable.passThrough(PaperAdventure.asVanilla(c))).toList(), // TODO should we validate legnth?
+            false
+        ));
+        return item;
+    }
+
+    private static String validateField(final String content, final int length, final String name) {
+        final int actual = content.length();
+        if (actual > length) {
+            throw new IllegalArgumentException("Field '" + name + "' has a maximum length of " + length + " but was passed '" + content + "', which was " + actual + " characters long.");
+        }
+        return content;
+    }
+
+    // Sounds
+
+    public static SoundSource asVanilla(final Sound.Source source) {
+        return switch (source) {
+            case MASTER -> SoundSource.MASTER;
+            case MUSIC -> SoundSource.MUSIC;
+            case RECORD -> SoundSource.RECORDS;
+            case WEATHER -> SoundSource.WEATHER;
+            case BLOCK -> SoundSource.BLOCKS;
+            case HOSTILE -> SoundSource.HOSTILE;
+            case NEUTRAL -> SoundSource.NEUTRAL;
+            case PLAYER -> SoundSource.PLAYERS;
+            case AMBIENT -> SoundSource.AMBIENT;
+            case VOICE -> SoundSource.VOICE;
+        };
+    }
+
+    public static @Nullable SoundSource asVanillaNullable(final Sound.@Nullable Source source) {
+        if (source == null) {
+            return null;
+        }
+        return asVanilla(source);
+    }
+
+    public static Packet<?> asSoundPacket(final Sound sound, final double x, final double y, final double z, final long seed, @Nullable BiConsumer<Packet<?>, Float> packetConsumer) {
+        final ResourceLocation name = asVanilla(sound.name());
+        final Optional<SoundEvent> soundEvent = BuiltInRegistries.SOUND_EVENT.getOptional(name);
+        final SoundSource source = asVanilla(sound.source());
+
+        final Holder<SoundEvent> soundEventHolder = soundEvent.map(BuiltInRegistries.SOUND_EVENT::wrapAsHolder).orElseGet(() -> Holder.direct(SoundEvent.createVariableRangeEvent(name)));
+        final Packet<?> packet = new ClientboundSoundPacket(soundEventHolder, source, x, y, z, sound.volume(), sound.pitch(), seed);
+        if (packetConsumer != null) {
+            packetConsumer.accept(packet, soundEventHolder.value().getRange(sound.volume()));
+        }
+        return packet;
+    }
+
+    public static Packet<?> asSoundPacket(final Sound sound, final Entity emitter, final long seed, @Nullable BiConsumer<Packet<?>, Float> packetConsumer) {
+        final ResourceLocation name = asVanilla(sound.name());
+        final Optional<SoundEvent> soundEvent = BuiltInRegistries.SOUND_EVENT.getOptional(name);
+        final SoundSource source = asVanilla(sound.source());
+
+        final Holder<SoundEvent> soundEventHolder = soundEvent.map(BuiltInRegistries.SOUND_EVENT::wrapAsHolder).orElseGet(() -> Holder.direct(SoundEvent.createVariableRangeEvent(name)));
+        final Packet<?> packet = new ClientboundSoundEntityPacket(soundEventHolder, source, emitter, sound.volume(), sound.pitch(), seed);
+        if (packetConsumer != null) {
+            packetConsumer.accept(packet, soundEventHolder.value().getRange(sound.volume()));
+        }
+        return packet;
+    }
+
+    // NBT
+
+    @SuppressWarnings({"rawtypes", "unchecked"})
+    public static Map<Key, ? extends DataComponentValue> asAdventure(
+        final DataComponentPatch patch
+    ) {
+        if (patch.isEmpty()) {
+            return Collections.emptyMap();
+        }
+        final Map<Key, DataComponentValue> map = new HashMap<>();
+        for (final Map.Entry<DataComponentType<?>, Optional<?>> entry : patch.entrySet()) {
+            if (entry.getKey().isTransient()) continue;
+            @Subst("key:value") final String typeKey = requireNonNull(BuiltInRegistries.DATA_COMPONENT_TYPE.getKey(entry.getKey())).toString();
+            if (entry.getValue().isEmpty()) {
+                   map.put(Key.key(typeKey), DataComponentValue.removed());
+            } else {
+                map.put(Key.key(typeKey), new DataComponentValueImpl(entry.getKey().codec(), entry.getValue().get()));
+            }
+        }
+        return map;
+    }
+
+    @SuppressWarnings({"rawtypes", "unchecked"})
+    public static DataComponentPatch asVanilla(final Map<? extends Key, ? extends DataComponentValue> map) {
+        if (map.isEmpty()) {
+            return DataComponentPatch.EMPTY;
+        }
+        final DataComponentPatch.Builder builder = DataComponentPatch.builder();
+        map.forEach((key, dataComponentValue) -> {
+            final DataComponentType<?> type = requireNonNull(BuiltInRegistries.DATA_COMPONENT_TYPE.get(asVanilla(key)));
+            if (dataComponentValue instanceof DataComponentValue.Removed) {
+                builder.remove(type);
+                return;
+            }
+            final DataComponentValueImpl<?> converted = DataComponentValueConverterRegistry.convert(DataComponentValueImpl.class, key, dataComponentValue);
+            builder.set((DataComponentType) type, (Object) converted.value());
+        });
+        return builder.build();
+    }
+
+    public record DataComponentValueImpl<T>(com.mojang.serialization.Codec<T> codec, T value) implements DataComponentValue.TagSerializable {
+
+        @Override
+        public @NotNull BinaryTagHolder asBinaryTag() {
+            return BinaryTagHolder.encode(this.codec.encodeStart(CraftRegistry.getMinecraftRegistry().createSerializationContext(NbtOps.INSTANCE), this.value).getOrThrow(IllegalArgumentException::new), NBT_CODEC);
+        }
+    }
+
+    public static @Nullable BinaryTagHolder asBinaryTagHolder(final @Nullable CompoundTag tag) {
+        if (tag == null) {
+            return null;
+        }
+        return BinaryTagHolder.encode(tag, NBT_CODEC);
+    }
+
+    // Colors
+
+    public static @NotNull TextColor asAdventure(final ChatFormatting formatting) {
+        final Integer color = formatting.getColor();
+        if (color == null) {
+            throw new IllegalArgumentException("Not a valid color");
+        }
+        return TextColor.color(color);
+    }
+
+    public static @Nullable ChatFormatting asVanilla(final TextColor color) {
+        return ChatFormatting.getByHexValue(color.value());
+    }
+
+    // Style
+
+    public static net.minecraft.network.chat.Style asVanilla(final Style style) {
+        final RegistryOps<Object> ops = CraftRegistry.getMinecraftRegistry().createSerializationContext(JavaOps.INSTANCE);
+        final Object encoded = AdventureCodecs.STYLE_MAP_CODEC.codec()
+            .encodeStart(ops, style).getOrThrow(IllegalStateException::new);
+
+        return net.minecraft.network.chat.Style.Serializer.CODEC
+            .parse(ops, encoded).getOrThrow(IllegalStateException::new);
+    }
+
+    public static Style asAdventure(final net.minecraft.network.chat.Style style) {
+        final RegistryOps<Object> ops = CraftRegistry.getMinecraftRegistry().createSerializationContext(JavaOps.INSTANCE);
+        final Object encoded = net.minecraft.network.chat.Style.Serializer.CODEC
+            .encodeStart(ops, style).getOrThrow(IllegalStateException::new);
+
+        return AdventureCodecs.STYLE_MAP_CODEC.codec()
+            .parse(ops, encoded).getOrThrow(IllegalStateException::new);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/adventure/WrapperAwareSerializer.java b/src/main/java/io/papermc/paper/adventure/WrapperAwareSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..c786ddf0ef19757011452204fd11d24541c39d9e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/adventure/WrapperAwareSerializer.java
@@ -0,0 +1,34 @@
+package io.papermc.paper.adventure;
+
+import com.mojang.datafixers.util.Pair;
+import com.mojang.serialization.JavaOps;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.ComponentSerializer;
+import net.minecraft.network.chat.ComponentSerialization;
+import net.minecraft.resources.RegistryOps;
+import org.bukkit.craftbukkit.CraftRegistry;
+
+final class WrapperAwareSerializer implements ComponentSerializer<Component, Component, net.minecraft.network.chat.Component> {
+    @Override
+    public Component deserialize(final net.minecraft.network.chat.Component input) {
+        if (input instanceof AdventureComponent) {
+            return ((AdventureComponent) input).adventure;
+        }
+        final RegistryOps<Object> ops = CraftRegistry.getMinecraftRegistry().createSerializationContext(JavaOps.INSTANCE);
+        final Object obj = ComponentSerialization.CODEC.encodeStart(ops, input)
+            .getOrThrow(s -> new RuntimeException("Failed to encode Minecraft Component: " + input + "; " + s));
+        final Pair<Component, Object> converted = AdventureCodecs.COMPONENT_CODEC.decode(ops, obj)
+            .getOrThrow(s -> new RuntimeException("Failed to decode to adventure Component: " + obj + "; " + s));
+        return converted.getFirst();
+    }
+
+    @Override
+    public net.minecraft.network.chat.Component serialize(final Component component) {
+        final RegistryOps<Object> ops = CraftRegistry.getMinecraftRegistry().createSerializationContext(JavaOps.INSTANCE);
+        final Object obj = AdventureCodecs.COMPONENT_CODEC.encodeStart(ops, component)
+            .getOrThrow(s -> new RuntimeException("Failed to encode adventure Component: " + component + "; " + s));
+        final Pair<net.minecraft.network.chat.Component, Object> converted = ComponentSerialization.CODEC.decode(ops, obj)
+            .getOrThrow(s -> new RuntimeException("Failed to decode to Minecraft Component: " + obj + "; " + s));
+        return converted.getFirst();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/adventure/providers/BossBarImplementationProvider.java b/src/main/java/io/papermc/paper/adventure/providers/BossBarImplementationProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..2ee72fe7cb56e70404b8c86f0c9578750a45af03
--- /dev/null
+++ b/src/main/java/io/papermc/paper/adventure/providers/BossBarImplementationProvider.java
@@ -0,0 +1,14 @@
+package io.papermc.paper.adventure.providers;
+
+import io.papermc.paper.adventure.BossBarImplementationImpl;
+import net.kyori.adventure.bossbar.BossBar;
+import net.kyori.adventure.bossbar.BossBarImplementation;
+import org.jetbrains.annotations.NotNull;
+
+@SuppressWarnings("UnstableApiUsage") // permitted provider
+public class BossBarImplementationProvider implements BossBarImplementation.Provider {
+    @Override
+    public @NotNull BossBarImplementation create(final @NotNull BossBar bar) {
+        return new BossBarImplementationImpl(bar);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/adventure/providers/ClickCallbackProviderImpl.java b/src/main/java/io/papermc/paper/adventure/providers/ClickCallbackProviderImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..23432eea862c6df716d7726a32da3a0612a3fb77
--- /dev/null
+++ b/src/main/java/io/papermc/paper/adventure/providers/ClickCallbackProviderImpl.java
@@ -0,0 +1,96 @@
+package io.papermc.paper.adventure.providers;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+import net.kyori.adventure.audience.Audience;
+import net.kyori.adventure.text.event.ClickCallback;
+import net.kyori.adventure.text.event.ClickEvent;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+@SuppressWarnings("UnstableApiUsage") // permitted provider
+public class ClickCallbackProviderImpl implements ClickCallback.Provider {
+
+    public static final CallbackManager CALLBACK_MANAGER = new CallbackManager();
+
+    @Override
+    public @NotNull ClickEvent create(final @NotNull ClickCallback<Audience> callback, final ClickCallback.@NotNull Options options) {
+        return ClickEvent.runCommand("/paper:callback " + CALLBACK_MANAGER.addCallback(callback, options));
+    }
+
+    public static final class CallbackManager {
+
+        private final Map<UUID, StoredCallback> callbacks = new HashMap<>();
+        private final Queue<StoredCallback> queue = new ConcurrentLinkedQueue<>();
+
+        private CallbackManager() {
+        }
+
+        public UUID addCallback(final @NotNull ClickCallback<Audience> callback, final ClickCallback.@NotNull Options options) {
+            final UUID id = UUID.randomUUID();
+            this.queue.add(new StoredCallback(callback, options, id));
+            return id;
+        }
+
+        public void handleQueue(final int currentTick) {
+            // Evict expired entries
+            if (currentTick % 100 == 0) {
+                this.callbacks.values().removeIf(callback -> !callback.valid());
+            }
+
+            // Add entries from queue
+            StoredCallback callback;
+            while ((callback = this.queue.poll()) != null) {
+                this.callbacks.put(callback.id(), callback);
+            }
+        }
+
+        public void runCallback(final @NotNull Audience audience, final UUID id) {
+            final StoredCallback callback = this.callbacks.get(id);
+            if (callback != null && callback.valid()) { //TODO Message if expired/invalid?
+                callback.takeUse();
+                callback.callback.accept(audience);
+            }
+        }
+    }
+
+    private static final class StoredCallback {
+        private final long startedAt = System.nanoTime();
+        private final ClickCallback<Audience> callback;
+        private final long lifetime;
+        private final UUID id;
+        private int remainingUses;
+
+        private StoredCallback(final @NotNull ClickCallback<Audience> callback, final ClickCallback.@NotNull Options options, final UUID id) {
+            this.callback = callback;
+            this.lifetime = options.lifetime().toNanos();
+            this.remainingUses = options.uses();
+            this.id = id;
+        }
+
+        public void takeUse() {
+            if (this.remainingUses != ClickCallback.UNLIMITED_USES) {
+                this.remainingUses--;
+            }
+        }
+
+        public boolean hasRemainingUses() {
+            return this.remainingUses == ClickCallback.UNLIMITED_USES || this.remainingUses > 0;
+        }
+
+        public boolean expired() {
+            return System.nanoTime() - this.startedAt >= this.lifetime;
+        }
+
+        public boolean valid() {
+            return hasRemainingUses() && !expired();
+        }
+
+        public UUID id() {
+            return this.id;
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/adventure/providers/ComponentLoggerProviderImpl.java b/src/main/java/io/papermc/paper/adventure/providers/ComponentLoggerProviderImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..8323f135d6bf2e1f12525e05094ffa3f2420e7e1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/adventure/providers/ComponentLoggerProviderImpl.java
@@ -0,0 +1,20 @@
+package io.papermc.paper.adventure.providers;
+
+import io.papermc.paper.adventure.PaperAdventure;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.logger.slf4j.ComponentLogger;
+import net.kyori.adventure.text.logger.slf4j.ComponentLoggerProvider;
+import org.jetbrains.annotations.NotNull;
+import org.slf4j.LoggerFactory;
+
+@SuppressWarnings("UnstableApiUsage")
+public class ComponentLoggerProviderImpl implements ComponentLoggerProvider {
+    @Override
+    public @NotNull ComponentLogger logger(@NotNull LoggerHelper helper, @NotNull String name) {
+        return helper.delegating(LoggerFactory.getLogger(name), this::serialize);
+    }
+
+    private String serialize(final Component message) {
+        return PaperAdventure.asPlain(message, null);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/adventure/providers/DataComponentValueConverterProviderImpl.java b/src/main/java/io/papermc/paper/adventure/providers/DataComponentValueConverterProviderImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..6b37c0ebda4a0cfcf9c3b2c3483ffababe622555
--- /dev/null
+++ b/src/main/java/io/papermc/paper/adventure/providers/DataComponentValueConverterProviderImpl.java
@@ -0,0 +1,82 @@
+package io.papermc.paper.adventure.providers;
+
+import com.google.gson.JsonElement;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.serialization.DynamicOps;
+import com.mojang.serialization.JsonOps;
+import io.papermc.paper.adventure.PaperAdventure;
+import java.util.List;
+import net.kyori.adventure.key.Key;
+import net.kyori.adventure.nbt.api.BinaryTagHolder;
+import net.kyori.adventure.text.event.DataComponentValue;
+import net.kyori.adventure.text.event.DataComponentValueConverterRegistry;
+import net.kyori.adventure.text.serializer.gson.GsonDataComponentValue;
+import net.minecraft.core.component.DataComponentType;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.nbt.NbtOps;
+import net.minecraft.nbt.Tag;
+import net.minecraft.resources.RegistryOps;
+import org.bukkit.craftbukkit.CraftRegistry;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+import static net.kyori.adventure.text.serializer.gson.GsonDataComponentValue.gsonDataComponentValue;
+
+@DefaultQualifier(NonNull.class)
+public class DataComponentValueConverterProviderImpl implements DataComponentValueConverterRegistry.Provider {
+
+    static final Key ID = Key.key("adventure", "platform/paper");
+
+    @Override
+    public Key id() {
+        return ID;
+    }
+
+    private static <T> RegistryOps<T> createOps(final DynamicOps<T> delegate) {
+        return CraftRegistry.getMinecraftRegistry().createSerializationContext(delegate);
+    }
+
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    @Override
+    public Iterable<DataComponentValueConverterRegistry.Conversion<?, ?>> conversions() {
+        return List.of(
+            DataComponentValueConverterRegistry.Conversion.convert(
+                PaperAdventure.DataComponentValueImpl.class,
+                GsonDataComponentValue.class,
+                (key, dataComponentValue) -> gsonDataComponentValue((JsonElement) dataComponentValue.codec().encodeStart(createOps(JsonOps.INSTANCE), dataComponentValue.value()).getOrThrow())
+            ),
+            DataComponentValueConverterRegistry.Conversion.convert(
+                GsonDataComponentValue.class,
+                PaperAdventure.DataComponentValueImpl.class,
+                (key, dataComponentValue) -> {
+                    final @Nullable DataComponentType<?> type = BuiltInRegistries.DATA_COMPONENT_TYPE.get(PaperAdventure.asVanilla(key));
+                    if (type == null) {
+                        throw new IllegalArgumentException("Unknown data component type: " + key);
+                    }
+                    return new PaperAdventure.DataComponentValueImpl(type.codecOrThrow(), type.codecOrThrow().parse(createOps(JsonOps.INSTANCE), dataComponentValue.element()).getOrThrow(IllegalArgumentException::new));
+                }
+            ),
+            DataComponentValueConverterRegistry.Conversion.convert(
+                PaperAdventure.DataComponentValueImpl.class,
+                DataComponentValue.TagSerializable.class,
+                (key, dataComponentValue) -> BinaryTagHolder.encode((Tag) dataComponentValue.codec().encodeStart(createOps(NbtOps.INSTANCE), dataComponentValue.value()).getOrThrow(), PaperAdventure.NBT_CODEC)
+            ),
+            DataComponentValueConverterRegistry.Conversion.convert(
+                DataComponentValue.TagSerializable.class,
+                PaperAdventure.DataComponentValueImpl.class,
+                (key, tagSerializable) -> {
+                    final @Nullable DataComponentType<?> type = BuiltInRegistries.DATA_COMPONENT_TYPE.get(PaperAdventure.asVanilla(key));
+                    if (type == null) {
+                        throw new IllegalArgumentException("Unknown data component type: " + key);
+                    }
+                    try {
+                        return new PaperAdventure.DataComponentValueImpl(type.codecOrThrow(), type.codecOrThrow().parse(createOps(NbtOps.INSTANCE), tagSerializable.asBinaryTag().get(PaperAdventure.NBT_CODEC)).getOrThrow(IllegalArgumentException::new));
+                    } catch (final CommandSyntaxException e) {
+                        throw new IllegalArgumentException(e);
+                    }
+                }
+            )
+        );
+    }
+}
diff --git a/src/main/java/io/papermc/paper/adventure/providers/GsonComponentSerializerProviderImpl.java b/src/main/java/io/papermc/paper/adventure/providers/GsonComponentSerializerProviderImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..c620d5aa2b0208b769dbe9563f0e99edc9a91047
--- /dev/null
+++ b/src/main/java/io/papermc/paper/adventure/providers/GsonComponentSerializerProviderImpl.java
@@ -0,0 +1,30 @@
+package io.papermc.paper.adventure.providers;
+
+import net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.function.Consumer;
+
+@SuppressWarnings("UnstableApiUsage") // permitted provider
+public class GsonComponentSerializerProviderImpl implements GsonComponentSerializer.Provider {
+
+    @Override
+    public @NotNull GsonComponentSerializer gson() {
+        return GsonComponentSerializer.builder()
+            .legacyHoverEventSerializer(NBTLegacyHoverEventSerializer.INSTANCE)
+            .build();
+    }
+
+    @Override
+    public @NotNull GsonComponentSerializer gsonLegacy() {
+        return GsonComponentSerializer.builder()
+            .legacyHoverEventSerializer(NBTLegacyHoverEventSerializer.INSTANCE)
+            .downsampleColors()
+            .build();
+    }
+
+    @Override
+    public @NotNull Consumer<GsonComponentSerializer.Builder> builder() {
+        return builder -> builder.legacyHoverEventSerializer(NBTLegacyHoverEventSerializer.INSTANCE);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/adventure/providers/LegacyComponentSerializerProviderImpl.java b/src/main/java/io/papermc/paper/adventure/providers/LegacyComponentSerializerProviderImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..03723dbe32b7eb95253e8ff6e72dbf8d2300a059
--- /dev/null
+++ b/src/main/java/io/papermc/paper/adventure/providers/LegacyComponentSerializerProviderImpl.java
@@ -0,0 +1,36 @@
+package io.papermc.paper.adventure.providers;
+
+import io.papermc.paper.adventure.PaperAdventure;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.function.Consumer;
+
+@SuppressWarnings("UnstableApiUsage") // permitted provider
+public class LegacyComponentSerializerProviderImpl implements LegacyComponentSerializer.Provider {
+
+    @Override
+    public @NotNull LegacyComponentSerializer legacyAmpersand() {
+        return LegacyComponentSerializer.builder()
+            .flattener(PaperAdventure.FLATTENER)
+            .character(LegacyComponentSerializer.AMPERSAND_CHAR)
+            .hexColors()
+            .useUnusualXRepeatedCharacterHexFormat()
+            .build();
+    }
+
+    @Override
+    public @NotNull LegacyComponentSerializer legacySection() {
+        return LegacyComponentSerializer.builder()
+            .flattener(PaperAdventure.FLATTENER)
+            .character(LegacyComponentSerializer.SECTION_CHAR)
+            .hexColors()
+            .useUnusualXRepeatedCharacterHexFormat()
+            .build();
+    }
+
+    @Override
+    public @NotNull Consumer<LegacyComponentSerializer.Builder> legacy() {
+        return builder -> builder.flattener(PaperAdventure.FLATTENER);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/adventure/providers/MiniMessageProviderImpl.java b/src/main/java/io/papermc/paper/adventure/providers/MiniMessageProviderImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..25fd6992c869c841b1b1b3240f4d524948487614
--- /dev/null
+++ b/src/main/java/io/papermc/paper/adventure/providers/MiniMessageProviderImpl.java
@@ -0,0 +1,20 @@
+package io.papermc.paper.adventure.providers;
+
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.function.Consumer;
+
+@SuppressWarnings("UnstableApiUsage") // permitted provider
+public class MiniMessageProviderImpl implements MiniMessage.Provider {
+
+    @Override
+    public @NotNull MiniMessage miniMessage() {
+        return MiniMessage.builder().build();
+    }
+
+    @Override
+    public @NotNull Consumer<MiniMessage.Builder> builder() {
+        return builder -> {};
+    }
+}
diff --git a/src/main/java/io/papermc/paper/adventure/providers/NBTLegacyHoverEventSerializer.java b/src/main/java/io/papermc/paper/adventure/providers/NBTLegacyHoverEventSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..202b964e7e67717904cd3f00b6af6ad7f2a5c90e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/adventure/providers/NBTLegacyHoverEventSerializer.java
@@ -0,0 +1,91 @@
+package io.papermc.paper.adventure.providers;
+
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import java.io.IOException;
+import java.util.UUID;
+import net.kyori.adventure.key.Key;
+import net.kyori.adventure.nbt.api.BinaryTagHolder;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.event.HoverEvent;
+import net.kyori.adventure.text.serializer.json.LegacyHoverEventSerializer;
+import net.kyori.adventure.text.serializer.plain.PlainTextComponentSerializer;
+import net.kyori.adventure.util.Codec;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.nbt.TagParser;
+import org.intellij.lang.annotations.Subst;
+
+final class NBTLegacyHoverEventSerializer implements LegacyHoverEventSerializer {
+    public static final NBTLegacyHoverEventSerializer INSTANCE = new NBTLegacyHoverEventSerializer();
+    private static final Codec<CompoundTag, String, CommandSyntaxException, RuntimeException> SNBT_CODEC = Codec.codec(TagParser::parseTag, Tag::toString);
+
+    static final String ITEM_TYPE = "id";
+    static final String ITEM_COUNT = "Count";
+    static final String ITEM_TAG = "tag";
+
+    static final String ENTITY_NAME = "name";
+    static final String ENTITY_TYPE = "type";
+    static final String ENTITY_ID = "id";
+
+    NBTLegacyHoverEventSerializer() {
+    }
+
+    @Override
+    public HoverEvent.ShowItem deserializeShowItem(final Component input) throws IOException {
+        final String raw = PlainTextComponentSerializer.plainText().serialize(input);
+        try {
+            final CompoundTag contents = SNBT_CODEC.decode(raw);
+            final CompoundTag tag = contents.getCompound(ITEM_TAG);
+            @Subst("key") final String keyString = contents.getString(ITEM_TYPE);
+            return HoverEvent.ShowItem.showItem(
+                Key.key(keyString),
+                contents.contains(ITEM_COUNT) ? contents.getByte(ITEM_COUNT) : 1,
+                tag.isEmpty() ? null : BinaryTagHolder.encode(tag, SNBT_CODEC)
+            );
+        } catch (final CommandSyntaxException ex) {
+            throw new IOException(ex);
+        }
+    }
+
+    @Override
+    public HoverEvent.ShowEntity deserializeShowEntity(final Component input, final Codec.Decoder<Component, String, ? extends RuntimeException> componentCodec) throws IOException {
+        final String raw = PlainTextComponentSerializer.plainText().serialize(input);
+        try {
+            final CompoundTag contents = SNBT_CODEC.decode(raw);
+            @Subst("key") final String keyString = contents.getString(ENTITY_TYPE);
+            return HoverEvent.ShowEntity.showEntity(
+                Key.key(keyString),
+                UUID.fromString(contents.getString(ENTITY_ID)),
+                componentCodec.decode(contents.getString(ENTITY_NAME))
+            );
+        } catch (final CommandSyntaxException ex) {
+            throw new IOException(ex);
+        }
+    }
+
+    @Override
+    public Component serializeShowItem(final HoverEvent.ShowItem input) throws IOException {
+        final CompoundTag tag = new CompoundTag();
+        tag.putString(ITEM_TYPE, input.item().asString());
+        tag.putByte(ITEM_COUNT, (byte) input.count());
+        if (input.nbt() != null) {
+            try {
+                tag.put(ITEM_TAG, input.nbt().get(SNBT_CODEC));
+            } catch (final CommandSyntaxException ex) {
+                throw new IOException(ex);
+            }
+        }
+        return Component.text(SNBT_CODEC.encode(tag));
+    }
+
+    @Override
+    public Component serializeShowEntity(final HoverEvent.ShowEntity input, final Codec.Encoder<Component, String, ? extends RuntimeException> componentCodec) {
+        final CompoundTag tag = new CompoundTag();
+        tag.putString(ENTITY_ID, input.id().toString());
+        tag.putString(ENTITY_TYPE, input.type().asString());
+        if (input.name() != null) {
+            tag.putString(ENTITY_NAME, componentCodec.encode(input.name()));
+        }
+        return Component.text(SNBT_CODEC.encode(tag));
+    }
+}
diff --git a/src/main/java/io/papermc/paper/adventure/providers/PlainTextComponentSerializerProviderImpl.java b/src/main/java/io/papermc/paper/adventure/providers/PlainTextComponentSerializerProviderImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..c0701d4f93a4d77a8177d2dd8d5076f9f781873d
--- /dev/null
+++ b/src/main/java/io/papermc/paper/adventure/providers/PlainTextComponentSerializerProviderImpl.java
@@ -0,0 +1,23 @@
+package io.papermc.paper.adventure.providers;
+
+import io.papermc.paper.adventure.PaperAdventure;
+import net.kyori.adventure.text.serializer.plain.PlainTextComponentSerializer;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.function.Consumer;
+
+@SuppressWarnings("UnstableApiUsage") // permitted provider
+public class PlainTextComponentSerializerProviderImpl implements PlainTextComponentSerializer.Provider {
+
+    @Override
+    public @NotNull PlainTextComponentSerializer plainTextSimple() {
+        return PlainTextComponentSerializer.builder()
+            .flattener(PaperAdventure.FLATTENER)
+            .build();
+    }
+
+    @Override
+    public @NotNull Consumer<PlainTextComponentSerializer.Builder> plainText() {
+        return builder -> builder.flattener(PaperAdventure.FLATTENER);
+    }
+}
diff --git a/src/main/java/net/minecraft/ChatFormatting.java b/src/main/java/net/minecraft/ChatFormatting.java
index f5ec57f68dff18c8b2622b58df5df2fd83761b7e..5c01964acd4182467c4de437d6a3b79b268b50dd 100644
--- a/src/main/java/net/minecraft/ChatFormatting.java
+++ b/src/main/java/net/minecraft/ChatFormatting.java
@@ -110,6 +110,18 @@ public enum ChatFormatting implements StringRepresentable {
         return name == null ? null : FORMATTING_BY_NAME.get(cleanName(name));
     }
 
+    // Paper start - add method to get by hex value
+    @Nullable public static ChatFormatting getByHexValue(int i) {
+        for (ChatFormatting value : values()) {
+            if (value.getColor() != null && value.getColor() == i) {
+                return value;
+            }
+        }
+
+        return null;
+    }
+    // Paper end - add method to get by hex value
+
     @Nullable
     public static ChatFormatting getById(int colorIndex) {
         if (colorIndex < 0) {
diff --git a/src/main/java/net/minecraft/commands/CommandSourceStack.java b/src/main/java/net/minecraft/commands/CommandSourceStack.java
index f30cdfa5fd294479e35680b2f758b3295f659b74..ec34e402104d7a696ea95e0b11ee70189b678ab9 100644
--- a/src/main/java/net/minecraft/commands/CommandSourceStack.java
+++ b/src/main/java/net/minecraft/commands/CommandSourceStack.java
@@ -65,6 +65,7 @@ public class CommandSourceStack implements ExecutionCommandSource<CommandSourceS
     private final CommandSigningContext signingContext;
     private final TaskChainer chatMessageChainer;
     public volatile CommandNode currentCommand; // CraftBukkit
+    public boolean bypassSelectorPermissions = false; // Paper - add bypass for selector permissions
 
     public CommandSourceStack(CommandSource output, Vec3 pos, Vec2 rot, ServerLevel world, int level, String name, Component displayName, MinecraftServer server, @Nullable Entity entity) {
         this(output, pos, rot, world, level, name, displayName, server, entity, false, CommandResultCallback.EMPTY, EntityAnchorArgument.Anchor.FEET, CommandSigningContext.ANONYMOUS, TaskChainer.immediate(server));
diff --git a/src/main/java/net/minecraft/commands/arguments/MessageArgument.java b/src/main/java/net/minecraft/commands/arguments/MessageArgument.java
index 0047fd758ad43cc7b13355b60c410a9bcc37bec0..982b2bab27e3d55d0ba07060862c0c3183ad91b0 100644
--- a/src/main/java/net/minecraft/commands/arguments/MessageArgument.java
+++ b/src/main/java/net/minecraft/commands/arguments/MessageArgument.java
@@ -53,17 +53,21 @@ public class MessageArgument implements SignedArgument<MessageArgument.Message>
     private static void resolveSignedMessage(Consumer<PlayerChatMessage> callback, CommandSourceStack source, PlayerChatMessage message) {
         MinecraftServer minecraftServer = source.getServer();
         CompletableFuture<FilteredText> completableFuture = filterPlainText(source, message);
-        Component component = minecraftServer.getChatDecorator().decorate(source.getPlayer(), message.decoratedContent());
-        source.getChatMessageChainer().append(completableFuture, filtered -> {
-            PlayerChatMessage playerChatMessage2 = message.withUnsignedContent(component).filter(filtered.mask());
+        // Paper start - support asynchronous chat decoration
+        CompletableFuture<Component> componentFuture = minecraftServer.getChatDecorator().decorate(source.getPlayer(), source, message.decoratedContent());
+        source.getChatMessageChainer().append(CompletableFuture.allOf(completableFuture, componentFuture), filtered -> {
+            PlayerChatMessage playerChatMessage2 = message.withUnsignedContent(componentFuture.join()).filter(completableFuture.join().mask());
+            // Paper end - support asynchronous chat decoration
             callback.accept(playerChatMessage2);
         });
     }
 
     private static void resolveDisguisedMessage(Consumer<PlayerChatMessage> callback, CommandSourceStack source, PlayerChatMessage message) {
         ChatDecorator chatDecorator = source.getServer().getChatDecorator();
-        Component component = chatDecorator.decorate(source.getPlayer(), message.decoratedContent());
-        callback.accept(message.withUnsignedContent(component));
+        // Paper start - support asynchronous chat decoration
+        CompletableFuture<Component> componentFuture = chatDecorator.decorate(source.getPlayer(), source, message.decoratedContent());
+        source.getChatMessageChainer().append(componentFuture, (result) -> callback.accept(message.withUnsignedContent(result)));
+        // Paper end - support asynchronous chat decoration
     }
 
     private static CompletableFuture<FilteredText> filterPlainText(CommandSourceStack source, PlayerChatMessage message) {
diff --git a/src/main/java/net/minecraft/commands/arguments/selector/EntitySelector.java b/src/main/java/net/minecraft/commands/arguments/selector/EntitySelector.java
index d120fff432d9c4fc7a35ddffdc4186459e45e950..d78ad5eccd18d89050a486a0c40090a09683bd16 100644
--- a/src/main/java/net/minecraft/commands/arguments/selector/EntitySelector.java
+++ b/src/main/java/net/minecraft/commands/arguments/selector/EntitySelector.java
@@ -92,7 +92,7 @@ public class EntitySelector {
     }
 
     private void checkPermissions(CommandSourceStack source) throws CommandSyntaxException {
-        if (this.usesSelector && !source.hasPermission(2, "minecraft.command.selector")) { // CraftBukkit
+        if (!source.bypassSelectorPermissions && (this.usesSelector && !source.hasPermission(2, "minecraft.command.selector"))) { // CraftBukkit // Paper - add bypass for selector perms
             throw EntityArgument.ERROR_SELECTORS_NOT_ALLOWED.create();
         }
     }
diff --git a/src/main/java/net/minecraft/network/FriendlyByteBuf.java b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
index a7419bcb0954f0adbf7ce2d1e9738e690c265f4d..aafeb9c61ddba6a8671f0238eda47b227619f1af 100644
--- a/src/main/java/net/minecraft/network/FriendlyByteBuf.java
+++ b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
@@ -72,6 +72,7 @@ public class FriendlyByteBuf extends ByteBuf {
 
     public static final int DEFAULT_NBT_QUOTA = 2097152;
     private final ByteBuf source;
+    @Nullable public final java.util.Locale adventure$locale; // Paper - track player's locale for server-side translations
     public static final short MAX_STRING_LENGTH = Short.MAX_VALUE;
     public static final int MAX_COMPONENT_STRING_LENGTH = 262144;
     private static final int PUBLIC_KEY_SIZE = 256;
@@ -80,6 +81,7 @@ public class FriendlyByteBuf extends ByteBuf {
     private static final Gson GSON = new Gson();
 
     public FriendlyByteBuf(ByteBuf parent) {
+        this.adventure$locale = PacketEncoder.ADVENTURE_LOCALE.get(); // Paper - track player's locale for server-side translations
         this.source = parent;
     }
 
@@ -120,11 +122,16 @@ public class FriendlyByteBuf extends ByteBuf {
     }
 
     public <T> void writeJsonWithCodec(Codec<T> codec, T value) {
+        // Paper start - Adventure; add max length parameter
+        this.writeJsonWithCodec(codec, value, MAX_STRING_LENGTH);
+    }
+    public <T> void writeJsonWithCodec(Codec<T> codec, T value, int maxLength) {
+        // Paper end - Adventure; add max length parameter
         DataResult<JsonElement> dataresult = codec.encodeStart(JsonOps.INSTANCE, value);
 
         this.writeUtf(FriendlyByteBuf.GSON.toJson((JsonElement) dataresult.getOrThrow((s) -> {
             return new EncoderException("Failed to encode: " + s + " " + String.valueOf(value));
-        })));
+        })), maxLength); // Paper - Adventure; add max length parameter
     }
 
     public static <T> IntFunction<T> limitValue(IntFunction<T> applier, int max) {
diff --git a/src/main/java/net/minecraft/network/PacketEncoder.java b/src/main/java/net/minecraft/network/PacketEncoder.java
index a58f67973b4ed986065860263c7a42214640520d..046bfc212b640de174b300e7a05cc30bb3cac93e 100644
--- a/src/main/java/net/minecraft/network/PacketEncoder.java
+++ b/src/main/java/net/minecraft/network/PacketEncoder.java
@@ -17,10 +17,12 @@ public class PacketEncoder<T extends PacketListener> extends MessageToByteEncode
         this.protocolInfo = state;
     }
 
+    static final ThreadLocal<java.util.Locale> ADVENTURE_LOCALE = ThreadLocal.withInitial(() -> null); // Paper - adventure; set player's locale
     protected void encode(ChannelHandlerContext channelHandlerContext, Packet<T> packet, ByteBuf byteBuf) throws Exception {
         PacketType<? extends Packet<? super T>> packetType = packet.type();
 
         try {
+            ADVENTURE_LOCALE.set(channelHandlerContext.channel().attr(io.papermc.paper.adventure.PaperAdventure.LOCALE_ATTRIBUTE).get()); // Paper - adventure; set player's locale
             this.protocolInfo.codec().encode(byteBuf, packet);
             int i = byteBuf.readableBytes();
             if (LOGGER.isDebugEnabled()) {
diff --git a/src/main/java/net/minecraft/network/chat/ChatDecorator.java b/src/main/java/net/minecraft/network/chat/ChatDecorator.java
index e4624d696dcf0ddb6d42a80701dfc47ec6877540..6b8dc1eb490098cc14673c9ab0aa16fe3471325b 100644
--- a/src/main/java/net/minecraft/network/chat/ChatDecorator.java
+++ b/src/main/java/net/minecraft/network/chat/ChatDecorator.java
@@ -2,10 +2,18 @@ package net.minecraft.network.chat;
 
 import javax.annotation.Nullable;
 import net.minecraft.server.level.ServerPlayer;
+import java.util.concurrent.CompletableFuture; // Paper
 
 @FunctionalInterface
 public interface ChatDecorator {
-    ChatDecorator PLAIN = (sender, message) -> message;
+    ChatDecorator PLAIN = (sender, message) -> CompletableFuture.completedFuture(message); // Paper - adventure; support async chat decoration events
 
-    Component decorate(@Nullable ServerPlayer sender, Component message);
+    @io.papermc.paper.annotation.DoNotUse @Deprecated // Paper - adventure; support chat decoration events (callers should use the overload with CommandSourceStack)
+    CompletableFuture<Component> decorate(@Nullable ServerPlayer sender, Component message); // Paper - adventure; support async chat decoration events
+
+    // Paper start - adventure; support async chat decoration events
+    default CompletableFuture<Component> decorate(@Nullable ServerPlayer sender, @Nullable net.minecraft.commands.CommandSourceStack commandSourceStack, Component message) {
+        throw new UnsupportedOperationException("Must override this implementation");
+    }
+    // Paper end - adventure; support async chat decoration events
 }
diff --git a/src/main/java/net/minecraft/network/chat/ComponentSerialization.java b/src/main/java/net/minecraft/network/chat/ComponentSerialization.java
index ec99dc00d83e2369e66ba5e93bf482555aab7b06..22c6a324dedeb315eac2d3d3f55d2f3a9eebb0ad 100644
--- a/src/main/java/net/minecraft/network/chat/ComponentSerialization.java
+++ b/src/main/java/net/minecraft/network/chat/ComponentSerialization.java
@@ -37,9 +37,31 @@ import net.minecraft.util.StringRepresentable;
 
 public class ComponentSerialization {
     public static final Codec<Component> CODEC = Codec.recursive("Component", ComponentSerialization::createCodec);
-    public static final StreamCodec<RegistryFriendlyByteBuf, Component> STREAM_CODEC = ByteBufCodecs.fromCodecWithRegistries(CODEC);
+    public static final StreamCodec<RegistryFriendlyByteBuf, Component> STREAM_CODEC = createTranslationAware(() -> net.minecraft.nbt.NbtAccounter.create(net.minecraft.network.FriendlyByteBuf.DEFAULT_NBT_QUOTA)); // Paper - adventure
     public static final StreamCodec<RegistryFriendlyByteBuf, Optional<Component>> OPTIONAL_STREAM_CODEC = STREAM_CODEC.apply(ByteBufCodecs::optional);
-    public static final StreamCodec<RegistryFriendlyByteBuf, Component> TRUSTED_STREAM_CODEC = ByteBufCodecs.fromCodecWithRegistriesTrusted(CODEC);
+    // Paper start - adventure; use locale from bytebuf for translation
+    public static final ThreadLocal<Boolean> DONT_RENDER_TRANSLATABLES = ThreadLocal.withInitial(() -> false);
+    public static final StreamCodec<RegistryFriendlyByteBuf, Component> TRUSTED_STREAM_CODEC = createTranslationAware(net.minecraft.nbt.NbtAccounter::unlimitedHeap);
+    private static StreamCodec<RegistryFriendlyByteBuf, Component> createTranslationAware(final Supplier<net.minecraft.nbt.NbtAccounter> sizeTracker) {
+        return new StreamCodec<>() {
+            final StreamCodec<ByteBuf, net.minecraft.nbt.Tag> streamCodec = ByteBufCodecs.tagCodec(sizeTracker);
+            @Override
+            public Component decode(RegistryFriendlyByteBuf registryFriendlyByteBuf) {
+                net.minecraft.nbt.Tag tag = this.streamCodec.decode(registryFriendlyByteBuf);
+                RegistryOps<net.minecraft.nbt.Tag> registryOps = registryFriendlyByteBuf.registryAccess().createSerializationContext(net.minecraft.nbt.NbtOps.INSTANCE);
+                return CODEC.parse(registryOps, tag).getOrThrow(error -> new io.netty.handler.codec.DecoderException("Failed to decode: " + error + " " + tag));
+            }
+
+            @Override
+            public void encode(RegistryFriendlyByteBuf registryFriendlyByteBuf, Component object) {
+                RegistryOps<net.minecraft.nbt.Tag> registryOps = registryFriendlyByteBuf.registryAccess().createSerializationContext(net.minecraft.nbt.NbtOps.INSTANCE);
+                net.minecraft.nbt.Tag tag = (DONT_RENDER_TRANSLATABLES.get() ? CODEC : ComponentSerialization.localizedCodec(registryFriendlyByteBuf.adventure$locale))
+                    .encodeStart(registryOps, object).getOrThrow(error -> new io.netty.handler.codec.EncoderException("Failed to encode: " + error + " " + object));
+                this.streamCodec.encode(registryFriendlyByteBuf, tag);
+            }
+        };
+    }
+    // Paper end - adventure; use locale from bytebuf for translation
     public static final StreamCodec<RegistryFriendlyByteBuf, Optional<Component>> TRUSTED_OPTIONAL_STREAM_CODEC = TRUSTED_STREAM_CODEC.apply(
         ByteBufCodecs::optional
     );
@@ -100,7 +122,27 @@ public class ComponentSerialization {
         return ExtraCodecs.orCompressed(mapCodec3, mapCodec2);
     }
 
+    // Paper start - adventure; create separate codec for each locale
+    private static final java.util.Map<java.util.Locale, Codec<Component>> LOCALIZED_CODECS = new java.util.concurrent.ConcurrentHashMap<>();
+
+    public static Codec<Component> localizedCodec(final java.util.@org.checkerframework.checker.nullness.qual.Nullable Locale locale) {
+        if (locale == null) {
+            return CODEC;
+        }
+        return LOCALIZED_CODECS.computeIfAbsent(locale,
+            loc -> Codec.recursive("Component", selfCodec -> createCodec(selfCodec, loc)));
+    }
+
+
+    // Paper end - adventure; create separate codec for each locale
+
     private static Codec<Component> createCodec(Codec<Component> selfCodec) {
+        // Paper start - adventure; create separate codec for each locale
+        return createCodec(selfCodec, null);
+    }
+
+    private static Codec<Component> createCodec(Codec<Component> selfCodec, @javax.annotation.Nullable java.util.Locale locale) {
+        // Paper end - adventure; create separate codec for each locale
         ComponentContents.Type<?>[] types = new ComponentContents.Type[]{
             PlainTextContents.TYPE, TranslatableContents.TYPE, KeybindContents.TYPE, ScoreContents.TYPE, SelectorContents.TYPE, NbtContents.TYPE
         };
@@ -113,6 +155,34 @@ public class ComponentSerialization {
                     )
                     .apply(instance, MutableComponent::new)
         );
+        // Paper start - adventure; create separate codec for each locale
+        final Codec<Component> origCodec = codec;
+        codec = new Codec<>() {
+            @Override
+            public <T> DataResult<com.mojang.datafixers.util.Pair<Component, T>> decode(final DynamicOps<T> ops, final T input) {
+                return origCodec.decode(ops, input);
+            }
+
+            @Override
+            public <T> DataResult<T> encode(final Component input, final DynamicOps<T> ops, final T prefix) {
+                final net.kyori.adventure.text.Component adventureComponent;
+                if (input instanceof io.papermc.paper.adventure.AdventureComponent adv) {
+                    adventureComponent = adv.adventure$component();
+                } else if (locale != null && input.getContents() instanceof TranslatableContents && io.papermc.paper.adventure.PaperAdventure.hasAnyTranslations()) {
+                    adventureComponent = io.papermc.paper.adventure.PaperAdventure.asAdventure(input);
+                } else {
+                    return origCodec.encode(input, ops, prefix);
+                }
+                return io.papermc.paper.adventure.PaperAdventure.localizedCodec(locale)
+                    .encode(adventureComponent, ops, prefix);
+            }
+
+            @Override
+            public String toString() {
+                return origCodec.toString() + "[AdventureComponentAware]";
+            }
+        };
+        // Paper end - adventure; create separate codec for each locale
         return Codec.either(Codec.either(Codec.STRING, ExtraCodecs.nonEmptyList(selfCodec.listOf())), codec)
             .xmap(either -> either.map(either2 -> either2.map(Component::literal, ComponentSerialization::createFromList), text -> (Component)text), text -> {
                 String string = text.tryCollapseToString();
diff --git a/src/main/java/net/minecraft/network/chat/ComponentUtils.java b/src/main/java/net/minecraft/network/chat/ComponentUtils.java
index 0030c0c91e989fcdc5b7ce6490836a0e8dd3b5d5..3365aed2b67ae0e4dd0410f5190ba474f146139b 100644
--- a/src/main/java/net/minecraft/network/chat/ComponentUtils.java
+++ b/src/main/java/net/minecraft/network/chat/ComponentUtils.java
@@ -41,6 +41,11 @@ public class ComponentUtils {
         if (depth > 100) {
             return text.copy();
         } else {
+            // Paper start - adventure; pass actual vanilla component
+            if (text instanceof io.papermc.paper.adventure.AdventureComponent adventureComponent) {
+                text = adventureComponent.deepConverted();
+            }
+            // Paper end - adventure; pass actual vanilla component
             MutableComponent mutableComponent = text.getContents().resolve(source, sender, depth + 1);
 
             for (Component component : text.getSiblings()) {
diff --git a/src/main/java/net/minecraft/network/chat/MessageSignature.java b/src/main/java/net/minecraft/network/chat/MessageSignature.java
index 739ef5fb6f4fa37382153ba6a308ca3b451e6b05..7c3154af5d7732037c0ee965f6f8b89424461abd 100644
--- a/src/main/java/net/minecraft/network/chat/MessageSignature.java
+++ b/src/main/java/net/minecraft/network/chat/MessageSignature.java
@@ -13,6 +13,7 @@ import net.minecraft.util.SignatureUpdater;
 import net.minecraft.util.SignatureValidator;
 
 public record MessageSignature(byte[] bytes) {
+    public net.kyori.adventure.chat.SignedMessage.Signature adventure() { return () -> this.bytes; } // Paper - adventure; support signed messages
     public static final Codec<MessageSignature> CODEC = ExtraCodecs.BASE64_STRING.xmap(MessageSignature::new, MessageSignature::bytes);
     public static final int BYTES = 256;
 
diff --git a/src/main/java/net/minecraft/network/chat/MutableComponent.java b/src/main/java/net/minecraft/network/chat/MutableComponent.java
index 1ce6b84e0d0bb708ced06955cd62281369b5fd4f..82e2a02336da4ee8cfd84bc82b143f8b9dbcf449 100644
--- a/src/main/java/net/minecraft/network/chat/MutableComponent.java
+++ b/src/main/java/net/minecraft/network/chat/MutableComponent.java
@@ -94,6 +94,11 @@ public class MutableComponent implements Component {
 
     @Override
     public boolean equals(Object object) {
+        // Paper start - make AdventureComponent equivalent
+        if (object instanceof io.papermc.paper.adventure.AdventureComponent adventureComponent) {
+            object = adventureComponent.deepConverted();
+        }
+        // Paper end - make AdventureComponent equivalent
         return this == object
             || object instanceof MutableComponent mutableComponent
                 && this.contents.equals(mutableComponent.contents)
diff --git a/src/main/java/net/minecraft/network/chat/OutgoingChatMessage.java b/src/main/java/net/minecraft/network/chat/OutgoingChatMessage.java
index e2def0ca552343143e495736d533b3334686fd62..c87b708c368713a23a10ad97704575ee4df27891 100644
--- a/src/main/java/net/minecraft/network/chat/OutgoingChatMessage.java
+++ b/src/main/java/net/minecraft/network/chat/OutgoingChatMessage.java
@@ -7,6 +7,12 @@ public interface OutgoingChatMessage {
 
     void sendToPlayer(ServerPlayer sender, boolean filterMaskEnabled, ChatType.Bound params);
 
+    // Paper start
+    default void sendToPlayer(ServerPlayer sender, boolean filterMaskEnabled, ChatType.Bound params, @javax.annotation.Nullable Component unsigned) {
+        this.sendToPlayer(sender, filterMaskEnabled, params);
+    }
+    // Paper end
+
     static OutgoingChatMessage create(PlayerChatMessage message) {
         return (OutgoingChatMessage)(message.isSystem()
             ? new OutgoingChatMessage.Disguised(message.decoratedContent())
@@ -16,7 +22,12 @@ public interface OutgoingChatMessage {
     public static record Disguised(@Override Component content) implements OutgoingChatMessage {
         @Override
         public void sendToPlayer(ServerPlayer sender, boolean filterMaskEnabled, ChatType.Bound params) {
-            sender.connection.sendDisguisedChatMessage(this.content, params);
+           // Paper start
+            this.sendToPlayer(sender, filterMaskEnabled, params, null);
+        }
+        public void sendToPlayer(ServerPlayer sender, boolean filterMaskEnabled, ChatType.Bound params, @javax.annotation.Nullable Component unsigned) {
+            sender.connection.sendDisguisedChatMessage(unsigned != null ? unsigned : this.content, params);
+            // Paper end
         }
     }
 
@@ -28,7 +39,13 @@ public interface OutgoingChatMessage {
 
         @Override
         public void sendToPlayer(ServerPlayer sender, boolean filterMaskEnabled, ChatType.Bound params) {
+            // Paper start
+            this.sendToPlayer(sender, filterMaskEnabled, params, null);
+        }
+        public void sendToPlayer(ServerPlayer sender, boolean filterMaskEnabled, ChatType.Bound params, @javax.annotation.Nullable Component unsigned) {
+            // Paper end
             PlayerChatMessage playerChatMessage = this.message.filter(filterMaskEnabled);
+            playerChatMessage = unsigned != null ? playerChatMessage.withUnsignedContent(unsigned) : playerChatMessage; // Paper
             if (!playerChatMessage.isFullyFiltered()) {
                 sender.connection.sendPlayerChatMessage(playerChatMessage, params);
             }
diff --git a/src/main/java/net/minecraft/network/chat/PlayerChatMessage.java b/src/main/java/net/minecraft/network/chat/PlayerChatMessage.java
index d89049328641faa889b7c567123ab3a2c63b8df0..76b304560c2b631a18f20e656a65ac75af7b4e63 100644
--- a/src/main/java/net/minecraft/network/chat/PlayerChatMessage.java
+++ b/src/main/java/net/minecraft/network/chat/PlayerChatMessage.java
@@ -17,6 +17,42 @@ import net.minecraft.util.SignatureValidator;
 public record PlayerChatMessage(
     SignedMessageLink link, @Nullable MessageSignature signature, SignedMessageBody signedBody, @Nullable Component unsignedContent, FilterMask filterMask
 ) {
+    // Paper start - adventure; support signed messages
+    public final class AdventureView implements net.kyori.adventure.chat.SignedMessage {
+        private AdventureView() {
+        }
+        @Override
+        public @org.jetbrains.annotations.NotNull Instant timestamp() {
+            return PlayerChatMessage.this.timeStamp();
+        }
+        @Override
+        public long salt() {
+            return PlayerChatMessage.this.salt();
+        }
+        @Override
+        public @org.jetbrains.annotations.Nullable Signature signature() {
+            return PlayerChatMessage.this.signature == null ? null : PlayerChatMessage.this.signature.adventure();
+        }
+        @Override
+        public net.kyori.adventure.text.@org.jetbrains.annotations.Nullable Component unsignedContent() {
+            return PlayerChatMessage.this.unsignedContent() == null ? null : io.papermc.paper.adventure.PaperAdventure.asAdventure(PlayerChatMessage.this.unsignedContent());
+        }
+        @Override
+        public @org.jetbrains.annotations.NotNull String message() {
+            return PlayerChatMessage.this.signedContent();
+        }
+        @Override
+        public @org.jetbrains.annotations.NotNull net.kyori.adventure.identity.Identity identity() {
+            return net.kyori.adventure.identity.Identity.identity(PlayerChatMessage.this.sender());
+        }
+        public PlayerChatMessage playerChatMessage() {
+            return PlayerChatMessage.this;
+        }
+    }
+    public AdventureView adventureView() {
+        return new AdventureView();
+    }
+    // Paper end - adventure; support signed messages
     public static final MapCodec<PlayerChatMessage> MAP_CODEC = RecordCodecBuilder.mapCodec(
         instance -> instance.group(
                     SignedMessageLink.CODEC.fieldOf("link").forGetter(PlayerChatMessage::link),
@@ -47,7 +83,14 @@ public record PlayerChatMessage(
     }
 
     public PlayerChatMessage withUnsignedContent(Component unsignedContent) {
-        Component component = !unsignedContent.equals(Component.literal(this.signedContent())) ? unsignedContent : null;
+        // Paper start - adventure
+        final Component component;
+        if (unsignedContent instanceof io.papermc.paper.adventure.AdventureComponent advComponent) {
+            component = this.signedContent().equals(io.papermc.paper.adventure.AdventureCodecs.tryCollapseToString(advComponent.adventure$component())) ? null : unsignedContent;
+        } else {
+            component = !unsignedContent.equals(Component.literal(this.signedContent())) ? unsignedContent : null;
+        }
+        // Paper end - adventure
         return new PlayerChatMessage(this.link, this.signature, this.signedBody, component, this.filterMask);
     }
 
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSystemChatPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSystemChatPacket.java
index c5ba5e30cd74ca2cfc3f952c7b992df239a53a34..fdb75db02603ef97b624219211a0db22cd447dea 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSystemChatPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSystemChatPacket.java
@@ -18,6 +18,11 @@ public record ClientboundSystemChatPacket(Component content, boolean overlay) im
         this(org.bukkit.craftbukkit.util.CraftChatMessage.fromJSON(net.md_5.bungee.chat.ComponentSerializer.toString(content)), overlay);
     }
     // Spigot end
+    // Paper start
+    public ClientboundSystemChatPacket(net.kyori.adventure.text.Component content, boolean overlay) {
+        this(io.papermc.paper.adventure.PaperAdventure.asVanilla(content), overlay);
+    }
+    // Paper end
 
     @Override
     public PacketType<ClientboundSystemChatPacket> type() {
diff --git a/src/main/java/net/minecraft/network/protocol/login/ClientboundLoginDisconnectPacket.java b/src/main/java/net/minecraft/network/protocol/login/ClientboundLoginDisconnectPacket.java
index bb97fdb9aa6167083442a928276ebe4225a586ef..5d1758086ed4fce5b36a5b31df44ccea42abc590 100644
--- a/src/main/java/net/minecraft/network/protocol/login/ClientboundLoginDisconnectPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/login/ClientboundLoginDisconnectPacket.java
@@ -18,11 +18,15 @@ public class ClientboundLoginDisconnectPacket implements Packet<ClientLoginPacke
     }
 
     private ClientboundLoginDisconnectPacket(FriendlyByteBuf buf) {
-        this.reason = Component.Serializer.fromJsonLenient(buf.readUtf(262144), RegistryAccess.EMPTY);
+        this.reason = Component.Serializer.fromJsonLenient(buf.readUtf(FriendlyByteBuf.MAX_COMPONENT_STRING_LENGTH), RegistryAccess.EMPTY); // Paper - diff on change
     }
 
     private void write(FriendlyByteBuf buf) {
-        buf.writeUtf(Component.Serializer.toJson(this.reason, RegistryAccess.EMPTY));
+        // Paper start - Adventure
+        // buf.writeUtf(Component.Serializer.toJson(this.reason, RegistryAccess.EMPTY));
+        // In the login phase, buf.adventure$locale field is always null
+        buf.writeJsonWithCodec(net.minecraft.network.chat.ComponentSerialization.localizedCodec(java.util.Locale.US), this.reason, FriendlyByteBuf.MAX_COMPONENT_STRING_LENGTH);
+        // Paper end - Adventure
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index da3cc749b3b1f3738e7e7cd77fb0b0fd6eea0b0b..84ad6aae39b5fe4c4ad5ec08890d4383829cbe50 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -195,6 +195,7 @@ import org.bukkit.craftbukkit.SpigotTimings; // Spigot
 public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements ServerInfo, CommandSource, AutoCloseable {
 
     public static final Logger LOGGER = LogUtils.getLogger();
+    public static final net.kyori.adventure.text.logger.slf4j.ComponentLogger COMPONENT_LOGGER = net.kyori.adventure.text.logger.slf4j.ComponentLogger.logger(LOGGER.getName()); // Paper
     public static final String VANILLA_BRAND = "vanilla";
     private static final float AVERAGE_TICK_TIME_SMOOTHING = 0.8F;
     private static final int TICK_STATS_SPAN = 100;
@@ -245,8 +246,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private boolean preventProxyConnections;
     private boolean pvp;
     private boolean allowFlight;
-    @Nullable
-    private String motd;
+    private net.kyori.adventure.text.Component motd; // Paper - Adventure
     private int playerIdleTimeout;
     private final long[] tickTimesNanos;
     private long aggregatedTickTimesNanos;
@@ -1369,7 +1369,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private ServerStatus buildServerStatus() {
         ServerStatus.Players serverping_serverpingplayersample = this.buildPlayerStatus();
 
-        return new ServerStatus(Component.nullToEmpty(this.motd), Optional.of(serverping_serverpingplayersample), Optional.of(ServerStatus.Version.current()), Optional.ofNullable(this.statusIcon), this.enforceSecureProfile());
+        return new ServerStatus(io.papermc.paper.adventure.PaperAdventure.asVanilla(this.motd), Optional.of(serverping_serverpingplayersample), Optional.of(ServerStatus.Version.current()), Optional.ofNullable(this.statusIcon), this.enforceSecureProfile()); // Paper - Adventure
     }
 
     private ServerStatus.Players buildPlayerStatus() {
@@ -1401,6 +1401,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         SpigotTimings.schedulerTimer.startTiming(); // Spigot
         this.server.getScheduler().mainThreadHeartbeat(this.tickCount); // CraftBukkit
         SpigotTimings.schedulerTimer.stopTiming(); // Spigot
+        io.papermc.paper.adventure.providers.ClickCallbackProviderImpl.CALLBACK_MANAGER.handleQueue(this.tickCount); // Paper
         this.profiler.push("commandFunctions");
         SpigotTimings.commandFunctionsTimer.startTiming(); // Spigot
         this.getFunctions().tick();
@@ -1777,10 +1778,20 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     @Override
     public String getMotd() {
-        return this.motd;
+        return net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().serialize(this.motd); // Paper - Adventure
     }
 
     public void setMotd(String motd) {
+        // Paper start - Adventure
+        this.motd = net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserializeOr(motd, net.kyori.adventure.text.Component.empty());
+    }
+
+    public net.kyori.adventure.text.Component motd() {
+        return this.motd;
+    }
+
+    public void motd(net.kyori.adventure.text.Component motd) {
+        // Paper end - Adventure
         this.motd = motd;
     }
 
@@ -2542,23 +2553,24 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     public void logChatMessage(Component message, ChatType.Bound params, @Nullable String prefix) {
-        String s1 = params.decorate(message).getString();
+        // Paper start
+        net.kyori.adventure.text.Component s1 = io.papermc.paper.adventure.PaperAdventure.asAdventure(params.decorate(message));
 
         if (prefix != null) {
-            MinecraftServer.LOGGER.info("[{}] {}", prefix, s1);
+            MinecraftServer.COMPONENT_LOGGER.info("[{}] {}", prefix, s1);
         } else {
-            MinecraftServer.LOGGER.info("{}", s1);
+            MinecraftServer.COMPONENT_LOGGER.info("{}", s1);
+            // Paper end
         }
 
     }
 
-    // CraftBukkit start
     public final java.util.concurrent.ExecutorService chatExecutor = java.util.concurrent.Executors.newCachedThreadPool(
-            new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon(true).setNameFormat("Async Chat Thread - #%d").build());
-    // CraftBukkit end
+            new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon(true).setNameFormat("Async Chat Thread - #%d").setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(net.minecraft.server.MinecraftServer.LOGGER)).build()); // Paper
 
+    public final ChatDecorator improvedChatDecorator = new io.papermc.paper.adventure.ImprovedChatDecorator(this); // Paper - adventure
     public ChatDecorator getChatDecorator() {
-        return ChatDecorator.PLAIN;
+        return this.improvedChatDecorator; // Paper - support async chat decoration events
     }
 
     public boolean logIPs() {
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index a1d4d3a66c48abdddd2bcdd957417f81290c7a6e..08b2d5c6fb6d236b805ca6556270ad1891b411f5 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -170,6 +170,7 @@ import net.minecraft.world.damagesource.CombatTracker;
 import net.minecraft.world.scores.Scoreboard;
 import net.minecraft.world.scores.Team;
 import net.minecraft.world.scores.criteria.ObjectiveCriteria;
+import io.papermc.paper.adventure.PaperAdventure; // Paper
 import org.bukkit.Bukkit;
 import org.bukkit.Location;
 import org.bukkit.WeatherType;
@@ -233,6 +234,7 @@ public class ServerPlayer extends Player {
     private boolean disconnected;
     private int requestedViewDistance;
     public String language = "en_us"; // CraftBukkit - default
+    public java.util.Locale adventure$locale = java.util.Locale.US; // Paper
     @Nullable
     private Vec3 startingToFallPosition;
     @Nullable
@@ -265,6 +267,7 @@ public class ServerPlayer extends Player {
     // CraftBukkit start
     public CraftPlayer.TransferCookieConnection transferCookieConnection;
     public String displayName;
+    public net.kyori.adventure.text.Component adventure$displayName; // Paper
     public Component listName;
     public org.bukkit.Location compassTarget;
     public int newExp = 0;
@@ -350,6 +353,7 @@ public class ServerPlayer extends Player {
 
         // CraftBukkit start
         this.displayName = this.getScoreboardName();
+        this.adventure$displayName = net.kyori.adventure.text.Component.text(this.getScoreboardName()); // Paper
         this.bukkitPickUpLoot = true;
         this.maxHealthCache = this.getMaxHealth();
     }
@@ -903,22 +907,17 @@ public class ServerPlayer extends Player {
 
         String deathmessage = defaultMessage.getString();
         this.keepLevel = keepInventory; // SPIGOT-2222: pre-set keepLevel
-        org.bukkit.event.entity.PlayerDeathEvent event = CraftEventFactory.callPlayerDeathEvent(this, damageSource, loot, deathmessage, keepInventory);
+        org.bukkit.event.entity.PlayerDeathEvent event = CraftEventFactory.callPlayerDeathEvent(this, damageSource, loot, PaperAdventure.asAdventure(defaultMessage), keepInventory); // Paper - Adventure
 
         // SPIGOT-943 - only call if they have an inventory open
         if (this.containerMenu != this.inventoryMenu) {
             this.closeContainer();
         }
 
-        String deathMessage = event.getDeathMessage();
+        net.kyori.adventure.text.Component deathMessage = event.deathMessage() != null ? event.deathMessage() : net.kyori.adventure.text.Component.empty(); // Paper - Adventure
 
-        if (deathMessage != null && deathMessage.length() > 0 && flag) { // TODO: allow plugins to override?
-            Component ichatbasecomponent;
-            if (deathMessage.equals(deathmessage)) {
-                ichatbasecomponent = this.getCombatTracker().getDeathMessage();
-            } else {
-                ichatbasecomponent = org.bukkit.craftbukkit.util.CraftChatMessage.fromStringOrNull(deathMessage);
-            }
+        if (deathMessage != null && deathMessage != net.kyori.adventure.text.Component.empty() && flag) { // Paper - Adventure // TODO: allow plugins to override?
+            Component ichatbasecomponent = PaperAdventure.asVanilla(deathMessage); // Paper - Adventure
 
             this.connection.send(new ClientboundPlayerCombatKillPacket(this.getId(), ichatbasecomponent), PacketSendListener.exceptionallySend(() -> {
                 boolean flag1 = true;
@@ -1985,8 +1984,13 @@ public class ServerPlayer extends Player {
     }
 
     public void sendChatMessage(OutgoingChatMessage message, boolean filterMaskEnabled, ChatType.Bound params) {
+        // Paper start
+        this.sendChatMessage(message, filterMaskEnabled, params, null);
+    }
+    public void sendChatMessage(OutgoingChatMessage message, boolean filterMaskEnabled, ChatType.Bound params, @Nullable Component unsigned) {
+        // Paper end
         if (this.acceptsChatMessages()) {
-            message.sendToPlayer(this, filterMaskEnabled, params);
+            message.sendToPlayer(this, filterMaskEnabled, params, unsigned); // Paper
         }
 
     }
@@ -2013,6 +2017,7 @@ public class ServerPlayer extends Player {
         }
         // CraftBukkit end
         this.language = clientOptions.language();
+        this.adventure$locale = java.util.Objects.requireNonNullElse(net.kyori.adventure.translation.Translator.parseLocale(this.language), java.util.Locale.US); // Paper
         this.requestedViewDistance = clientOptions.viewDistance();
         this.chatVisibility = clientOptions.chatVisibility();
         this.canChatColor = clientOptions.chatColors();
diff --git a/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
index 6f17aeae2941c43205fa6db5950d65f510774104..26b8a69a528db8a836b138a2a223c385508ce2c4 100644
--- a/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
@@ -66,7 +66,7 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
     private static final Component TIMEOUT_DISCONNECTION_MESSAGE = Component.translatable("disconnect.timeout");
     static final Component DISCONNECT_UNEXPECTED_QUERY = Component.translatable("multiplayer.disconnect.unexpected_query_response");
     protected final MinecraftServer server;
-    protected final Connection connection;
+    public final Connection connection; // Paper
     private final boolean transferred;
     private long keepAliveTime;
     private boolean keepAlivePending;
@@ -75,6 +75,7 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
     private boolean closed = false;
     private int latency;
     private volatile boolean suspendFlushingOnServerThread = false;
+    public final java.util.Map<java.util.UUID, net.kyori.adventure.resource.ResourcePackCallback> packCallbacks = new java.util.concurrent.ConcurrentHashMap<>(); // Paper - adventure resource pack callbacks
 
     public ServerCommonPacketListenerImpl(MinecraftServer minecraftserver, Connection networkmanager, CommonListenerCookie commonlistenercookie, ServerPlayer player) { // CraftBukkit
         this.server = minecraftserver;
@@ -188,6 +189,18 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
             ServerCommonPacketListenerImpl.LOGGER.info("Disconnecting {} due to resource pack {} rejection", this.playerProfile().getName(), packet.id());
             this.disconnect(Component.translatable("multiplayer.requiredTexturePrompt.disconnect"));
         }
+        // Paper start - adventure pack callbacks
+        // call the callbacks before the previously-existing event so the event has final say
+        final net.kyori.adventure.resource.ResourcePackCallback callback;
+        if (packet.action().isTerminal()) {
+            callback = this.packCallbacks.remove(packet.id());
+        } else {
+            callback = this.packCallbacks.get(packet.id());
+        }
+        if (callback != null) {
+            callback.packEventReceived(packet.id(), net.kyori.adventure.resource.ResourcePackStatus.valueOf(packet.action().name()), this.getCraftPlayer());
+        }
+        // Paper end
         this.cserver.getPluginManager().callEvent(new PlayerResourcePackStatusEvent(this.getCraftPlayer(), packet.id(), PlayerResourcePackStatusEvent.Status.values()[packet.action().ordinal()])); // CraftBukkit
 
     }
@@ -276,12 +289,18 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
 
     // CraftBukkit start
     @Deprecated
-    public void disconnect(Component reason) {
-        this.disconnect(CraftChatMessage.fromComponent(reason));
+    public void disconnect(String s) { // Paper
+        this.disconnect(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(s)); // Paper
     }
     // CraftBukkit end
 
-    public void disconnect(String s) {
+    // Paper start
+    public void disconnect(final Component reason) {
+        this.disconnect(io.papermc.paper.adventure.PaperAdventure.asAdventure(reason));
+    }
+
+    public void disconnect(net.kyori.adventure.text.Component reason) {
+        // Paper end
         // CraftBukkit start - fire PlayerKickEvent
         if (this.processedDisconnect) {
             return;
@@ -290,7 +309,7 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
             Waitable waitable = new Waitable() {
                 @Override
                 protected Object evaluate() {
-                    ServerCommonPacketListenerImpl.this.disconnect(s);
+                    ServerCommonPacketListenerImpl.this.disconnect(reason); // Paper - adventure
                     return null;
                 }
             };
@@ -307,9 +326,9 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
             return;
         }
 
-        String leaveMessage = ChatFormatting.YELLOW + this.player.getScoreboardName() + " left the game.";
+        net.kyori.adventure.text.Component leaveMessage = net.kyori.adventure.text.Component.translatable("multiplayer.player.left", net.kyori.adventure.text.format.NamedTextColor.YELLOW, io.papermc.paper.configuration.GlobalConfiguration.get().messages.useDisplayNameInQuitMessage ? this.player.getBukkitEntity().displayName() : net.kyori.adventure.text.Component.text(this.player.getScoreboardName())); // Paper - Adventure
 
-        PlayerKickEvent event = new PlayerKickEvent(this.player.getBukkitEntity(), s, leaveMessage);
+        PlayerKickEvent event = new PlayerKickEvent(this.player.getBukkitEntity(), reason, leaveMessage); // Paper - adventure
 
         if (this.cserver.getServer().isRunning()) {
             this.cserver.getPluginManager().callEvent(event);
@@ -321,7 +340,7 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
         }
         this.player.kickLeaveMessage = event.getLeaveMessage(); // CraftBukkit - SPIGOT-3034: Forward leave message to PlayerQuitEvent
         // Send the possibly modified leave message
-        final Component ichatbasecomponent = CraftChatMessage.fromString(event.getReason(), true)[0];
+        final Component ichatbasecomponent = io.papermc.paper.adventure.PaperAdventure.asVanilla(event.reason()); // Paper - Adventure
         // CraftBukkit end
 
         this.connection.send(new ClientboundDisconnectPacket(ichatbasecomponent), PacketSendListener.thenRun(() -> {
diff --git a/src/main/java/net/minecraft/server/network/ServerConfigurationPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerConfigurationPacketListenerImpl.java
index bd7107279ca004f35c932e5d6e82f8302ec781ae..970d1ddf0a014b47b0ac97440489706137324991 100644
--- a/src/main/java/net/minecraft/server/network/ServerConfigurationPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerConfigurationPacketListenerImpl.java
@@ -100,6 +100,7 @@ public class ServerConfigurationPacketListenerImpl extends ServerCommonPacketLis
     @Override
     public void handleClientInformation(ServerboundClientInformationPacket packet) {
         this.clientInformation = packet.information();
+        this.connection.channel.attr(io.papermc.paper.adventure.PaperAdventure.LOCALE_ATTRIBUTE).set(net.kyori.adventure.translation.Translator.parseLocale(packet.information().language())); // Paper
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 912fe77278ba085ef9cea7187e43a3ad3bb2e0d5..7788f703c47480b009b26c23fa5e075b581c3aca 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -44,6 +44,7 @@ import net.minecraft.core.registries.Registries;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.Connection;
 import net.minecraft.network.TickablePacketListener;
+import net.minecraft.network.chat.ChatDecorator;
 import net.minecraft.network.chat.ChatType;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.LastSeenMessages;
@@ -195,6 +196,8 @@ import net.minecraft.world.phys.shapes.VoxelShape;
 import org.slf4j.Logger;
 
 // CraftBukkit start
+import io.papermc.paper.adventure.ChatProcessor; // Paper
+import io.papermc.paper.adventure.PaperAdventure; // Paper
 import com.mojang.datafixers.util.Pair;
 import java.util.Arrays;
 import java.util.concurrent.ExecutionException;
@@ -1711,9 +1714,11 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         */
 
         this.player.disconnect();
-        String quitMessage = this.server.getPlayerList().remove(this.player);
-        if ((quitMessage != null) && (quitMessage.length() > 0)) {
-            this.server.getPlayerList().broadcastMessage(CraftChatMessage.fromString(quitMessage));
+        // Paper start - Adventure
+        net.kyori.adventure.text.Component quitMessage = this.server.getPlayerList().remove(this.player);
+        if ((quitMessage != null) && !quitMessage.equals(net.kyori.adventure.text.Component.empty())) {
+            this.server.getPlayerList().broadcastSystemMessage(PaperAdventure.asVanilla(quitMessage), false);
+            // Paper end
         }
         // CraftBukkit end
         this.player.getTextFilter().leave();
@@ -1774,10 +1779,10 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                 }
 
                 CompletableFuture<FilteredText> completablefuture = this.filterTextPacket(playerchatmessage.signedContent()).thenApplyAsync(Function.identity(), this.server.chatExecutor); // CraftBukkit - async chat
-                Component ichatbasecomponent = this.server.getChatDecorator().decorate(this.player, playerchatmessage.decoratedContent());
+                CompletableFuture<Component> componentFuture = this.server.getChatDecorator().decorate(this.player, null, playerchatmessage.decoratedContent()); // Paper - Adventure
 
-                this.chatMessageChain.append(completablefuture, (filteredtext) -> {
-                    PlayerChatMessage playerchatmessage1 = playerchatmessage.withUnsignedContent(ichatbasecomponent).filter(filteredtext.mask());
+                this.chatMessageChain.append(CompletableFuture.allOf(completablefuture, componentFuture), (filteredtext) -> { // Paper - Adventure
+                    PlayerChatMessage playerchatmessage1 = playerchatmessage.withUnsignedContent(componentFuture.join()).filter(completablefuture.join().mask()); // Paper - Adventure
 
                     this.broadcastChatMessage(playerchatmessage1);
                 });
@@ -1997,7 +2002,15 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
             this.handleCommand(s);
         } else if (this.player.getChatVisibility() == ChatVisiblity.SYSTEM) {
             // Do nothing, this is coming from a plugin
-        } else {
+        // Paper start
+        } else if (true) {
+            if (!async && !org.bukkit.Bukkit.isPrimaryThread()) {
+                org.spigotmc.AsyncCatcher.catchOp("Asynchronous player chat is not allowed here");
+            }
+            final ChatProcessor cp = new ChatProcessor(this.server, this.player, original, async);
+            cp.process();
+            // Paper end
+        } else if (false) { // Paper
             Player player = this.getCraftPlayer();
             AsyncPlayerChatEvent event = new AsyncPlayerChatEvent(async, player, s, new LazyPlayerSet(this.server));
             String originalFormat = event.getFormat(), originalMessage = event.getMessage();
@@ -2994,6 +3007,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     public void handleClientInformation(ServerboundClientInformationPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
         this.player.updateOptions(packet.information());
+        this.connection.channel.attr(io.papermc.paper.adventure.PaperAdventure.LOCALE_ATTRIBUTE).set(net.kyori.adventure.translation.Translator.parseLocale(packet.information().language())); // Paper
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
index 47a1c62dd6f927cb01f679a597d1526bbca9e433..7beda9a16addb2dbcd4bdc45e58b343e91323af5 100644
--- a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -331,7 +331,7 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
         if (PlayerPreLoginEvent.getHandlerList().getRegisteredListeners().length != 0) {
             final PlayerPreLoginEvent event = new PlayerPreLoginEvent(playerName, address, uniqueId);
             if (asyncEvent.getResult() != PlayerPreLoginEvent.Result.ALLOWED) {
-                event.disallow(asyncEvent.getResult(), asyncEvent.getKickMessage());
+                event.disallow(asyncEvent.getResult(), asyncEvent.kickMessage()); // Paper - Adventure
             }
             Waitable<PlayerPreLoginEvent.Result> waitable = new Waitable<PlayerPreLoginEvent.Result>() {
                 @Override
@@ -343,12 +343,12 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
 
             ServerLoginPacketListenerImpl.this.server.processQueue.add(waitable);
             if (waitable.get() != PlayerPreLoginEvent.Result.ALLOWED) {
-                this.disconnect(event.getKickMessage());
+                this.disconnect(io.papermc.paper.adventure.PaperAdventure.asVanilla(event.kickMessage())); // Paper - Adventure
                 return;
             }
         } else {
             if (asyncEvent.getLoginResult() != AsyncPlayerPreLoginEvent.Result.ALLOWED) {
-                this.disconnect(asyncEvent.getKickMessage());
+                this.disconnect(io.papermc.paper.adventure.PaperAdventure.asVanilla(asyncEvent.kickMessage())); // Paper - Adventure
                 return;
             }
         }
diff --git a/src/main/java/net/minecraft/server/network/ServerStatusPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerStatusPacketListenerImpl.java
index a4d8d4400a1f6f6d05a3c362f2bc4a391d4ee9a1..9e62aa13845f19faf0dc0b7b27d958626e77d96e 100644
--- a/src/main/java/net/minecraft/server/network/ServerStatusPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerStatusPacketListenerImpl.java
@@ -57,7 +57,7 @@ public class ServerStatusPacketListenerImpl implements ServerStatusPacketListene
                 CraftIconCache icon = server.server.getServerIcon();
 
                 ServerListPingEvent() {
-                    super(ServerStatusPacketListenerImpl.this.connection.hostname, ((InetSocketAddress) ServerStatusPacketListenerImpl.this.connection.getRemoteAddress()).getAddress(), server.getMotd(), server.getPlayerList().getMaxPlayers());
+                    super(ServerStatusPacketListenerImpl.this.connection.hostname, ((InetSocketAddress) ServerStatusPacketListenerImpl.this.connection.getRemoteAddress()).getAddress(), server.server.motd(), server.getPlayerList().getMaxPlayers()); // Paper - Adventure
                 }
 
                 @Override
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 54fee00a462c2f6fcc567d762b1afd24cf5c7d06..0ff094a90bf471ce57a3054c7701dc3d67742d9d 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -271,7 +271,7 @@ public abstract class PlayerList {
         }
         // CraftBukkit start
         ichatmutablecomponent.withStyle(ChatFormatting.YELLOW);
-        String joinMessage = CraftChatMessage.fromComponent(ichatmutablecomponent);
+        Component joinMessage = ichatmutablecomponent; // Paper - Adventure
 
         playerconnection.teleport(player.getX(), player.getY(), player.getZ(), player.getYRot(), player.getXRot());
         ServerStatus serverping = this.server.getStatus();
@@ -292,19 +292,18 @@ public abstract class PlayerList {
         // Ensure that player inventory is populated with its viewer
         player.containerMenu.transferTo(player.containerMenu, bukkitPlayer);
 
-        PlayerJoinEvent playerJoinEvent = new PlayerJoinEvent(bukkitPlayer, joinMessage);
+        PlayerJoinEvent playerJoinEvent = new PlayerJoinEvent(bukkitPlayer, io.papermc.paper.adventure.PaperAdventure.asAdventure(ichatmutablecomponent)); // Paper - Adventure
         this.cserver.getPluginManager().callEvent(playerJoinEvent);
 
         if (!player.connection.isAcceptingMessages()) {
             return;
         }
 
-        joinMessage = playerJoinEvent.getJoinMessage();
+        final net.kyori.adventure.text.Component jm = playerJoinEvent.joinMessage();
 
-        if (joinMessage != null && joinMessage.length() > 0) {
-            for (Component line : org.bukkit.craftbukkit.util.CraftChatMessage.fromString(joinMessage)) {
-                this.server.getPlayerList().broadcastSystemMessage(line, false);
-            }
+        if (jm != null && !jm.equals(net.kyori.adventure.text.Component.empty())) { // Paper - Adventure
+            joinMessage = io.papermc.paper.adventure.PaperAdventure.asVanilla(jm); // Paper - Adventure
+            this.server.getPlayerList().broadcastSystemMessage(joinMessage, false); // Paper - Adventure
         }
         // CraftBukkit end
 
@@ -499,7 +498,7 @@ public abstract class PlayerList {
 
     }
 
-    public String remove(ServerPlayer entityplayer) { // CraftBukkit - return string
+    public net.kyori.adventure.text.Component remove(ServerPlayer entityplayer) { // CraftBukkit - return string // Paper - return Component
         ServerLevel worldserver = entityplayer.serverLevel();
 
         entityplayer.awardStat(Stats.LEAVE_GAME);
@@ -510,7 +509,7 @@ public abstract class PlayerList {
             entityplayer.closeContainer();
         }
 
-        PlayerQuitEvent playerQuitEvent = new PlayerQuitEvent(entityplayer.getBukkitEntity(), entityplayer.kickLeaveMessage != null ? entityplayer.kickLeaveMessage : "\u00A7e" + entityplayer.getScoreboardName() + " left the game");
+        PlayerQuitEvent playerQuitEvent = new PlayerQuitEvent(entityplayer.getBukkitEntity(), net.kyori.adventure.text.Component.translatable("multiplayer.player.left", net.kyori.adventure.text.format.NamedTextColor.YELLOW, io.papermc.paper.configuration.GlobalConfiguration.get().messages.useDisplayNameInQuitMessage ? entityplayer.getBukkitEntity().displayName() : io.papermc.paper.adventure.PaperAdventure.asAdventure(entityplayer.getDisplayName()))); // Paper - Adventure
         this.cserver.getPluginManager().callEvent(playerQuitEvent);
         entityplayer.getBukkitEntity().disconnect(playerQuitEvent.getQuitMessage());
 
@@ -563,7 +562,7 @@ public abstract class PlayerList {
         this.cserver.getScoreboardManager().removePlayer(entityplayer.getBukkitEntity());
         // CraftBukkit end
 
-        return playerQuitEvent.getQuitMessage(); // CraftBukkit
+        return playerQuitEvent.quitMessage(); // Paper - Adventure
     }
 
     // CraftBukkit start - Whole method, SocketAddress to LoginListener, added hostname to signature, return EntityPlayer
@@ -610,11 +609,11 @@ public abstract class PlayerList {
             }
 
             // return chatmessage;
-            event.disallow(PlayerLoginEvent.Result.KICK_BANNED, CraftChatMessage.fromComponent(ichatmutablecomponent));
+            event.disallow(PlayerLoginEvent.Result.KICK_BANNED, io.papermc.paper.adventure.PaperAdventure.asAdventure(ichatmutablecomponent)); // Paper - Adventure
         } else if (!this.isWhiteListed(gameprofile)) {
             ichatmutablecomponent = Component.translatable("multiplayer.disconnect.not_whitelisted");
-            event.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, org.spigotmc.SpigotConfig.whitelistMessage); // Spigot
-        } else if (this.ipBans.isBanned(socketaddress)) {
+            event.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.whitelistMessage)); // Spigot // Paper - Adventure
+        } else if (this.getIpBans().isBanned(socketaddress) && !this.getIpBans().get(socketaddress).hasExpired()) {
             IpBanListEntry ipbanentry = this.ipBans.get(socketaddress);
 
             ichatmutablecomponent = Component.translatable("multiplayer.disconnect.banned_ip.reason", ipbanentry.getReason());
@@ -623,17 +622,17 @@ public abstract class PlayerList {
             }
 
             // return chatmessage;
-            event.disallow(PlayerLoginEvent.Result.KICK_BANNED, CraftChatMessage.fromComponent(ichatmutablecomponent));
+            event.disallow(PlayerLoginEvent.Result.KICK_BANNED, io.papermc.paper.adventure.PaperAdventure.asAdventure(ichatmutablecomponent)); // Paper - Adventure
         } else {
             // return this.players.size() >= this.maxPlayers && !this.canBypassPlayerLimit(gameprofile) ? IChatBaseComponent.translatable("multiplayer.disconnect.server_full") : null;
             if (this.players.size() >= this.maxPlayers && !this.canBypassPlayerLimit(gameprofile)) {
-                event.disallow(PlayerLoginEvent.Result.KICK_FULL, org.spigotmc.SpigotConfig.serverFullMessage); // Spigot
+                event.disallow(PlayerLoginEvent.Result.KICK_FULL, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.serverFullMessage)); // Spigot // Paper - Adventure
             }
         }
 
         this.cserver.getPluginManager().callEvent(event);
         if (event.getResult() != PlayerLoginEvent.Result.ALLOWED) {
-            loginlistener.disconnect(event.getKickMessage());
+            loginlistener.disconnect(io.papermc.paper.adventure.PaperAdventure.asVanilla(event.kickMessage())); // Paper - Adventure
             return null;
         }
         return entity;
@@ -1153,7 +1152,7 @@ public abstract class PlayerList {
     public void removeAll() {
         // CraftBukkit start - disconnect safely
         for (ServerPlayer player : this.players) {
-            player.connection.disconnect(this.server.server.getShutdownMessage()); // CraftBukkit - add custom shutdown message
+            player.connection.disconnect(this.server.server.shutdownMessage()); // CraftBukkit - add custom shutdown message // Paper - Adventure
         }
         // CraftBukkit end
 
@@ -1194,24 +1193,43 @@ public abstract class PlayerList {
     }
 
     public void broadcastChatMessage(PlayerChatMessage message, ServerPlayer sender, ChatType.Bound params) {
+        // Paper start
+        this.broadcastChatMessage(message, sender, params, null);
+    }
+    public void broadcastChatMessage(PlayerChatMessage message, ServerPlayer sender, ChatType.Bound params, @Nullable Function<net.kyori.adventure.audience.Audience, Component> unsignedFunction) {
+        // Paper end
         Objects.requireNonNull(sender);
-        this.broadcastChatMessage(message, sender::shouldFilterMessageTo, sender, params);
+        this.broadcastChatMessage(message, sender::shouldFilterMessageTo, sender, params, unsignedFunction); // Paper
     }
 
     private void broadcastChatMessage(PlayerChatMessage message, Predicate<ServerPlayer> shouldSendFiltered, @Nullable ServerPlayer sender, ChatType.Bound params) {
+        // Paper start
+        this.broadcastChatMessage(message, shouldSendFiltered, sender, params, null);
+    }
+    public void broadcastChatMessage(PlayerChatMessage message, Predicate<ServerPlayer> shouldSendFiltered, @Nullable ServerPlayer sender, ChatType.Bound params, @Nullable Function<net.kyori.adventure.audience.Audience, Component> unsignedFunction) {
+        // Paper end
         boolean flag = this.verifyChatTrusted(message);
 
-        this.server.logChatMessage(message.decoratedContent(), params, flag ? null : "Not Secure");
+        this.server.logChatMessage((unsignedFunction == null ? message.decoratedContent() : unsignedFunction.apply(this.server.console)), params, flag ? null : "Not Secure"); // Paper
         OutgoingChatMessage outgoingchatmessage = OutgoingChatMessage.create(message);
         boolean flag1 = false;
 
         boolean flag2;
+        Packet<?> disguised = sender != null && unsignedFunction == null ? new net.minecraft.network.protocol.game.ClientboundDisguisedChatPacket(outgoingchatmessage.content(), params) : null; // Paper - don't send player chat packets from vanished players
 
         for (Iterator iterator = this.players.iterator(); iterator.hasNext(); flag1 |= flag2 && message.isFullyFiltered()) {
             ServerPlayer entityplayer1 = (ServerPlayer) iterator.next();
 
             flag2 = shouldSendFiltered.test(entityplayer1);
-            entityplayer1.sendChatMessage(outgoingchatmessage, flag2, params);
+            // Paper start - don't send player chat packets from vanished players
+            if (sender != null && !entityplayer1.getBukkitEntity().canSee(sender.getBukkitEntity())) {
+                entityplayer1.connection.send(unsignedFunction != null
+                    ? new net.minecraft.network.protocol.game.ClientboundDisguisedChatPacket(unsignedFunction.apply(entityplayer1.getBukkitEntity()), params)
+                    : disguised);
+                continue;
+            }
+            // Paper end
+            entityplayer1.sendChatMessage(outgoingchatmessage, flag2, params, unsignedFunction == null ? null : unsignedFunction.apply(entityplayer1.getBukkitEntity())); // Paper
         }
 
         if (flag1 && sender != null) {
@@ -1220,7 +1238,7 @@ public abstract class PlayerList {
 
     }
 
-    private boolean verifyChatTrusted(PlayerChatMessage message) {
+    public boolean verifyChatTrusted(PlayerChatMessage message) { // Paper - private -> public
         return message.hasSignature() && !message.hasExpiredServer(Instant.now());
     }
 
diff --git a/src/main/java/net/minecraft/world/BossEvent.java b/src/main/java/net/minecraft/world/BossEvent.java
index ed54c81a3269360acce674aa4e1d54ccb2461841..c9c849534c3998cfcab7ddcb12a71ccb1fdb3e1a 100644
--- a/src/main/java/net/minecraft/world/BossEvent.java
+++ b/src/main/java/net/minecraft/world/BossEvent.java
@@ -13,6 +13,7 @@ public abstract class BossEvent {
     protected boolean darkenScreen;
     protected boolean playBossMusic;
     protected boolean createWorldFog;
+    public net.kyori.adventure.bossbar.BossBar adventure; // Paper
 
     public BossEvent(UUID uuid, Component name, BossEvent.BossBarColor color, BossEvent.BossBarOverlay style) {
         this.id = uuid;
@@ -27,61 +28,75 @@ public abstract class BossEvent {
     }
 
     public Component getName() {
+        if (this.adventure != null) return io.papermc.paper.adventure.PaperAdventure.asVanilla(this.adventure.name()); // Paper
         return this.name;
     }
 
     public void setName(Component name) {
+        if (this.adventure != null) this.adventure.name(io.papermc.paper.adventure.PaperAdventure.asAdventure(name)); // Paper
         this.name = name;
     }
 
     public float getProgress() {
+        if (this.adventure != null) return this.adventure.progress(); // Paper
         return this.progress;
     }
 
     public void setProgress(float percent) {
+        if (this.adventure != null) this.adventure.progress(percent); // Paper
         this.progress = percent;
     }
 
     public BossEvent.BossBarColor getColor() {
+        if (this.adventure != null) return io.papermc.paper.adventure.PaperAdventure.asVanilla(this.adventure.color()); // Paper
         return this.color;
     }
 
     public void setColor(BossEvent.BossBarColor color) {
+        if (this.adventure != null) this.adventure.color(io.papermc.paper.adventure.PaperAdventure.asAdventure(color)); // Paper
         this.color = color;
     }
 
     public BossEvent.BossBarOverlay getOverlay() {
+        if (this.adventure != null) return io.papermc.paper.adventure.PaperAdventure.asVanilla(this.adventure.overlay()); // Paper
         return this.overlay;
     }
 
     public void setOverlay(BossEvent.BossBarOverlay style) {
+        if (this.adventure != null) this.adventure.overlay(io.papermc.paper.adventure.PaperAdventure.asAdventure(style)); // Paper
         this.overlay = style;
     }
 
     public boolean shouldDarkenScreen() {
+        if (this.adventure != null) return this.adventure.hasFlag(net.kyori.adventure.bossbar.BossBar.Flag.DARKEN_SCREEN); // Paper
         return this.darkenScreen;
     }
 
     public BossEvent setDarkenScreen(boolean darkenSky) {
+        if (this.adventure != null) io.papermc.paper.adventure.PaperAdventure.setFlag(this.adventure, net.kyori.adventure.bossbar.BossBar.Flag.DARKEN_SCREEN, darkenSky); // Paper
         this.darkenScreen = darkenSky;
         return this;
     }
 
     public boolean shouldPlayBossMusic() {
+        if (this.adventure != null) return this.adventure.hasFlag(net.kyori.adventure.bossbar.BossBar.Flag.PLAY_BOSS_MUSIC); // Paper
         return this.playBossMusic;
     }
 
     public BossEvent setPlayBossMusic(boolean dragonMusic) {
+        if (this.adventure != null) io.papermc.paper.adventure.PaperAdventure.setFlag(this.adventure, net.kyori.adventure.bossbar.BossBar.Flag.PLAY_BOSS_MUSIC, dragonMusic); // Paper
         this.playBossMusic = dragonMusic;
         return this;
     }
 
     public BossEvent setCreateWorldFog(boolean thickenFog) {
+        if (this.adventure != null) io.papermc.paper.adventure.PaperAdventure.setFlag(this.adventure, net.kyori.adventure.bossbar.BossBar.Flag.CREATE_WORLD_FOG, thickenFog); // Paper
         this.createWorldFog = thickenFog;
         return this;
     }
 
     public boolean shouldCreateWorldFog() {
+        if (this.adventure != null) return this.adventure.hasFlag(net.kyori.adventure.bossbar.BossBar.Flag.CREATE_WORLD_FOG); // Paper
         return this.createWorldFog;
     }
 
diff --git a/src/main/java/net/minecraft/world/item/ItemStack.java b/src/main/java/net/minecraft/world/item/ItemStack.java
index d7f427bf5c84d1bb405e4aaf16e3a8f1fed5ad79..e65a5abfaac1f68bbefe0b7f3877823a548d56cc 100644
--- a/src/main/java/net/minecraft/world/item/ItemStack.java
+++ b/src/main/java/net/minecraft/world/item/ItemStack.java
@@ -186,7 +186,15 @@ public final class ItemStack implements DataComponentHolder {
                 CraftItemStack.setItemMeta(itemstack, CraftItemStack.getItemMeta(itemstack));
                 // Spigot end
                 ITEM_STREAM_CODEC.encode(registryfriendlybytebuf, itemstack.getItemHolder()); // CraftBukkit - decompile error
+                // Paper start - adventure; conditionally render translatable components
+                boolean prev = net.minecraft.network.chat.ComponentSerialization.DONT_RENDER_TRANSLATABLES.get();
+                try {
+                    net.minecraft.network.chat.ComponentSerialization.DONT_RENDER_TRANSLATABLES.set(true);
                 DataComponentPatch.STREAM_CODEC.encode(registryfriendlybytebuf, itemstack.components.asPatch());
+                } finally {
+                    net.minecraft.network.chat.ComponentSerialization.DONT_RENDER_TRANSLATABLES.set(prev);
+                }
+                // Paper end - adventure; conditionally render translatable components
             }
         }
     };
diff --git a/src/main/java/net/minecraft/world/level/block/entity/SignBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/SignBlockEntity.java
index 8ec376f453ac1f4c9423483f5ae1625b295858c7..e535fb3b5194b8412c0c26c0799340916c7542eb 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/SignBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/SignBlockEntity.java
@@ -210,22 +210,22 @@ public class SignBlockEntity extends BlockEntity implements CommandSource { // C
 
         // CraftBukkit start
         Player player = ((ServerPlayer) entityhuman).getBukkitEntity();
-        String[] lines = new String[4];
+        List<net.kyori.adventure.text.Component> lines = new java.util.ArrayList<>(); // Paper - adventure
 
         for (int i = 0; i < list.size(); ++i) {
-            lines[i] = CraftChatMessage.fromComponent(signtext.getMessage(i, entityhuman.isTextFilteringEnabled()));
+            lines.add(io.papermc.paper.adventure.PaperAdventure.asAdventure(signtext.getMessage(i, entityhuman.isTextFilteringEnabled()))); // Paper - Adventure
         }
 
-        SignChangeEvent event = new SignChangeEvent(CraftBlock.at(this.level, this.worldPosition), player, lines.clone(), (front) ? Side.FRONT : Side.BACK);
+        SignChangeEvent event = new SignChangeEvent(CraftBlock.at(this.level, this.worldPosition), player, new java.util.ArrayList<>(lines), (front) ? Side.FRONT : Side.BACK); // Paper - Adventure
         entityhuman.level().getCraftServer().getPluginManager().callEvent(event);
 
         if (event.isCancelled()) {
             return originalText;
         }
 
-        Component[] components = org.bukkit.craftbukkit.block.CraftSign.sanitizeLines(event.getLines());
+        Component[] components = org.bukkit.craftbukkit.block.CraftSign.sanitizeLines(event.lines()); // Paper - Adventure
         for (int i = 0; i < components.length; i++) {
-            if (!Objects.equals(lines[i], event.getLine(i))) {
+            if (!Objects.equals(lines.get(i), event.line(i))) { // Paper - Adventure
                 signtext = signtext.setMessage(i, components[i]);
             }
         }
diff --git a/src/main/java/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java b/src/main/java/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
index 3db3c6858d98d2eaf7c9bd8d395b83b22c447bb9..d42d39dff5aeb91c5b1e6a7fb967ce70f1a88b7e 100644
--- a/src/main/java/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
+++ b/src/main/java/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
@@ -45,6 +45,7 @@ import net.minecraft.world.level.saveddata.SavedData;
 import org.slf4j.Logger;
 
 // CraftBukkit start
+import io.papermc.paper.adventure.PaperAdventure; // Paper
 import java.util.UUID;
 import org.bukkit.Bukkit;
 import org.bukkit.craftbukkit.CraftServer;
@@ -610,7 +611,7 @@ public class MapItemSavedData extends SavedData {
 
                 for (org.bukkit.map.MapCursor cursor : render.cursors) {
                     if (cursor.isVisible()) {
-                        icons.add(new MapDecoration(CraftMapCursor.CraftType.bukkitToMinecraftHolder(cursor.getType()), cursor.getX(), cursor.getY(), cursor.getDirection(), CraftChatMessage.fromStringOrOptional(cursor.getCaption())));
+                        icons.add(new MapDecoration(CraftMapCursor.CraftType.bukkitToMinecraftHolder(cursor.getType()), cursor.getX(), cursor.getY(), cursor.getDirection(), Optional.ofNullable(PaperAdventure.asVanilla(cursor.caption()))));
                     }
                 }
                 collection = icons;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 69d27337f13ca85ba74d611a0ca635c8af1d694e..beff0bfe2502a17fd297524c51f96b33f889db93 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -633,8 +633,10 @@ public final class CraftServer implements Server {
     }
 
     @Override
+    @Deprecated // Paper start
     public int broadcastMessage(String message) {
         return this.broadcast(message, BROADCAST_CHANNEL_USERS);
+        // Paper end
     }
 
     @Override
@@ -1610,7 +1612,15 @@ public final class CraftServer implements Server {
         return this.configuration.getInt("settings.spawn-radius", -1);
     }
 
+    // Paper start
+    @Override
+    public net.kyori.adventure.text.Component shutdownMessage() {
+        String msg = getShutdownMessage();
+        return msg != null ? net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(msg) : null;
+    }
+    // Paper end
     @Override
+    @Deprecated // Paper
     public String getShutdownMessage() {
         return this.configuration.getString("settings.shutdown-message");
     }
@@ -1784,7 +1794,20 @@ public final class CraftServer implements Server {
     }
 
     @Override
+    @Deprecated // Paper
     public int broadcast(String message, String permission) {
+        // Paper start - Adventure
+        return this.broadcast(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(message), permission);
+    }
+
+    @Override
+    public int broadcast(net.kyori.adventure.text.Component message) {
+        return this.broadcast(message, BROADCAST_CHANNEL_USERS);
+    }
+
+    @Override
+    public int broadcast(net.kyori.adventure.text.Component message, String permission) {
+        // Paper end
         Set<CommandSender> recipients = new HashSet<>();
         for (Permissible permissible : this.getPluginManager().getPermissionSubscriptions(permission)) {
             if (permissible instanceof CommandSender && permissible.hasPermission(permission)) {
@@ -1792,14 +1815,14 @@ public final class CraftServer implements Server {
             }
         }
 
-        BroadcastMessageEvent broadcastMessageEvent = new BroadcastMessageEvent(!Bukkit.isPrimaryThread(), message, recipients);
+        BroadcastMessageEvent broadcastMessageEvent = new BroadcastMessageEvent(!Bukkit.isPrimaryThread(), message, recipients); // Paper - Adventure
         this.getPluginManager().callEvent(broadcastMessageEvent);
 
         if (broadcastMessageEvent.isCancelled()) {
             return 0;
         }
 
-        message = broadcastMessageEvent.getMessage();
+        message = broadcastMessageEvent.message(); // Paper - Adventure
 
         for (CommandSender recipient : recipients) {
             recipient.sendMessage(message);
@@ -2061,6 +2084,14 @@ public final class CraftServer implements Server {
         return CraftInventoryCreator.INSTANCE.createInventory(owner, type);
     }
 
+    // Paper start
+    @Override
+    public Inventory createInventory(InventoryHolder owner, InventoryType type, net.kyori.adventure.text.Component title) {
+        Preconditions.checkArgument(type.isCreatable(), "Cannot open an inventory of type ", type);
+        return CraftInventoryCreator.INSTANCE.createInventory(owner, type, title);
+    }
+    // Paper end
+
     @Override
     public Inventory createInventory(InventoryHolder owner, InventoryType type, String title) {
         Preconditions.checkArgument(type != null, "InventoryType cannot be null");
@@ -2075,13 +2106,28 @@ public final class CraftServer implements Server {
         return CraftInventoryCreator.INSTANCE.createInventory(owner, size);
     }
 
+    // Paper start
+    @Override
+    public Inventory createInventory(InventoryHolder owner, int size, net.kyori.adventure.text.Component title) throws IllegalArgumentException {
+        Preconditions.checkArgument(9 <= size && size <= 54 && size % 9 == 0, "Size for custom inventory must be a multiple of 9 between 9 and 54 slots (got " + size + ")");
+        return CraftInventoryCreator.INSTANCE.createInventory(owner, size, title);
+    }
+    // Paper end
+
     @Override
     public Inventory createInventory(InventoryHolder owner, int size, String title) throws IllegalArgumentException {
         Preconditions.checkArgument(9 <= size && size <= 54 && size % 9 == 0, "Size for custom inventory must be a multiple of 9 between 9 and 54 slots (got %s)", size);
         return CraftInventoryCreator.INSTANCE.createInventory(owner, size, title);
     }
 
+    // Paper start
+    @Override
+    public Merchant createMerchant(net.kyori.adventure.text.Component title) {
+        return new org.bukkit.craftbukkit.inventory.CraftMerchantCustom(title == null ? InventoryType.MERCHANT.defaultTitle() : title);
+    }
+    // Paper end
     @Override
+    @Deprecated // Paper
     public Merchant createMerchant(String title) {
         return new CraftMerchantCustom(title == null ? InventoryType.MERCHANT.getDefaultTitle() : title);
     }
@@ -2146,6 +2192,17 @@ public final class CraftServer implements Server {
         return Thread.currentThread().equals(this.console.serverThread) || this.console.hasStopped() || !org.spigotmc.AsyncCatcher.enabled; // All bets are off if we have shut down (e.g. due to watchdog)
     }
 
+    // Paper start - Adventure
+    @Override
+    public net.kyori.adventure.text.Component motd() {
+        return this.console.motd();
+    }
+    @Override
+    public void motd(final net.kyori.adventure.text.Component motd) {
+        this.console.motd(motd);
+    }
+    // Paper end
+
     @Override
     public String getMotd() {
         return this.console.getMotd();
@@ -2590,4 +2647,57 @@ public final class CraftServer implements Server {
     public double[] getTPS() {
         return new double[]{0, 0, 0}; // TODO
     }
+
+    // Paper start - adventure sounds
+    @Override
+    public void playSound(final net.kyori.adventure.sound.Sound sound) {
+        if (sound.seed().isEmpty()) org.spigotmc.AsyncCatcher.catchOp("play sound; cannot generate seed with world random"); // Paper
+        final long seed = sound.seed().orElseGet(this.console.overworld().getRandom()::nextLong);
+        for (ServerPlayer player : this.playerList.getPlayers()) {
+            player.connection.send(io.papermc.paper.adventure.PaperAdventure.asSoundPacket(sound, player.getX(), player.getY(), player.getZ(), seed, null));
+        }
+    }
+
+    @Override
+    public void playSound(final net.kyori.adventure.sound.Sound sound, final double x, final double y, final double z) {
+        org.spigotmc.AsyncCatcher.catchOp("play sound"); // Paper
+        io.papermc.paper.adventure.PaperAdventure.asSoundPacket(sound, x, y, z, sound.seed().orElseGet(this.console.overworld().getRandom()::nextLong), this.playSound0(x, y, z, this.console.getAllLevels()));
+    }
+
+    @Override
+    public void playSound(final net.kyori.adventure.sound.Sound sound, final net.kyori.adventure.sound.Sound.Emitter emitter) {
+        if (sound.seed().isEmpty()) org.spigotmc.AsyncCatcher.catchOp("play sound; cannot generate seed with world random"); // Paper
+        final long seed = sound.seed().orElseGet(this.console.overworld().getRandom()::nextLong);
+        if (emitter == net.kyori.adventure.sound.Sound.Emitter.self()) {
+            for (ServerPlayer player : this.playerList.getPlayers()) {
+                player.connection.send(io.papermc.paper.adventure.PaperAdventure.asSoundPacket(sound, player, seed, null));
+            }
+        } else if (emitter instanceof org.bukkit.craftbukkit.entity.CraftEntity craftEntity) {
+            org.spigotmc.AsyncCatcher.catchOp("play sound; cannot use entity emitter"); // Paper
+            final net.minecraft.world.entity.Entity entity = craftEntity.getHandle();
+            io.papermc.paper.adventure.PaperAdventure.asSoundPacket(sound, entity, seed, this.playSound0(entity.getX(), entity.getY(), entity.getZ(), List.of((ServerLevel) entity.level())));
+        } else {
+            throw new IllegalArgumentException("Sound emitter must be an Entity or self(), but was: " + emitter);
+        }
+    }
+
+    private java.util.function.BiConsumer<net.minecraft.network.protocol.Packet<?>, Float> playSound0(final double x, final double y, final double z, final Iterable<ServerLevel> levels) {
+        return (packet, distance) -> {
+            for (final ServerLevel level : levels) {
+                level.getServer().getPlayerList().broadcast(null, x, y, z, distance, level.dimension(), packet);
+            }
+        };
+    }
+    // Paper end
+
+    // Paper start
+    private Iterable<? extends net.kyori.adventure.audience.Audience> adventure$audiences;
+    @Override
+    public Iterable<? extends net.kyori.adventure.audience.Audience> audiences() {
+        if (this.adventure$audiences == null) {
+            this.adventure$audiences = com.google.common.collect.Iterables.concat(java.util.Collections.singleton(this.getConsoleSender()), this.getOnlinePlayers());
+        }
+        return this.adventure$audiences;
+    }
+    // Paper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index bd32f4e6ab8c41404ebcc8ef3b448c71db7b0650..ee5b61c476abc1f9a2babf350ac9dfa45b2c3253 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -162,6 +162,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     private final BlockMetadataStore blockMetadata = new BlockMetadataStore(this);
     private final Object2IntOpenHashMap<SpawnCategory> spawnCategoryLimit = new Object2IntOpenHashMap<>();
     private final CraftPersistentDataContainer persistentDataContainer = new CraftPersistentDataContainer(CraftWorld.DATA_TYPE_REGISTRY);
+    private net.kyori.adventure.pointer.Pointers adventure$pointers; // Paper - implement pointers
 
     private static final Random rand = new Random();
 
@@ -1709,6 +1710,42 @@ public class CraftWorld extends CraftRegionAccessor implements World {
             entityTracker.broadcastAndSend(packet);
         }
     }
+    // Paper start - Adventure
+    @Override
+    public void playSound(final net.kyori.adventure.sound.Sound sound) {
+        org.spigotmc.AsyncCatcher.catchOp("play sound"); // Paper
+        final long seed = sound.seed().orElseGet(this.world.getRandom()::nextLong);
+        for (ServerPlayer player : this.getHandle().players()) {
+            player.connection.send(io.papermc.paper.adventure.PaperAdventure.asSoundPacket(sound, player.getX(), player.getY(), player.getZ(), seed, null));
+        }
+    }
+
+    @Override
+    public void playSound(final net.kyori.adventure.sound.Sound sound, final double x, final double y, final double z) {
+        org.spigotmc.AsyncCatcher.catchOp("play sound"); // Paper
+        io.papermc.paper.adventure.PaperAdventure.asSoundPacket(sound, x, y, z, sound.seed().orElseGet(this.world.getRandom()::nextLong), this.playSound0(x, y, z));
+    }
+
+    @Override
+    public void playSound(final net.kyori.adventure.sound.Sound sound, final net.kyori.adventure.sound.Sound.Emitter emitter) {
+        org.spigotmc.AsyncCatcher.catchOp("play sound"); // Paper
+        final long seed = sound.seed().orElseGet(this.getHandle().getRandom()::nextLong);
+        if (emitter == net.kyori.adventure.sound.Sound.Emitter.self()) {
+            for (ServerPlayer player : this.getHandle().players()) {
+                player.connection.send(io.papermc.paper.adventure.PaperAdventure.asSoundPacket(sound, player, seed, null));
+            }
+        } else if (emitter instanceof CraftEntity craftEntity) {
+            final net.minecraft.world.entity.Entity entity = craftEntity.getHandle();
+            io.papermc.paper.adventure.PaperAdventure.asSoundPacket(sound, entity, seed, this.playSound0(entity.getX(), entity.getY(), entity.getZ()));
+        } else {
+            throw new IllegalArgumentException("Sound emitter must be an Entity or self(), but was: " + emitter);
+        }
+    }
+
+    private java.util.function.BiConsumer<net.minecraft.network.protocol.Packet<?>, Float> playSound0(final double x, final double y, final double z) {
+        return (packet, distance) -> this.world.getServer().getPlayerList().broadcast(null, x, y, z, distance, this.world.dimension(), packet);
+    }
+    // Paper end
 
     private static Map<String, GameRules.Key<?>> gamerules;
     public static synchronized Map<String, GameRules.Key<?>> getGameRulesNMS() {
@@ -2150,5 +2187,18 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     public void setSendViewDistance(final int viewDistance) {
         throw new UnsupportedOperationException("Not implemented yet");
     }
+
+    // Paper start - implement pointers
+    @Override
+    public net.kyori.adventure.pointer.Pointers pointers() {
+        if (this.adventure$pointers == null) {
+            this.adventure$pointers = net.kyori.adventure.pointer.Pointers.builder()
+                .withDynamic(net.kyori.adventure.identity.Identity.NAME, this::getName)
+                .withDynamic(net.kyori.adventure.identity.Identity.UUID, this::getUID)
+                .build();
+        }
+
+        return this.adventure$pointers;
+    }
     // Paper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index e5f070de12b63487b71c54d8020a895e5eda862c..73c44f94aac069fa3ea9e82be6b95e77a2421c63 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -20,6 +20,12 @@ public class Main {
     public static boolean useConsole = true;
 
     public static void main(String[] args) {
+        // Paper start
+        final String warnWhenLegacyFormattingDetected = String.join(".", "net", "kyori", "adventure", "text", "warnWhenLegacyFormattingDetected");
+        if (false && System.getProperty(warnWhenLegacyFormattingDetected) == null) {
+            System.setProperty(warnWhenLegacyFormattingDetected, String.valueOf(true));
+        }
+        // Paper end
         // Todo: Installation script
         OptionParser parser = new OptionParser() {
             {
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBeacon.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBeacon.java
index 9ef8b0327e377817faaf58b82a8fdfa5e801eac8..2dfbe061a064b0c79b96f644a1c3639bb900eca4 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBeacon.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBeacon.java
@@ -72,6 +72,19 @@ public class CraftBeacon extends CraftBlockEntityState<BeaconBlockEntity> implem
         this.getSnapshot().secondaryPower = (effect != null) ? CraftPotionEffectType.bukkitToMinecraftHolder(effect) : null;
     }
 
+    // Paper start
+    @Override
+    public net.kyori.adventure.text.Component customName() {
+        final BeaconBlockEntity be = this.getSnapshot();
+        return be.name != null ? io.papermc.paper.adventure.PaperAdventure.asAdventure(be.name) : null;
+    }
+
+    @Override
+    public void customName(final net.kyori.adventure.text.Component customName) {
+        this.getSnapshot().setCustomName(customName != null ? io.papermc.paper.adventure.PaperAdventure.asVanilla(customName) : null);
+    }
+    // Paper end
+
     @Override
     public String getCustomName() {
         BeaconBlockEntity beacon = this.getSnapshot();
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftCommandBlock.java b/src/main/java/org/bukkit/craftbukkit/block/CraftCommandBlock.java
index f9b89a7c6ac9f7fdbd29567a5b6550398dbc7345..f5b0bec4c1164fe7ef6da1f19a6ce9bb3d6864d0 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftCommandBlock.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftCommandBlock.java
@@ -45,4 +45,16 @@ public class CraftCommandBlock extends CraftBlockEntityState<CommandBlockEntity>
     public CraftCommandBlock copy(Location location) {
         return new CraftCommandBlock(this, location);
     }
+
+    // Paper start
+    @Override
+    public net.kyori.adventure.text.Component name() {
+        return io.papermc.paper.adventure.PaperAdventure.asAdventure(getSnapshot().getCommandBlock().getName());
+    }
+
+    @Override
+    public void name(net.kyori.adventure.text.Component name) {
+        getSnapshot().getCommandBlock().setCustomName(name == null ? net.minecraft.network.chat.Component.literal("@") : io.papermc.paper.adventure.PaperAdventure.asVanilla(name));
+    }
+    // Paper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftContainer.java b/src/main/java/org/bukkit/craftbukkit/block/CraftContainer.java
index 007b6d66dd837ca6352c0fba5c2399139f6b5425..513402b61e6b8388b7bc163d98e54ffae0e18254 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftContainer.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftContainer.java
@@ -32,6 +32,19 @@ public abstract class CraftContainer<T extends BaseContainerBlockEntity> extends
         this.getSnapshot().lockKey = (key == null) ? LockCode.NO_LOCK : new LockCode(key);
     }
 
+    // Paper start
+    @Override
+    public net.kyori.adventure.text.Component customName() {
+        final T be = this.getSnapshot();
+        return be.hasCustomName() ? io.papermc.paper.adventure.PaperAdventure.asAdventure(be.getCustomName()) : null;
+    }
+
+    @Override
+    public void customName(final net.kyori.adventure.text.Component customName) {
+        this.getSnapshot().name = (customName != null ? io.papermc.paper.adventure.PaperAdventure.asVanilla(customName) : null);
+    }
+    // Paper end
+
     @Override
     public String getCustomName() {
         T container = this.getSnapshot();
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftEnchantingTable.java b/src/main/java/org/bukkit/craftbukkit/block/CraftEnchantingTable.java
index 690dd79b82108322a290c00de63b1f038f617c84..a01691f98a378a818b8bf12176c7270e15c316d8 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftEnchantingTable.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftEnchantingTable.java
@@ -16,6 +16,19 @@ public class CraftEnchantingTable extends CraftBlockEntityState<EnchantingTableB
         super(state, location);
     }
 
+    // Paper start
+    @Override
+    public net.kyori.adventure.text.Component customName() {
+        final EnchantingTableBlockEntity be = this.getSnapshot();
+        return be.hasCustomName() ? io.papermc.paper.adventure.PaperAdventure.asAdventure(be.getCustomName()) : null;
+    }
+
+    @Override
+    public void customName(final net.kyori.adventure.text.Component customName) {
+        this.getSnapshot().setCustomName(customName != null ? io.papermc.paper.adventure.PaperAdventure.asVanilla(customName) : null);
+    }
+    // Paper end
+
     @Override
     public String getCustomName() {
         EnchantingTableBlockEntity enchant = this.getSnapshot();
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftSign.java b/src/main/java/org/bukkit/craftbukkit/block/CraftSign.java
index 0641d17d8095e7700c651e90472ae53d6f7dbbb2..a12702cdf36c75572e661b5b5758270f5058c181 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftSign.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftSign.java
@@ -36,6 +36,23 @@ public class CraftSign<T extends SignBlockEntity> extends CraftBlockEntityState<
         this.back = new CraftSignSide(this.getSnapshot().getBackText());
     }
 
+    // Paper start
+    @Override
+    public java.util.@NotNull List<net.kyori.adventure.text.Component> lines() {
+        return this.front.lines();
+    }
+
+    @Override
+    public net.kyori.adventure.text.@NotNull Component line(int index) {
+        return this.front.line(index);
+    }
+
+    @Override
+    public void line(int index, net.kyori.adventure.text.@NotNull Component line) {
+        this.front.line(index, line);
+    }
+    // Paper end
+
     @Override
     public String[] getLines() {
         return this.front.getLines();
@@ -161,6 +178,20 @@ public class CraftSign<T extends SignBlockEntity> extends CraftBlockEntityState<
         ((CraftPlayer) player).getHandle().openTextEdit(handle, Side.FRONT == side);
     }
 
+    // Paper start
+    public static Component[] sanitizeLines(java.util.List<? extends net.kyori.adventure.text.Component> lines) {
+        Component[] components = new Component[4];
+        for (int i = 0; i < 4; i++) {
+            if (i < lines.size() && lines.get(i) != null) {
+                components[i] = io.papermc.paper.adventure.PaperAdventure.asVanilla(lines.get(i));
+            } else {
+                components[i] = net.minecraft.network.chat.Component.literal("");
+            }
+        }
+        return components;
+    }
+    // Paper end
+
     public static Component[] sanitizeLines(String[] lines) {
         Component[] components = new Component[4];
 
diff --git a/src/main/java/org/bukkit/craftbukkit/block/sign/CraftSignSide.java b/src/main/java/org/bukkit/craftbukkit/block/sign/CraftSignSide.java
index d4724c812f8b7322ad59dc0695d01ceb47772dc4..4747d77fd5fd12116ef40d897a08c7baca60a399 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/sign/CraftSignSide.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/sign/CraftSignSide.java
@@ -12,37 +12,70 @@ import org.jetbrains.annotations.Nullable;
 public class CraftSignSide implements SignSide {
 
     // Lazily initialized only if requested:
-    private String[] originalLines = null;
-    private String[] lines = null;
+    // Paper start
+    private java.util.ArrayList<net.kyori.adventure.text.Component> originalLines = null; // ArrayList for RandomAccess
+    private java.util.ArrayList<net.kyori.adventure.text.Component> lines = null; // ArrayList for RandomAccess
+    // Paper end
     private SignText signText;
 
     public CraftSignSide(SignText signText) {
         this.signText = signText;
     }
 
+    // Paper start
+    @Override
+    public java.util.@NotNull List<net.kyori.adventure.text.Component> lines() {
+        this.loadLines();
+        return this.lines;
+    }
+
+    @Override
+    public net.kyori.adventure.text.@NotNull Component line(final int index) throws IndexOutOfBoundsException {
+        this.loadLines();
+        return this.lines.get(index);
+    }
+
+    @Override
+    public void line(final int index, final net.kyori.adventure.text.@NotNull Component line) throws IndexOutOfBoundsException {
+        com.google.common.base.Preconditions.checkArgument(line != null, "Line cannot be null");
+        this.loadLines();
+        this.lines.set(index, line);
+    }
+
+    private void loadLines() {
+        if (this.lines != null) {
+            return;
+        }
+        // Lazy initialization:
+        this.lines = io.papermc.paper.adventure.PaperAdventure.asAdventure(com.google.common.collect.Lists.newArrayList(this.signText.getMessages(false)));
+        this.originalLines = new java.util.ArrayList<>(this.lines);
+    }
+    // Paper end
+
     @NotNull
     @Override
     public String[] getLines() {
-        if (this.lines == null) {
-            // Lazy initialization:
-            Component[] messages = this.signText.getMessages(false);
-            this.lines = new String[messages.length];
-            System.arraycopy(CraftSign.revertComponents(messages), 0, this.lines, 0, this.lines.length);
-            this.originalLines = new String[this.lines.length];
-            System.arraycopy(this.lines, 0, this.originalLines, 0, this.originalLines.length);
-        }
-        return this.lines;
+        // Paper start
+        this.loadLines();
+        return this.lines.stream().map(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection()::serialize).toArray(String[]::new); // Paper
+        // Paper end
     }
 
     @NotNull
     @Override
     public String getLine(int index) throws IndexOutOfBoundsException {
-        return this.getLines()[index];
+        // Paper start
+        this.loadLines();
+        return net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().serialize(this.lines.get(index));
+        // Paper end
     }
 
     @Override
     public void setLine(int index, @NotNull String line) throws IndexOutOfBoundsException {
-        this.getLines()[index] = line;
+        // Paper start
+        this.loadLines();
+        this.lines.set(index, line != null ? net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(line) : net.kyori.adventure.text.Component.empty());
+        // Paper end
     }
 
     @Override
@@ -68,13 +101,16 @@ public class CraftSignSide implements SignSide {
 
     public SignText applyLegacyStringToSignSide() {
         if (this.lines != null) {
-            for (int i = 0; i < this.lines.length; i++) {
-                String line = (this.lines[i] == null) ? "" : this.lines[i];
-                if (line.equals(this.originalLines[i])) {
+            // Paper start
+            for (int i = 0; i < this.lines.size(); ++i) {
+                net.kyori.adventure.text.Component component = this.lines.get(i);
+                net.kyori.adventure.text.Component origComp = this.originalLines.get(i);
+                if (component.equals(origComp)) {
                     continue; // The line contents are still the same, skip.
                 }
-                this.signText = this.signText.setMessage(i, CraftChatMessage.fromString(line)[0]);
+                this.signText = this.signText.setMessage(i, io.papermc.paper.adventure.PaperAdventure.asVanilla(component));
             }
+            // Paper end
         }
 
         return this.signText;
diff --git a/src/main/java/org/bukkit/craftbukkit/command/CraftBlockCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/CraftBlockCommandSender.java
index f2e8b63d787754c0a92441dcc9eb39dffdc1e280..9feae61fe02cbc624581ef0bd4c60af636407367 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/CraftBlockCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/CraftBlockCommandSender.java
@@ -61,6 +61,18 @@ public class CraftBlockCommandSender extends ServerCommandSender implements Bloc
         return this.block.getTextName();
     }
 
+    // Paper start
+    @Override
+    public void sendMessage(net.kyori.adventure.identity.Identity identity, net.kyori.adventure.text.Component message, net.kyori.adventure.audience.MessageType type) {
+        block.source.sendSystemMessage(io.papermc.paper.adventure.PaperAdventure.asVanilla(message));
+    }
+
+    @Override
+    public net.kyori.adventure.text.Component name() {
+        return io.papermc.paper.adventure.PaperAdventure.asAdventure(this.block.getDisplayName());
+    }
+    // Paper end
+
     @Override
     public boolean isOp() {
         return CraftBlockCommandSender.SHARED_PERM.isOp();
diff --git a/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
index f3cb4102ab223f379f60dac317df7da1fab812a8..324e6d1a4fadd3e557e4ba05f04e6a5891cc54df 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
@@ -46,6 +46,13 @@ public class CraftConsoleCommandSender extends ServerCommandSender implements Co
         return "CONSOLE";
     }
 
+    // Paper start
+    @Override
+    public net.kyori.adventure.text.Component name() {
+        return net.kyori.adventure.text.Component.text(this.getName());
+    }
+    // Paper end
+
     @Override
     public boolean isOp() {
         return true;
@@ -80,4 +87,11 @@ public class CraftConsoleCommandSender extends ServerCommandSender implements Co
     public boolean isConversing() {
         return this.conversationTracker.isConversing();
     }
+
+    // Paper start
+    @Override
+    public void sendMessage(final net.kyori.adventure.identity.Identity identity, final net.kyori.adventure.text.Component message, final net.kyori.adventure.audience.MessageType type) {
+        this.sendRawMessage(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().serialize(message));
+    }
+    // Paper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/CraftRemoteConsoleCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/CraftRemoteConsoleCommandSender.java
index e3c7fa50fad3077a297d2412de9d26d53371808c..5b7d230103f421fb939072e1526854f715430e51 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/CraftRemoteConsoleCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/CraftRemoteConsoleCommandSender.java
@@ -39,6 +39,13 @@ public class CraftRemoteConsoleCommandSender extends ServerCommandSender impleme
         return "Rcon";
     }
 
+    // Paper start
+    @Override
+    public net.kyori.adventure.text.Component name() {
+        return net.kyori.adventure.text.Component.text(this.getName());
+    }
+    // Paper end
+
     @Override
     public boolean isOp() {
         return true;
diff --git a/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
index 53d6950ad270ba901de5226b9daecb683248ad05..3e7d14564f11a3ed0b0766444e9d681804597e9a 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
@@ -67,6 +67,13 @@ public class ProxiedNativeCommandSender implements ProxiedCommandSender {
         return this.getCallee().getName();
     }
 
+    // Paper start
+    @Override
+    public net.kyori.adventure.text.Component name() {
+        return this.getCallee().name();
+    }
+    // Paper end
+
     @Override
     public boolean isPermissionSet(String name) {
         return this.getCaller().isPermissionSet(name);
diff --git a/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java
index 1e82312c24cb752d63b165926861fc178cd7849b..7f22950ae61436e91a59cd29a345809c42bbe739 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java
@@ -13,6 +13,7 @@ import org.bukkit.plugin.Plugin;
 
 public abstract class ServerCommandSender implements CommandSender {
     private final PermissibleBase perm;
+    private net.kyori.adventure.pointer.Pointers adventure$pointers; // Paper - implement pointers
 
     protected ServerCommandSender() {
         this.perm = new PermissibleBase(this);
@@ -130,4 +131,18 @@ public abstract class ServerCommandSender implements CommandSender {
         return this.spigot;
     }
     // Spigot end
+
+    // Paper start - implement pointers
+    @Override
+    public net.kyori.adventure.pointer.Pointers pointers() {
+        if (this.adventure$pointers == null) {
+            this.adventure$pointers = net.kyori.adventure.pointer.Pointers.builder()
+                .withDynamic(net.kyori.adventure.identity.Identity.DISPLAY_NAME, this::name)
+                .withStatic(net.kyori.adventure.permission.PermissionChecker.POINTER, this::permissionValue)
+                .build();
+        }
+
+        return this.adventure$pointers;
+    }
+    // Paper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/enchantments/CraftEnchantment.java b/src/main/java/org/bukkit/craftbukkit/enchantments/CraftEnchantment.java
index 85cef6c2ebe8f53c3a63c17055c48c2d46e6c680..5ed90ed0461165da02c7a1acae805c12466e38d6 100644
--- a/src/main/java/org/bukkit/craftbukkit/enchantments/CraftEnchantment.java
+++ b/src/main/java/org/bukkit/craftbukkit/enchantments/CraftEnchantment.java
@@ -163,6 +163,12 @@ public class CraftEnchantment extends Enchantment implements Handleable<net.mine
         CraftEnchantment ench = (CraftEnchantment) other;
         return !this.handle.isCompatibleWith(ench.getHandle());
     }
+    // Paper start
+    @Override
+    public net.kyori.adventure.text.Component displayName(int level) {
+        return io.papermc.paper.adventure.PaperAdventure.asAdventure(getHandle().getFullname(level));
+    }
+    // Paper end
 
     @Override
     public String getTranslationKey() {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 941035a6cf73c8757e3ea75358d5d405b22c1a6f..0996bfe664e0085dcacdd2b6c08a2737d3b2fa6a 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -67,6 +67,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
     private final EntityType entityType;
     private EntityDamageEvent lastDamageEvent;
     private final CraftPersistentDataContainer persistentDataContainer = new CraftPersistentDataContainer(CraftEntity.DATA_TYPE_REGISTRY);
+    protected net.kyori.adventure.pointer.Pointers adventure$pointers; // Paper - implement pointers
 
     public CraftEntity(final CraftServer server, final Entity entity) {
         this.server = server;
@@ -523,6 +524,32 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         return this.getHandle().getVehicle().getBukkitEntity();
     }
 
+    // Paper start
+    @Override
+    public net.kyori.adventure.text.Component customName() {
+        final Component name = this.getHandle().getCustomName();
+        return name != null ? io.papermc.paper.adventure.PaperAdventure.asAdventure(name) : null;
+    }
+
+    @Override
+    public void customName(final net.kyori.adventure.text.Component customName) {
+        this.getHandle().setCustomName(customName != null ? io.papermc.paper.adventure.PaperAdventure.asVanilla(customName) : null);
+    }
+
+    @Override
+    public net.kyori.adventure.pointer.Pointers pointers() {
+        if (this.adventure$pointers == null) {
+            this.adventure$pointers = net.kyori.adventure.pointer.Pointers.builder()
+                .withDynamic(net.kyori.adventure.identity.Identity.DISPLAY_NAME, this::name)
+                .withDynamic(net.kyori.adventure.identity.Identity.UUID, this::getUniqueId)
+                .withStatic(net.kyori.adventure.permission.PermissionChecker.POINTER, this::permissionValue)
+                .build();
+        }
+
+        return this.adventure$pointers;
+    }
+    // Paper end
+
     @Override
     public void setCustomName(String name) {
         // sane limit for name length
@@ -619,6 +646,17 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
     public String getName() {
         return CraftChatMessage.fromComponent(this.getHandle().getName());
     }
+    // Paper start
+    @Override
+    public net.kyori.adventure.text.@org.jetbrains.annotations.NotNull Component name() {
+        return io.papermc.paper.adventure.PaperAdventure.asAdventure(this.getHandle().getName());
+    }
+
+    @Override
+    public net.kyori.adventure.text.@org.jetbrains.annotations.NotNull Component teamDisplayName() {
+        return io.papermc.paper.adventure.PaperAdventure.asAdventure(this.getHandle().getDisplayName());
+    }
+    // Paper end
 
     @Override
     public boolean isPermissionSet(String name) {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
index 8ba24b389a16a7f4ec4dcac87f2acfd560d65c34..1010ac55d91559bcb6ebadeea447f32c6aa89226 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
@@ -321,9 +321,12 @@ public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
         container = CraftEventFactory.callInventoryOpenEvent(player, container);
         if (container == null) return;
 
-        String title = container.getBukkitView().getTitle();
+        //String title = container.getBukkitView().getTitle(); // Paper - comment
+        net.kyori.adventure.text.Component adventure$title = container.getBukkitView().title(); // Paper
+        if (adventure$title == null) adventure$title = net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(container.getBukkitView().getTitle()); // Paper
 
-        player.connection.send(new ClientboundOpenScreenPacket(container.containerId, windowType, CraftChatMessage.fromString(title)[0]));
+        //player.connection.send(new ClientboundOpenScreenPacket(container.containerId, windowType, CraftChatMessage.fromString(title)[0])); // Paper - comment
+        player.connection.send(new ClientboundOpenScreenPacket(container.containerId, windowType, io.papermc.paper.adventure.PaperAdventure.asVanilla(adventure$title))); // Paper
         player.containerMenu = container;
         player.initMenu(container);
     }
@@ -392,8 +395,12 @@ public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
 
         // Now open the window
         MenuType<?> windowType = CraftContainer.getNotchInventoryType(inventory.getTopInventory());
-        String title = inventory.getTitle();
-        player.connection.send(new ClientboundOpenScreenPacket(container.containerId, windowType, CraftChatMessage.fromString(title)[0]));
+
+        //String title = inventory.getTitle(); // Paper - comment
+        net.kyori.adventure.text.Component adventure$title = inventory.title(); // Paper
+        if (adventure$title == null) adventure$title = net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(inventory.getTitle()); // Paper
+        //player.connection.send(new ClientboundOpenScreenPacket(container.containerId, windowType, CraftChatMessage.fromString(title)[0])); // Paper - comment
+        player.connection.send(new ClientboundOpenScreenPacket(container.containerId, windowType, io.papermc.paper.adventure.PaperAdventure.asVanilla(adventure$title))); // Paper
         player.containerMenu = container;
         player.initMenu(container);
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftMinecartCommand.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftMinecartCommand.java
index 55945b83a5426b352bad9507cc9e94afb1278032..9ea1537408ff2d790747b6e5a681d9171a4233ae 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftMinecartCommand.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftMinecartCommand.java
@@ -59,6 +59,13 @@ public class CraftMinecartCommand extends CraftMinecart implements CommandMineca
         return CraftChatMessage.fromComponent(this.getHandle().getCommandBlock().getName());
     }
 
+    // Paper start
+    @Override
+    public net.kyori.adventure.text.@org.jetbrains.annotations.NotNull Component name() {
+        return io.papermc.paper.adventure.PaperAdventure.asAdventure(this.getHandle().getCommandBlock().getName());
+    }
+    // Paper end
+
     @Override
     public boolean isOp() {
         return true;
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 1c0b19a8d7ce31802436bd5f0910f4fba8a391b7..e59f2ae85126061ee35812eaa02a35ddb4a9eb66 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -386,14 +386,40 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public String getDisplayName() {
+        if(true) return io.papermc.paper.adventure.DisplayNames.getLegacy(this); // Paper
         return this.getHandle().displayName;
     }
 
     @Override
     public void setDisplayName(final String name) {
+        this.getHandle().adventure$displayName = name != null ? net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(name) : net.kyori.adventure.text.Component.text(this.getName()); // Paper
         this.getHandle().displayName = name == null ? this.getName() : name;
     }
 
+    // Paper start
+    @Override
+    public void playerListName(net.kyori.adventure.text.Component name) {
+        getHandle().listName = name == null ? null : io.papermc.paper.adventure.PaperAdventure.asVanilla(name);
+        if (getHandle().connection == null) return; // Updates are possible before the player has fully joined
+        for (ServerPlayer player : server.getHandle().players) {
+            if (player.getBukkitEntity().canSee(this)) {
+                player.connection.send(new ClientboundPlayerInfoUpdatePacket(ClientboundPlayerInfoUpdatePacket.Action.UPDATE_DISPLAY_NAME, getHandle()));
+            }
+        }
+    }
+    @Override
+    public net.kyori.adventure.text.Component playerListName() {
+        return getHandle().listName == null ? net.kyori.adventure.text.Component.text(getName()) : io.papermc.paper.adventure.PaperAdventure.asAdventure(getHandle().listName);
+    }
+    @Override
+    public net.kyori.adventure.text.Component playerListHeader() {
+        return playerListHeader;
+    }
+    @Override
+    public net.kyori.adventure.text.Component playerListFooter() {
+        return playerListFooter;
+    }
+    // Paper end
     @Override
     public String getPlayerListName() {
         return this.getHandle().listName == null ? this.getName() : CraftChatMessage.fromComponent(this.getHandle().listName);
@@ -405,6 +431,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
             name = this.getName();
         }
         this.getHandle().listName = name.equals(this.getName()) ? null : CraftChatMessage.fromStringOrNull(name);
+        if (this.getHandle().connection == null) return; // Paper - Updates are possible before the player has fully joined
         for (ServerPlayer player : (List<ServerPlayer>) this.server.getHandle().players) {
             if (player.getBukkitEntity().canSee(this)) {
                 player.connection.send(new ClientboundPlayerInfoUpdatePacket(ClientboundPlayerInfoUpdatePacket.Action.UPDATE_DISPLAY_NAME, this.getHandle()));
@@ -412,42 +439,42 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         }
     }
 
-    private Component playerListHeader;
-    private Component playerListFooter;
+    private net.kyori.adventure.text.Component playerListHeader; // Paper - Adventure
+    private net.kyori.adventure.text.Component playerListFooter; // Paper - Adventure
 
     @Override
     public String getPlayerListHeader() {
-        return (this.playerListHeader == null) ? null : CraftChatMessage.fromComponent(this.playerListHeader);
+        return (this.playerListHeader == null) ? null : net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().serialize(this.playerListHeader);
     }
 
     @Override
     public String getPlayerListFooter() {
-        return (this.playerListFooter == null) ? null : CraftChatMessage.fromComponent(this.playerListFooter);
+        return (this.playerListFooter == null) ? null : net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().serialize(this.playerListFooter); // Paper - Adventure
     }
 
     @Override
     public void setPlayerListHeader(String header) {
-        this.playerListHeader = CraftChatMessage.fromStringOrNull(header, true);
+        this.playerListHeader = header == null ? null : net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(header); // Paper - Adventure
         this.updatePlayerListHeaderFooter();
     }
 
     @Override
     public void setPlayerListFooter(String footer) {
-        this.playerListFooter = CraftChatMessage.fromStringOrNull(footer, true);
+        this.playerListFooter = footer == null ? null : net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(footer); // Paper - Adventure
         this.updatePlayerListHeaderFooter();
     }
 
     @Override
     public void setPlayerListHeaderFooter(String header, String footer) {
-        this.playerListHeader = CraftChatMessage.fromStringOrNull(header, true);
-        this.playerListFooter = CraftChatMessage.fromStringOrNull(footer, true);
+        this.playerListHeader = header == null ? null : net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(header); // Paper - Adventure
+        this.playerListFooter = footer == null ? null : net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(footer); // Paper - Adventure
         this.updatePlayerListHeaderFooter();
     }
 
     private void updatePlayerListHeaderFooter() {
         if (this.getHandle().connection == null) return;
 
-        ClientboundTabListPacket packet = new ClientboundTabListPacket((this.playerListHeader == null) ? Component.empty() : this.playerListHeader, (this.playerListFooter == null) ? Component.empty() : this.playerListFooter);
+        ClientboundTabListPacket packet = new ClientboundTabListPacket(io.papermc.paper.adventure.PaperAdventure.asVanillaNullToEmpty(this.playerListHeader), io.papermc.paper.adventure.PaperAdventure.asVanillaNullToEmpty(this.playerListFooter)); // Paper - adventure
         this.getHandle().connection.send(packet);
     }
 
@@ -479,6 +506,23 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         this.getHandle().connection.disconnect(message == null ? "" : message);
     }
 
+    // Paper start
+    private static final net.kyori.adventure.text.Component DEFAULT_KICK_COMPONENT = net.kyori.adventure.text.Component.translatable("multiplayer.disconnect.kicked");
+    @Override
+    public void kick() {
+        this.kick(DEFAULT_KICK_COMPONENT);
+    }
+
+    @Override
+    public void kick(final net.kyori.adventure.text.Component message) {
+        org.spigotmc.AsyncCatcher.catchOp("player kick");
+        final ServerGamePacketListenerImpl connection = this.getHandle().connection;
+        if (connection != null) {
+            connection.disconnect(message == null ? net.kyori.adventure.text.Component.empty() : message);
+        }
+    }
+    // Paper end
+
     @Override
     public void setCompassTarget(Location loc) {
         Preconditions.checkArgument(loc != null, "Location cannot be null");
@@ -775,6 +819,24 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         this.getHandle().connection.send(packet);
     }
 
+    // Paper start
+    @Override
+    public void sendSignChange(Location loc, @Nullable List<? extends net.kyori.adventure.text.Component> lines, DyeColor dyeColor, boolean hasGlowingText) {
+        if (getHandle().connection == null) {
+            return;
+        }
+        if (lines == null) {
+            lines = new java.util.ArrayList<>(4);
+        }
+        Preconditions.checkArgument(loc != null, "Location cannot be null");
+        Preconditions.checkArgument(dyeColor != null, "DyeColor cannot be null");
+        if (lines.size() < 4) {
+            throw new IllegalArgumentException("Must have at least 4 lines");
+        }
+        Component[] components = CraftSign.sanitizeLines(lines);
+        this.sendSignChange0(components, loc, dyeColor, hasGlowingText);
+    }
+    // Paper end
     @Override
     public void sendSignChange(Location loc, String[] lines) {
         this.sendSignChange(loc, lines, DyeColor.BLACK);
@@ -798,6 +860,12 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         if (this.getHandle().connection == null) return;
 
         Component[] components = CraftSign.sanitizeLines(lines);
+        // Paper start - adventure
+        this.sendSignChange0(components, loc, dyeColor, hasGlowingText);
+    }
+
+    private void sendSignChange0(Component[] components, Location loc, DyeColor dyeColor, boolean hasGlowingText) {
+        // Paper end
         SignBlockEntity sign = new SignBlockEntity(CraftLocation.toBlockPosition(loc), Blocks.OAK_SIGN.defaultBlockState());
         SignText text = sign.getFrontText();
         text = text.setColor(net.minecraft.world.item.DyeColor.byId(dyeColor.getWoolData()));
@@ -1802,7 +1870,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public void setResourcePack(String url) {
-        this.setResourcePack(url, null);
+        this.setResourcePack(url, (byte[]) null);
     }
 
     @Override
@@ -1817,7 +1885,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public void setResourcePack(String url, byte[] hash, boolean force) {
-        this.setResourcePack(url, hash, null, force);
+        this.setResourcePack(url, hash, (String) null, force);
     }
 
     @Override
@@ -1854,6 +1922,59 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         this.handlePushResourcePack(new ClientboundResourcePackPushPacket(id, url, hashStr, force, CraftChatMessage.fromStringOrOptional(prompt, true)), false);
     }
 
+    // Paper start - adventure
+    @Override
+    public void setResourcePack(final UUID uuid, final String url, final byte[] hashBytes, final net.kyori.adventure.text.Component prompt, final boolean force) {
+        Preconditions.checkArgument(uuid != null, "Resource pack UUID cannot be null");
+        Preconditions.checkArgument(url != null, "Resource pack URL cannot be null");
+        final String hash;
+        if (hashBytes != null) {
+            Preconditions.checkArgument(hashBytes.length == 20, "Resource pack hash should be 20 bytes long but was " + hashBytes.length);
+            hash = BaseEncoding.base16().lowerCase().encode(hashBytes);
+        } else {
+            hash = "";
+        }
+        this.getHandle().connection.send(new ClientboundResourcePackPopPacket(Optional.empty()));
+        this.getHandle().connection.send(new ClientboundResourcePackPushPacket(uuid, url, hash, force, Optional.ofNullable(prompt).map(io.papermc.paper.adventure.PaperAdventure::asVanilla)));
+    }
+
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    void sendBundle(final List<? extends net.minecraft.network.protocol.Packet<? extends net.minecraft.network.protocol.common.ClientCommonPacketListener>> packet) {
+        this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundBundlePacket((List) packet));
+    }
+
+    @Override
+    public void sendResourcePacks(final net.kyori.adventure.resource.ResourcePackRequest request) {
+        if (this.getHandle().connection == null) return;
+        final List<ClientboundResourcePackPushPacket> packs = new java.util.ArrayList<>(request.packs().size());
+        if (request.replace()) {
+            this.clearResourcePacks();
+        }
+        final Component prompt = io.papermc.paper.adventure.PaperAdventure.asVanilla(request.prompt());
+        for (final java.util.Iterator<net.kyori.adventure.resource.ResourcePackInfo> iter = request.packs().iterator(); iter.hasNext();) {
+            final net.kyori.adventure.resource.ResourcePackInfo pack = iter.next();
+            packs.add(new ClientboundResourcePackPushPacket(pack.id(), pack.uri().toASCIIString(), pack.hash(), request.required(), iter.hasNext() ? Optional.empty() : Optional.ofNullable(prompt)));
+            if (request.callback() != net.kyori.adventure.resource.ResourcePackCallback.noOp()) {
+                this.getHandle().connection.packCallbacks.put(pack.id(), request.callback()); // just override if there is a previously existing callback
+            }
+        }
+        this.sendBundle(packs);
+        super.sendResourcePacks(request);
+    }
+
+    @Override
+    public void removeResourcePacks(final UUID id, final UUID ... others) {
+        if (this.getHandle().connection == null) return;
+        this.sendBundle(net.kyori.adventure.util.MonkeyBars.nonEmptyArrayToList(pack -> new ClientboundResourcePackPopPacket(Optional.of(pack)), id, others));
+    }
+
+    @Override
+    public void clearResourcePacks() {
+        if (this.getHandle().connection == null) return;
+        this.getHandle().connection.send(new ClientboundResourcePackPopPacket(Optional.empty()));
+    }
+    // Paper end - adventure
+
     @Override
     public void removeResourcePack(UUID id) {
         Preconditions.checkArgument(id != null, "Resource pack id cannot be null");
@@ -2274,6 +2395,12 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         return (this.getHandle().requestedViewDistance() == 0) ? Bukkit.getViewDistance() : this.getHandle().requestedViewDistance();
     }
 
+    // Paper start
+    @Override
+    public java.util.Locale locale() {
+        return getHandle().adventure$locale;
+    }
+    // Paper end
     @Override
     public int getPing() {
         return this.getHandle().connection.latency();
@@ -2324,6 +2451,248 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         return this.getHandle().allowsListing();
     }
 
+    // Paper start
+    @Override
+    public net.kyori.adventure.text.Component displayName() {
+        return this.getHandle().adventure$displayName;
+    }
+
+    @Override
+    public void displayName(final net.kyori.adventure.text.Component displayName) {
+        this.getHandle().adventure$displayName = displayName != null ? displayName : net.kyori.adventure.text.Component.text(this.getName());
+        this.getHandle().displayName = null;
+    }
+
+    @Override
+    public void deleteMessage(net.kyori.adventure.chat.SignedMessage.Signature signature) {
+        if (getHandle().connection == null) return;
+        net.minecraft.network.chat.MessageSignature sig = new net.minecraft.network.chat.MessageSignature(signature.bytes());
+
+        this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundDeleteChatPacket(new net.minecraft.network.chat.MessageSignature.Packed(sig)));
+    }
+
+    private net.minecraft.network.chat.ChatType.Bound toHandle(net.kyori.adventure.chat.ChatType.Bound boundChatType) {
+        net.minecraft.core.Registry<net.minecraft.network.chat.ChatType> chatTypeRegistry = this.getHandle().level().registryAccess().registryOrThrow(net.minecraft.core.registries.Registries.CHAT_TYPE);
+
+        return new net.minecraft.network.chat.ChatType.Bound(
+            chatTypeRegistry.getHolderOrThrow(net.minecraft.resources.ResourceKey.create(net.minecraft.core.registries.Registries.CHAT_TYPE, io.papermc.paper.adventure.PaperAdventure.asVanilla(boundChatType.type().key()))),
+            io.papermc.paper.adventure.PaperAdventure.asVanilla(boundChatType.name()),
+            Optional.ofNullable(io.papermc.paper.adventure.PaperAdventure.asVanilla(boundChatType.target()))
+        );
+    }
+
+    @Override
+    public void sendMessage(net.kyori.adventure.text.Component message, net.kyori.adventure.chat.ChatType.Bound boundChatType) {
+        if (getHandle().connection == null) return;
+
+        net.minecraft.network.chat.Component component = io.papermc.paper.adventure.PaperAdventure.asVanilla(message);
+        this.getHandle().sendChatMessage(new net.minecraft.network.chat.OutgoingChatMessage.Disguised(component), this.getHandle().isTextFilteringEnabled(), this.toHandle(boundChatType));
+    }
+
+    @Override
+    public void sendMessage(net.kyori.adventure.chat.SignedMessage signedMessage, net.kyori.adventure.chat.ChatType.Bound boundChatType) {
+        if (getHandle().connection == null) return;
+
+        if (signedMessage instanceof PlayerChatMessage.AdventureView view) {
+            this.getHandle().sendChatMessage(net.minecraft.network.chat.OutgoingChatMessage.create(view.playerChatMessage()), this.getHandle().isTextFilteringEnabled(), this.toHandle(boundChatType));
+            return;
+        }
+        net.kyori.adventure.text.Component message = signedMessage.unsignedContent() == null ? net.kyori.adventure.text.Component.text(signedMessage.message()) : signedMessage.unsignedContent();
+        if (signedMessage.isSystem()) {
+            this.sendMessage(message, boundChatType);
+        } else {
+            super.sendMessage(signedMessage, boundChatType);
+        }
+//        net.minecraft.network.chat.PlayerChatMessage playerChatMessage = new net.minecraft.network.chat.PlayerChatMessage(
+//            null, // TODO:
+//            new net.minecraft.network.chat.MessageSignature(signedMessage.signature().bytes()),
+//            null, // TODO
+//            io.papermc.paper.adventure.PaperAdventure.asVanilla(signedMessage.unsignedContent()),
+//            net.minecraft.network.chat.FilterMask.PASS_THROUGH
+//        );
+//
+//        this.getHandle().sendChatMessage(net.minecraft.network.chat.OutgoingChatMessage.create(playerChatMessage), this.getHandle().isTextFilteringEnabled(), this.toHandle(boundChatType));
+    }
+
+    @Deprecated(forRemoval = true)
+    @Override
+    public void sendMessage(final net.kyori.adventure.identity.Identity identity, final net.kyori.adventure.text.Component message, final net.kyori.adventure.audience.MessageType type) {
+        if (getHandle().connection == null) return;
+        final net.minecraft.core.Registry<net.minecraft.network.chat.ChatType> chatTypeRegistry = this.getHandle().level().registryAccess().registryOrThrow(net.minecraft.core.registries.Registries.CHAT_TYPE);
+        this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundSystemChatPacket(message, false));
+    }
+
+    @Override
+    public void sendActionBar(final net.kyori.adventure.text.Component message) {
+        final net.minecraft.network.protocol.game.ClientboundSetActionBarTextPacket packet = new net.minecraft.network.protocol.game.ClientboundSetActionBarTextPacket(io.papermc.paper.adventure.PaperAdventure.asVanillaNullToEmpty(message));
+        this.getHandle().connection.send(packet);
+    }
+
+    @Override
+    public void sendPlayerListHeader(final net.kyori.adventure.text.Component header) {
+        this.playerListHeader = header;
+        this.adventure$sendPlayerListHeaderAndFooter();
+    }
+
+    @Override
+    public void sendPlayerListFooter(final net.kyori.adventure.text.Component footer) {
+        this.playerListFooter = footer;
+        this.adventure$sendPlayerListHeaderAndFooter();
+    }
+
+    @Override
+    public void sendPlayerListHeaderAndFooter(final net.kyori.adventure.text.Component header, final net.kyori.adventure.text.Component footer) {
+        this.playerListHeader = header;
+        this.playerListFooter = footer;
+        this.adventure$sendPlayerListHeaderAndFooter();
+    }
+
+    private void adventure$sendPlayerListHeaderAndFooter() {
+        final ServerGamePacketListenerImpl connection = this.getHandle().connection;
+        if (connection == null) return;
+        final ClientboundTabListPacket packet = new ClientboundTabListPacket(
+            io.papermc.paper.adventure.PaperAdventure.asVanillaNullToEmpty(this.playerListHeader),
+            io.papermc.paper.adventure.PaperAdventure.asVanillaNullToEmpty(this.playerListFooter)
+        );
+        connection.send(packet);
+    }
+
+    @Override
+    public void showTitle(final net.kyori.adventure.title.Title title) {
+        final ServerGamePacketListenerImpl connection = this.getHandle().connection;
+        final net.kyori.adventure.title.Title.Times times = title.times();
+        if (times != null) {
+            connection.send(new ClientboundSetTitlesAnimationPacket(ticks(times.fadeIn()), ticks(times.stay()), ticks(times.fadeOut())));
+        }
+        final ClientboundSetSubtitleTextPacket sp = new ClientboundSetSubtitleTextPacket(io.papermc.paper.adventure.PaperAdventure.asVanilla(title.subtitle()));
+        connection.send(sp);
+        final ClientboundSetTitleTextPacket tp = new ClientboundSetTitleTextPacket(io.papermc.paper.adventure.PaperAdventure.asVanilla(title.title()));
+        connection.send(tp);
+    }
+
+    @Override
+    public <T> void sendTitlePart(final net.kyori.adventure.title.TitlePart<T> part, T value) {
+        java.util.Objects.requireNonNull(part, "part");
+        java.util.Objects.requireNonNull(value, "value");
+        if (part == net.kyori.adventure.title.TitlePart.TITLE) {
+            final ClientboundSetTitleTextPacket tp = new ClientboundSetTitleTextPacket(io.papermc.paper.adventure.PaperAdventure.asVanilla((net.kyori.adventure.text.Component)value));
+            this.getHandle().connection.send(tp);
+        } else if (part == net.kyori.adventure.title.TitlePart.SUBTITLE) {
+            final ClientboundSetSubtitleTextPacket sp = new ClientboundSetSubtitleTextPacket(io.papermc.paper.adventure.PaperAdventure.asVanilla((net.kyori.adventure.text.Component)value));
+            this.getHandle().connection.send(sp);
+        } else if (part == net.kyori.adventure.title.TitlePart.TIMES) {
+            final net.kyori.adventure.title.Title.Times times = (net.kyori.adventure.title.Title.Times) value;
+            this.getHandle().connection.send(new ClientboundSetTitlesAnimationPacket(ticks(times.fadeIn()), ticks(times.stay()), ticks(times.fadeOut())));
+        } else {
+            throw new IllegalArgumentException("Unknown TitlePart");
+        }
+    }
+
+    private static int ticks(final java.time.Duration duration) {
+        if (duration == null) {
+            return -1;
+        }
+        return (int) (duration.toMillis() / 50L);
+    }
+
+    @Override
+    public void clearTitle() {
+        this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundClearTitlesPacket(false));
+    }
+
+    // resetTitle implemented above
+
+    private @Nullable Set<net.kyori.adventure.bossbar.BossBar> activeBossBars;
+
+    @Override
+    public @NotNull Iterable<? extends net.kyori.adventure.bossbar.BossBar> activeBossBars() {
+        if (this.activeBossBars != null) {
+            return java.util.Collections.unmodifiableSet(this.activeBossBars);
+        }
+        return Set.of();
+    }
+
+    @Override
+    public void showBossBar(final net.kyori.adventure.bossbar.BossBar bar) {
+        net.kyori.adventure.bossbar.BossBarImplementation.get(bar, io.papermc.paper.adventure.BossBarImplementationImpl.class).playerShow(this);
+        if (this.activeBossBars == null) {
+            this.activeBossBars = new HashSet<>();
+        }
+        this.activeBossBars.add(bar);
+    }
+
+    @Override
+    public void hideBossBar(final net.kyori.adventure.bossbar.BossBar bar) {
+        net.kyori.adventure.bossbar.BossBarImplementation.get(bar, io.papermc.paper.adventure.BossBarImplementationImpl.class).playerHide(this);
+        if (this.activeBossBars != null) {
+            this.activeBossBars.remove(bar);
+            if (this.activeBossBars.isEmpty()) {
+                this.activeBossBars = null;
+            }
+        }
+    }
+
+    @Override
+    public void playSound(final net.kyori.adventure.sound.Sound sound) {
+        final Vec3 pos = this.getHandle().position();
+        this.playSound(sound, pos.x, pos.y, pos.z);
+    }
+
+    @Override
+    public void playSound(final net.kyori.adventure.sound.Sound sound, final double x, final double y, final double z) {
+        this.getHandle().connection.send(io.papermc.paper.adventure.PaperAdventure.asSoundPacket(sound, x, y, z, sound.seed().orElseGet(this.getHandle().getRandom()::nextLong), null));
+    }
+
+    @Override
+    public void playSound(final net.kyori.adventure.sound.Sound sound, final net.kyori.adventure.sound.Sound.Emitter emitter) {
+        final Entity entity;
+        if (emitter == net.kyori.adventure.sound.Sound.Emitter.self()) {
+            entity = this.getHandle();
+        } else if (emitter instanceof CraftEntity craftEntity) {
+            entity = craftEntity.getHandle();
+        } else {
+            throw new IllegalArgumentException("Sound emitter must be an Entity or self(), but was: " + emitter);
+        }
+        this.getHandle().connection.send(io.papermc.paper.adventure.PaperAdventure.asSoundPacket(sound, entity, sound.seed().orElseGet(this.getHandle().getRandom()::nextLong), null));
+    }
+
+    @Override
+    public void stopSound(final net.kyori.adventure.sound.SoundStop stop) {
+        this.getHandle().connection.send(new ClientboundStopSoundPacket(
+            io.papermc.paper.adventure.PaperAdventure.asVanillaNullable(stop.sound()),
+            io.papermc.paper.adventure.PaperAdventure.asVanillaNullable(stop.source())
+        ));
+    }
+
+    @Override
+    public void openBook(final net.kyori.adventure.inventory.Book book) {
+        final java.util.Locale locale = this.getHandle().adventure$locale;
+        final net.minecraft.world.item.ItemStack item = io.papermc.paper.adventure.PaperAdventure.asItemStack(book, locale);
+        final ServerPlayer player = this.getHandle();
+        final ServerGamePacketListenerImpl connection = player.connection;
+        final net.minecraft.world.entity.player.Inventory inventory = player.getInventory();
+        final int slot = inventory.items.size() + inventory.selected;
+        final int stateId = getHandle().containerMenu.getStateId();
+        connection.send(new net.minecraft.network.protocol.game.ClientboundContainerSetSlotPacket(0, stateId, slot, item));
+        connection.send(new net.minecraft.network.protocol.game.ClientboundOpenBookPacket(net.minecraft.world.InteractionHand.MAIN_HAND));
+        connection.send(new net.minecraft.network.protocol.game.ClientboundContainerSetSlotPacket(0, stateId, slot, inventory.getSelected()));
+    }
+
+    @Override
+    public net.kyori.adventure.pointer.Pointers pointers() {
+        if (this.adventure$pointers == null) {
+            this.adventure$pointers = net.kyori.adventure.pointer.Pointers.builder()
+                .withDynamic(net.kyori.adventure.identity.Identity.DISPLAY_NAME, this::displayName)
+                .withDynamic(net.kyori.adventure.identity.Identity.NAME, this::getName)
+                .withDynamic(net.kyori.adventure.identity.Identity.UUID, this::getUniqueId)
+                .withStatic(net.kyori.adventure.permission.PermissionChecker.POINTER, this::permissionValue)
+                .withDynamic(net.kyori.adventure.identity.Identity.LOCALE, this::locale)
+                .build();
+        }
+
+        return this.adventure$pointers;
+    }
+    // Paper end
     // Spigot start
     private final Player.Spigot spigot = new Player.Spigot()
     {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftTextDisplay.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftTextDisplay.java
index 5725b0281ac53a2354b233223259d6784353bc6e..9ef939b76d06874b856e0c850addb364146f5a00 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftTextDisplay.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftTextDisplay.java
@@ -32,6 +32,17 @@ public class CraftTextDisplay extends CraftDisplay implements TextDisplay {
     public void setText(String text) {
         this.getHandle().setText(CraftChatMessage.fromString(text, true)[0]);
     }
+    // Paper start
+    @Override
+    public net.kyori.adventure.text.Component text() {
+        return io.papermc.paper.adventure.PaperAdventure.asAdventure(this.getHandle().getText());
+    }
+
+    @Override
+    public void text(net.kyori.adventure.text.Component text) {
+        this.getHandle().setText(text == null ? net.minecraft.network.chat.Component.empty() : io.papermc.paper.adventure.PaperAdventure.asVanilla(text));
+    }
+    // Paper end
 
     @Override
     public int getLineWidth() {
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index d6b2352d5f64a85f7c7e817f395d5cd69275ff0c..4c59520355a21249d2a3132dbaae97fd4e17c86b 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -906,7 +906,7 @@ public class CraftEventFactory {
         return event;
     }
 
-    public static PlayerDeathEvent callPlayerDeathEvent(ServerPlayer victim, DamageSource damageSource, List<org.bukkit.inventory.ItemStack> drops, String deathMessage, boolean keepInventory) {
+    public static PlayerDeathEvent callPlayerDeathEvent(ServerPlayer victim, DamageSource damageSource, List<org.bukkit.inventory.ItemStack> drops, net.kyori.adventure.text.Component deathMessage, boolean keepInventory) { // Paper - Adventure
         CraftPlayer entity = victim.getBukkitEntity();
         CraftDamageSource bukkitDamageSource = new CraftDamageSource(damageSource);
         PlayerDeathEvent event = new PlayerDeathEvent(entity, bukkitDamageSource, drops, victim.getExpReward(), 0, deathMessage);
@@ -934,7 +934,7 @@ public class CraftEventFactory {
      * Server methods
      */
     public static ServerListPingEvent callServerListPingEvent(SocketAddress address, String motd, int numPlayers, int maxPlayers) {
-        ServerListPingEvent event = new ServerListPingEvent("", ((InetSocketAddress) address).getAddress(), motd, numPlayers, maxPlayers);
+        ServerListPingEvent event = new ServerListPingEvent("", ((InetSocketAddress) address).getAddress(), Bukkit.getServer().motd(), numPlayers, maxPlayers);
         Bukkit.getServer().getPluginManager().callEvent(event);
         return event;
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftContainer.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftContainer.java
index d47b248535882bb58ae6c1b6ef756464a1989918..39be45585835eabc8d8bcae0158c094c3dcb1aa3 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftContainer.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftContainer.java
@@ -73,6 +73,13 @@ public class CraftContainer extends AbstractContainerMenu {
                 return inventory.getType();
             }
 
+            // Paper start
+            @Override
+            public net.kyori.adventure.text.Component title() {
+                return inventory instanceof CraftInventoryCustom ? ((CraftInventoryCustom.MinecraftInventory) ((CraftInventory) inventory).getInventory()).title() : net.kyori.adventure.text.Component.text(inventory.getType().getDefaultTitle());
+            }
+            // Paper end
+
             @Override
             public String getTitle() {
                 return this.title;
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryCustom.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryCustom.java
index c9cc23757a9fcc58d30b2915d4c5cfbc7d1c767a..fc0e1212022d1aa3506699b60ef338196eb54eba 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryCustom.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryCustom.java
@@ -19,6 +19,12 @@ public class CraftInventoryCustom extends CraftInventory {
         super(new MinecraftInventory(owner, type));
     }
 
+    // Paper start
+    public CraftInventoryCustom(InventoryHolder owner, InventoryType type, net.kyori.adventure.text.Component title) {
+        super(new MinecraftInventory(owner, type, title));
+    }
+    // Paper end
+
     public CraftInventoryCustom(InventoryHolder owner, InventoryType type, String title) {
         super(new MinecraftInventory(owner, type, title));
     }
@@ -27,6 +33,12 @@ public class CraftInventoryCustom extends CraftInventory {
         super(new MinecraftInventory(owner, size));
     }
 
+    // Paper start
+    public CraftInventoryCustom(InventoryHolder owner, int size, net.kyori.adventure.text.Component title) {
+        super(new MinecraftInventory(owner, size, title));
+    }
+    // Paper end
+
     public CraftInventoryCustom(InventoryHolder owner, int size, String title) {
         super(new MinecraftInventory(owner, size, title));
     }
@@ -36,9 +48,17 @@ public class CraftInventoryCustom extends CraftInventory {
         private int maxStack = MAX_STACK;
         private final List<HumanEntity> viewers;
         private final String title;
+        private final net.kyori.adventure.text.Component adventure$title; // Paper
         private InventoryType type;
         private final InventoryHolder owner;
 
+        // Paper start
+        public MinecraftInventory(InventoryHolder owner, InventoryType type, net.kyori.adventure.text.Component title) {
+            this(owner, type.getDefaultSize(), title);
+            this.type = type;
+        }
+        // Paper end
+
         public MinecraftInventory(InventoryHolder owner, InventoryType type) {
             this(owner, type.getDefaultSize(), type.getDefaultTitle());
             this.type = type;
@@ -57,11 +77,24 @@ public class CraftInventoryCustom extends CraftInventory {
             Preconditions.checkArgument(title != null, "title cannot be null");
             this.items = NonNullList.withSize(size, ItemStack.EMPTY);
             this.title = title;
+            this.adventure$title = net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(title);
             this.viewers = new ArrayList<HumanEntity>();
             this.owner = owner;
             this.type = InventoryType.CHEST;
         }
 
+        // Paper start
+        public MinecraftInventory(final InventoryHolder owner, final int size, final net.kyori.adventure.text.Component title) {
+            Preconditions.checkArgument(title != null, "Title cannot be null");
+            this.items = NonNullList.withSize(size, ItemStack.EMPTY);
+            this.title = net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().serialize(title);
+            this.adventure$title = title;
+            this.viewers = new ArrayList<HumanEntity>();
+            this.owner = owner;
+            this.type = InventoryType.CHEST;
+        }
+        // Paper end
+
         @Override
         public int getContainerSize() {
             return this.items.size();
@@ -183,6 +216,12 @@ public class CraftInventoryCustom extends CraftInventory {
             return null;
         }
 
+        // Paper start
+        public net.kyori.adventure.text.Component title() {
+            return this.adventure$title;
+        }
+        // Paper end
+
         public String getTitle() {
             return this.title;
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryView.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryView.java
index 4dd9a80af9901287ab6740b072f2b89678c3d0cb..b2586684295b295a3196a2a9cf724cec975b5a40 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryView.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryView.java
@@ -73,6 +73,13 @@ public class CraftInventoryView extends InventoryView {
         return CraftItemStack.asCraftMirror(this.container.getSlot(slot).getItem());
     }
 
+    // Paper start
+    @Override
+    public net.kyori.adventure.text.Component title() {
+        return io.papermc.paper.adventure.PaperAdventure.asAdventure(this.container.getTitle());
+    }
+    // Paper end
+
     @Override
     public String getTitle() {
         return this.title;
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemFactory.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemFactory.java
index efbef9a72e1ee7c4928ffc9e3a818dbbca6aa002..e8dd4ba93c09c514f3594f0d4b5f1167b719a17d 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemFactory.java
@@ -499,4 +499,21 @@ public final class CraftItemFactory implements ItemFactory {
         CraftItemStack craft = (CraftItemStack) itemStack;
         return CraftItemStack.asCraftMirror(EnchantmentHelper.enchantItem(MinecraftServer.getServer().getWorldData().enabledFeatures(), source, craft.handle, level, allowTreasures));
     }
+
+    // Paper start - Adventure
+    @Override
+    public net.kyori.adventure.text.event.HoverEvent<net.kyori.adventure.text.event.HoverEvent.ShowItem> asHoverEvent(final ItemStack item, final java.util.function.UnaryOperator<net.kyori.adventure.text.event.HoverEvent.ShowItem> op) {
+        return net.kyori.adventure.text.event.HoverEvent.showItem(op.apply(
+            net.kyori.adventure.text.event.HoverEvent.ShowItem.showItem(
+                item.getType().getKey(),
+                item.getAmount(),
+                io.papermc.paper.adventure.PaperAdventure.asAdventure(CraftItemStack.unwrap(item).getComponentsPatch())) // unwrap is fine here because the components patch will be safely copied
+        ));
+    }
+
+    @Override
+    public net.kyori.adventure.text.@org.jetbrains.annotations.NotNull Component displayName(@org.jetbrains.annotations.NotNull ItemStack itemStack) {
+        return io.papermc.paper.adventure.PaperAdventure.asAdventure(CraftItemStack.asNMSCopy(itemStack).getDisplayName());
+    }
+    // Paper end - Adventure
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMerchantCustom.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMerchantCustom.java
index 9e05a8515c5f6f340182e91150fcad8bbf80a22b..adf22ce4f0bcd3bd57dc2030c6c92d3df96566e3 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMerchantCustom.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMerchantCustom.java
@@ -13,10 +13,17 @@ import org.bukkit.craftbukkit.util.CraftChatMessage;
 
 public class CraftMerchantCustom extends CraftMerchant {
 
+    @Deprecated // Paper - Adventure
     public CraftMerchantCustom(String title) {
         super(new MinecraftMerchant(title));
         this.getMerchant().craftMerchant = this;
     }
+    // Paper start
+    public CraftMerchantCustom(net.kyori.adventure.text.Component title) {
+        super(new MinecraftMerchant(title));
+        getMerchant().craftMerchant = this;
+    }
+    // Paper end
 
     @Override
     public String toString() {
@@ -35,10 +42,17 @@ public class CraftMerchantCustom extends CraftMerchant {
         private Player tradingPlayer;
         protected CraftMerchant craftMerchant;
 
+        @Deprecated // Paper - Adventure
         public MinecraftMerchant(String title) {
             Preconditions.checkArgument(title != null, "Title cannot be null");
             this.title = CraftChatMessage.fromString(title)[0];
         }
+        // Paper start
+        public MinecraftMerchant(net.kyori.adventure.text.Component title) {
+            Preconditions.checkArgument(title != null, "Title cannot be null");
+            this.title = io.papermc.paper.adventure.PaperAdventure.asVanilla(title);
+        }
+        // Paper end
 
         @Override
         public CraftMerchant getCraftMerchant() {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java
index 61ad00c38cfef8a1de61b4597ec1042428feccf4..4da38ebb7fdbdb0f8fa422ebcd2e3eec2b2be846 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java
@@ -2,8 +2,9 @@ package org.bukkit.craftbukkit.inventory;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap.Builder;
 import com.google.common.collect.Lists;
+
+import com.google.common.collect.ImmutableMap; // Paper
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -170,6 +171,130 @@ public class CraftMetaBook extends CraftMetaItem implements BookMeta, WritableBo
     public void setGeneration(Generation generation) {
     }
 
+    // Paper start
+    @Override
+    public net.kyori.adventure.text.Component title() {
+        return null;
+    }
+
+    @Override
+    public org.bukkit.inventory.meta.BookMeta title(net.kyori.adventure.text.Component title) {
+        return this;
+    }
+
+    @Override
+    public net.kyori.adventure.text.Component author() {
+        return null;
+    }
+
+    @Override
+    public org.bukkit.inventory.meta.BookMeta author(net.kyori.adventure.text.Component author) {
+        return this;
+    }
+
+    @Override
+    public net.kyori.adventure.text.Component page(final int page) {
+        Preconditions.checkArgument(this.isValidPage(page), "Invalid page number");
+        return net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(this.pages.get(page - 1));
+    }
+
+    @Override
+    public void page(final int page, net.kyori.adventure.text.Component data) {
+        if (!this.isValidPage(page)) {
+            throw new IllegalArgumentException("Invalid page number " + page + "/" + this.pages.size());
+        }
+        if (data == null) {
+            data = net.kyori.adventure.text.Component.empty();
+        }
+        this.pages.set(page - 1, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().serialize(data));
+    }
+
+    @Override
+    public List<net.kyori.adventure.text.Component> pages() {
+        if (this.pages == null) return ImmutableList.of();
+        return this.pages.stream().map(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection()::deserialize).collect(ImmutableList.toImmutableList());
+    }
+
+    @Override
+    public BookMeta pages(List<net.kyori.adventure.text.Component> pages) {
+        if (this.pages != null) this.pages.clear();
+        for (net.kyori.adventure.text.Component page : pages) {
+            this.addPages(page);
+        }
+        return this;
+    }
+
+    @Override
+    public BookMeta pages(net.kyori.adventure.text.Component... pages) {
+        if (this.pages != null) this.pages.clear();
+        this.addPages(pages);
+        return this;
+    }
+
+    @Override
+    public void addPages(net.kyori.adventure.text.Component... pages) {
+        if (this.pages == null) this.pages = new ArrayList<>();
+        for (net.kyori.adventure.text.Component page : pages) {
+            if (this.pages.size() >= MAX_PAGES) {
+                return;
+            }
+
+            if (page == null) {
+                page = net.kyori.adventure.text.Component.empty();
+            }
+
+            this.pages.add(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().serialize(page));
+        }
+    }
+
+    private CraftMetaBook(List<net.kyori.adventure.text.Component> pages) {
+        super((org.bukkit.craftbukkit.inventory.CraftMetaItem) org.bukkit.Bukkit.getItemFactory().getItemMeta(org.bukkit.Material.WRITABLE_BOOK));
+        this.pages = pages.subList(0, Math.min(MAX_PAGES, pages.size())).stream().map(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection()::serialize).collect(java.util.stream.Collectors.toList());
+    }
+
+    static class CraftMetaBookBuilder implements BookMetaBuilder {
+        protected final List<net.kyori.adventure.text.Component> pages = new java.util.ArrayList<>();
+
+        @Override
+        public BookMetaBuilder title(net.kyori.adventure.text.Component title) {
+            return this;
+        }
+
+        @Override
+        public BookMetaBuilder author(net.kyori.adventure.text.Component author) {
+            return this;
+        }
+
+        @Override
+        public BookMetaBuilder addPage(net.kyori.adventure.text.Component page) {
+            this.pages.add(page);
+            return this;
+        }
+
+        @Override
+        public BookMetaBuilder pages(net.kyori.adventure.text.Component... pages) {
+            java.util.Collections.addAll(this.pages, pages);
+            return this;
+        }
+
+        @Override
+        public BookMetaBuilder pages(java.util.Collection<net.kyori.adventure.text.Component> pages) {
+            this.pages.addAll(pages);
+            return this;
+        }
+
+        @Override
+        public BookMeta build() {
+            return new CraftMetaBook(this.pages);
+        }
+    }
+
+    @Override
+    public BookMetaBuilder toBuilder() {
+        return new CraftMetaBookBuilder();
+    }
+
+    // Paper end
     @Override
     public String getPage(final int page) {
         Preconditions.checkArgument(this.isValidPage(page), "Invalid page number (%s)", page);
@@ -286,7 +411,7 @@ public class CraftMetaBook extends CraftMetaItem implements BookMeta, WritableBo
     }
 
     @Override
-    Builder<String, Object> serialize(Builder<String, Object> builder) {
+    ImmutableMap.Builder<String, Object> serialize(ImmutableMap.Builder<String, Object> builder) {
         super.serialize(builder);
 
         if (this.pages != null) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBookSigned.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBookSigned.java
index 2e6f0a0f4bbe4ae3c7c85e679f6187e89d1298ff..c7360e2b2d6e50abc371c21b09cdadd63892f439 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBookSigned.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBookSigned.java
@@ -2,7 +2,7 @@ package org.bukkit.craftbukkit.inventory;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap.Builder;
+import com.google.common.collect.ImmutableMap; // Paper
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -346,7 +346,7 @@ public class CraftMetaBookSigned extends CraftMetaItem implements BookMeta {
     }
 
     @Override
-    Builder<String, Object> serialize(Builder<String, Object> builder) {
+    ImmutableMap.Builder<String, Object> serialize(ImmutableMap.Builder<String, Object> builder) {
         super.serialize(builder);
 
         if (this.hasTitle()) {
@@ -459,4 +459,113 @@ public class CraftMetaBookSigned extends CraftMetaItem implements BookMeta {
         return this.spigot;
     }
     // Spigot end
+
+    // Paper start - adventure
+    public static final net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer LEGACY_DOWNSAMPLING_COMPONENT_SERIALIZER = net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.builder()
+        .character(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.SECTION_CHAR)
+        .build();
+    private CraftMetaBookSigned(net.kyori.adventure.text.Component title, net.kyori.adventure.text.Component author, java.util.List<net.kyori.adventure.text.Component> pages) {
+        super((org.bukkit.craftbukkit.inventory.CraftMetaItem) org.bukkit.Bukkit.getItemFactory().getItemMeta(Material.WRITABLE_BOOK));
+        this.title = title == null ? null : LEGACY_DOWNSAMPLING_COMPONENT_SERIALIZER.serialize(title);
+        this.author = author == null ? null : LEGACY_DOWNSAMPLING_COMPONENT_SERIALIZER.serialize(author);
+        this.pages = io.papermc.paper.adventure.PaperAdventure.asVanilla(pages.subList(0, Math.min(MAX_PAGES, pages.size())));
+    }
+
+    static final class CraftMetaBookSignedBuilder extends CraftMetaBook.CraftMetaBookBuilder {
+        private net.kyori.adventure.text.Component title;
+        private net.kyori.adventure.text.Component author;
+
+        @Override
+        public org.bukkit.inventory.meta.BookMeta.BookMetaBuilder title(final net.kyori.adventure.text.Component title) {
+            this.title = title;
+            return this;
+        }
+
+        @Override
+        public org.bukkit.inventory.meta.BookMeta.BookMetaBuilder author(final net.kyori.adventure.text.Component author) {
+            this.author = author;
+            return this;
+        }
+
+        @Override
+        public org.bukkit.inventory.meta.BookMeta build() {
+            return new CraftMetaBookSigned(this.title, this.author, this.pages);
+        }
+    }
+
+    @Override
+    public BookMetaBuilder toBuilder() {
+        return new CraftMetaBookSignedBuilder();
+    }
+
+    @Override
+    public net.kyori.adventure.text.Component title() {
+        return this.title == null ? null : LEGACY_DOWNSAMPLING_COMPONENT_SERIALIZER.deserialize(this.title);
+    }
+
+    @Override
+    public org.bukkit.inventory.meta.BookMeta title(net.kyori.adventure.text.Component title) {
+        this.setTitle(title == null ? null : LEGACY_DOWNSAMPLING_COMPONENT_SERIALIZER.serialize(title));
+        return this;
+    }
+
+    @Override
+    public net.kyori.adventure.text.Component author() {
+        return this.author == null ? null : LEGACY_DOWNSAMPLING_COMPONENT_SERIALIZER.deserialize(this.author);
+    }
+
+    @Override
+    public org.bukkit.inventory.meta.BookMeta author(net.kyori.adventure.text.Component author) {
+        this.setAuthor(author == null ? null : LEGACY_DOWNSAMPLING_COMPONENT_SERIALIZER.serialize(author));
+        return this;
+    }
+
+    @Override
+    public net.kyori.adventure.text.Component page(final int page) {
+        Preconditions.checkArgument(this.isValidPage(page), "Invalid page number");
+        return io.papermc.paper.adventure.PaperAdventure.asAdventure(this.pages.get(page - 1));
+    }
+
+    @Override
+    public void page(final int page, net.kyori.adventure.text.Component data) {
+        if (!this.isValidPage(page)) {
+            throw new IllegalArgumentException("Invalid page number " + page + "/" + this.pages.size());
+        }
+        this.pages.set(page - 1, io.papermc.paper.adventure.PaperAdventure.asVanillaNullToEmpty(data));
+    }
+
+    @Override
+    public List<net.kyori.adventure.text.Component> pages() {
+        if (this.pages == null) return ImmutableList.of();
+        return this.pages.stream().map(io.papermc.paper.adventure.PaperAdventure::asAdventure).collect(ImmutableList.toImmutableList());
+    }
+
+    @Override
+    public BookMeta pages(List<net.kyori.adventure.text.Component> pages) {
+        if (this.pages != null) this.pages.clear();
+        for (net.kyori.adventure.text.Component page : pages) {
+            this.addPages(page);
+        }
+        return this;
+    }
+
+    @Override
+    public BookMeta pages(net.kyori.adventure.text.Component... pages) {
+        if (this.pages != null) this.pages.clear();
+        this.addPages(pages);
+        return this;
+    }
+
+    @Override
+    public void addPages(net.kyori.adventure.text.Component... pages) {
+        if (this.pages == null) this.pages = new ArrayList<>();
+        for (net.kyori.adventure.text.Component page : pages) {
+            if (this.pages.size() >= MAX_PAGES) {
+                return;
+            }
+
+            this.pages.add(io.papermc.paper.adventure.PaperAdventure.asVanillaNullToEmpty(page));
+        }
+    }
+    // Paper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
index c33161090f6f746c04a87ca5b71f4df80f4fd246..41ba64593bd548131d1cdbecc79b2f38406aa78b 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
@@ -883,6 +883,18 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         return !(this.hasDisplayName() || this.hasItemName() || this.hasLocalizedName() || this.hasEnchants() || (this.lore != null) || this.hasCustomModelData() || this.hasBlockData() || this.hasRepairCost() || !this.unhandledTags.build().isEmpty() || !this.persistentDataContainer.isEmpty() || this.hideFlag != 0 || this.isHideTooltip() || this.isUnbreakable() || this.hasEnchantmentGlintOverride() || this.isFireResistant() || this.hasMaxStackSize() || this.hasRarity() || this.hasFood() || this.hasTool() || this.hasDamage() || this.hasMaxDamage() || this.hasAttributeModifiers() || this.customTag != null);
     }
 
+    // Paper start
+    @Override
+    public net.kyori.adventure.text.Component displayName() {
+        return displayName == null ? null : io.papermc.paper.adventure.PaperAdventure.asAdventure(displayName);
+    }
+
+    @Override
+    public void displayName(final net.kyori.adventure.text.Component displayName) {
+        this.displayName = displayName == null ? null : io.papermc.paper.adventure.PaperAdventure.asVanilla(displayName);
+    }
+    // Paper end
+
     @Override
     public String getDisplayName() {
         return CraftChatMessage.fromComponent(this.displayName);
@@ -913,6 +925,18 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         return this.itemName != null;
     }
 
+    // Paper start - Adventure
+    @Override
+    public net.kyori.adventure.text.Component itemName() {
+        return io.papermc.paper.adventure.PaperAdventure.asAdventure(this.itemName);
+    }
+
+    @Override
+    public void itemName(final net.kyori.adventure.text.Component name) {
+        this.itemName = io.papermc.paper.adventure.PaperAdventure.asVanilla(name);
+    }
+    // Paper end - Adventure
+
     @Override
     public String getLocalizedName() {
         return this.getDisplayName();
@@ -932,6 +956,18 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         return this.lore != null && !this.lore.isEmpty();
     }
 
+    // Paper start
+    @Override
+    public List<net.kyori.adventure.text.Component> lore() {
+        return this.lore != null ? io.papermc.paper.adventure.PaperAdventure.asAdventure(this.lore) : null;
+    }
+
+    @Override
+    public void lore(final List<? extends net.kyori.adventure.text.Component> lore) {
+        this.lore = lore != null ? io.papermc.paper.adventure.PaperAdventure.asVanilla(lore) : null;
+    }
+    // Paper end
+
     @Override
     public boolean hasRepairCost() {
         return this.repairCost > 0;
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/trim/CraftTrimMaterial.java b/src/main/java/org/bukkit/craftbukkit/inventory/trim/CraftTrimMaterial.java
index 8952e5526cfe90ad16a7af28b0a8d9c65b159f90..cd3e35867075e65f46051fb88d8a2460a8bb4b53 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/trim/CraftTrimMaterial.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/trim/CraftTrimMaterial.java
@@ -60,6 +60,14 @@ public class CraftTrimMaterial implements TrimMaterial, Handleable<net.minecraft
     @NotNull
     @Override
     public String getTranslationKey() {
+        if (!(this.handle.description().getContents() instanceof TranslatableContents)) throw new UnsupportedOperationException("Description isn't translatable!"); // Paper
         return ((TranslatableContents) this.handle.description().getContents()).getKey();
     }
+
+    // Paper start - adventure
+    @Override
+    public net.kyori.adventure.text.Component description() {
+        return io.papermc.paper.adventure.PaperAdventure.asAdventure(this.handle.description());
+    }
+    // Paper end - adventure
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/trim/CraftTrimPattern.java b/src/main/java/org/bukkit/craftbukkit/inventory/trim/CraftTrimPattern.java
index 0a6df5fdaf6724bb1cf777d527f032e2ae74fbbd..364f8d7a7106259401154d91b1b79869d014a469 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/trim/CraftTrimPattern.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/trim/CraftTrimPattern.java
@@ -60,6 +60,14 @@ public class CraftTrimPattern implements TrimPattern, Handleable<net.minecraft.w
     @NotNull
     @Override
     public String getTranslationKey() {
+        if (!(this.handle.description().getContents() instanceof TranslatableContents)) throw new UnsupportedOperationException("Description isn't translatable!"); // Paper
         return ((TranslatableContents) this.handle.description().getContents()).getKey();
     }
+
+    // Paper start - adventure
+    @Override
+    public net.kyori.adventure.text.Component description() {
+        return io.papermc.paper.adventure.PaperAdventure.asAdventure(this.handle.description());
+    }
+    // Paper end - adventure
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/util/CraftCustomInventoryConverter.java b/src/main/java/org/bukkit/craftbukkit/inventory/util/CraftCustomInventoryConverter.java
index ed4415f6dd588c08c922efd5beebb3b124beb9d6..78a7ac47f20e84ccd67ff44d0bc7a2f2faa0d476 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/util/CraftCustomInventoryConverter.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/util/CraftCustomInventoryConverter.java
@@ -12,6 +12,13 @@ public class CraftCustomInventoryConverter implements CraftInventoryCreator.Inve
         return new CraftInventoryCustom(holder, type);
     }
 
+    // Paper start
+    @Override
+    public Inventory createInventory(InventoryHolder owner, InventoryType type, net.kyori.adventure.text.Component title) {
+        return new CraftInventoryCustom(owner, type, title);
+    }
+    // Paper end
+
     @Override
     public Inventory createInventory(InventoryHolder owner, InventoryType type, String title) {
         return new CraftInventoryCustom(owner, type, title);
@@ -21,6 +28,12 @@ public class CraftCustomInventoryConverter implements CraftInventoryCreator.Inve
         return new CraftInventoryCustom(owner, size);
     }
 
+    // Paper start
+    public Inventory createInventory(InventoryHolder owner, int size, net.kyori.adventure.text.Component title) {
+        return new CraftInventoryCustom(owner, size, title);
+    }
+    // Paper end
+
     public Inventory createInventory(InventoryHolder owner, int size, String title) {
         return new CraftInventoryCustom(owner, size, title);
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/util/CraftInventoryCreator.java b/src/main/java/org/bukkit/craftbukkit/inventory/util/CraftInventoryCreator.java
index ec8ef47ed7cc627fef2c71b2b281119245e88b97..53cbc743b1e722d029021f9d63ffbf7d0fddd04e 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/util/CraftInventoryCreator.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/util/CraftInventoryCreator.java
@@ -45,6 +45,12 @@ public final class CraftInventoryCreator {
         return this.converterMap.get(type).createInventory(holder, type);
     }
 
+    // Paper start
+    public Inventory createInventory(InventoryHolder holder, InventoryType type, net.kyori.adventure.text.Component title) {
+        return converterMap.get(type).createInventory(holder, type, title);
+    }
+    // Paper end
+
     public Inventory createInventory(InventoryHolder holder, InventoryType type, String title) {
         return this.converterMap.get(type).createInventory(holder, type, title);
     }
@@ -53,6 +59,12 @@ public final class CraftInventoryCreator {
         return this.DEFAULT_CONVERTER.createInventory(holder, size);
     }
 
+    // Paper start
+    public Inventory createInventory(InventoryHolder holder, int size, net.kyori.adventure.text.Component title) {
+        return DEFAULT_CONVERTER.createInventory(holder, size, title);
+    }
+    // Paper end
+
     public Inventory createInventory(InventoryHolder holder, int size, String title) {
         return this.DEFAULT_CONVERTER.createInventory(holder, size, title);
     }
@@ -61,6 +73,10 @@ public final class CraftInventoryCreator {
 
         Inventory createInventory(InventoryHolder holder, InventoryType type);
 
+        // Paper start
+        Inventory createInventory(InventoryHolder holder, InventoryType type, net.kyori.adventure.text.Component title);
+        // Paper end
+
         Inventory createInventory(InventoryHolder holder, InventoryType type, String title);
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/util/CraftTileInventoryConverter.java b/src/main/java/org/bukkit/craftbukkit/inventory/util/CraftTileInventoryConverter.java
index 11d23b3a9a0c99ede04f2cd64d8022b2b0b737df..7bc082d08a3d577481046818f0d58133413fc723 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/util/CraftTileInventoryConverter.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/util/CraftTileInventoryConverter.java
@@ -31,6 +31,18 @@ public abstract class CraftTileInventoryConverter implements CraftInventoryCreat
         return this.getInventory(this.getTileEntity());
     }
 
+    // Paper start
+    @Override
+    public Inventory createInventory(InventoryHolder owner, InventoryType type, net.kyori.adventure.text.Component title) {
+        Container te = getTileEntity();
+        if (te instanceof RandomizableContainerBlockEntity) {
+            ((RandomizableContainerBlockEntity) te).name = io.papermc.paper.adventure.PaperAdventure.asVanilla(title);
+        }
+
+        return getInventory(te);
+    }
+    // Paper end
+
     @Override
     public Inventory createInventory(InventoryHolder holder, InventoryType type, String title) {
         Container te = this.getTileEntity();
@@ -53,6 +65,15 @@ public abstract class CraftTileInventoryConverter implements CraftInventoryCreat
             return furnace;
         }
 
+        // Paper start
+        @Override
+        public Inventory createInventory(InventoryHolder owner, InventoryType type, net.kyori.adventure.text.Component title) {
+            Container tileEntity = getTileEntity();
+            ((AbstractFurnaceBlockEntity) tileEntity).setCustomName(io.papermc.paper.adventure.PaperAdventure.asVanilla(title));
+            return getInventory(tileEntity);
+        }
+        // Paper end
+
         @Override
         public Inventory createInventory(InventoryHolder owner, InventoryType type, String title) {
             Container tileEntity = this.getTileEntity();
@@ -73,6 +94,18 @@ public abstract class CraftTileInventoryConverter implements CraftInventoryCreat
             return new BrewingStandBlockEntity(BlockPos.ZERO, Blocks.BREWING_STAND.defaultBlockState());
         }
 
+        // Paper start
+        @Override
+        public Inventory createInventory(InventoryHolder owner, InventoryType type, net.kyori.adventure.text.Component title) {
+            // BrewingStand does not extend TileEntityLootable
+            Container tileEntity = getTileEntity();
+            if (tileEntity instanceof BrewingStandBlockEntity) {
+                ((BrewingStandBlockEntity) tileEntity).name = io.papermc.paper.adventure.PaperAdventure.asVanilla(title);
+            }
+            return getInventory(tileEntity);
+        }
+        // Paper end
+
         @Override
         public Inventory createInventory(InventoryHolder holder, InventoryType type, String title) {
             // BrewingStand does not extend TileEntityLootable
diff --git a/src/main/java/org/bukkit/craftbukkit/map/CraftMapRenderer.java b/src/main/java/org/bukkit/craftbukkit/map/CraftMapRenderer.java
index 9efd33cc208af7068be6cf4040dd398f2506c709..0cbbd915631904fe8c6effefb92895422b33eff6 100644
--- a/src/main/java/org/bukkit/craftbukkit/map/CraftMapRenderer.java
+++ b/src/main/java/org/bukkit/craftbukkit/map/CraftMapRenderer.java
@@ -43,7 +43,7 @@ public class CraftMapRenderer extends MapRenderer {
             }
 
             MapDecoration decoration = this.worldMap.decorations.get(key);
-            cursors.addCursor(new MapCursor(decoration.x(), decoration.y(), (byte) (decoration.rot() & 15), CraftMapCursor.CraftType.minecraftHolderToBukkit(decoration.type()), true, CraftChatMessage.fromComponent(decoration.name().orElse(null))));
+            cursors.addCursor(new MapCursor(decoration.x(), decoration.y(), (byte) (decoration.rot() & 15), CraftMapCursor.CraftType.minecraftHolderToBukkit(decoration.type()), true, decoration.name().isEmpty() ? null : io.papermc.paper.adventure.PaperAdventure.asAdventure(decoration.name().get()))); // Paper
         }
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftObjective.java b/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftObjective.java
index 5c987c7d9e43bb481800935cbc918a43a3656524..da1e4496d78a2c1b258ff8bb316414cb8a662ba2 100644
--- a/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftObjective.java
+++ b/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftObjective.java
@@ -31,6 +31,21 @@ final class CraftObjective extends CraftScoreboardComponent implements Objective
         return this.objective.getName();
     }
 
+    // Paper start
+    @Override
+    public net.kyori.adventure.text.Component displayName() throws IllegalStateException {
+        CraftScoreboard scoreboard = checkState();
+        return io.papermc.paper.adventure.PaperAdventure.asAdventure(objective.getDisplayName());
+    }
+    @Override
+    public void displayName(net.kyori.adventure.text.Component displayName) throws IllegalStateException, IllegalArgumentException {
+        if (displayName == null) {
+            displayName = net.kyori.adventure.text.Component.empty();
+        }
+        CraftScoreboard scoreboard = checkState();
+        objective.setDisplayName(io.papermc.paper.adventure.PaperAdventure.asVanilla(displayName));
+    }
+    // Paper end
     @Override
     public String getDisplayName() {
         this.checkState();
diff --git a/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftScoreboard.java b/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftScoreboard.java
index d9f8a0c894a2a70b3dc2cef4feb87363627ec73a..5681630159bb52628e6cc391db324bbafe333414 100644
--- a/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftScoreboard.java
+++ b/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftScoreboard.java
@@ -29,6 +29,33 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     public CraftObjective registerNewObjective(String name, String criteria) {
         return this.registerNewObjective(name, criteria, name);
     }
+    // Paper start - Adventure
+    @Override
+    public CraftObjective registerNewObjective(String name, String criteria, net.kyori.adventure.text.Component displayName) {
+        return this.registerNewObjective(name, CraftCriteria.getFromBukkit(criteria), displayName, RenderType.INTEGER);
+    }
+    @Override
+    public CraftObjective registerNewObjective(String name, String criteria, net.kyori.adventure.text.Component displayName, RenderType renderType) {
+        return this.registerNewObjective(name, CraftCriteria.getFromBukkit(criteria), displayName, renderType);
+    }
+    @Override
+    public CraftObjective registerNewObjective(String name, Criteria criteria, net.kyori.adventure.text.Component displayName) throws IllegalArgumentException {
+        return this.registerNewObjective(name, criteria, displayName, RenderType.INTEGER);
+    }
+    @Override
+    public CraftObjective registerNewObjective(String name, Criteria criteria, net.kyori.adventure.text.Component displayName, RenderType renderType) throws IllegalArgumentException {
+        if (displayName == null) {
+            displayName = net.kyori.adventure.text.Component.empty();
+        }
+        Preconditions.checkArgument(name != null, "Objective name cannot be null");
+        Preconditions.checkArgument(criteria != null, "Criteria cannot be null");
+        Preconditions.checkArgument(renderType != null, "RenderType cannot be null");
+        Preconditions.checkArgument(name.length() <= Short.MAX_VALUE, "The name '%s' is longer than the limit of 32767 characters (%s)", name, name.length());
+        Preconditions.checkArgument(this.board.getObjective(name) == null, "An objective of name '%s' already exists", name);
+        net.minecraft.world.scores.Objective objective = this.board.addObjective(name, ((CraftCriteria) criteria).criteria, io.papermc.paper.adventure.PaperAdventure.asVanilla(displayName), CraftScoreboardTranslations.fromBukkitRender(renderType), true, null);
+        return new CraftObjective(this, objective);
+    }
+    // Paper end - Adventure
 
     @Override
     public CraftObjective registerNewObjective(String name, String criteria, String displayName) {
@@ -47,15 +74,7 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
 
     @Override
     public CraftObjective registerNewObjective(String name, Criteria criteria, String displayName, RenderType renderType) {
-        Preconditions.checkArgument(name != null, "Objective name cannot be null");
-        Preconditions.checkArgument(criteria != null, "Criteria cannot be null");
-        Preconditions.checkArgument(displayName != null, "Display name cannot be null");
-        Preconditions.checkArgument(renderType != null, "RenderType cannot be null");
-        Preconditions.checkArgument(name.length() <= Short.MAX_VALUE, "The name '%s' is longer than the limit of 32767 characters (%s)", name, name.length());
-        Preconditions.checkArgument(this.board.getObjective(name) == null, "An objective of name '%s' already exists", name);
-
-        net.minecraft.world.scores.Objective objective = this.board.addObjective(name, ((CraftCriteria) criteria).criteria, CraftChatMessage.fromStringOrNull(displayName), CraftScoreboardTranslations.fromBukkitRender(renderType), true, null);
-        return new CraftObjective(this, objective);
+        return this.registerNewObjective(name, criteria, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(displayName), renderType); // Paper - Adventure
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftTeam.java b/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftTeam.java
index 4d586e1375ed8782939c9d480479e0dd981f8cbc..7900adb0b158bc17dd792dd082c338547bc1aa0a 100644
--- a/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftTeam.java
+++ b/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftTeam.java
@@ -26,6 +26,63 @@ final class CraftTeam extends CraftScoreboardComponent implements Team {
 
         return this.team.getName();
     }
+    // Paper start
+    @Override
+    public net.kyori.adventure.text.Component displayName() throws IllegalStateException {
+        CraftScoreboard scoreboard = checkState();
+        return io.papermc.paper.adventure.PaperAdventure.asAdventure(team.getDisplayName());
+    }
+    @Override
+    public void displayName(net.kyori.adventure.text.Component displayName) throws IllegalStateException, IllegalArgumentException {
+        if (displayName == null) displayName = net.kyori.adventure.text.Component.empty();
+        CraftScoreboard scoreboard = checkState();
+        team.setDisplayName(io.papermc.paper.adventure.PaperAdventure.asVanilla(displayName));
+    }
+    @Override
+    public net.kyori.adventure.text.Component prefix() throws IllegalStateException {
+        CraftScoreboard scoreboard = checkState();
+        return io.papermc.paper.adventure.PaperAdventure.asAdventure(team.getPlayerPrefix());
+    }
+    @Override
+    public void prefix(net.kyori.adventure.text.Component prefix) throws IllegalStateException, IllegalArgumentException {
+        if (prefix == null) prefix = net.kyori.adventure.text.Component.empty();
+        CraftScoreboard scoreboard = checkState();
+        team.setPlayerPrefix(io.papermc.paper.adventure.PaperAdventure.asVanilla(prefix));
+    }
+    @Override
+    public net.kyori.adventure.text.Component suffix() throws IllegalStateException {
+        CraftScoreboard scoreboard = checkState();
+        return io.papermc.paper.adventure.PaperAdventure.asAdventure(team.getPlayerSuffix());
+    }
+    @Override
+    public void suffix(net.kyori.adventure.text.Component suffix) throws IllegalStateException, IllegalArgumentException {
+        if (suffix == null) suffix = net.kyori.adventure.text.Component.empty();
+        CraftScoreboard scoreboard = checkState();
+        team.setPlayerSuffix(io.papermc.paper.adventure.PaperAdventure.asVanilla(suffix));
+    }
+    @Override
+    public boolean hasColor() {
+        CraftScoreboard scoreboard = checkState();
+        return this.team.getColor().getColor() != null;
+    }
+    @Override
+    public net.kyori.adventure.text.format.TextColor color() throws IllegalStateException {
+        CraftScoreboard scoreboard = checkState();
+        if (team.getColor().getColor() == null) throw new IllegalStateException("Team colors must have hex values");
+        net.kyori.adventure.text.format.TextColor color = net.kyori.adventure.text.format.TextColor.color(team.getColor().getColor());
+        if (!(color instanceof net.kyori.adventure.text.format.NamedTextColor)) throw new IllegalStateException("Team doesn't have a NamedTextColor");
+        return (net.kyori.adventure.text.format.NamedTextColor) color;
+    }
+    @Override
+    public void color(net.kyori.adventure.text.format.NamedTextColor color) {
+        CraftScoreboard scoreboard = checkState();
+        if (color == null) {
+            this.team.setColor(net.minecraft.ChatFormatting.RESET);
+        } else {
+            this.team.setColor(io.papermc.paper.adventure.PaperAdventure.asVanilla(color));
+        }
+    }
+    // Paper end
 
     @Override
     public String getDisplayName() {
@@ -303,4 +360,20 @@ final class CraftTeam extends CraftScoreboardComponent implements Team {
         return !(this.team != other.team && (this.team == null || !this.team.equals(other.team)));
     }
 
+    // Paper start - make Team extend ForwardingAudience
+    @Override
+    public @org.jetbrains.annotations.NotNull Iterable<? extends net.kyori.adventure.audience.Audience> audiences() {
+        this.checkState();
+        java.util.List<net.kyori.adventure.audience.Audience> audiences = new java.util.ArrayList<>();
+        for (String playerName : this.team.getPlayers()) {
+            org.bukkit.entity.Player player = Bukkit.getPlayerExact(playerName);
+            if (player != null) {
+                audiences.add(player);
+            }
+        }
+
+        return audiences;
+    }
+    // Paper end - make Team extend ForwardingAudience
+
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftChatMessage.java b/src/main/java/org/bukkit/craftbukkit/util/CraftChatMessage.java
index 28038c3a531680201dcc8f2716b8f46f3886e769..5a9ddf71dc186c537a23083ac59434fb446a2140 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftChatMessage.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftChatMessage.java
@@ -308,6 +308,7 @@ public final class CraftChatMessage {
 
     public static String fromComponent(Component component) {
         if (component == null) return "";
+        if (component instanceof io.papermc.paper.adventure.AdventureComponent) component = ((io.papermc.paper.adventure.AdventureComponent) component).deepConverted();
         StringBuilder out = new StringBuilder();
 
         boolean hadFormat = false;
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index 8a5d5d3bccc974feea09119eb90732934c8ae6a1..8727d09566cba3b7223e4c72f960e568a9d8bb62 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -81,6 +81,43 @@ public final class CraftMagicNumbers implements UnsafeValues {
 
     private CraftMagicNumbers() {}
 
+    // Paper start
+    @Override
+    public net.kyori.adventure.text.flattener.ComponentFlattener componentFlattener() {
+        return io.papermc.paper.adventure.PaperAdventure.FLATTENER;
+    }
+
+    @Override
+    public net.kyori.adventure.text.serializer.gson.GsonComponentSerializer colorDownsamplingGsonComponentSerializer() {
+        return net.kyori.adventure.text.serializer.gson.GsonComponentSerializer.colorDownsamplingGson();
+    }
+
+    @Override
+    public net.kyori.adventure.text.serializer.gson.GsonComponentSerializer gsonComponentSerializer() {
+        return net.kyori.adventure.text.serializer.gson.GsonComponentSerializer.gson();
+    }
+
+    @Override
+    public net.kyori.adventure.text.serializer.plain.PlainComponentSerializer plainComponentSerializer() {
+        return io.papermc.paper.adventure.PaperAdventure.PLAIN;
+    }
+
+    @Override
+    public net.kyori.adventure.text.serializer.plain.PlainTextComponentSerializer plainTextSerializer() {
+        return net.kyori.adventure.text.serializer.plain.PlainTextComponentSerializer.plainText();
+    }
+
+    @Override
+    public net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer legacyComponentSerializer() {
+        return net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection();
+    }
+
+    @Override
+    public net.kyori.adventure.text.Component resolveWithContext(final net.kyori.adventure.text.Component component, final org.bukkit.command.CommandSender context, final org.bukkit.entity.Entity scoreboardSubject, final boolean bypassPermissions) throws IOException {
+        return io.papermc.paper.adventure.PaperAdventure.resolveWithContext(component, context, scoreboardSubject, bypassPermissions);
+    }
+    // Paper end
+
     public static BlockState getBlock(MaterialData material) {
         return CraftMagicNumbers.getBlock(material.getItemType(), material.getData());
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/LazyHashSet.java b/src/main/java/org/bukkit/craftbukkit/util/LazyHashSet.java
index 62c66e3179b9557cdba46242df0fb15bce7e7710..73a37638abacdffbff8274291a64ea6cd0be7a5e 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/LazyHashSet.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/LazyHashSet.java
@@ -80,7 +80,7 @@ public abstract class LazyHashSet<E> implements Set<E> {
         return this.reference = this.makeReference();
     }
 
-    abstract Set<E> makeReference();
+    protected abstract Set<E> makeReference(); // Paper - protected
 
     public boolean isLazy() {
         return this.reference == null;
diff --git a/src/main/java/org/bukkit/craftbukkit/util/LazyPlayerSet.java b/src/main/java/org/bukkit/craftbukkit/util/LazyPlayerSet.java
index 0ab4c7eaffe69b314423732dd529aaeafc476e08..8a44e7260518bda87c6d0eeade98d5b81a04c3b6 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/LazyPlayerSet.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/LazyPlayerSet.java
@@ -16,9 +16,14 @@ public class LazyPlayerSet extends LazyHashSet<Player> {
     }
 
     @Override
-    HashSet<Player> makeReference() {
+    protected HashSet<Player> makeReference() { // Paper - protected
         Preconditions.checkState(this.reference == null, "Reference already created!");
-        List<ServerPlayer> players = this.server.getPlayerList().players;
+        // Paper start
+        return makePlayerSet(this.server);
+    }
+    public static HashSet<Player> makePlayerSet(final MinecraftServer server) {
+        List<ServerPlayer> players = server.getPlayerList().players;
+        // Paper end
         HashSet<Player> reference = new HashSet<Player>(players.size());
         for (ServerPlayer player : players) {
             reference.add(player.getBukkitEntity());
diff --git a/src/main/resources/META-INF/services/net.kyori.adventure.bossbar.BossBarImplementation$Provider b/src/main/resources/META-INF/services/net.kyori.adventure.bossbar.BossBarImplementation$Provider
new file mode 100644
index 0000000000000000000000000000000000000000..9b7119d0b88bf7f9d25fab37a15340cabc0c9b7b
--- /dev/null
+++ b/src/main/resources/META-INF/services/net.kyori.adventure.bossbar.BossBarImplementation$Provider
@@ -0,0 +1 @@
+io.papermc.paper.adventure.providers.BossBarImplementationProvider
diff --git a/src/main/resources/META-INF/services/net.kyori.adventure.text.event.ClickCallback$Provider b/src/main/resources/META-INF/services/net.kyori.adventure.text.event.ClickCallback$Provider
new file mode 100644
index 0000000000000000000000000000000000000000..845711e03c41c6b6a03d541f1c43d37b24c11733
--- /dev/null
+++ b/src/main/resources/META-INF/services/net.kyori.adventure.text.event.ClickCallback$Provider
@@ -0,0 +1 @@
+io.papermc.paper.adventure.providers.ClickCallbackProviderImpl
diff --git a/src/main/resources/META-INF/services/net.kyori.adventure.text.event.DataComponentValueConverterRegistry$Provider b/src/main/resources/META-INF/services/net.kyori.adventure.text.event.DataComponentValueConverterRegistry$Provider
new file mode 100644
index 0000000000000000000000000000000000000000..714cb03596627badb6ad7f23b17f2e686761a9b5
--- /dev/null
+++ b/src/main/resources/META-INF/services/net.kyori.adventure.text.event.DataComponentValueConverterRegistry$Provider
@@ -0,0 +1 @@
+io.papermc.paper.adventure.providers.DataComponentValueConverterProviderImpl
diff --git a/src/main/resources/META-INF/services/net.kyori.adventure.text.logger.slf4j.ComponentLoggerProvider b/src/main/resources/META-INF/services/net.kyori.adventure.text.logger.slf4j.ComponentLoggerProvider
new file mode 100644
index 0000000000000000000000000000000000000000..399bde6e57cd82b50d3ebe0f51a3958fa2d52d43
--- /dev/null
+++ b/src/main/resources/META-INF/services/net.kyori.adventure.text.logger.slf4j.ComponentLoggerProvider
@@ -0,0 +1 @@
+io.papermc.paper.adventure.providers.ComponentLoggerProviderImpl
diff --git a/src/main/resources/META-INF/services/net.kyori.adventure.text.minimessage.MiniMessage$Provider b/src/main/resources/META-INF/services/net.kyori.adventure.text.minimessage.MiniMessage$Provider
new file mode 100644
index 0000000000000000000000000000000000000000..6ce632b6c9dc5e4b3b978331df51c0ffd1526471
--- /dev/null
+++ b/src/main/resources/META-INF/services/net.kyori.adventure.text.minimessage.MiniMessage$Provider
@@ -0,0 +1 @@
+io.papermc.paper.adventure.providers.MiniMessageProviderImpl
diff --git a/src/main/resources/META-INF/services/net.kyori.adventure.text.serializer.gson.GsonComponentSerializer$Provider b/src/main/resources/META-INF/services/net.kyori.adventure.text.serializer.gson.GsonComponentSerializer$Provider
new file mode 100644
index 0000000000000000000000000000000000000000..bc9f7398a0fe158af05b562a8ded9e74a22eae9b
--- /dev/null
+++ b/src/main/resources/META-INF/services/net.kyori.adventure.text.serializer.gson.GsonComponentSerializer$Provider
@@ -0,0 +1 @@
+io.papermc.paper.adventure.providers.GsonComponentSerializerProviderImpl
diff --git a/src/main/resources/META-INF/services/net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer$Provider b/src/main/resources/META-INF/services/net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer$Provider
new file mode 100644
index 0000000000000000000000000000000000000000..820f381981a91754b7f0c5106f93b773d885e321
--- /dev/null
+++ b/src/main/resources/META-INF/services/net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer$Provider
@@ -0,0 +1 @@
+io.papermc.paper.adventure.providers.LegacyComponentSerializerProviderImpl
diff --git a/src/main/resources/META-INF/services/net.kyori.adventure.text.serializer.plain.PlainTextComponentSerializer$Provider b/src/main/resources/META-INF/services/net.kyori.adventure.text.serializer.plain.PlainTextComponentSerializer$Provider
new file mode 100644
index 0000000000000000000000000000000000000000..28d777610b52ba74f808bf3245d73b8333d01fa7
--- /dev/null
+++ b/src/main/resources/META-INF/services/net.kyori.adventure.text.serializer.plain.PlainTextComponentSerializer$Provider
@@ -0,0 +1 @@
+io.papermc.paper.adventure.providers.PlainTextComponentSerializerProviderImpl
diff --git a/src/main/resources/data/minecraft/datapacks/paper/data/paper/chat_type/raw.json b/src/main/resources/data/minecraft/datapacks/paper/data/paper/chat_type/raw.json
new file mode 100644
index 0000000000000000000000000000000000000000..3aedd0bbc97edacc1ebf71264b310e55aaaa5cb3
--- /dev/null
+++ b/src/main/resources/data/minecraft/datapacks/paper/data/paper/chat_type/raw.json
@@ -0,0 +1,14 @@
+{
+    "chat": {
+        "parameters": [
+            "content"
+        ],
+        "translation_key": "%s"
+    },
+    "narration": {
+        "parameters": [
+            "content"
+        ],
+        "translation_key": "%s"
+    }
+}
diff --git a/src/test/java/io/papermc/paper/adventure/AdventureCodecsTest.java b/src/test/java/io/papermc/paper/adventure/AdventureCodecsTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..69b3aa957161e75d6344e437a8b4a4533ef00523
--- /dev/null
+++ b/src/test/java/io/papermc/paper/adventure/AdventureCodecsTest.java
@@ -0,0 +1,403 @@
+package io.papermc.paper.adventure;
+
+import com.mojang.datafixers.util.Pair;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.DataResult;
+import com.mojang.serialization.DynamicOps;
+import com.mojang.serialization.JavaOps;
+import com.mojang.serialization.JsonOps;
+import io.papermc.paper.util.MethodParameterSource;
+import java.io.IOException;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+import java.util.List;
+import java.util.UUID;
+import java.util.function.Function;
+import java.util.stream.Stream;
+import net.kyori.adventure.key.Key;
+import net.kyori.adventure.text.BlockNBTComponent;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.event.ClickEvent;
+import net.kyori.adventure.text.event.HoverEvent;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.format.Style;
+import net.kyori.adventure.text.format.TextColor;
+import net.kyori.adventure.text.format.TextDecoration;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.nbt.ByteTag;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.IntTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.NbtOps;
+import net.minecraft.nbt.Tag;
+import net.minecraft.network.chat.ComponentSerialization;
+import net.minecraft.resources.RegistryOps;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import org.apache.commons.lang3.RandomStringUtils;
+import org.bukkit.support.AbstractTestingBase;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.EnumSource;
+import org.junit.jupiter.params.provider.MethodSource;
+import org.junitpioneer.jupiter.cartesian.CartesianTest;
+
+import static io.papermc.paper.adventure.AdventureCodecs.CLICK_EVENT_CODEC;
+import static io.papermc.paper.adventure.AdventureCodecs.COMPONENT_CODEC;
+import static io.papermc.paper.adventure.AdventureCodecs.HOVER_EVENT_CODEC;
+import static io.papermc.paper.adventure.AdventureCodecs.KEY_CODEC;
+import static io.papermc.paper.adventure.AdventureCodecs.STYLE_MAP_CODEC;
+import static io.papermc.paper.adventure.AdventureCodecs.TEXT_COLOR_CODEC;
+import static java.util.Objects.requireNonNull;
+import static net.kyori.adventure.key.Key.key;
+import static net.kyori.adventure.text.Component.blockNBT;
+import static net.kyori.adventure.text.Component.entityNBT;
+import static net.kyori.adventure.text.Component.keybind;
+import static net.kyori.adventure.text.Component.score;
+import static net.kyori.adventure.text.Component.selector;
+import static net.kyori.adventure.text.Component.storageNBT;
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.Component.translatable;
+import static net.kyori.adventure.text.TranslationArgument.numeric;
+import static net.kyori.adventure.text.event.ClickEvent.openUrl;
+import static net.kyori.adventure.text.event.ClickEvent.suggestCommand;
+import static net.kyori.adventure.text.event.HoverEvent.showEntity;
+import static net.kyori.adventure.text.format.Style.style;
+import static net.kyori.adventure.text.format.TextColor.color;
+import static net.kyori.adventure.text.minimessage.MiniMessage.miniMessage;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+class AdventureCodecsTest extends AbstractTestingBase {
+
+    static final String PARAMETERIZED_NAME = "[{index}] {displayName}: {arguments}";
+
+    @Test
+    void testTextColor() {
+        final TextColor color = color(0x1d38df);
+        final Tag result = TEXT_COLOR_CODEC.encodeStart(NbtOps.INSTANCE, color).result().orElseThrow();
+        assertEquals(color.asHexString(), result.getAsString());
+        final net.minecraft.network.chat.TextColor nms = net.minecraft.network.chat.TextColor.CODEC.decode(NbtOps.INSTANCE, result).result().orElseThrow().getFirst();
+        assertEquals(color.value(), nms.getValue());
+    }
+
+    @Test
+    void testNamedTextColor() {
+        final NamedTextColor color = NamedTextColor.BLUE;
+        final Tag result = TEXT_COLOR_CODEC.encodeStart(NbtOps.INSTANCE, color).result().orElseThrow();
+        assertEquals(NamedTextColor.NAMES.keyOrThrow(color), result.getAsString());
+        final net.minecraft.network.chat.TextColor nms = net.minecraft.network.chat.TextColor.CODEC.decode(NbtOps.INSTANCE, result).result().orElseThrow().getFirst();
+        assertEquals(color.value(), nms.getValue());
+    }
+
+    @Test
+    void testKey() {
+        final Key key = key("hello", "there");
+        final Tag result = KEY_CODEC.encodeStart(NbtOps.INSTANCE, key).result().orElseThrow();
+        assertEquals(key.asString(), result.getAsString());
+        final ResourceLocation location = ResourceLocation.CODEC.decode(NbtOps.INSTANCE, result).result().orElseThrow().getFirst();
+        assertEquals(key.asString(), location.toString());
+    }
+
+    @ParameterizedTest(name = PARAMETERIZED_NAME)
+    @EnumSource(value = ClickEvent.Action.class, mode = EnumSource.Mode.EXCLUDE, names = {"OPEN_FILE"})
+    void testClickEvent(final ClickEvent.Action action) {
+        final ClickEvent event = ClickEvent.clickEvent(action, RandomStringUtils.randomAlphanumeric(20));
+        final Tag result = CLICK_EVENT_CODEC.encodeStart(NbtOps.INSTANCE, event).result().orElseThrow();
+        final net.minecraft.network.chat.ClickEvent nms = net.minecraft.network.chat.ClickEvent.CODEC.decode(NbtOps.INSTANCE, result).result().orElseThrow().getFirst();
+        assertEquals(event.action().toString(), nms.getAction().getSerializedName());
+        assertEquals(event.value(), nms.getValue());
+    }
+
+    @Test
+    void testShowTextHoverEvent() {
+        final HoverEvent<Component> hoverEvent = HoverEvent.hoverEvent(HoverEvent.Action.SHOW_TEXT, text("hello"));
+        final Tag result = HOVER_EVENT_CODEC.encodeStart(NbtOps.INSTANCE, hoverEvent).result().orElseThrow();
+        final net.minecraft.network.chat.HoverEvent nms = net.minecraft.network.chat.HoverEvent.CODEC.decode(NbtOps.INSTANCE, result).result().orElseThrow().getFirst();
+        assertEquals(hoverEvent.action().toString(), nms.getAction().getSerializedName());
+        assertNotNull(nms.getValue(net.minecraft.network.chat.HoverEvent.Action.SHOW_TEXT));
+    }
+
+    @Test
+    void testShowItemHoverEvent() throws IOException {
+        final ItemStack stack = new ItemStack(Items.PUMPKIN, 3);
+        stack.set(DataComponents.CUSTOM_NAME, net.minecraft.network.chat.Component.literal("NAME"));
+        final HoverEvent<HoverEvent.ShowItem> hoverEvent = HoverEvent.showItem(key("minecraft:pumpkin"), 3, PaperAdventure.asAdventure(stack.getComponentsPatch()));
+        final Tag result = HOVER_EVENT_CODEC.encodeStart(NbtOps.INSTANCE, hoverEvent).result().orElseThrow();
+        final DataResult<Pair<net.minecraft.network.chat.HoverEvent, Tag>> dataResult = net.minecraft.network.chat.HoverEvent.CODEC.decode(NbtOps.INSTANCE, result);
+        assertTrue(dataResult.result().isPresent(), () -> dataResult + " result is not present");
+        final net.minecraft.network.chat.HoverEvent nms = dataResult.result().orElseThrow().getFirst();
+        assertEquals(hoverEvent.action().toString(), nms.getAction().getSerializedName());
+        final net.minecraft.network.chat.HoverEvent.ItemStackInfo value = nms.getValue(net.minecraft.network.chat.HoverEvent.Action.SHOW_ITEM);
+        assertNotNull(value);
+        assertEquals(hoverEvent.value().count(), value.count);
+        assertEquals(hoverEvent.value().item().asString(), value.item.unwrapKey().orElseThrow().location().toString());
+        assertEquals(stack.getComponentsPatch(), value.components);
+    }
+
+    @Test
+    void testShowEntityHoverEvent() {
+        UUID uuid = UUID.randomUUID();
+        final HoverEvent<HoverEvent.ShowEntity> hoverEvent = showEntity(key("minecraft:wolf"), uuid, text("NAME"));
+        final Tag result = HOVER_EVENT_CODEC.encodeStart(NbtOps.INSTANCE, hoverEvent).result().orElseThrow();
+        final DataResult<Pair<net.minecraft.network.chat.HoverEvent, Tag>> dataResult = net.minecraft.network.chat.HoverEvent.CODEC.decode(NbtOps.INSTANCE, result);
+        assertTrue(dataResult.result().isPresent(), () -> dataResult + " result is not present");
+        final net.minecraft.network.chat.HoverEvent nms = dataResult.result().orElseThrow().getFirst();
+        assertEquals(hoverEvent.action().toString(), nms.getAction().getSerializedName());
+        final net.minecraft.network.chat.HoverEvent.EntityTooltipInfo value = nms.getValue(net.minecraft.network.chat.HoverEvent.Action.SHOW_ENTITY);
+        assertNotNull(value);
+        assertEquals(hoverEvent.value().type().asString(), BuiltInRegistries.ENTITY_TYPE.getKey(value.type).toString());
+        assertEquals(hoverEvent.value().id(), value.id);
+        assertEquals("NAME", value.name.orElseThrow().getString());
+    }
+
+    @Test
+    void testSimpleStyle() {
+        final Style style = style().decorate(TextDecoration.BOLD).color(NamedTextColor.RED).build();
+        final Tag result = STYLE_MAP_CODEC.codec().encodeStart(NbtOps.INSTANCE, style).result().orElseThrow();
+        final DataResult<Pair<net.minecraft.network.chat.Style, Tag>> dataResult = net.minecraft.network.chat.Style.Serializer.CODEC.decode(NbtOps.INSTANCE, result);
+        assertTrue(dataResult.result().isPresent(), () -> dataResult + " result is not present");
+        final net.minecraft.network.chat.Style nms = dataResult.result().get().getFirst();
+        assertTrue(nms.isBold());
+        assertEquals(requireNonNull(style.color()).value(), requireNonNull(nms.getColor()).getValue());
+    }
+
+    @CartesianTest(name = PARAMETERIZED_NAME)
+    void testDirectRoundTripStyle(
+        @MethodParameterSource("dynamicOps") final DynamicOps<?> dynamicOps,
+        @MethodParameterSource("testStyles") final Style style
+    ) {
+        testDirectRoundTrip(dynamicOps, STYLE_MAP_CODEC.codec(), style);
+    }
+
+    @CartesianTest(name = PARAMETERIZED_NAME)
+    void testMinecraftRoundTripStyle(
+        @MethodParameterSource("dynamicOps") final DynamicOps<?> dynamicOps,
+        @MethodParameterSource("testStyles") final Style style
+    ) {
+        testMinecraftRoundTrip(dynamicOps, STYLE_MAP_CODEC.codec(), net.minecraft.network.chat.Style.Serializer.CODEC, style);
+    }
+
+    @CartesianTest(name = PARAMETERIZED_NAME)
+    void testDirectRoundTripComponent(
+        @MethodParameterSource("dynamicOps") final DynamicOps<?> dynamicOps,
+        @TestComponents final Component component
+    ) {
+        testDirectRoundTrip(dynamicOps, COMPONENT_CODEC, component);
+    }
+
+    @CartesianTest(name = PARAMETERIZED_NAME)
+    void testMinecraftRoundTripComponent(
+        @MethodParameterSource("dynamicOps") final DynamicOps<?> dynamicOps,
+        @TestComponents final Component component
+    ) {
+        testMinecraftRoundTrip(dynamicOps, COMPONENT_CODEC, ComponentSerialization.CODEC, component);
+    }
+
+    static List<? extends DynamicOps<?>> dynamicOps() {
+        return Stream.of(
+            NbtOps.INSTANCE,
+            JavaOps.INSTANCE,
+            JsonOps.INSTANCE
+        )
+            .map(ops -> AbstractTestingBase.REGISTRY_CUSTOM.createSerializationContext(ops))
+            .toList();
+    }
+
+    @ParameterizedTest(name = PARAMETERIZED_NAME)
+    @MethodSource({"invalidData"})
+    void invalidThrows(final Tag input) {
+        assertThrows(RuntimeException.class, () -> {
+            require(
+                COMPONENT_CODEC.decode(NbtOps.INSTANCE, input),
+                msg -> "Failed to decode " + input + ": " + msg
+            );
+        });
+    }
+
+    static <A, O> void testDirectRoundTrip(final DynamicOps<O> ops, final Codec<A> codec, final A adventure) {
+        final O encoded = require(
+            codec.encodeStart(ops, adventure),
+            msg -> "Failed to encode " + adventure + ": " + msg
+        );
+        final Pair<A, O> roundTripResult = require(
+            codec.decode(ops, encoded),
+            msg -> "Failed to decode " + encoded + ": " + msg
+        );
+        assertEquals(adventure, roundTripResult.getFirst());
+    }
+
+    static <A, M, O> void testMinecraftRoundTrip(final DynamicOps<O> ops, final Codec<A> adventureCodec, final Codec<M> minecraftCodec, final A adventure) {
+        final O encoded = require(
+            adventureCodec.encodeStart(ops, adventure),
+            msg -> "Failed to encode " + adventure + ": " + msg
+        );
+        final M minecraftResult = require(
+            minecraftCodec.decode(ops, encoded),
+            msg -> "Failed to decode to Minecraft: " + encoded + "; " + msg
+        ).getFirst();
+        final O minecraftReEncoded = require(
+            minecraftCodec.encodeStart(ops, minecraftResult),
+            msg -> "Failed to re-encode Minecraft: " + minecraftResult + "; " + msg
+        );
+        final Pair<A, O> roundTripResult = require(
+            adventureCodec.decode(ops, minecraftReEncoded),
+            msg -> "Failed to decode " + minecraftReEncoded + ": " + msg
+        );
+        assertEquals(adventure, roundTripResult.getFirst());
+    }
+
+    static <R> R require(final DataResult<R> result, final Function<String, String> errorMessage) {
+        return result.getOrThrow(s -> new RuntimeException(errorMessage.apply(s)));
+    }
+
+    static List<Tag> invalidData() {
+        return List.of(
+            IntTag.valueOf(-1),
+            ByteTag.ZERO,
+            new CompoundTag(),
+            new ListTag()
+        );
+    }
+
+    static List<Style> testStyles() {
+        return List.of(
+            Style.empty(),
+            style(color(0x0a1ab9)),
+            style(NamedTextColor.LIGHT_PURPLE),
+            style(TextDecoration.BOLD),
+            style(TextDecoration.BOLD.withState(false)),
+            style(TextDecoration.BOLD.withState(TextDecoration.State.NOT_SET)),
+            style()
+                .font(key("kyori", "kittens"))
+                .color(NamedTextColor.RED)
+                .decoration(TextDecoration.BOLD, true)
+                .clickEvent(openUrl("https://github.com"))
+                .build(),
+            style()
+                .hoverEvent(HoverEvent.showEntity(HoverEvent.ShowEntity.showEntity(
+                    Key.key(Key.MINECRAFT_NAMESPACE, "pig"),
+                    UUID.randomUUID(),
+                    Component.text("Dolores", TextColor.color(0x0a1ab9))
+                )))
+                .build()
+        );
+    }
+
+    @Retention(RetentionPolicy.RUNTIME)
+    @Target({ElementType.PARAMETER, ElementType.ANNOTATION_TYPE})
+    @MethodParameterSource({
+        "testTexts", "testTranslatables", "testKeybinds", "testScores",
+        "testSelectors", "testBlockNbts", "testEntityNbts", "testStorageNbts"
+    })
+    @interface TestComponents {
+    }
+
+    static List<Component> testTexts() {
+        return List.of(
+            Component.empty(),
+            text("Hello, world."),
+            text().content("c")
+                .color(NamedTextColor.GOLD)
+                .append(text("o", NamedTextColor.DARK_AQUA))
+                .append(text("l", NamedTextColor.LIGHT_PURPLE))
+                .append(text("o", NamedTextColor.DARK_PURPLE))
+                .append(text("u", NamedTextColor.BLUE))
+                .append(text("r", NamedTextColor.DARK_GREEN))
+                .append(text("s", NamedTextColor.RED))
+                .build(),
+            text().content("This is a test.")
+                .color(NamedTextColor.DARK_PURPLE)
+                .hoverEvent(HoverEvent.showText(text("A test.")))
+                .append(text(" "))
+                .append(text("A what?", NamedTextColor.DARK_AQUA))
+                .build(),
+            text().append(text("Hello")).build(),
+            miniMessage().deserialize("<rainbow>|||||||||||||||||||||||<bold>|||||||||||||</bold>|||||||||")
+        );
+    }
+
+    static List<Component> testTranslatables() {
+        final String key = "multiplayer.player.left";
+        final UUID id = UUID.fromString("eb121687-8b1a-4944-bd4d-e0a818d9dfe2");
+        final String name = "kashike";
+        final String command = String.format("/msg %s ", name);
+
+        return List.of(
+            translatable(key),
+            translatable()
+                .key("thisIsA")
+                .fallback("This is a test.")
+                .build(),
+            translatable(key, numeric(Integer.MAX_VALUE), text("HEY")), // boolean doesn't work in vanilla, can't test here
+            translatable(
+                key,
+                text().content(name)
+                    .clickEvent(suggestCommand(command))
+                    .hoverEvent(showEntity(HoverEvent.ShowEntity.showEntity(
+                        key("minecraft", "player"),
+                        id,
+                        text(name)
+                    )))
+                    .build()
+            ).color(NamedTextColor.YELLOW)
+        );
+    }
+
+    static List<Component> testKeybinds() {
+        return List.of(keybind("key.jump"));
+    }
+
+    static List<Component> testScores() {
+        final String name = "abc";
+        final String objective = "def";
+
+        return List.of(score(name, objective));
+    }
+
+    static List<Component> testSelectors() {
+        final String selector = "@p";
+
+        return List.of(
+            selector(selector),
+            selector(selector, text(','))
+        );
+    }
+
+    static List<Component> testBlockNbts() {
+        return List.of(
+            blockNBT().nbtPath("abc").localPos(1.23d, 2.0d, 3.89d).build(),
+            blockNBT().nbtPath("xyz").absoluteWorldPos(4, 5, 6).interpret(true).build(),
+            blockNBT().nbtPath("eeee").relativeWorldPos(7, 83, 900)
+                .separator(text(';'))
+                .build(),
+            blockNBT().nbtPath("qwert").worldPos(
+                BlockNBTComponent.WorldPos.Coordinate.absolute(12),
+                BlockNBTComponent.WorldPos.Coordinate.relative(3),
+                BlockNBTComponent.WorldPos.Coordinate.absolute(1200)
+            ).build()
+        );
+    }
+
+    static List<Component> testEntityNbts() {
+        return List.of(
+            entityNBT().nbtPath("abc").selector("test").build(),
+            entityNBT().nbtPath("abc").selector("test").separator(text(',')).build(),
+            entityNBT().nbtPath("abc").selector("test").interpret(true).build()
+        );
+    }
+
+    static List<Component> testStorageNbts() {
+        return List.of(
+            storageNBT().nbtPath("abc").storage(key("doom:apple")).build(),
+            storageNBT().nbtPath("abc").storage(key("doom:apple")).separator(text(", ")).build(),
+            storageNBT().nbtPath("abc").storage(key("doom:apple")).interpret(true).build()
+        );
+    }
+}
diff --git a/src/test/java/io/papermc/paper/adventure/ComponentServicesTest.java b/src/test/java/io/papermc/paper/adventure/ComponentServicesTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..98114b8fdc441f2a1642abf230457c2b5208bb5c
--- /dev/null
+++ b/src/test/java/io/papermc/paper/adventure/ComponentServicesTest.java
@@ -0,0 +1,23 @@
+package io.papermc.paper.adventure;
+
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import net.kyori.adventure.text.serializer.plain.PlainTextComponentSerializer;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+public class ComponentServicesTest {
+
+    @Test
+    public void testPlainTextComponentSerializerProvider() {
+        assertEquals("Done", PlainTextComponentSerializer.plainText().serialize(Component.translatable("narrator.loading.done")));
+    }
+
+    @Test
+    public void testLegacyComponentSerializerProvider() {
+        assertEquals("§cDone", LegacyComponentSerializer.legacySection().serialize(Component.translatable("narrator.loading.done", NamedTextColor.RED)));
+        assertEquals("&cDone", LegacyComponentSerializer.legacyAmpersand().serialize(Component.translatable("narrator.loading.done", NamedTextColor.RED)));
+    }
+}
diff --git a/src/test/java/io/papermc/paper/util/MethodParameterSource.java b/src/test/java/io/papermc/paper/util/MethodParameterSource.java
index 6cbf11c898439834cffb99ef84e5df1494356809..381668df2f58df82ac6da85796752934e92d0796 100644
--- a/src/test/java/io/papermc/paper/util/MethodParameterSource.java
+++ b/src/test/java/io/papermc/paper/util/MethodParameterSource.java
@@ -4,11 +4,13 @@ import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
+import org.intellij.lang.annotations.Language;
 import org.junitpioneer.jupiter.cartesian.CartesianArgumentsSource;
 
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.PARAMETER, ElementType.ANNOTATION_TYPE})
 @CartesianArgumentsSource(MethodParameterProvider.class)
 public @interface MethodParameterSource {
+    @Language("jvm-method-name")
     String[] value() default {};
 }

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Potrebic <jake.m.potrebic@gmail.com>
Date: Wed, 12 Sep 2018 18:53:55 +0300
Subject: [PATCH] Add API for CanPlaceOn and CanDestroy NBT values


diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
index d5c45cc09b9d60c1650507ad6fedb27246291063..64e9a101cca95d94942f61aaa839629d648868b0 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
@@ -2183,4 +2183,123 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
     }
     // Paper end
 
+    // Paper start - Add an API for can-place-on/can-break adventure mode predicates
+    @Override
+    public Set<Material> getCanDestroy() {
+        return !this.hasDestroyableKeys() ? Collections.emptySet() : convertToLegacyMaterial(this.canBreakPredicates);
+    }
+
+    @Override
+    public void setCanDestroy(final Set<Material> canDestroy) {
+        Preconditions.checkArgument(canDestroy != null, "Cannot replace with null set!");
+        this.canBreakPredicates = convertFromLegacyMaterial(canDestroy);
+    }
+
+    @Override
+    public Set<Material> getCanPlaceOn() {
+        return !this.hasPlaceableKeys() ? Collections.emptySet() : convertToLegacyMaterial(this.canPlaceOnPredicates);
+    }
+
+    @Override
+    public void setCanPlaceOn(final Set<Material> canPlaceOn) {
+        Preconditions.checkArgument(canPlaceOn != null, "Cannot replace with null set!");
+        this.canPlaceOnPredicates = convertFromLegacyMaterial(canPlaceOn);
+    }
+
+    private static List<net.minecraft.advancements.critereon.BlockPredicate> convertFromLegacyMaterial(final Collection<Material> materials) {
+        return Collections.singletonList(
+            net.minecraft.advancements.critereon.BlockPredicate.Builder.block()
+                .of(materials.stream().map(org.bukkit.craftbukkit.block.CraftBlockType::bukkitToMinecraft).toList())
+                .build()
+        );
+    }
+
+    private static Set<Material> convertToLegacyMaterial(final List<net.minecraft.advancements.critereon.BlockPredicate> predicates) {
+        return predicates.stream()
+            .flatMap(p -> p.blocks().map(net.minecraft.core.HolderSet::stream).orElse(java.util.stream.Stream.empty()))
+            .map(holder -> CraftBlockType.minecraftToBukkit(holder.value()))
+            .collect(java.util.stream.Collectors.toSet());
+    }
+
+    @Override
+    public Set<com.destroystokyo.paper.Namespaced> getDestroyableKeys() {
+        return !this.hasDestroyableKeys() ? Collections.emptySet() : convertToLegacyNamespaced(this.canBreakPredicates);
+    }
+
+    @Override
+    public void setDestroyableKeys(final Collection<com.destroystokyo.paper.Namespaced> canDestroy) {
+        Preconditions.checkArgument(canDestroy != null, "Cannot replace with null collection!");
+        Preconditions.checkArgument(ofAcceptableType(canDestroy), "Can only use NamespacedKey or NamespacedTag objects!");
+        this.canBreakPredicates = convertFromLegacyNamespaced(canDestroy);
+    }
+
+    @Override
+    public Set<com.destroystokyo.paper.Namespaced> getPlaceableKeys() {
+        return !this.hasPlaceableKeys() ? Collections.emptySet() : convertToLegacyNamespaced(this.canPlaceOnPredicates);
+    }
+
+    @Override
+    public void setPlaceableKeys(final Collection<com.destroystokyo.paper.Namespaced> canPlaceOn) {
+        Preconditions.checkArgument(canPlaceOn != null, "Cannot replace with null collection!");
+        Preconditions.checkArgument(ofAcceptableType(canPlaceOn), "Can only use NamespacedKey or NamespacedTag objects!");
+        this.canPlaceOnPredicates = convertFromLegacyNamespaced(canPlaceOn);
+    }
+
+    private static List<net.minecraft.advancements.critereon.BlockPredicate> convertFromLegacyNamespaced(final Collection<com.destroystokyo.paper.Namespaced> namespaceds) {
+        final List<Material> blocks = new ArrayList<>();
+        final List<net.minecraft.advancements.critereon.BlockPredicate> predicates = new ArrayList<>();
+        for (final com.destroystokyo.paper.Namespaced namespaced : namespaceds) {
+            if (namespaced instanceof final org.bukkit.NamespacedKey key) {
+                blocks.add(Objects.requireNonNull(org.bukkit.Registry.MATERIAL.get(key)));
+            } else if (namespaced instanceof final com.destroystokyo.paper.NamespacedTag tag) {
+                predicates.add(net.minecraft.advancements.critereon.BlockPredicate.Builder.block().of(net.minecraft.tags.TagKey.create(Registries.BLOCK, new net.minecraft.resources.ResourceLocation(tag.getNamespace(), tag.getKey()))).build());
+            }
+        }
+        if (!blocks.isEmpty()) {
+            predicates.addAll(convertFromLegacyMaterial(blocks));
+        }
+        return predicates;
+    }
+
+    private static Set<com.destroystokyo.paper.Namespaced> convertToLegacyNamespaced(final Collection<net.minecraft.advancements.critereon.BlockPredicate> predicates) {
+        final Set<com.destroystokyo.paper.Namespaced> namespaceds = Sets.newHashSet();
+        for (final net.minecraft.advancements.critereon.BlockPredicate predicate : predicates) {
+            if (predicate.blocks().isEmpty()) {
+                continue;
+            }
+            final net.minecraft.core.HolderSet<net.minecraft.world.level.block.Block> holders = predicate.blocks().get();
+            if (holders instanceof final net.minecraft.core.HolderSet.Named<net.minecraft.world.level.block.Block> named) {
+                namespaceds.add(new com.destroystokyo.paper.NamespacedTag(named.key().location().getNamespace(), named.key().location().getPath()));
+            } else {
+                holders.forEach(h -> {
+                    h.unwrapKey().ifPresent(key -> {
+                        namespaceds.add(new org.bukkit.NamespacedKey(key.location().getNamespace(), key.location().getPath()));
+                    });
+                });
+            }
+        }
+        return namespaceds;
+    }
+
+    @Override
+    public boolean hasPlaceableKeys() {
+        return this.canPlaceOnPredicates != null;
+    }
+
+    @Override
+    public boolean hasDestroyableKeys() {
+        return this.canBreakPredicates != null;
+    }
+
+    // not a fan of this
+    private static boolean ofAcceptableType(final Collection<com.destroystokyo.paper.Namespaced> namespacedResources) {
+        for (com.destroystokyo.paper.Namespaced resource : namespacedResources) {
+            if (!(resource instanceof org.bukkit.NamespacedKey || resource instanceof com.destroystokyo.paper.NamespacedTag)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+    // Paper end - Add an API for can-place-on/can-break adventure mode predicates
 }

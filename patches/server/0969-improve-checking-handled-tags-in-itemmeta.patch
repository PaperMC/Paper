From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Potrebic <jake.m.potrebic@gmail.com>
Date: Mon, 10 Jul 2023 16:10:15 -0700
Subject: [PATCH] improve checking handled tags in itemmeta


diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemMetas.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemMetas.java
index a6c78854c10362864c2297de903ab9594cdb1eb6..251aac8690f15be2ad0e3f6399676205b7d7860c 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemMetas.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemMetas.java
@@ -32,116 +32,116 @@ import org.bukkit.inventory.meta.TropicalFishBucketMeta;
 
 public final class CraftItemMetas {
 
-    public record ItemMetaData<I extends ItemMeta>(Class<I> metaClass, Function<ItemStack, I> fromItemStack,
+    public record ItemMetaData<I extends ItemMeta>(Class<I> metaClass, BiFunction<ItemStack, java.util.Set<net.minecraft.core.component.DataComponentType<?>>, I> fromItemStack,
                                                    BiFunction<ItemType.Typed<I>, CraftMetaItem, I> fromItemMeta) {
     }
 
     private static final ItemMetaData<ItemMeta> EMPTY_META_DATA = new ItemMetaData<>(ItemMeta.class,
-            item -> null,
+            (item, extras) -> null,
             (type, meta) -> null);
 
     private static final ItemMetaData<ItemMeta> ITEM_META_DATA = new ItemMetaData<>(ItemMeta.class,
-            item -> new CraftMetaItem(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaItem(item.getComponentsPatch(), extras),
             (type, meta) -> new CraftMetaItem(meta));
 
     private static final ItemMetaData<BookMeta> SIGNED_BOOK_META_DATA = new ItemMetaData<>(BookMeta.class,
-            item -> new CraftMetaBookSigned(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaBookSigned(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof CraftMetaBookSigned signed ? signed : new CraftMetaBookSigned(meta));
 
     private static final ItemMetaData<BookMeta> WRITABLE_BOOK_META_DATA = new ItemMetaData<>(BookMeta.class,
-            item -> new CraftMetaBook(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaBook(item.getComponentsPatch(), extras),
             (type, meta) -> meta != null && meta.getClass().equals(CraftMetaBook.class) ? (BookMeta) meta : new CraftMetaBook(meta));
 
     private static final ItemMetaData<SkullMeta> SKULL_META_DATA = new ItemMetaData<>(SkullMeta.class,
-            item -> new CraftMetaSkull(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaSkull(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof CraftMetaSkull skull ? skull : new CraftMetaSkull(meta));
 
     private static final ItemMetaData<ArmorMeta> ARMOR_META_DATA = new ItemMetaData<>(ArmorMeta.class,
-            item -> new CraftMetaArmor(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaArmor(item.getComponentsPatch(), extras),
             (type, meta) -> meta != null && meta.getClass().equals(CraftMetaArmor.class) ? (ArmorMeta) meta : new CraftMetaArmor(meta));
 
     private static final ItemMetaData<ColorableArmorMeta> COLORABLE_ARMOR_META_DATA = new ItemMetaData<>(ColorableArmorMeta.class,
-            item -> new CraftMetaColorableArmor(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaColorableArmor(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof ColorableArmorMeta colorable ? colorable : new CraftMetaColorableArmor(meta));
 
     private static final ItemMetaData<LeatherArmorMeta> LEATHER_ARMOR_META_DATA = new ItemMetaData<>(LeatherArmorMeta.class,
-            item -> new CraftMetaLeatherArmor(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaLeatherArmor(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof CraftMetaLeatherArmor leather ? leather : new CraftMetaLeatherArmor(meta));
 
     private static final ItemMetaData<PotionMeta> POTION_META_DATA = new ItemMetaData<>(PotionMeta.class,
-            item -> new CraftMetaPotion(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaPotion(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof CraftMetaPotion potion ? potion : new CraftMetaPotion(meta));
 
     private static final ItemMetaData<MapMeta> MAP_META_DATA = new ItemMetaData<>(MapMeta.class,
-            item -> new CraftMetaMap(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaMap(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof CraftMetaMap map ? map : new CraftMetaMap(meta));
 
     private static final ItemMetaData<FireworkMeta> FIREWORK_META_DATA = new ItemMetaData<>(FireworkMeta.class,
-            item -> new CraftMetaFirework(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaFirework(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof CraftMetaFirework firework ? firework : new CraftMetaFirework(meta));
 
     private static final ItemMetaData<FireworkEffectMeta> CHARGE_META_DATA = new ItemMetaData<>(FireworkEffectMeta.class,
-            item -> new CraftMetaCharge(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaCharge(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof CraftMetaCharge charge ? charge : new CraftMetaCharge(meta));
 
     private static final ItemMetaData<EnchantmentStorageMeta> ENCHANTED_BOOK_META_DATA = new ItemMetaData<>(EnchantmentStorageMeta.class,
-            item -> new CraftMetaEnchantedBook(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaEnchantedBook(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof CraftMetaEnchantedBook enchantedBook ? enchantedBook : new CraftMetaEnchantedBook(meta));
 
     private static final ItemMetaData<BannerMeta> BANNER_META_DATA = new ItemMetaData<>(BannerMeta.class,
-            item -> new CraftMetaBanner(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaBanner(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof CraftMetaBanner banner ? banner : new CraftMetaBanner(meta));
 
     private static final ItemMetaData<SpawnEggMeta> SPAWN_EGG_META_DATA = new ItemMetaData<>(SpawnEggMeta.class,
-            item -> new CraftMetaSpawnEgg(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaSpawnEgg(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof CraftMetaSpawnEgg spawnEgg ? spawnEgg : new CraftMetaSpawnEgg(meta));
 
     private static final ItemMetaData<ArmorStandMeta> ARMOR_STAND_META_DATA = new ItemMetaData<>(ArmorStandMeta.class, // paper
-            item -> new CraftMetaArmorStand(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaArmorStand(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof CraftMetaArmorStand armorStand ? armorStand : new CraftMetaArmorStand(meta));
 
     private static final ItemMetaData<KnowledgeBookMeta> KNOWLEDGE_BOOK_META_DATA = new ItemMetaData<>(KnowledgeBookMeta.class,
-            item -> new CraftMetaKnowledgeBook(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaKnowledgeBook(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof CraftMetaKnowledgeBook knowledgeBook ? knowledgeBook : new CraftMetaKnowledgeBook(meta));
 
     private static final ItemMetaData<BlockStateMeta> BLOCK_STATE_META_DATA = new ItemMetaData<>(BlockStateMeta.class,
-            item -> new CraftMetaBlockState(item.getComponentsPatch(), CraftItemType.minecraftToBukkit(item.getItem())),
+            (item, extras) -> new CraftMetaBlockState(item.getComponentsPatch(), CraftItemType.minecraftToBukkit(item.getItem()), extras),
             (type, meta) -> new CraftMetaBlockState(meta, type.asMaterial()));
 
     private static final ItemMetaData<TropicalFishBucketMeta> TROPICAL_FISH_BUCKET_META_DATA = new ItemMetaData<>(TropicalFishBucketMeta.class,
-            item -> new CraftMetaTropicalFishBucket(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaTropicalFishBucket(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof CraftMetaTropicalFishBucket tropicalFishBucket ? tropicalFishBucket : new CraftMetaTropicalFishBucket(meta));
 
     private static final ItemMetaData<AxolotlBucketMeta> AXOLOTL_BUCKET_META_DATA = new ItemMetaData<>(AxolotlBucketMeta.class,
-            item -> new CraftMetaAxolotlBucket(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaAxolotlBucket(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof CraftMetaAxolotlBucket axolotlBucket ? axolotlBucket : new CraftMetaAxolotlBucket(meta));
 
     private static final ItemMetaData<CrossbowMeta> CROSSBOW_META_DATA = new ItemMetaData<>(CrossbowMeta.class,
-            item -> new CraftMetaCrossbow(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaCrossbow(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof CraftMetaCrossbow crossbow ? crossbow : new CraftMetaCrossbow(meta));
 
     private static final ItemMetaData<SuspiciousStewMeta> SUSPICIOUS_STEW_META_DATA = new ItemMetaData<>(SuspiciousStewMeta.class,
-            item -> new CraftMetaSuspiciousStew(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaSuspiciousStew(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof CraftMetaSuspiciousStew suspiciousStew ? suspiciousStew : new CraftMetaSuspiciousStew(meta));
 
     private static final ItemMetaData<ItemMeta> ENTITY_TAG_META_DATA = new ItemMetaData<>(ItemMeta.class,
-            item -> new CraftMetaEntityTag(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaEntityTag(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof CraftMetaEntityTag entityTag ? entityTag : new CraftMetaEntityTag(meta));
 
     private static final ItemMetaData<CompassMeta> COMPASS_META_DATA = new ItemMetaData<>(CompassMeta.class,
-            item -> new CraftMetaCompass(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaCompass(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof CraftMetaCompass compass ? compass : new CraftMetaCompass(meta));
 
     private static final ItemMetaData<BundleMeta> BUNDLE_META_DATA = new ItemMetaData<>(BundleMeta.class,
-            item -> new CraftMetaBundle(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaBundle(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof CraftMetaBundle bundle ? bundle : new CraftMetaBundle(meta));
 
     private static final ItemMetaData<MusicInstrumentMeta> MUSIC_INSTRUMENT_META_DATA = new ItemMetaData<>(MusicInstrumentMeta.class,
-            item -> new CraftMetaMusicInstrument(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaMusicInstrument(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof CraftMetaMusicInstrument musicInstrument ? musicInstrument : new CraftMetaMusicInstrument(meta));
 
     private static final ItemMetaData<OminousBottleMeta> OMINOUS_BOTTLE_META_DATA = new ItemMetaData<>(OminousBottleMeta.class,
-            item -> new CraftMetaOminousBottle(item.getComponentsPatch()),
+            (item, extras) -> new CraftMetaOminousBottle(item.getComponentsPatch(), extras),
             (type, meta) -> meta instanceof CraftMetaOminousBottle musicInstrument ? musicInstrument : new CraftMetaOminousBottle(meta));
 
     // We use if instead of a set, since the result gets cached in CraftItemType,
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
index ef56ebc8060da1d416d91299b03ff0a8f6901ac1..7672128ecca3052f2dc422349a863484c301310e 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
@@ -159,10 +159,11 @@ public final class CraftItemStack extends ItemStack {
         } else if (this.handle == null) {
             this.handle = new net.minecraft.world.item.ItemStack(CraftItemType.bukkitToMinecraft(type), 1);
         } else {
+            final Material oldType = CraftMagicNumbers.getMaterial(this.handle.getItem()); // Paper
             this.handle.setItem(CraftItemType.bukkitToMinecraft(type));
             if (this.hasItemMeta()) {
                 // This will create the appropriate item meta, which will contain all the data we intend to keep
-                CraftItemStack.setItemMeta(this.handle, CraftItemStack.getItemMeta(this.handle));
+                this.adjustTagForItemMeta(oldType); // Paper
             }
         }
         this.setData(null);
@@ -323,6 +324,19 @@ public final class CraftItemStack extends ItemStack {
     public ItemMeta getItemMeta() {
         return CraftItemStack.getItemMeta(this.handle);
     }
+    // Paper start - improve handled tags on type change
+    public void adjustTagForItemMeta(final Material oldType) {
+        final CraftMetaItem oldMeta = (CraftMetaItem) CraftItemFactory.instance().getItemMeta(oldType);
+        final ItemMeta newMeta;
+        if (oldMeta == null) {
+            newMeta = getItemMeta(this.handle);
+        } else {
+            final java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts = new java.util.HashSet<>(CraftMetaItem.getTopLevelHandledDcts(oldMeta.getClass()));
+            newMeta = getItemMeta(this.handle, CraftItemType.minecraftToBukkitNew(this.handle.getItem()), extraHandledDcts);
+        }
+        this.setItemMeta(newMeta);
+    }
+    // Paper end - improve handled tags on type change
     // Paper start
     public static void applyMetaToItem(net.minecraft.world.item.ItemStack itemStack, ItemMeta itemMeta) {
         final CraftMetaItem.Applicator tag = new CraftMetaItem.Applicator();
@@ -335,12 +349,17 @@ public final class CraftItemStack extends ItemStack {
     }
     public static ItemMeta getItemMeta(net.minecraft.world.item.ItemStack item, org.bukkit.inventory.ItemType metaForType) {
         // Paper end
+        // Paper start - handled tags on type change
+        return getItemMeta(item, metaForType, null);
+    }
+    public static ItemMeta getItemMeta(net.minecraft.world.item.ItemStack item, org.bukkit.inventory.ItemType metaForType, final java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) {
+        // Paper end - handled tags on type change
         if (!CraftItemStack.hasItemMeta(item)) {
             return CraftItemFactory.instance().getItemMeta(CraftItemStack.getType(item));
         }
 
-        if (metaForType != null) { return ((CraftItemType<?>) metaForType).getItemMeta(item); } // Paper
-        return ((CraftItemType<?>) CraftItemType.minecraftToBukkitNew(item.getItem())).getItemMeta(item);
+        if (metaForType != null) { return ((CraftItemType<?>) metaForType).getItemMeta(item, extraHandledDcts); } // Paper
+        return ((CraftItemType<?>) CraftItemType.minecraftToBukkitNew(item.getItem())).getItemMeta(item, extraHandledDcts); // Paper
     }
 
     static Material getType(net.minecraft.world.item.ItemStack item) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemType.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemType.java
index a1f2b9d40d374e8cdbaf916b25fa74b6c0970f81..d03f4a767f6c7fe7d6bcef20e6676c39d9657584 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemType.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemType.java
@@ -114,8 +114,8 @@ public class CraftItemType<M extends ItemMeta> implements ItemType.Typed<M>, Han
         return this.item;
     }
 
-    public M getItemMeta(net.minecraft.world.item.ItemStack itemStack) {
-        return this.itemMetaData.get().fromItemStack().apply(itemStack);
+    public M getItemMeta(net.minecraft.world.item.ItemStack itemStack, final java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) {
+        return this.itemMetaData.get().fromItemStack().apply(itemStack, extraHandledDcts);
     }
 
     public M getItemMeta(ItemMeta itemMeta) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaArmor.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaArmor.java
index 865977ce17fbb8793a1eefd71079729e83f5cfaf..889d43acf4cf7a5917f110105ed05838e24c8cf7 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaArmor.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaArmor.java
@@ -34,8 +34,8 @@ public class CraftMetaArmor extends CraftMetaItem implements ArmorMeta {
         }
     }
 
-    CraftMetaArmor(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaArmor(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
 
         getOrEmpty(tag, CraftMetaArmor.TRIM).ifPresent((trimCompound) -> {
             TrimMaterial trimMaterial = org.bukkit.craftbukkit.CraftRegistry.unwrapAndConvertHolder(io.papermc.paper.registry.RegistryKey.TRIM_MATERIAL, trimCompound.material()).orElse(null); // Paper - fix upstream not being correct
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaArmorStand.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaArmorStand.java
index 59bdac414e8205ed608f79ef0d1502acd826d216..53df7e876c9f3e67aa2326fa1a5ce5e90ab7efd6 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaArmorStand.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaArmorStand.java
@@ -47,8 +47,8 @@ public class CraftMetaArmorStand extends CraftMetaItem implements com.destroysto
         this.entityTag = armorStand.entityTag;
     }
 
-    CraftMetaArmorStand(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaArmorStand(DataComponentPatch tag, final java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
 
         getOrEmpty(tag, CraftMetaArmorStand.ENTITY_TAG).ifPresent((nbt) -> {
             this.entityTag = nbt.copyTag();
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaAxolotlBucket.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaAxolotlBucket.java
index c4beb94d8e5448e69f31f30299448f344b5d8f59..169fefb64e1af444f7c2efb1234cb6e7779fb717 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaAxolotlBucket.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaAxolotlBucket.java
@@ -36,8 +36,8 @@ public class CraftMetaAxolotlBucket extends CraftMetaItem implements AxolotlBuck
         this.bucketEntityTag = bucket.bucketEntityTag;
     }
 
-    CraftMetaAxolotlBucket(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaAxolotlBucket(DataComponentPatch tag, final java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
 
         getOrEmpty(tag, CraftMetaAxolotlBucket.ENTITY_TAG).ifPresent((nbt) -> {
             this.entityTag = nbt.copyTag();
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBanner.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBanner.java
index c56fb1eeea79176c4dbb1e9c0a8023f86220fe6a..1c17fb294d83d99ae657eff6a8a986bf72c6ec47 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBanner.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBanner.java
@@ -34,8 +34,8 @@ public class CraftMetaBanner extends CraftMetaItem implements BannerMeta {
         this.patterns = new ArrayList<Pattern>(banner.patterns);
     }
 
-    CraftMetaBanner(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaBanner(DataComponentPatch tag, final java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
 
         getOrEmpty(tag, CraftMetaBanner.PATTERNS).ifPresent((entityTag) -> {
             List<BannerPatternLayers.Layer> patterns = entityTag.layers();
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBlockState.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBlockState.java
index 4faada5f974214f3054dc1bec9c79e2600c8df48..d7e5491cc0296563fb9fdf28d64b21a10c08ea4a 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBlockState.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBlockState.java
@@ -69,8 +69,8 @@ public class CraftMetaBlockState extends CraftMetaItem implements BlockStateMeta
         this.blockEntityTag = te.blockEntityTag;
     }
 
-    CraftMetaBlockState(DataComponentPatch tag, Material material) {
-        super(tag);
+    CraftMetaBlockState(DataComponentPatch tag, Material material, final Set<DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
         this.material = material;
 
         getOrEmpty(tag, CraftMetaBlockState.BLOCK_ENTITY_TAG).ifPresent((nbt) -> {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java
index 552ebe67f87b48734adf0da8ef78dcac9dd670a2..e064af399dcae40b4f35aa993d356b1462f91d6c 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java
@@ -64,8 +64,8 @@ public class CraftMetaBook extends CraftMetaItem implements BookMeta, WritableBo
         }
     }
 
-    CraftMetaBook(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaBook(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
 
         getOrEmpty(tag, CraftMetaBook.BOOK_CONTENT).ifPresent((writable) -> {
             List<Filterable<String>> pages = writable.pages();
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBookSigned.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBookSigned.java
index 162997fc80dfe2df1f13c802c1b610f04cb9d05a..806c1cbee7c4e23eee38c8f400ec2d924c9a360c 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBookSigned.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBookSigned.java
@@ -78,8 +78,8 @@ public class CraftMetaBookSigned extends CraftMetaItem implements BookMeta {
         }
     }
 
-    CraftMetaBookSigned(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaBookSigned(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
 
         getOrEmpty(tag, CraftMetaBookSigned.BOOK_CONTENT).ifPresent((written) -> {
             this.title = written.title().raw();
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBundle.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBundle.java
index 30533ce683e0471742b27d1d31df20def8ea169c..2736a87a6c481da0575e6e29ea08faa539c24378 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBundle.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBundle.java
@@ -34,8 +34,8 @@ public class CraftMetaBundle extends CraftMetaItem implements BundleMeta {
         }
     }
 
-    CraftMetaBundle(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaBundle(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
 
         getOrEmpty(tag, CraftMetaBundle.ITEMS).ifPresent((bundle) -> {
             bundle.items().forEach((item) -> {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCharge.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCharge.java
index 72340e7269a5464d72abe8370c8113f3de9573d2..56c6784e29cecf8655282235959de536d07c1e08 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCharge.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCharge.java
@@ -29,8 +29,8 @@ class CraftMetaCharge extends CraftMetaItem implements FireworkEffectMeta {
         this.setEffect(SerializableMeta.getObject(FireworkEffect.class, map, CraftMetaCharge.EXPLOSION.BUKKIT, true));
     }
 
-    CraftMetaCharge(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaCharge(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
 
         getOrEmpty(tag, CraftMetaCharge.EXPLOSION).ifPresent((f) -> {
             try {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaColorableArmor.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaColorableArmor.java
index 366fec1aee66de4031727a1383acebd319eeef88..6517ec4933b0eae761fceb117ea1db175755d0b1 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaColorableArmor.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaColorableArmor.java
@@ -18,8 +18,8 @@ public class CraftMetaColorableArmor extends CraftMetaArmor implements Colorable
         CraftMetaLeatherArmor.readColor(this, meta);
     }
 
-    CraftMetaColorableArmor(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaColorableArmor(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
         CraftMetaLeatherArmor.readColor(this, tag);
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCompass.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCompass.java
index 607e23040383576b2805c25947a69f6efe6d2c88..69a112b3a9726966aecbe687d905fd1a11cfa1e3 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCompass.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCompass.java
@@ -50,8 +50,8 @@ public class CraftMetaCompass extends CraftMetaItem implements CompassMeta {
         this.tracked = compassMeta.tracked;
     }
 
-    CraftMetaCompass(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaCompass(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
         getOrEmpty(tag, CraftMetaCompass.LODESTONE_TARGET).ifPresent((lodestoneTarget) -> {
             lodestoneTarget.target().ifPresent((target) -> {
                 this.lodestoneWorld = target.dimension();
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCrossbow.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCrossbow.java
index c278af519308c84ad76fc2312046980c01c528ba..0807c2172c5a4bee675cef265a45a9350e98b880 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCrossbow.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCrossbow.java
@@ -36,8 +36,8 @@ public class CraftMetaCrossbow extends CraftMetaItem implements CrossbowMeta {
         }
     }
 
-    CraftMetaCrossbow(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaCrossbow(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
 
         getOrEmpty(tag, CraftMetaCrossbow.CHARGED_PROJECTILES).ifPresent((p) -> {
             List<net.minecraft.world.item.ItemStack> list = p.getItems();
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaEnchantedBook.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaEnchantedBook.java
index 19af55ec2bf62b70bd3be44f499b32f5efe71ab1..c93f769ee6c55022653696da45de568fcf7589fe 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaEnchantedBook.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaEnchantedBook.java
@@ -32,8 +32,8 @@ class CraftMetaEnchantedBook extends CraftMetaItem implements EnchantmentStorage
         }
     }
 
-    CraftMetaEnchantedBook(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaEnchantedBook(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
 
         getOrEmpty(tag, CraftMetaEnchantedBook.STORED_ENCHANTMENTS).ifPresent((itemEnchantments) -> {
             this.enchantments = buildEnchantments(itemEnchantments);
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaEntityTag.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaEntityTag.java
index 3ff0340c40e9dc9a6e690de15ccade7a0c4e8f02..3f6c5cbbf63631e4b72dc43558651ea94f31ca78 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaEntityTag.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaEntityTag.java
@@ -39,8 +39,8 @@ public class CraftMetaEntityTag extends CraftMetaItem {
         this.entityTag = entity.entityTag;
     }
 
-    CraftMetaEntityTag(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaEntityTag(DataComponentPatch tag, final java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
 
         getOrEmpty(tag, CraftMetaEntityTag.ENTITY_TAG).ifPresent((nbt) -> {
             this.entityTag = nbt.copyTag();
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaFirework.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaFirework.java
index 8c1d2d0521da52f9a1262f5433da21700b9b0454..9600b23666668d7d581e2920a4e03e59cc2339fb 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaFirework.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaFirework.java
@@ -59,8 +59,8 @@ class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
         }
     }
 
-    CraftMetaFirework(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaFirework(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
 
         getOrEmpty(tag, CraftMetaFirework.FIREWORKS).ifPresent((fireworks) -> {
             this.power = fireworks.flightDuration();
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
index d29b8c6851aad227eb8f12012903e0ddd5531755..11c6c8d9c14fb31d1819a5c61e3b743b0b6c6d65 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
@@ -346,7 +346,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         // Paper end
     }
 
-    CraftMetaItem(DataComponentPatch tag) {
+    CraftMetaItem(DataComponentPatch tag, Set<DataComponentType<?>> extraHandledTags) { // Paper - improve handled tags on type changes
         CraftMetaItem.getOrEmpty(tag, CraftMetaItem.NAME).ifPresent((component) -> {
             this.displayName = component;
         });
@@ -457,1657 +457,1672 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         });
         // Paper end - fix ItemFlags
 
-        Set<Map.Entry<DataComponentType<?>, Optional<?>>> keys = tag.entrySet();
-        for (Map.Entry<DataComponentType<?>, Optional<?>> key : keys) {
-            // Paper start - don't lose unhandled tags
-            if (key.getValue().isEmpty()) {
-                this.unhandledTags.remove(key.getKey());
-            } else if (!CraftMetaItem.getHandledTags().contains(key.getKey())) {
-                // Paper end - don't lose unhandled tags
-                key.getValue().ifPresent((value) -> {
-                    this.unhandledTags.set((DataComponentType) key.getKey(), value);
-                });
+        // Paper start - improve checking handled data component types
+        Set<DataComponentType<?>> handledTags = getTopLevelHandledDcts(this.getClass());
+        if (extraHandledTags != null) {
+            extraHandledTags.addAll(handledTags);
+            handledTags = extraHandledTags;
+        }
+        // Paper end - improve checking handled data component types
+            Set<Map.Entry<DataComponentType<?>, Optional<?>>> keys = tag.entrySet();
+            for (Map.Entry<DataComponentType<?>, Optional<?>> key : keys) {
+                // Paper start - don't lose unhandled tags
+                if (key.getValue().isEmpty()) {
+                    this.unhandledTags.remove(key.getKey());
+                } else if (!handledTags.contains(key.getKey())) { // Paper - improve checking handled data component types
+                    // Paper end - don't lose unhandled tags
+                    key.getValue().ifPresent((value) -> {
+                        this.unhandledTags.set((DataComponentType) key.getKey(), value);
+                    });
+                }
+
+                if (key.getValue().isEmpty()) {
+                    this.removedTags.add(key.getKey());
+                }
             }
+        }
+
+        static EnchantmentMap buildEnchantments(ItemEnchantments tag) { // Paper
+            EnchantmentMap enchantments = new EnchantmentMap(); // Paper
+
+            tag.entrySet().forEach((entry) -> {
+                Holder<net.minecraft.world.item.enchantment.Enchantment> id = entry.getKey();
+                int level = entry.getIntValue();
+
+                Enchantment enchant = CraftEnchantment.minecraftHolderToBukkit(id);
+                if (enchant != null) {
+                    enchantments.put(enchant, level);
+                }
+            });
+
+            return enchantments;
+        }
+
+        static Multimap<Attribute, AttributeModifier> buildModifiers(ItemAttributeModifiers tag) {
+            Multimap<Attribute, AttributeModifier> modifiers = LinkedHashMultimap.create();
+            List<ItemAttributeModifiers.Entry> mods = tag.modifiers();
+            int size = mods.size();
+
+            for (int i = 0; i < size; i++) {
+                ItemAttributeModifiers.Entry entry = mods.get(i);
+                net.minecraft.world.entity.ai.attributes.AttributeModifier nmsModifier = entry.modifier();
+                if (nmsModifier == null) {
+                    continue;
+                }
+
+                AttributeModifier attribMod = CraftAttributeInstance.convert(nmsModifier);
+
+                Attribute attribute = CraftAttribute.minecraftHolderToBukkit(entry.attribute());
+                if (attribute == null) {
+                    continue;
+                }
+
+                if (entry.slot() != null) {
+                    EquipmentSlotGroup slotName = entry.slot();
+                    if (slotName == null) {
+                        modifiers.put(attribute, attribMod);
+                        continue;
+                    }
+
+                    org.bukkit.inventory.EquipmentSlotGroup slot = null;
+                    try {
+                        slot = CraftEquipmentSlot.getSlot(slotName);
+                    } catch (IllegalArgumentException ex) {
+                        // SPIGOT-4551 - Slot is invalid, should really match nothing but this is undefined behaviour anyway
+                    }
+
+                    if (slot == null) {
+                        modifiers.put(attribute, attribMod);
+                        continue;
+                    }
 
-            if (key.getValue().isEmpty()) {
-                this.removedTags.add(key.getKey());
+                    attribMod = new AttributeModifier(attribMod.getKey(), attribMod.getAmount(), attribMod.getOperation(), slot);
+                }
+                modifiers.put(attribute, attribMod);
             }
+            return modifiers;
         }
-    }
 
-    static EnchantmentMap buildEnchantments(ItemEnchantments tag) { // Paper
-        EnchantmentMap enchantments = new EnchantmentMap(); // Paper
+        CraftMetaItem(Map<String, Object> map) {
+            this.displayName = CraftChatMessage.fromJSONOrString(SerializableMeta.getString(map, CraftMetaItem.NAME.BUKKIT, true), true, false);
+            this.itemName = CraftChatMessage.fromJSONOrNull(SerializableMeta.getString(map, CraftMetaItem.ITEM_NAME.BUKKIT, true));
 
-        tag.entrySet().forEach((entry) -> {
-            Holder<net.minecraft.world.item.enchantment.Enchantment> id = entry.getKey();
-            int level = entry.getIntValue();
+            Iterable<?> lore = SerializableMeta.getObject(Iterable.class, map, CraftMetaItem.LORE.BUKKIT, true);
+            if (lore != null) {
+                CraftMetaItem.safelyAdd(lore, this.lore = new ArrayList<Component>(), true);
+            }
 
-            Enchantment enchant = CraftEnchantment.minecraftHolderToBukkit(id);
-            if (enchant != null) {
-                enchantments.put(enchant, level);
+            Integer customModelData = SerializableMeta.getObject(Integer.class, map, CraftMetaItem.CUSTOM_MODEL_DATA.BUKKIT, true);
+            if (customModelData != null) {
+                this.setCustomModelData(customModelData);
             }
-        });
 
-        return enchantments;
-    }
+            Object blockData = SerializableMeta.getObject(Object.class, map, CraftMetaItem.BLOCK_DATA.BUKKIT, true);
+            if (blockData != null) {
+                Map<String, String> mapBlockData = new HashMap<>();
 
-    static Multimap<Attribute, AttributeModifier> buildModifiers(ItemAttributeModifiers tag) {
-        Multimap<Attribute, AttributeModifier> modifiers = LinkedHashMultimap.create();
-        List<ItemAttributeModifiers.Entry> mods = tag.modifiers();
-        int size = mods.size();
+                CompoundTag nbtBlockData = (CompoundTag) CraftNBTTagConfigSerializer.deserialize(blockData);
+                for (String key : nbtBlockData.getAllKeys()) {
+                    mapBlockData.put(key, nbtBlockData.getString(key));
+                }
 
-        for (int i = 0; i < size; i++) {
-            ItemAttributeModifiers.Entry entry = mods.get(i);
-            net.minecraft.world.entity.ai.attributes.AttributeModifier nmsModifier = entry.modifier();
-            if (nmsModifier == null) {
-                continue;
+                this.blockData = mapBlockData;
             }
 
-            AttributeModifier attribMod = CraftAttributeInstance.convert(nmsModifier);
+            this.enchantments = CraftMetaItem.buildEnchantments(map, CraftMetaItem.ENCHANTMENTS);
+            this.attributeModifiers = CraftMetaItem.buildModifiers(map, CraftMetaItem.ATTRIBUTES);
 
-            Attribute attribute = CraftAttribute.minecraftHolderToBukkit(entry.attribute());
-            if (attribute == null) {
-                continue;
+            Integer repairCost = SerializableMeta.getObject(Integer.class, map, CraftMetaItem.REPAIR.BUKKIT, true);
+            if (repairCost != null) {
+                this.setRepairCost(repairCost);
             }
 
-            if (entry.slot() != null) {
-                EquipmentSlotGroup slotName = entry.slot();
-                if (slotName == null) {
-                    modifiers.put(attribute, attribMod);
-                    continue;
+            Iterable<?> hideFlags = SerializableMeta.getObject(Iterable.class, map, CraftMetaItem.HIDEFLAGS.BUKKIT, true);
+            if (hideFlags != null) {
+                for (Object hideFlagObject : hideFlags) {
+                    String hideFlagString = (String) hideFlagObject;
+                    try {
+                        ItemFlag hideFlatEnum = CraftItemFlag.stringToBukkit(hideFlagString);
+                        this.addItemFlags(hideFlatEnum);
+                    } catch (IllegalArgumentException ex) {
+                        // Ignore when we got a old String which does not map to a Enum value anymore
+                    }
                 }
+            }
 
-                org.bukkit.inventory.EquipmentSlotGroup slot = null;
-                try {
-                    slot = CraftEquipmentSlot.getSlot(slotName);
-                } catch (IllegalArgumentException ex) {
-                    // SPIGOT-4551 - Slot is invalid, should really match nothing but this is undefined behaviour anyway
-                }
+            Boolean hideTooltip = SerializableMeta.getObject(Boolean.class, map, CraftMetaItem.HIDE_TOOLTIP.BUKKIT, true);
+            if (hideTooltip != null) {
+                this.setHideTooltip(hideTooltip);
+            }
 
-                if (slot == null) {
-                    modifiers.put(attribute, attribMod);
-                    continue;
-                }
+            Boolean unbreakable = SerializableMeta.getObject(Boolean.class, map, CraftMetaItem.UNBREAKABLE.BUKKIT, true);
+            if (unbreakable != null) {
+                this.setUnbreakable(unbreakable);
+            }
 
-                attribMod = new AttributeModifier(attribMod.getKey(), attribMod.getAmount(), attribMod.getOperation(), slot);
+            Boolean enchantmentGlintOverride = SerializableMeta.getObject(Boolean.class, map, CraftMetaItem.ENCHANTMENT_GLINT_OVERRIDE.BUKKIT, true);
+            if (enchantmentGlintOverride != null) {
+                this.setEnchantmentGlintOverride(enchantmentGlintOverride);
             }
-            modifiers.put(attribute, attribMod);
-        }
-        return modifiers;
-    }
 
-    CraftMetaItem(Map<String, Object> map) {
-        this.displayName = CraftChatMessage.fromJSONOrString(SerializableMeta.getString(map, CraftMetaItem.NAME.BUKKIT, true), true, false);
-        this.itemName = CraftChatMessage.fromJSONOrNull(SerializableMeta.getString(map, CraftMetaItem.ITEM_NAME.BUKKIT, true));
+            Boolean fireResistant = SerializableMeta.getObject(Boolean.class, map, CraftMetaItem.FIRE_RESISTANT.BUKKIT, true);
+            if (fireResistant != null) {
+                this.setFireResistant(fireResistant);
+            }
 
-        Iterable<?> lore = SerializableMeta.getObject(Iterable.class, map, CraftMetaItem.LORE.BUKKIT, true);
-        if (lore != null) {
-            CraftMetaItem.safelyAdd(lore, this.lore = new ArrayList<Component>(), true);
-        }
+            Integer maxStackSize = SerializableMeta.getObject(Integer.class, map, CraftMetaItem.MAX_STACK_SIZE.BUKKIT, true);
+            if (maxStackSize != null) {
+                this.setMaxStackSize(maxStackSize);
+            }
 
-        Integer customModelData = SerializableMeta.getObject(Integer.class, map, CraftMetaItem.CUSTOM_MODEL_DATA.BUKKIT, true);
-        if (customModelData != null) {
-            this.setCustomModelData(customModelData);
-        }
+            String rarity = SerializableMeta.getString(map, CraftMetaItem.RARITY.BUKKIT, true);
+            if (rarity != null) {
+                this.setRarity(ItemRarity.valueOf(rarity));
+            }
 
-        Object blockData = SerializableMeta.getObject(Object.class, map, CraftMetaItem.BLOCK_DATA.BUKKIT, true);
-        if (blockData != null) {
-            Map<String, String> mapBlockData = new HashMap<>();
+            CraftFoodComponent food = SerializableMeta.getObject(CraftFoodComponent.class, map, CraftMetaItem.FOOD.BUKKIT, true);
+            if (food != null) {
+                this.setFood(food);
+            }
 
-            CompoundTag nbtBlockData = (CompoundTag) CraftNBTTagConfigSerializer.deserialize(blockData);
-            for (String key : nbtBlockData.getAllKeys()) {
-                mapBlockData.put(key, nbtBlockData.getString(key));
+            CraftToolComponent tool = SerializableMeta.getObject(CraftToolComponent.class, map, CraftMetaItem.TOOL.BUKKIT, true);
+            if (tool != null) {
+                this.setTool(tool);
             }
 
-            this.blockData = mapBlockData;
-        }
+            CraftJukeboxComponent jukeboxPlayable = SerializableMeta.getObject(CraftJukeboxComponent.class, map, CraftMetaItem.JUKEBOX_PLAYABLE.BUKKIT, true);
+            if (jukeboxPlayable != null) {
+                this.setJukeboxPlayable(jukeboxPlayable);
+            }
 
-        this.enchantments = CraftMetaItem.buildEnchantments(map, CraftMetaItem.ENCHANTMENTS);
-        this.attributeModifiers = CraftMetaItem.buildModifiers(map, CraftMetaItem.ATTRIBUTES);
+            Integer damage = SerializableMeta.getObject(Integer.class, map, CraftMetaItem.DAMAGE.BUKKIT, true);
+            if (damage != null) {
+                this.setDamage(damage);
+            }
 
-        Integer repairCost = SerializableMeta.getObject(Integer.class, map, CraftMetaItem.REPAIR.BUKKIT, true);
-        if (repairCost != null) {
-            this.setRepairCost(repairCost);
-        }
+            Integer maxDamage = SerializableMeta.getObject(Integer.class, map, CraftMetaItem.MAX_DAMAGE.BUKKIT, true);
+            if (maxDamage != null) {
+                this.setMaxDamage(maxDamage);
+            }
 
-        Iterable<?> hideFlags = SerializableMeta.getObject(Iterable.class, map, CraftMetaItem.HIDEFLAGS.BUKKIT, true);
-        if (hideFlags != null) {
-            for (Object hideFlagObject : hideFlags) {
-                String hideFlagString = (String) hideFlagObject;
+            String internal = SerializableMeta.getString(map, "internal", true);
+            if (internal != null) {
+                ByteArrayInputStream buf = new ByteArrayInputStream(Base64.getDecoder().decode(internal));
                 try {
-                    ItemFlag hideFlatEnum = CraftItemFlag.stringToBukkit(hideFlagString);
-                    this.addItemFlags(hideFlatEnum);
-                } catch (IllegalArgumentException ex) {
-                    // Ignore when we got a old String which does not map to a Enum value anymore
+                    CompoundTag internalTag = NbtIo.readCompressed(buf, NbtAccounter.unlimitedHeap());
+                    this.deserializeInternal(internalTag, map);
+                } catch (IOException ex) {
+                    Logger.getLogger(CraftMetaItem.class.getName()).log(Level.SEVERE, null, ex);
                 }
             }
-        }
 
-        Boolean hideTooltip = SerializableMeta.getObject(Boolean.class, map, CraftMetaItem.HIDE_TOOLTIP.BUKKIT, true);
-        if (hideTooltip != null) {
-            this.setHideTooltip(hideTooltip);
-        }
+            String unhandled = SerializableMeta.getString(map, "unhandled", true);
+            if (unhandled != null) {
+                ByteArrayInputStream buf = new ByteArrayInputStream(Base64.getDecoder().decode(unhandled));
+                try {
+                    CompoundTag unhandledTag = NbtIo.readCompressed(buf, NbtAccounter.unlimitedHeap());
+                    DataComponentPatch unhandledPatch = DataComponentPatch.CODEC.parse(MinecraftServer.getDefaultRegistryAccess().createSerializationContext(NbtOps.INSTANCE), unhandledTag).result().get();
+                    // Paper start
+                    CraftMetaItem.getOrEmpty(unhandledPatch, CraftMetaItem.CAN_PLACE_ON).ifPresent(data -> {
+                        this.canPlaceOnPredicates = List.copyOf(data.predicates);
+                    });
+                    CraftMetaItem.getOrEmpty(unhandledPatch, CraftMetaItem.CAN_BREAK).ifPresent(data -> {
+                        this.canBreakPredicates = List.copyOf(data.predicates);
+                    });
+                    this.unhandledTags.copy(unhandledPatch.forget(type -> type == CraftMetaItem.CAN_PLACE_ON.TYPE || type == CraftMetaItem.CAN_BREAK.TYPE));
+                    // Paper end
+
+                    for (Entry<DataComponentType<?>, Optional<?>> entry : unhandledPatch.entrySet()) {
+                        // Move removed unhandled tags to dedicated removedTags
+                        if (!entry.getValue().isPresent()) {
+                            DataComponentType<?> key = entry.getKey();
+
+                            this.unhandledTags.clear(key);
+                            this.removedTags.add(key);
+                        }
+                    }
+                } catch (IOException ex) {
+                    Logger.getLogger(CraftMetaItem.class.getName()).log(Level.SEVERE, null, ex);
+                }
+            }
 
-        Boolean unbreakable = SerializableMeta.getObject(Boolean.class, map, CraftMetaItem.UNBREAKABLE.BUKKIT, true);
-        if (unbreakable != null) {
-            this.setUnbreakable(unbreakable);
-        }
+            Iterable<?> removed = SerializableMeta.getObject(Iterable.class, map, "removed", true);
+            if (removed != null) {
+                RegistryAccess registryAccess = CraftRegistry.getMinecraftRegistry();
+                Registry<DataComponentType<?>> componentTypeRegistry = registryAccess.registryOrThrow(Registries.DATA_COMPONENT_TYPE);
 
-        Boolean enchantmentGlintOverride = SerializableMeta.getObject(Boolean.class, map, CraftMetaItem.ENCHANTMENT_GLINT_OVERRIDE.BUKKIT, true);
-        if (enchantmentGlintOverride != null) {
-            this.setEnchantmentGlintOverride(enchantmentGlintOverride);
-        }
+                for (Object removedObject : removed) {
+                    String removedString = (String) removedObject;
 
-        Boolean fireResistant = SerializableMeta.getObject(Boolean.class, map, CraftMetaItem.FIRE_RESISTANT.BUKKIT, true);
-        if (fireResistant != null) {
-            this.setFireResistant(fireResistant);
-        }
+                    DataComponentType<?> component = componentTypeRegistry.get(ResourceLocation.parse(removedString));
+                    if (component != null) {
+                        this.removedTags.add(component);
+                    }
+                }
+            }
 
-        Integer maxStackSize = SerializableMeta.getObject(Integer.class, map, CraftMetaItem.MAX_STACK_SIZE.BUKKIT, true);
-        if (maxStackSize != null) {
-            this.setMaxStackSize(maxStackSize);
-        }
+            Object nbtMap = SerializableMeta.getObject(Object.class, map, CraftMetaItem.BUKKIT_CUSTOM_TAG.BUKKIT, true); // We read both legacy maps and potential modern snbt strings here
+            if (nbtMap != null) {
+                this.persistentDataContainer.putAll((CompoundTag) CraftNBTTagConfigSerializer.deserialize(nbtMap));
+            }
 
-        String rarity = SerializableMeta.getString(map, CraftMetaItem.RARITY.BUKKIT, true);
-        if (rarity != null) {
-            this.setRarity(ItemRarity.valueOf(rarity));
+            String custom = SerializableMeta.getString(map, "custom", true);
+            if (custom != null) {
+                ByteArrayInputStream buf = new ByteArrayInputStream(Base64.getDecoder().decode(custom));
+                try {
+                    this.customTag = NbtIo.readCompressed(buf, NbtAccounter.unlimitedHeap());
+                } catch (IOException ex) {
+                    Logger.getLogger(CraftMetaItem.class.getName()).log(Level.SEVERE, null, ex);
+                }
+            }
         }
 
-        CraftFoodComponent food = SerializableMeta.getObject(CraftFoodComponent.class, map, CraftMetaItem.FOOD.BUKKIT, true);
-        if (food != null) {
-            this.setFood(food);
+        void deserializeInternal(CompoundTag tag, Object context) {
+            // SPIGOT-4576: Need to migrate from internal to proper data
+            if (tag.contains(CraftMetaItem.ATTRIBUTES.NBT, CraftMagicNumbers.NBT.TAG_LIST)) {
+                this.attributeModifiers = CraftMetaItem.buildModifiersLegacy(tag, CraftMetaItem.ATTRIBUTES);
+            }
         }
 
-        CraftToolComponent tool = SerializableMeta.getObject(CraftToolComponent.class, map, CraftMetaItem.TOOL.BUKKIT, true);
-        if (tool != null) {
-            this.setTool(tool);
-        }
+        private static Multimap<Attribute, AttributeModifier> buildModifiersLegacy(CompoundTag tag, ItemMetaKey key) {
+            Multimap<Attribute, AttributeModifier> modifiers = LinkedHashMultimap.create();
+            if (!tag.contains(key.NBT, CraftMagicNumbers.NBT.TAG_LIST)) {
+                return modifiers;
+            }
+            ListTag mods = tag.getList(key.NBT, CraftMagicNumbers.NBT.TAG_COMPOUND);
+            int size = mods.size();
 
-        CraftJukeboxComponent jukeboxPlayable = SerializableMeta.getObject(CraftJukeboxComponent.class, map, CraftMetaItem.JUKEBOX_PLAYABLE.BUKKIT, true);
-        if (jukeboxPlayable != null) {
-            this.setJukeboxPlayable(jukeboxPlayable);
-        }
+            for (int i = 0; i < size; i++) {
+                CompoundTag entry = mods.getCompound(i);
+                if (entry.isEmpty()) {
+                    // entry is not an actual NBTTagCompound. getCompound returns empty NBTTagCompound in that case
+                    continue;
+                }
+                net.minecraft.world.entity.ai.attributes.AttributeModifier nmsModifier = net.minecraft.world.entity.ai.attributes.AttributeModifier.load(entry);
+                if (nmsModifier == null) {
+                    continue;
+                }
 
-        Integer damage = SerializableMeta.getObject(Integer.class, map, CraftMetaItem.DAMAGE.BUKKIT, true);
-        if (damage != null) {
-            this.setDamage(damage);
-        }
+                AttributeModifier attribMod = CraftAttributeInstance.convert(nmsModifier);
 
-        Integer maxDamage = SerializableMeta.getObject(Integer.class, map, CraftMetaItem.MAX_DAMAGE.BUKKIT, true);
-        if (maxDamage != null) {
-            this.setMaxDamage(maxDamage);
+                String attributeName = org.bukkit.craftbukkit.attribute.CraftAttributeMap.convertIfNeeded(entry.getString(CraftMetaItem.ATTRIBUTES_IDENTIFIER.NBT)); // Paper
+                if (attributeName == null || attributeName.isEmpty()) {
+                    continue;
+                }
+
+                Attribute attribute = CraftAttribute.stringToBukkit(attributeName);
+                if (attribute == null) {
+                    continue;
+                }
+
+                if (entry.contains(CraftMetaItem.ATTRIBUTES_SLOT.NBT, CraftMagicNumbers.NBT.TAG_STRING)) {
+                    String slotName = entry.getString(CraftMetaItem.ATTRIBUTES_SLOT.NBT);
+                    if (slotName == null || slotName.isEmpty()) {
+                        modifiers.put(attribute, attribMod);
+                        continue;
+                    }
+
+                    EquipmentSlot slot = null;
+                    try {
+                        slot = CraftEquipmentSlot.getSlot(net.minecraft.world.entity.EquipmentSlot.byName(slotName.toLowerCase(Locale.ROOT)));
+                    } catch (IllegalArgumentException ex) {
+                        // SPIGOT-4551 - Slot is invalid, should really match nothing but this is undefined behaviour anyway
+                    }
+
+                    if (slot == null) {
+                        modifiers.put(attribute, attribMod);
+                        continue;
+                    }
+
+                    attribMod = new AttributeModifier(attribMod.getKey(), attribMod.getAmount(), attribMod.getOperation(), slot.getGroup());
+                }
+                modifiers.put(attribute, attribMod);
+            }
+            return modifiers;
         }
 
-        String internal = SerializableMeta.getString(map, "internal", true);
-        if (internal != null) {
-            ByteArrayInputStream buf = new ByteArrayInputStream(Base64.getDecoder().decode(internal));
-            try {
-                CompoundTag internalTag = NbtIo.readCompressed(buf, NbtAccounter.unlimitedHeap());
-                this.deserializeInternal(internalTag, map);
-            } catch (IOException ex) {
-                Logger.getLogger(CraftMetaItem.class.getName()).log(Level.SEVERE, null, ex);
+        static EnchantmentMap buildEnchantments(Map<String, Object> map, ItemMetaKey key) { // Paper
+            Map<?, ?> ench = SerializableMeta.getObject(Map.class, map, key.BUKKIT, true);
+            if (ench == null) {
+                return null;
+            }
+
+            EnchantmentMap enchantments = new EnchantmentMap(); // Paper
+            for (Map.Entry<?, ?> entry : ench.entrySet()) {
+                Enchantment enchantment = CraftEnchantment.stringToBukkit(entry.getKey().toString());
+                if ((enchantment != null) && (entry.getValue() instanceof Integer)) {
+                    enchantments.put(enchantment, (Integer) entry.getValue());
+                }
             }
+
+            return enchantments;
         }
 
-        String unhandled = SerializableMeta.getString(map, "unhandled", true);
-        if (unhandled != null) {
-            ByteArrayInputStream buf = new ByteArrayInputStream(Base64.getDecoder().decode(unhandled));
-            try {
-                CompoundTag unhandledTag = NbtIo.readCompressed(buf, NbtAccounter.unlimitedHeap());
-                DataComponentPatch unhandledPatch = DataComponentPatch.CODEC.parse(MinecraftServer.getDefaultRegistryAccess().createSerializationContext(NbtOps.INSTANCE), unhandledTag).result().get();
-                // Paper start
-                CraftMetaItem.getOrEmpty(unhandledPatch, CraftMetaItem.CAN_PLACE_ON).ifPresent(data -> {
-                    this.canPlaceOnPredicates = List.copyOf(data.predicates);
-                });
-                CraftMetaItem.getOrEmpty(unhandledPatch, CraftMetaItem.CAN_BREAK).ifPresent(data -> {
-                    this.canBreakPredicates = List.copyOf(data.predicates);
-                });
-                this.unhandledTags.copy(unhandledPatch.forget(type -> type == CraftMetaItem.CAN_PLACE_ON.TYPE || type == CraftMetaItem.CAN_BREAK.TYPE));
-                // Paper end
+        static Multimap<Attribute, AttributeModifier> buildModifiers(Map<String, Object> map, ItemMetaKey key) {
+            Map<?, ?> mods = SerializableMeta.getObject(Map.class, map, key.BUKKIT, true);
+            Multimap<Attribute, AttributeModifier> result = LinkedHashMultimap.create();
+            if (mods == null) {
+                return result;
+            }
 
-                for (Entry<DataComponentType<?>, Optional<?>> entry : unhandledPatch.entrySet()) {
-                    // Move removed unhandled tags to dedicated removedTags
-                    if (!entry.getValue().isPresent()) {
-                        DataComponentType<?> key = entry.getKey();
+            for (Object obj : mods.keySet()) {
+                if (!(obj instanceof String)) {
+                    continue;
+                }
+                String attributeName = (String) obj;
+                if (Strings.isNullOrEmpty(attributeName)) {
+                    continue;
+                }
+                List<?> list = SerializableMeta.getObject(List.class, mods, attributeName, true);
+                if (list == null || list.isEmpty()) {
+                    return result;
+                }
 
-                        this.unhandledTags.clear(key);
-                        this.removedTags.add(key);
+                for (Object o : list) {
+                    if (!(o instanceof AttributeModifier)) { // this catches null
+                        continue;
                     }
+                    AttributeModifier modifier = (AttributeModifier) o;
+                    Attribute attribute = CraftAttribute.stringToBukkit(attributeName);
+                    if (attribute == null) {
+                        continue;
+                    }
+
+                    result.put(attribute, modifier);
                 }
-            } catch (IOException ex) {
-                Logger.getLogger(CraftMetaItem.class.getName()).log(Level.SEVERE, null, ex);
             }
+            return result;
         }
 
-        Iterable<?> removed = SerializableMeta.getObject(Iterable.class, map, "removed", true);
-        if (removed != null) {
-            RegistryAccess registryAccess = CraftRegistry.getMinecraftRegistry();
-            Registry<DataComponentType<?>> componentTypeRegistry = registryAccess.registryOrThrow(Registries.DATA_COMPONENT_TYPE);
+        @Overridden
+        void applyToItem(CraftMetaItem.Applicator itemTag) {
+            if (this.hasDisplayName()) {
+                itemTag.put(CraftMetaItem.NAME, this.displayName);
+            }
+
+            if (this.hasItemName()) {
+                itemTag.put(CraftMetaItem.ITEM_NAME, this.itemName);
+            }
 
-            for (Object removedObject : removed) {
-                String removedString = (String) removedObject;
+            if (this.lore != null) {
+                itemTag.put(CraftMetaItem.LORE, new ItemLore(this.lore));
+            }
+
+            if (this.hasCustomModelData()) {
+                itemTag.put(CraftMetaItem.CUSTOM_MODEL_DATA, new CustomModelData(this.customModelData));
+            }
 
-                DataComponentType<?> component = componentTypeRegistry.get(ResourceLocation.parse(removedString));
-                if (component != null) {
-                    this.removedTags.add(component);
+            if (this.hasBlockData()) {
+                itemTag.put(CraftMetaItem.BLOCK_DATA, new BlockItemStateProperties(this.blockData));
+            }
+
+            if (this.hideFlag != 0) {
+                if (this.hasItemFlag(ItemFlag.HIDE_ADDITIONAL_TOOLTIP)) {
+                    itemTag.put(CraftMetaItem.HIDE_ADDITIONAL_TOOLTIP, Unit.INSTANCE);
                 }
             }
-        }
 
-        Object nbtMap = SerializableMeta.getObject(Object.class, map, CraftMetaItem.BUKKIT_CUSTOM_TAG.BUKKIT, true); // We read both legacy maps and potential modern snbt strings here
-        if (nbtMap != null) {
-            this.persistentDataContainer.putAll((CompoundTag) CraftNBTTagConfigSerializer.deserialize(nbtMap));
-        }
+            this.applyEnchantments(this.enchantments, itemTag, CraftMetaItem.ENCHANTMENTS, ItemFlag.HIDE_ENCHANTS);
+            this.applyModifiers(this.attributeModifiers, itemTag);
 
-        String custom = SerializableMeta.getString(map, "custom", true);
-        if (custom != null) {
-            ByteArrayInputStream buf = new ByteArrayInputStream(Base64.getDecoder().decode(custom));
-            try {
-                this.customTag = NbtIo.readCompressed(buf, NbtAccounter.unlimitedHeap());
-            } catch (IOException ex) {
-                Logger.getLogger(CraftMetaItem.class.getName()).log(Level.SEVERE, null, ex);
+            if (this.hasRepairCost()) {
+                itemTag.put(CraftMetaItem.REPAIR, this.repairCost);
             }
-        }
-    }
 
-    void deserializeInternal(CompoundTag tag, Object context) {
-        // SPIGOT-4576: Need to migrate from internal to proper data
-        if (tag.contains(CraftMetaItem.ATTRIBUTES.NBT, CraftMagicNumbers.NBT.TAG_LIST)) {
-            this.attributeModifiers = CraftMetaItem.buildModifiersLegacy(tag, CraftMetaItem.ATTRIBUTES);
-        }
-    }
+            if (this.isHideTooltip()) {
+                itemTag.put(CraftMetaItem.HIDE_TOOLTIP, Unit.INSTANCE);
+            }
 
-    private static Multimap<Attribute, AttributeModifier> buildModifiersLegacy(CompoundTag tag, ItemMetaKey key) {
-        Multimap<Attribute, AttributeModifier> modifiers = LinkedHashMultimap.create();
-        if (!tag.contains(key.NBT, CraftMagicNumbers.NBT.TAG_LIST)) {
-            return modifiers;
-        }
-        ListTag mods = tag.getList(key.NBT, CraftMagicNumbers.NBT.TAG_COMPOUND);
-        int size = mods.size();
+            if (this.isUnbreakable()) {
+                itemTag.put(CraftMetaItem.UNBREAKABLE, new Unbreakable(!this.hasItemFlag(ItemFlag.HIDE_UNBREAKABLE)));
+            }
 
-        for (int i = 0; i < size; i++) {
-            CompoundTag entry = mods.getCompound(i);
-            if (entry.isEmpty()) {
-                // entry is not an actual NBTTagCompound. getCompound returns empty NBTTagCompound in that case
-                continue;
+            if (this.hasEnchantmentGlintOverride()) {
+                itemTag.put(CraftMetaItem.ENCHANTMENT_GLINT_OVERRIDE, this.getEnchantmentGlintOverride());
             }
-            net.minecraft.world.entity.ai.attributes.AttributeModifier nmsModifier = net.minecraft.world.entity.ai.attributes.AttributeModifier.load(entry);
-            if (nmsModifier == null) {
-                continue;
+
+            if (this.isFireResistant()) {
+                itemTag.put(CraftMetaItem.FIRE_RESISTANT, Unit.INSTANCE);
             }
 
-            AttributeModifier attribMod = CraftAttributeInstance.convert(nmsModifier);
+            if (this.hasMaxStackSize()) {
+                itemTag.put(CraftMetaItem.MAX_STACK_SIZE, this.maxStackSize);
+            }
 
-            String attributeName = org.bukkit.craftbukkit.attribute.CraftAttributeMap.convertIfNeeded(entry.getString(CraftMetaItem.ATTRIBUTES_IDENTIFIER.NBT)); // Paper
-            if (attributeName == null || attributeName.isEmpty()) {
-                continue;
+            if (this.hasRarity()) {
+                itemTag.put(CraftMetaItem.RARITY, Rarity.valueOf(this.rarity.name()));
             }
 
-            Attribute attribute = CraftAttribute.stringToBukkit(attributeName);
-            if (attribute == null) {
-                continue;
+            if (this.hasFood()) {
+                itemTag.put(CraftMetaItem.FOOD, this.food.getHandle());
             }
 
-            if (entry.contains(CraftMetaItem.ATTRIBUTES_SLOT.NBT, CraftMagicNumbers.NBT.TAG_STRING)) {
-                String slotName = entry.getString(CraftMetaItem.ATTRIBUTES_SLOT.NBT);
-                if (slotName == null || slotName.isEmpty()) {
-                    modifiers.put(attribute, attribMod);
-                    continue;
-                }
+            if (this.hasTool()) {
+                itemTag.put(CraftMetaItem.TOOL, this.tool.getHandle());
+            }
 
-                EquipmentSlot slot = null;
-                try {
-                    slot = CraftEquipmentSlot.getSlot(net.minecraft.world.entity.EquipmentSlot.byName(slotName.toLowerCase(Locale.ROOT)));
-                } catch (IllegalArgumentException ex) {
-                    // SPIGOT-4551 - Slot is invalid, should really match nothing but this is undefined behaviour anyway
+            if (this.hasJukeboxPlayable()) {
+                itemTag.put(CraftMetaItem.JUKEBOX_PLAYABLE, this.jukebox.getHandle());
+            }
+
+            if (this.hasDamage()) {
+                itemTag.put(CraftMetaItem.DAMAGE, this.damage);
+            }
+
+            if (this.hasMaxDamage()) {
+                itemTag.put(CraftMetaItem.MAX_DAMAGE, this.maxDamage);
+            }
+
+            // Paper start
+            if (this.canPlaceOnPredicates != null && !this.canPlaceOnPredicates.isEmpty()) {
+                itemTag.put(CraftMetaItem.CAN_PLACE_ON, new net.minecraft.world.item.AdventureModePredicate(this.canPlaceOnPredicates, !this.hasItemFlag(ItemFlag.HIDE_PLACED_ON)));
+            }
+            if (this.canBreakPredicates != null && !this.canBreakPredicates.isEmpty()) {
+                itemTag.put(CraftMetaItem.CAN_BREAK, new net.minecraft.world.item.AdventureModePredicate(this.canBreakPredicates, !this.hasItemFlag(ItemFlag.HIDE_DESTROYS)));
+            }
+            // Paper end
+
+            for (Map.Entry<DataComponentType<?>, Optional<?>> e : this.unhandledTags.build().entrySet()) {
+                e.getValue().ifPresentOrElse((value) -> {
+                    itemTag.builder.set((DataComponentType) e.getKey(), value);
+                }, () -> itemTag.remove(e.getKey()));
+            }
+
+            for (DataComponentType<?> removed : this.removedTags) {
+                if (!itemTag.builder.isSet(removed)) {
+                    itemTag.builder.remove(removed);
                 }
+            }
 
-                if (slot == null) {
-                    modifiers.put(attribute, attribMod);
-                    continue;
+            CompoundTag customTag = (this.customTag != null) ? this.customTag.copy() : null;
+            if (!this.persistentDataContainer.isEmpty()) {
+                CompoundTag bukkitCustomCompound = new CompoundTag();
+                Map<String, Tag> rawPublicMap = this.persistentDataContainer.getRaw();
+
+                for (Map.Entry<String, Tag> nbtBaseEntry : rawPublicMap.entrySet()) {
+                    bukkitCustomCompound.put(nbtBaseEntry.getKey(), nbtBaseEntry.getValue());
                 }
 
-                attribMod = new AttributeModifier(attribMod.getKey(), attribMod.getAmount(), attribMod.getOperation(), slot.getGroup());
+                if (customTag == null) {
+                    customTag = new CompoundTag();
+                }
+                customTag.put(CraftMetaItem.BUKKIT_CUSTOM_TAG.BUKKIT, bukkitCustomCompound);
             }
-            modifiers.put(attribute, attribMod);
-        }
-        return modifiers;
-    }
 
-    static EnchantmentMap buildEnchantments(Map<String, Object> map, ItemMetaKey key) { // Paper
-        Map<?, ?> ench = SerializableMeta.getObject(Map.class, map, key.BUKKIT, true);
-        if (ench == null) {
-            return null;
+            if (customTag != null) {
+                itemTag.put(CraftMetaItem.CUSTOM_DATA, CustomData.of(customTag));
+            }
         }
 
-        EnchantmentMap enchantments = new EnchantmentMap(); // Paper
-        for (Map.Entry<?, ?> entry : ench.entrySet()) {
-            Enchantment enchantment = CraftEnchantment.stringToBukkit(entry.getKey().toString());
-            if ((enchantment != null) && (entry.getValue() instanceof Integer)) {
-                enchantments.put(enchantment, (Integer) entry.getValue());
+        void applyEnchantments(Map<Enchantment, Integer> enchantments, CraftMetaItem.Applicator tag, ItemMetaKeyType<ItemEnchantments> key, ItemFlag itemFlag) {
+            if (enchantments == null) {
+                return;
             }
-        }
 
-        return enchantments;
-    }
+            ItemEnchantments.Mutable list = new ItemEnchantments.Mutable(ItemEnchantments.EMPTY);
 
-    static Multimap<Attribute, AttributeModifier> buildModifiers(Map<String, Object> map, ItemMetaKey key) {
-        Map<?, ?> mods = SerializableMeta.getObject(Map.class, map, key.BUKKIT, true);
-        Multimap<Attribute, AttributeModifier> result = LinkedHashMultimap.create();
-        if (mods == null) {
-            return result;
+            for (Map.Entry<Enchantment, Integer> entry : enchantments.entrySet()) {
+                list.set(CraftEnchantment.bukkitToMinecraftHolder(entry.getKey()), entry.getValue());
+            }
+
+            list.showInTooltip = !this.hasItemFlag(itemFlag);
+            tag.put(key, list.toImmutable());
         }
 
-        for (Object obj : mods.keySet()) {
-            if (!(obj instanceof String)) {
-                continue;
-            }
-            String attributeName = (String) obj;
-            if (Strings.isNullOrEmpty(attributeName)) {
-                continue;
-            }
-            List<?> list = SerializableMeta.getObject(List.class, mods, attributeName, true);
-            if (list == null || list.isEmpty()) {
-                return result;
+        void applyModifiers(Multimap<Attribute, AttributeModifier> modifiers, CraftMetaItem.Applicator tag) {
+            if (modifiers == null || modifiers.isEmpty()) {
+                if (this.hasItemFlag(ItemFlag.HIDE_ATTRIBUTES)) {
+                    tag.put(CraftMetaItem.ATTRIBUTES, new ItemAttributeModifiers(Collections.emptyList(), false));
+                }
+                return;
             }
 
-            for (Object o : list) {
-                if (!(o instanceof AttributeModifier)) { // this catches null
+            ItemAttributeModifiers.Builder list = ItemAttributeModifiers.builder();
+            for (Map.Entry<Attribute, AttributeModifier> entry : modifiers.entries()) {
+                if (entry.getKey() == null || entry.getValue() == null) {
                     continue;
                 }
-                AttributeModifier modifier = (AttributeModifier) o;
-                Attribute attribute = CraftAttribute.stringToBukkit(attributeName);
-                if (attribute == null) {
+                net.minecraft.world.entity.ai.attributes.AttributeModifier nmsModifier = CraftAttributeInstance.convert(entry.getValue());
+
+                Holder<net.minecraft.world.entity.ai.attributes.Attribute> name = CraftAttribute.bukkitToMinecraftHolder(entry.getKey());
+                if (name == null) {
                     continue;
                 }
 
-                result.put(attribute, modifier);
+                EquipmentSlotGroup group = CraftEquipmentSlot.getNMSGroup(entry.getValue().getSlotGroup());
+                list.add(name, nmsModifier, group);
             }
+            tag.put(CraftMetaItem.ATTRIBUTES, list.build().withTooltip(!this.hasItemFlag(ItemFlag.HIDE_ATTRIBUTES)));
         }
-        return result;
-    }
 
-    @Overridden
-    void applyToItem(CraftMetaItem.Applicator itemTag) {
-        if (this.hasDisplayName()) {
-            itemTag.put(CraftMetaItem.NAME, this.displayName);
-        }
+        boolean applicableTo(Material type) {
+            if (type == Material.AIR || !type.isItem()) {
+                return false;
+            }
 
-        if (this.hasItemName()) {
-            itemTag.put(CraftMetaItem.ITEM_NAME, this.itemName);
-        }
+            if (this.getClass() == CraftMetaItem.class) {
+                return true;
+            }
 
-        if (this.lore != null) {
-            itemTag.put(CraftMetaItem.LORE, new ItemLore(this.lore));
+            // We assume that the corresponding bukkit interface is always the first one
+            return type.asItemType().getItemMetaClass() == this.getClass().getInterfaces()[0];
         }
 
-        if (this.hasCustomModelData()) {
-            itemTag.put(CraftMetaItem.CUSTOM_MODEL_DATA, new CustomModelData(this.customModelData));
+        @Overridden
+        boolean isEmpty() {
+            return !(this.hasDisplayName() || this.hasItemName() || this.hasLocalizedName() || this.hasEnchants() || (this.lore != null) || this.hasCustomModelData() || this.hasBlockData() || this.hasRepairCost() || !this.unhandledTags.build().isEmpty() || !this.removedTags.isEmpty() || !this.persistentDataContainer.isEmpty() || this.hideFlag != 0 || this.isHideTooltip() || this.isUnbreakable() || this.hasEnchantmentGlintOverride() || this.isFireResistant() || this.hasMaxStackSize() || this.hasRarity() || this.hasFood() || this.hasTool() || this.hasDamage() || this.hasMaxDamage() || this.hasAttributeModifiers() || this.customTag != null || this.canPlaceOnPredicates != null || this.canBreakPredicates != null); // Paper
         }
 
-        if (this.hasBlockData()) {
-            itemTag.put(CraftMetaItem.BLOCK_DATA, new BlockItemStateProperties(this.blockData));
+        // Paper start
+        @Override
+        public net.kyori.adventure.text.Component displayName() {
+            return displayName == null ? null : io.papermc.paper.adventure.PaperAdventure.asAdventure(displayName);
         }
 
-        if (this.hideFlag != 0) {
-            if (this.hasItemFlag(ItemFlag.HIDE_ADDITIONAL_TOOLTIP)) {
-                itemTag.put(CraftMetaItem.HIDE_ADDITIONAL_TOOLTIP, Unit.INSTANCE);
-            }
+        @Override
+        public void displayName(final net.kyori.adventure.text.Component displayName) {
+            this.displayName = displayName == null ? null : io.papermc.paper.adventure.PaperAdventure.asVanilla(displayName);
         }
+        // Paper end
 
-        this.applyEnchantments(this.enchantments, itemTag, CraftMetaItem.ENCHANTMENTS, ItemFlag.HIDE_ENCHANTS);
-        this.applyModifiers(this.attributeModifiers, itemTag);
-
-        if (this.hasRepairCost()) {
-            itemTag.put(CraftMetaItem.REPAIR, this.repairCost);
+        @Override
+        public String getDisplayName() {
+            return CraftChatMessage.fromComponent(this.displayName);
         }
 
-        if (this.isHideTooltip()) {
-            itemTag.put(CraftMetaItem.HIDE_TOOLTIP, Unit.INSTANCE);
+        // Paper start
+        @Override
+        public net.md_5.bungee.api.chat.BaseComponent[] getDisplayNameComponent() {
+            return displayName == null ? new net.md_5.bungee.api.chat.BaseComponent[0] : net.md_5.bungee.chat.ComponentSerializer.parse(CraftChatMessage.toJSON(displayName));
+        }
+        // Paper end
+        @Override
+        public final void setDisplayName(String name) {
+            this.displayName = CraftChatMessage.fromStringOrNull(name);
         }
 
-        if (this.isUnbreakable()) {
-            itemTag.put(CraftMetaItem.UNBREAKABLE, new Unbreakable(!this.hasItemFlag(ItemFlag.HIDE_UNBREAKABLE)));
+        // Paper start
+        @Override
+        public void setDisplayNameComponent(net.md_5.bungee.api.chat.BaseComponent[] component) {
+            this.displayName = CraftChatMessage.fromJSON(net.md_5.bungee.chat.ComponentSerializer.toString(component));
+        }
+        // Paper end
+        @Override
+        public boolean hasDisplayName() {
+            return this.displayName != null;
         }
 
-        if (this.hasEnchantmentGlintOverride()) {
-            itemTag.put(CraftMetaItem.ENCHANTMENT_GLINT_OVERRIDE, this.getEnchantmentGlintOverride());
+        @Override
+        public String getItemName() {
+            return CraftChatMessage.fromComponent(this.itemName);
         }
 
-        if (this.isFireResistant()) {
-            itemTag.put(CraftMetaItem.FIRE_RESISTANT, Unit.INSTANCE);
+        @Override
+        public final void setItemName(String name) {
+            this.itemName = CraftChatMessage.fromStringOrNull(name);
         }
 
-        if (this.hasMaxStackSize()) {
-            itemTag.put(CraftMetaItem.MAX_STACK_SIZE, this.maxStackSize);
+        @Override
+        public boolean hasItemName() {
+            return this.itemName != null;
         }
 
-        if (this.hasRarity()) {
-            itemTag.put(CraftMetaItem.RARITY, Rarity.valueOf(this.rarity.name()));
+        // Paper start - Adventure
+        @Override
+        public net.kyori.adventure.text.Component itemName() {
+            return io.papermc.paper.adventure.PaperAdventure.asAdventure(this.itemName);
         }
 
-        if (this.hasFood()) {
-            itemTag.put(CraftMetaItem.FOOD, this.food.getHandle());
+        @Override
+        public void itemName(final net.kyori.adventure.text.Component name) {
+            this.itemName = io.papermc.paper.adventure.PaperAdventure.asVanilla(name);
         }
+        // Paper end - Adventure
 
-        if (this.hasTool()) {
-            itemTag.put(CraftMetaItem.TOOL, this.tool.getHandle());
+        @Override
+        public String getLocalizedName() {
+            return this.getDisplayName();
         }
 
-        if (this.hasJukeboxPlayable()) {
-            itemTag.put(CraftMetaItem.JUKEBOX_PLAYABLE, this.jukebox.getHandle());
+        @Override
+        public void setLocalizedName(String name) {
         }
 
-        if (this.hasDamage()) {
-            itemTag.put(CraftMetaItem.DAMAGE, this.damage);
+        @Override
+        public boolean hasLocalizedName() {
+            return false;
         }
 
-        if (this.hasMaxDamage()) {
-            itemTag.put(CraftMetaItem.MAX_DAMAGE, this.maxDamage);
+        @Override
+        public boolean hasLore() {
+            return this.lore != null && !this.lore.isEmpty();
         }
 
         // Paper start
-        if (this.canPlaceOnPredicates != null && !this.canPlaceOnPredicates.isEmpty()) {
-            itemTag.put(CraftMetaItem.CAN_PLACE_ON, new net.minecraft.world.item.AdventureModePredicate(this.canPlaceOnPredicates, !this.hasItemFlag(ItemFlag.HIDE_PLACED_ON)));
+        @Override
+        public List<net.kyori.adventure.text.Component> lore() {
+            return this.lore != null ? io.papermc.paper.adventure.PaperAdventure.asAdventure(this.lore) : null;
         }
-        if (this.canBreakPredicates != null && !this.canBreakPredicates.isEmpty()) {
-            itemTag.put(CraftMetaItem.CAN_BREAK, new net.minecraft.world.item.AdventureModePredicate(this.canBreakPredicates, !this.hasItemFlag(ItemFlag.HIDE_DESTROYS)));
+
+        @Override
+        public void lore(final List<? extends net.kyori.adventure.text.Component> lore) {
+            this.lore = lore != null ? io.papermc.paper.adventure.PaperAdventure.asVanilla(lore) : null;
         }
         // Paper end
 
-        for (Map.Entry<DataComponentType<?>, Optional<?>> e : this.unhandledTags.build().entrySet()) {
-            e.getValue().ifPresentOrElse((value) -> {
-                itemTag.builder.set((DataComponentType) e.getKey(), value);
-            }, () -> itemTag.remove(e.getKey()));
+        @Override
+        public boolean hasRepairCost() {
+            return this.repairCost > 0;
+        }
+
+        @Override
+        public boolean hasEnchant(Enchantment ench) {
+            Preconditions.checkArgument(ench != null, "Enchantment cannot be null");
+            return this.hasEnchants() && this.enchantments.containsKey(ench);
         }
 
-        for (DataComponentType<?> removed : this.removedTags) {
-            if (!itemTag.builder.isSet(removed)) {
-                itemTag.builder.remove(removed);
+        @Override
+        public int getEnchantLevel(Enchantment ench) {
+            Preconditions.checkArgument(ench != null, "Enchantment cannot be null");
+            Integer level = this.hasEnchants() ? this.enchantments.get(ench) : null;
+            if (level == null) {
+                return 0;
             }
+            return level;
         }
 
-        CompoundTag customTag = (this.customTag != null) ? this.customTag.copy() : null;
-        if (!this.persistentDataContainer.isEmpty()) {
-            CompoundTag bukkitCustomCompound = new CompoundTag();
-            Map<String, Tag> rawPublicMap = this.persistentDataContainer.getRaw();
+        @Override
+        public Map<Enchantment, Integer> getEnchants() {
+            return this.hasEnchants() ? ImmutableSortedMap.copyOfSorted(this.enchantments) : ImmutableMap.<Enchantment, Integer>of(); // Paper
+        }
 
-            for (Map.Entry<String, Tag> nbtBaseEntry : rawPublicMap.entrySet()) {
-                bukkitCustomCompound.put(nbtBaseEntry.getKey(), nbtBaseEntry.getValue());
+        @Override
+        public boolean addEnchant(Enchantment ench, int level, boolean ignoreRestrictions) {
+            Preconditions.checkArgument(ench != null, "Enchantment cannot be null");
+            if (this.enchantments == null) {
+                this.enchantments = new EnchantmentMap(); // Paper
             }
 
-            if (customTag == null) {
-                customTag = new CompoundTag();
+            if (ignoreRestrictions || level >= ench.getStartLevel() && level <= ench.getMaxLevel()) {
+                Integer old = this.enchantments.put(ench, level);
+                return old == null || old != level;
             }
-            customTag.put(CraftMetaItem.BUKKIT_CUSTOM_TAG.BUKKIT, bukkitCustomCompound);
+            return false;
         }
 
-        if (customTag != null) {
-            itemTag.put(CraftMetaItem.CUSTOM_DATA, CustomData.of(customTag));
+        @Override
+        public boolean removeEnchant(Enchantment ench) {
+            Preconditions.checkArgument(ench != null, "Enchantment cannot be null");
+            boolean enchantmentRemoved = this.hasEnchants() && this.enchantments.remove(ench) != null;
+            // If we no longer have any enchantments, then clear enchantment tag
+            if (enchantmentRemoved && this.enchantments.isEmpty()) {
+                this.enchantments = null;
+            }
+            return enchantmentRemoved;
         }
-    }
 
-    void applyEnchantments(Map<Enchantment, Integer> enchantments, CraftMetaItem.Applicator tag, ItemMetaKeyType<ItemEnchantments> key, ItemFlag itemFlag) {
-        if (enchantments == null) {
-            return;
+        @Override
+        public void removeEnchantments() {
+            if (this.hasEnchants()) {
+                this.enchantments.clear();
+            }
         }
 
-        ItemEnchantments.Mutable list = new ItemEnchantments.Mutable(ItemEnchantments.EMPTY);
-
-        for (Map.Entry<Enchantment, Integer> entry : enchantments.entrySet()) {
-            list.set(CraftEnchantment.bukkitToMinecraftHolder(entry.getKey()), entry.getValue());
+        @Override
+        public boolean hasEnchants() {
+            return !(this.enchantments == null || this.enchantments.isEmpty());
         }
 
-        list.showInTooltip = !this.hasItemFlag(itemFlag);
-        tag.put(key, list.toImmutable());
-    }
+        @Override
+        public boolean hasConflictingEnchant(Enchantment ench) {
+            return CraftMetaItem.checkConflictingEnchants(this.enchantments, ench);
+        }
 
-    void applyModifiers(Multimap<Attribute, AttributeModifier> modifiers, CraftMetaItem.Applicator tag) {
-        if (modifiers == null || modifiers.isEmpty()) {
-            if (this.hasItemFlag(ItemFlag.HIDE_ATTRIBUTES)) {
-                tag.put(CraftMetaItem.ATTRIBUTES, new ItemAttributeModifiers(Collections.emptyList(), false));
+        @Override
+        public void addItemFlags(ItemFlag... hideFlags) {
+            for (ItemFlag f : hideFlags) {
+                this.hideFlag |= this.getBitModifier(f);
             }
-            return;
         }
 
-        ItemAttributeModifiers.Builder list = ItemAttributeModifiers.builder();
-        for (Map.Entry<Attribute, AttributeModifier> entry : modifiers.entries()) {
-            if (entry.getKey() == null || entry.getValue() == null) {
-                continue;
+        @Override
+        public void removeItemFlags(ItemFlag... hideFlags) {
+            for (ItemFlag f : hideFlags) {
+                this.hideFlag &= ~this.getBitModifier(f);
             }
-            net.minecraft.world.entity.ai.attributes.AttributeModifier nmsModifier = CraftAttributeInstance.convert(entry.getValue());
+        }
+
+        @Override
+        public Set<ItemFlag> getItemFlags() {
+            Set<ItemFlag> currentFlags = EnumSet.noneOf(ItemFlag.class);
 
-            Holder<net.minecraft.world.entity.ai.attributes.Attribute> name = CraftAttribute.bukkitToMinecraftHolder(entry.getKey());
-            if (name == null) {
-                continue;
+            for (ItemFlag f : ItemFlag.values()) {
+                if (this.hasItemFlag(f)) {
+                    currentFlags.add(f);
+                }
             }
 
-            EquipmentSlotGroup group = CraftEquipmentSlot.getNMSGroup(entry.getValue().getSlotGroup());
-            list.add(name, nmsModifier, group);
+            return currentFlags;
         }
-        tag.put(CraftMetaItem.ATTRIBUTES, list.build().withTooltip(!this.hasItemFlag(ItemFlag.HIDE_ATTRIBUTES)));
-    }
 
-    boolean applicableTo(Material type) {
-        if (type == Material.AIR || !type.isItem()) {
-            return false;
+        @Override
+        public boolean hasItemFlag(ItemFlag flag) {
+            int bitModifier = this.getBitModifier(flag);
+            return (this.hideFlag & bitModifier) == bitModifier;
         }
 
-        if (this.getClass() == CraftMetaItem.class) {
-            return true;
+        private int getBitModifier(ItemFlag hideFlag) {
+            return 1 << hideFlag.ordinal();
         }
 
-        // We assume that the corresponding bukkit interface is always the first one
-        return type.asItemType().getItemMetaClass() == this.getClass().getInterfaces()[0];
-    }
+        @Override
+        public List<String> getLore() {
+            return this.lore == null ? null : new ArrayList<String>(Lists.transform(this.lore, CraftChatMessage::fromComponent));
+        }
 
-    @Overridden
-    boolean isEmpty() {
-        return !(this.hasDisplayName() || this.hasItemName() || this.hasLocalizedName() || this.hasEnchants() || (this.lore != null) || this.hasCustomModelData() || this.hasBlockData() || this.hasRepairCost() || !this.unhandledTags.build().isEmpty() || !this.removedTags.isEmpty() || !this.persistentDataContainer.isEmpty() || this.hideFlag != 0 || this.isHideTooltip() || this.isUnbreakable() || this.hasEnchantmentGlintOverride() || this.isFireResistant() || this.hasMaxStackSize() || this.hasRarity() || this.hasFood() || this.hasTool() || this.hasDamage() || this.hasMaxDamage() || this.hasAttributeModifiers() || this.customTag != null || this.canPlaceOnPredicates != null || this.canBreakPredicates != null); // Paper
-    }
+        // Paper start
+        @Override
+        public List<net.md_5.bungee.api.chat.BaseComponent[]> getLoreComponents() {
+            return this.lore == null ? null : new ArrayList<>(this.lore.stream().map(entry ->
+                net.md_5.bungee.chat.ComponentSerializer.parse(CraftChatMessage.toJSON(entry))
+            ).collect(java.util.stream.Collectors.toList()));
+        }
+        // Paper end
+        @Override
+        public void setLore(List<String> lore) {
+            if (lore == null || lore.isEmpty()) {
+                this.lore = null;
+            } else {
+                if (this.lore == null) {
+                    this.lore = new ArrayList<Component>(lore.size());
+                } else {
+                    this.lore.clear();
+                }
+                CraftMetaItem.safelyAdd(lore, this.lore, false);
+            }
+        }
 
-    // Paper start
-    @Override
-    public net.kyori.adventure.text.Component displayName() {
-        return displayName == null ? null : io.papermc.paper.adventure.PaperAdventure.asAdventure(displayName);
-    }
+        // Paper start
+        @Override
+        public void setLoreComponents(List<net.md_5.bungee.api.chat.BaseComponent[]> lore) {
+            if (lore == null) {
+                this.lore = null;
+            } else {
+                if (this.lore == null) {
+                    safelyAdd(lore, this.lore = new ArrayList<>(lore.size()), false);
+                } else {
+                    this.lore.clear();
+                    safelyAdd(lore, this.lore, false);
+                }
+            }
+        }
+        // Paper end
+        @Override
+        public boolean hasCustomModelData() {
+            return this.customModelData != null;
+        }
 
-    @Override
-    public void displayName(final net.kyori.adventure.text.Component displayName) {
-        this.displayName = displayName == null ? null : io.papermc.paper.adventure.PaperAdventure.asVanilla(displayName);
-    }
-    // Paper end
+        @Override
+        public int getCustomModelData() {
+            Preconditions.checkState(this.hasCustomModelData(), "We don't have CustomModelData! Check hasCustomModelData first!");
+            return this.customModelData;
+        }
 
-    @Override
-    public String getDisplayName() {
-        return CraftChatMessage.fromComponent(this.displayName);
-    }
+        @Override
+        public void setCustomModelData(Integer data) {
+            this.customModelData = data;
+        }
 
-    // Paper start
-    @Override
-    public net.md_5.bungee.api.chat.BaseComponent[] getDisplayNameComponent() {
-        return displayName == null ? new net.md_5.bungee.api.chat.BaseComponent[0] : net.md_5.bungee.chat.ComponentSerializer.parse(CraftChatMessage.toJSON(displayName));
-    }
-    // Paper end
-    @Override
-    public final void setDisplayName(String name) {
-        this.displayName = CraftChatMessage.fromStringOrNull(name);
-    }
+        @Override
+        public boolean hasBlockData() {
+            return this.blockData != null;
+        }
 
-    // Paper start
-    @Override
-    public void setDisplayNameComponent(net.md_5.bungee.api.chat.BaseComponent[] component) {
-        this.displayName = CraftChatMessage.fromJSON(net.md_5.bungee.chat.ComponentSerializer.toString(component));
-    }
-    // Paper end
-    @Override
-    public boolean hasDisplayName() {
-        return this.displayName != null;
-    }
+        @Override
+        public BlockData getBlockData(Material material) {
+            BlockState defaultData = CraftBlockType.bukkitToMinecraft(material).defaultBlockState();
+            return CraftBlockData.fromData((this.hasBlockData()) ? new BlockItemStateProperties(this.blockData).apply(defaultData) : defaultData);
+        }
 
-    @Override
-    public String getItemName() {
-        return CraftChatMessage.fromComponent(this.itemName);
-    }
+        @Override
+        public void setBlockData(BlockData blockData) {
+            this.blockData = (blockData == null) ? null : ((CraftBlockData) blockData).toStates();
+        }
 
-    @Override
-    public final void setItemName(String name) {
-        this.itemName = CraftChatMessage.fromStringOrNull(name);
-    }
+        @Override
+        public int getRepairCost() {
+            return this.repairCost;
+        }
 
-    @Override
-    public boolean hasItemName() {
-        return this.itemName != null;
-    }
+        @Override
+        public void setRepairCost(int cost) { // TODO: Does this have limits?
+            this.repairCost = cost;
+        }
 
-    // Paper start - Adventure
-    @Override
-    public net.kyori.adventure.text.Component itemName() {
-        return io.papermc.paper.adventure.PaperAdventure.asAdventure(this.itemName);
-    }
+        @Override
+        public boolean isHideTooltip() {
+            return this.hideTooltip;
+        }
 
-    @Override
-    public void itemName(final net.kyori.adventure.text.Component name) {
-        this.itemName = io.papermc.paper.adventure.PaperAdventure.asVanilla(name);
-    }
-    // Paper end - Adventure
+        @Override
+        public void setHideTooltip(boolean hideTooltip) {
+            this.hideTooltip = hideTooltip;
+        }
 
-    @Override
-    public String getLocalizedName() {
-        return this.getDisplayName();
-    }
+        @Override
+        public boolean isUnbreakable() {
+            return this.unbreakable;
+        }
 
-    @Override
-    public void setLocalizedName(String name) {
-    }
+        @Override
+        public void setUnbreakable(boolean unbreakable) {
+            this.unbreakable = unbreakable;
+        }
 
-    @Override
-    public boolean hasLocalizedName() {
-        return false;
-    }
+        @Override
+        public boolean hasEnchantmentGlintOverride() {
+            return this.enchantmentGlintOverride != null;
+        }
 
-    @Override
-    public boolean hasLore() {
-        return this.lore != null && !this.lore.isEmpty();
-    }
+        @Override
+        public Boolean getEnchantmentGlintOverride() {
+            Preconditions.checkState(this.hasEnchantmentGlintOverride(), "We don't have enchantment_glint_override! Check hasEnchantmentGlintOverride first!");
+            return this.enchantmentGlintOverride;
+        }
 
-    // Paper start
-    @Override
-    public List<net.kyori.adventure.text.Component> lore() {
-        return this.lore != null ? io.papermc.paper.adventure.PaperAdventure.asAdventure(this.lore) : null;
-    }
+        @Override
+        public void setEnchantmentGlintOverride(Boolean override) {
+            this.enchantmentGlintOverride = override;
+        }
 
-    @Override
-    public void lore(final List<? extends net.kyori.adventure.text.Component> lore) {
-        this.lore = lore != null ? io.papermc.paper.adventure.PaperAdventure.asVanilla(lore) : null;
-    }
-    // Paper end
+        @Override
+        public boolean isFireResistant() {
+            return this.fireResistant;
+        }
 
-    @Override
-    public boolean hasRepairCost() {
-        return this.repairCost > 0;
-    }
+        @Override
+        public void setFireResistant(boolean fireResistant) {
+            this.fireResistant = fireResistant;
+        }
 
-    @Override
-    public boolean hasEnchant(Enchantment ench) {
-        Preconditions.checkArgument(ench != null, "Enchantment cannot be null");
-        return this.hasEnchants() && this.enchantments.containsKey(ench);
-    }
+        @Override
+        public boolean hasMaxStackSize() {
+            return this.maxStackSize != null;
+        }
 
-    @Override
-    public int getEnchantLevel(Enchantment ench) {
-        Preconditions.checkArgument(ench != null, "Enchantment cannot be null");
-        Integer level = this.hasEnchants() ? this.enchantments.get(ench) : null;
-        if (level == null) {
-            return 0;
+        @Override
+        public int getMaxStackSize() {
+            Preconditions.checkState(this.hasMaxStackSize(), "We don't have max_stack_size! Check hasMaxStackSize first!");
+            return this.maxStackSize;
         }
-        return level;
-    }
 
-    @Override
-    public Map<Enchantment, Integer> getEnchants() {
-        return this.hasEnchants() ? ImmutableSortedMap.copyOfSorted(this.enchantments) : ImmutableMap.<Enchantment, Integer>of(); // Paper
-    }
+        @Override
+        public void setMaxStackSize(Integer max) {
+            Preconditions.checkArgument(max == null || max > 0, "max_stack_size must be > 0");
+            Preconditions.checkArgument(max == null || max <= net.minecraft.world.item.Item.ABSOLUTE_MAX_STACK_SIZE, "max_stack_size must be <= 99");
+            this.maxStackSize = max;
+        }
 
-    @Override
-    public boolean addEnchant(Enchantment ench, int level, boolean ignoreRestrictions) {
-        Preconditions.checkArgument(ench != null, "Enchantment cannot be null");
-        if (this.enchantments == null) {
-            this.enchantments = new EnchantmentMap(); // Paper
+        @Override
+        public boolean hasRarity() {
+            return this.rarity != null;
         }
 
-        if (ignoreRestrictions || level >= ench.getStartLevel() && level <= ench.getMaxLevel()) {
-            Integer old = this.enchantments.put(ench, level);
-            return old == null || old != level;
+        @Override
+        public ItemRarity getRarity() {
+            Preconditions.checkState(this.hasRarity(), "We don't have rarity! Check hasRarity first!");
+            return this.rarity;
         }
-        return false;
-    }
 
-    @Override
-    public boolean removeEnchant(Enchantment ench) {
-        Preconditions.checkArgument(ench != null, "Enchantment cannot be null");
-        boolean enchantmentRemoved = this.hasEnchants() && this.enchantments.remove(ench) != null;
-        // If we no longer have any enchantments, then clear enchantment tag
-        if (enchantmentRemoved && this.enchantments.isEmpty()) {
-            this.enchantments = null;
+        @Override
+        public void setRarity(ItemRarity rarity) {
+            this.rarity = rarity;
         }
-        return enchantmentRemoved;
-    }
 
-    @Override
-    public void removeEnchantments() {
-        if (this.hasEnchants()) {
-            this.enchantments.clear();
+        @Override
+        public boolean hasFood() {
+            return this.food != null;
         }
-    }
 
-    @Override
-    public boolean hasEnchants() {
-        return !(this.enchantments == null || this.enchantments.isEmpty());
-    }
+        @Override
+        public FoodComponent getFood() {
+            return (this.hasFood()) ? new CraftFoodComponent(this.food) : new CraftFoodComponent(new FoodProperties(0, 0, false, 0, Optional.empty(), Collections.emptyList()));
+        }
 
-    @Override
-    public boolean hasConflictingEnchant(Enchantment ench) {
-        return CraftMetaItem.checkConflictingEnchants(this.enchantments, ench);
-    }
+        @Override
+        public void setFood(FoodComponent food) {
+            this.food = (food == null) ? null : new CraftFoodComponent((CraftFoodComponent) food);
+        }
 
-    @Override
-    public void addItemFlags(ItemFlag... hideFlags) {
-        for (ItemFlag f : hideFlags) {
-            this.hideFlag |= this.getBitModifier(f);
+        @Override
+        public boolean hasTool() {
+            return this.tool != null;
         }
-    }
 
-    @Override
-    public void removeItemFlags(ItemFlag... hideFlags) {
-        for (ItemFlag f : hideFlags) {
-            this.hideFlag &= ~this.getBitModifier(f);
+        @Override
+        public ToolComponent getTool() {
+            return (this.hasTool()) ? new CraftToolComponent(this.tool) : new CraftToolComponent(new Tool(Collections.emptyList(), 1.0F, 0));
         }
-    }
 
-    @Override
-    public Set<ItemFlag> getItemFlags() {
-        Set<ItemFlag> currentFlags = EnumSet.noneOf(ItemFlag.class);
+        @Override
+        public void setTool(ToolComponent tool) {
+            this.tool = (tool == null) ? null : new CraftToolComponent((CraftToolComponent) tool);
+        }
 
-        for (ItemFlag f : ItemFlag.values()) {
-            if (this.hasItemFlag(f)) {
-                currentFlags.add(f);
-            }
+        @Override
+        public boolean hasJukeboxPlayable() {
+            return this.jukebox != null;
         }
 
-        return currentFlags;
-    }
+        @Override
+        public JukeboxPlayableComponent getJukeboxPlayable() {
+            return (this.hasJukeboxPlayable()) ? new CraftJukeboxComponent(this.jukebox) : new CraftJukeboxComponent(new JukeboxPlayable(new EitherHolder<>(JukeboxSongs.THIRTEEN), true));
+        }
 
-    @Override
-    public boolean hasItemFlag(ItemFlag flag) {
-        int bitModifier = this.getBitModifier(flag);
-        return (this.hideFlag & bitModifier) == bitModifier;
-    }
+        @Override
+        public void setJukeboxPlayable(JukeboxPlayableComponent jukeboxPlayable) {
+            this.jukebox = (jukeboxPlayable == null) ? null : new CraftJukeboxComponent((CraftJukeboxComponent) jukeboxPlayable);
+        }
 
-    private int getBitModifier(ItemFlag hideFlag) {
-        return 1 << hideFlag.ordinal();
-    }
+        @Override
+        public boolean hasAttributeModifiers() {
+            return this.attributeModifiers != null && !this.attributeModifiers.isEmpty();
+        }
 
-    @Override
-    public List<String> getLore() {
-        return this.lore == null ? null : new ArrayList<String>(Lists.transform(this.lore, CraftChatMessage::fromComponent));
-    }
+        @Override
+        public Multimap<Attribute, AttributeModifier> getAttributeModifiers() {
+            return this.hasAttributeModifiers() ? ImmutableMultimap.copyOf(this.attributeModifiers) : null;
+        }
 
-    // Paper start
-    @Override
-    public List<net.md_5.bungee.api.chat.BaseComponent[]> getLoreComponents() {
-        return this.lore == null ? null : new ArrayList<>(this.lore.stream().map(entry ->
-            net.md_5.bungee.chat.ComponentSerializer.parse(CraftChatMessage.toJSON(entry))
-        ).collect(java.util.stream.Collectors.toList()));
-    }
-    // Paper end
-    @Override
-    public void setLore(List<String> lore) {
-        if (lore == null || lore.isEmpty()) {
-            this.lore = null;
-        } else {
-            if (this.lore == null) {
-                this.lore = new ArrayList<Component>(lore.size());
-            } else {
-                this.lore.clear();
+        private void checkAttributeList() {
+            if (this.attributeModifiers == null) {
+                this.attributeModifiers = LinkedHashMultimap.create();
             }
-            CraftMetaItem.safelyAdd(lore, this.lore, false);
         }
-    }
 
-    // Paper start
-    @Override
-    public void setLoreComponents(List<net.md_5.bungee.api.chat.BaseComponent[]> lore) {
-        if (lore == null) {
-            this.lore = null;
-        } else {
-            if (this.lore == null) {
-                safelyAdd(lore, this.lore = new ArrayList<>(lore.size()), false);
-            } else {
-                this.lore.clear();
-                safelyAdd(lore, this.lore, false);
+        @Override
+        public Multimap<Attribute, AttributeModifier> getAttributeModifiers(@Nullable EquipmentSlot slot) {
+            this.checkAttributeList();
+            SetMultimap<Attribute, AttributeModifier> result = LinkedHashMultimap.create();
+            for (Map.Entry<Attribute, AttributeModifier> entry : this.attributeModifiers.entries()) {
+                if (entry.getValue().getSlot() == null || entry.getValue().getSlot() == slot) {
+                    result.put(entry.getKey(), entry.getValue());
+                }
             }
+            return result;
         }
-    }
-    // Paper end
-    @Override
-    public boolean hasCustomModelData() {
-        return this.customModelData != null;
-    }
-
-    @Override
-    public int getCustomModelData() {
-        Preconditions.checkState(this.hasCustomModelData(), "We don't have CustomModelData! Check hasCustomModelData first!");
-        return this.customModelData;
-    }
-
-    @Override
-    public void setCustomModelData(Integer data) {
-        this.customModelData = data;
-    }
-
-    @Override
-    public boolean hasBlockData() {
-        return this.blockData != null;
-    }
-
-    @Override
-    public BlockData getBlockData(Material material) {
-        BlockState defaultData = CraftBlockType.bukkitToMinecraft(material).defaultBlockState();
-        return CraftBlockData.fromData((this.hasBlockData()) ? new BlockItemStateProperties(this.blockData).apply(defaultData) : defaultData);
-    }
-
-    @Override
-    public void setBlockData(BlockData blockData) {
-        this.blockData = (blockData == null) ? null : ((CraftBlockData) blockData).toStates();
-    }
-
-    @Override
-    public int getRepairCost() {
-        return this.repairCost;
-    }
-
-    @Override
-    public void setRepairCost(int cost) { // TODO: Does this have limits?
-        this.repairCost = cost;
-    }
-
-    @Override
-    public boolean isHideTooltip() {
-        return this.hideTooltip;
-    }
-
-    @Override
-    public void setHideTooltip(boolean hideTooltip) {
-        this.hideTooltip = hideTooltip;
-    }
-
-    @Override
-    public boolean isUnbreakable() {
-        return this.unbreakable;
-    }
-
-    @Override
-    public void setUnbreakable(boolean unbreakable) {
-        this.unbreakable = unbreakable;
-    }
-
-    @Override
-    public boolean hasEnchantmentGlintOverride() {
-        return this.enchantmentGlintOverride != null;
-    }
-
-    @Override
-    public Boolean getEnchantmentGlintOverride() {
-        Preconditions.checkState(this.hasEnchantmentGlintOverride(), "We don't have enchantment_glint_override! Check hasEnchantmentGlintOverride first!");
-        return this.enchantmentGlintOverride;
-    }
-
-    @Override
-    public void setEnchantmentGlintOverride(Boolean override) {
-        this.enchantmentGlintOverride = override;
-    }
 
-    @Override
-    public boolean isFireResistant() {
-        return this.fireResistant;
-    }
+        @Override
+        public Collection<AttributeModifier> getAttributeModifiers(@Nonnull Attribute attribute) {
+            Preconditions.checkNotNull(attribute, "Attribute cannot be null");
+            return this.attributeModifiers.containsKey(attribute) ? ImmutableList.copyOf(this.attributeModifiers.get(attribute)) : null;
+        }
 
-    @Override
-    public void setFireResistant(boolean fireResistant) {
-        this.fireResistant = fireResistant;
-    }
+        @Override
+        public boolean addAttributeModifier(@Nonnull Attribute attribute, @Nonnull AttributeModifier modifier) {
+            Preconditions.checkNotNull(attribute, "Attribute cannot be null");
+            Preconditions.checkNotNull(modifier, "AttributeModifier cannot be null");
+            this.checkAttributeList();
+            for (Map.Entry<Attribute, AttributeModifier> entry : this.attributeModifiers.entries()) {
+                Preconditions.checkArgument(!(entry.getValue().getKey().equals(modifier.getKey()) && entry.getKey() == attribute), "Cannot register AttributeModifier. Modifier is already applied! %s", modifier); // Paper - attribute modifiers with same namespaced key but on different attributes are fine
+            }
+            return this.attributeModifiers.put(attribute, modifier);
+        }
 
-    @Override
-    public boolean hasMaxStackSize() {
-        return this.maxStackSize != null;
-    }
+        @Override
+        public void setAttributeModifiers(@Nullable Multimap<Attribute, AttributeModifier> attributeModifiers) {
+            if (attributeModifiers == null || attributeModifiers.isEmpty()) {
+                this.attributeModifiers = LinkedHashMultimap.create();
+                return;
+            }
 
-    @Override
-    public int getMaxStackSize() {
-        Preconditions.checkState(this.hasMaxStackSize(), "We don't have max_stack_size! Check hasMaxStackSize first!");
-        return this.maxStackSize;
-    }
+            this.checkAttributeList();
+            this.attributeModifiers.clear();
 
-    @Override
-    public void setMaxStackSize(Integer max) {
-        Preconditions.checkArgument(max == null || max > 0, "max_stack_size must be > 0");
-        Preconditions.checkArgument(max == null || max <= net.minecraft.world.item.Item.ABSOLUTE_MAX_STACK_SIZE, "max_stack_size must be <= 99");
-        this.maxStackSize = max;
-    }
+            Iterator<Map.Entry<Attribute, AttributeModifier>> iterator = attributeModifiers.entries().iterator();
+            while (iterator.hasNext()) {
+                Map.Entry<Attribute, AttributeModifier> next = iterator.next();
 
-    @Override
-    public boolean hasRarity() {
-        return this.rarity != null;
-    }
+                if (next.getKey() == null || next.getValue() == null) {
+                    iterator.remove();
+                    continue;
+                }
+                this.attributeModifiers.put(next.getKey(), next.getValue());
+            }
+        }
 
-    @Override
-    public ItemRarity getRarity() {
-        Preconditions.checkState(this.hasRarity(), "We don't have rarity! Check hasRarity first!");
-        return this.rarity;
-    }
+        @Override
+        public boolean removeAttributeModifier(@Nonnull Attribute attribute) {
+            Preconditions.checkNotNull(attribute, "Attribute cannot be null");
+            this.checkAttributeList();
+            return !this.attributeModifiers.removeAll(attribute).isEmpty();
+        }
 
-    @Override
-    public void setRarity(ItemRarity rarity) {
-        this.rarity = rarity;
-    }
+        @Override
+        public boolean removeAttributeModifier(@Nullable EquipmentSlot slot) {
+            this.checkAttributeList();
+            int removed = 0;
+            Iterator<Map.Entry<Attribute, AttributeModifier>> iter = this.attributeModifiers.entries().iterator();
 
-    @Override
-    public boolean hasFood() {
-        return this.food != null;
-    }
+            while (iter.hasNext()) {
+                Map.Entry<Attribute, AttributeModifier> entry = iter.next();
+                // Explicitly match against null because (as of MC 1.13) AttributeModifiers without a -
+                // set slot are active in any slot.
+                if (entry.getValue().getSlot() == null || entry.getValue().getSlot() == slot) {
+                    iter.remove();
+                    ++removed;
+                }
+            }
+            return removed > 0;
+        }
 
-    @Override
-    public FoodComponent getFood() {
-        return (this.hasFood()) ? new CraftFoodComponent(this.food) : new CraftFoodComponent(new FoodProperties(0, 0, false, 0, Optional.empty(), Collections.emptyList()));
-    }
+        @Override
+        public boolean removeAttributeModifier(@Nonnull Attribute attribute, @Nonnull AttributeModifier modifier) {
+            Preconditions.checkNotNull(attribute, "Attribute cannot be null");
+            Preconditions.checkNotNull(modifier, "AttributeModifier cannot be null");
+            this.checkAttributeList();
+            int removed = 0;
+            Iterator<Map.Entry<Attribute, AttributeModifier>> iter = this.attributeModifiers.entries().iterator();
 
-    @Override
-    public void setFood(FoodComponent food) {
-        this.food = (food == null) ? null : new CraftFoodComponent((CraftFoodComponent) food);
-    }
+            while (iter.hasNext()) {
+                Map.Entry<Attribute, AttributeModifier> entry = iter.next();
+                if (entry.getKey() == null || entry.getValue() == null) {
+                    iter.remove();
+                    ++removed;
+                    continue; // remove all null values while we are here
+                }
 
-    @Override
-    public boolean hasTool() {
-        return this.tool != null;
-    }
+                if (entry.getKey() == attribute && entry.getValue().getKey().equals(modifier.getKey())) {
+                    iter.remove();
+                    ++removed;
+                }
+            }
+            return removed > 0;
+        }
 
-    @Override
-    public ToolComponent getTool() {
-        return (this.hasTool()) ? new CraftToolComponent(this.tool) : new CraftToolComponent(new Tool(Collections.emptyList(), 1.0F, 0));
-    }
+        @Override
+        public String getAsString() {
+            CraftMetaItem.Applicator tag = new CraftMetaItem.Applicator();
+            this.applyToItem(tag);
+            DataComponentPatch patch = tag.build();
+            Tag nbt = DataComponentPatch.CODEC.encodeStart(MinecraftServer.getDefaultRegistryAccess().createSerializationContext(NbtOps.INSTANCE), patch).getOrThrow();
+            return nbt.toString();
+        }
 
-    @Override
-    public void setTool(ToolComponent tool) {
-        this.tool = (tool == null) ? null : new CraftToolComponent((CraftToolComponent) tool);
-    }
+        @Override
+        public String getAsComponentString() {
+            CraftMetaItem.Applicator tag = new CraftMetaItem.Applicator();
+            this.applyToItem(tag);
+            DataComponentPatch patch = tag.build();
 
-    @Override
-    public boolean hasJukeboxPlayable() {
-        return this.jukebox != null;
-    }
+            RegistryAccess registryAccess = CraftRegistry.getMinecraftRegistry();
+            DynamicOps<Tag> ops = registryAccess.createSerializationContext(NbtOps.INSTANCE);
+            Registry<DataComponentType<?>> componentTypeRegistry = registryAccess.registryOrThrow(Registries.DATA_COMPONENT_TYPE);
 
-    @Override
-    public JukeboxPlayableComponent getJukeboxPlayable() {
-        return (this.hasJukeboxPlayable()) ? new CraftJukeboxComponent(this.jukebox) : new CraftJukeboxComponent(new JukeboxPlayable(new EitherHolder<>(JukeboxSongs.THIRTEEN), true));
-    }
+            StringJoiner componentString = new StringJoiner(",", "[", "]");
+            for (Entry<DataComponentType<?>, Optional<?>> entry : patch.entrySet()) {
+                DataComponentType<?> componentType = entry.getKey();
+                Optional<?> componentValue = entry.getValue();
+                String componentKey = componentTypeRegistry.getResourceKey(componentType).orElseThrow().location().toString();
 
-    @Override
-    public void setJukeboxPlayable(JukeboxPlayableComponent jukeboxPlayable) {
-        this.jukebox = (jukeboxPlayable == null) ? null : new CraftJukeboxComponent((CraftJukeboxComponent) jukeboxPlayable);
-    }
+                if (componentValue.isPresent()) {
+                    Tag componentValueAsNBT = (Tag) ((DataComponentType) componentType).codecOrThrow().encodeStart(ops, componentValue.get()).getOrThrow();
+                    String componentValueAsNBTString = new SnbtPrinterTagVisitor("", 0, new ArrayList<>()).visit(componentValueAsNBT);
+                    componentString.add(componentKey + "=" + componentValueAsNBTString);
+                } else {
+                    componentString.add("!" + componentKey);
+                }
+            }
 
-    @Override
-    public boolean hasAttributeModifiers() {
-        return this.attributeModifiers != null && !this.attributeModifiers.isEmpty();
-    }
+            return componentString.toString();
+        }
 
-    @Override
-    public Multimap<Attribute, AttributeModifier> getAttributeModifiers() {
-        return this.hasAttributeModifiers() ? ImmutableMultimap.copyOf(this.attributeModifiers) : null;
-    }
+        @Override
+        public CustomItemTagContainer getCustomTagContainer() {
+            return new DeprecatedCustomTagContainer(this.getPersistentDataContainer());
+        }
 
-    private void checkAttributeList() {
-        if (this.attributeModifiers == null) {
-            this.attributeModifiers = LinkedHashMultimap.create();
+        @Override
+        public PersistentDataContainer getPersistentDataContainer() {
+            return this.persistentDataContainer;
         }
-    }
 
-    @Override
-    public Multimap<Attribute, AttributeModifier> getAttributeModifiers(@Nullable EquipmentSlot slot) {
-        this.checkAttributeList();
-        SetMultimap<Attribute, AttributeModifier> result = LinkedHashMultimap.create();
-        for (Map.Entry<Attribute, AttributeModifier> entry : this.attributeModifiers.entries()) {
-            if (entry.getValue().getSlot() == null || entry.getValue().getSlot() == slot) {
-                result.put(entry.getKey(), entry.getValue());
+        private static boolean compareModifiers(Multimap<Attribute, AttributeModifier> first, Multimap<Attribute, AttributeModifier> second) {
+            if (first == null || second == null) {
+                return false;
+            }
+            for (Map.Entry<Attribute, AttributeModifier> entry : first.entries()) {
+                if (!second.containsEntry(entry.getKey(), entry.getValue())) {
+                    return false;
+                }
             }
+            for (Map.Entry<Attribute, AttributeModifier> entry : second.entries()) {
+                if (!first.containsEntry(entry.getKey(), entry.getValue())) {
+                    return false;
+                }
+            }
+            return true;
         }
-        return result;
-    }
-
-    @Override
-    public Collection<AttributeModifier> getAttributeModifiers(@Nonnull Attribute attribute) {
-        Preconditions.checkNotNull(attribute, "Attribute cannot be null");
-        return this.attributeModifiers.containsKey(attribute) ? ImmutableList.copyOf(this.attributeModifiers.get(attribute)) : null;
-    }
 
-    @Override
-    public boolean addAttributeModifier(@Nonnull Attribute attribute, @Nonnull AttributeModifier modifier) {
-        Preconditions.checkNotNull(attribute, "Attribute cannot be null");
-        Preconditions.checkNotNull(modifier, "AttributeModifier cannot be null");
-        this.checkAttributeList();
-        for (Map.Entry<Attribute, AttributeModifier> entry : this.attributeModifiers.entries()) {
-            Preconditions.checkArgument(!(entry.getValue().getKey().equals(modifier.getKey()) && entry.getKey() == attribute), "Cannot register AttributeModifier. Modifier is already applied! %s", modifier); // Paper - attribute modifiers with same namespaced key but on different attributes are fine
+        @Override
+        public boolean hasDamage() {
+            return this.damage > 0;
         }
-        return this.attributeModifiers.put(attribute, modifier);
-    }
 
-    @Override
-    public void setAttributeModifiers(@Nullable Multimap<Attribute, AttributeModifier> attributeModifiers) {
-        if (attributeModifiers == null || attributeModifiers.isEmpty()) {
-            this.attributeModifiers = LinkedHashMultimap.create();
-            return;
+        @Override
+        public int getDamage() {
+            return this.damage;
         }
 
-        this.checkAttributeList();
-        this.attributeModifiers.clear();
-
-        Iterator<Map.Entry<Attribute, AttributeModifier>> iterator = attributeModifiers.entries().iterator();
-        while (iterator.hasNext()) {
-            Map.Entry<Attribute, AttributeModifier> next = iterator.next();
+        @Override
+        public void setDamage(int damage) {
+            this.damage = damage;
+        }
 
-            if (next.getKey() == null || next.getValue() == null) {
-                iterator.remove();
-                continue;
-            }
-            this.attributeModifiers.put(next.getKey(), next.getValue());
+        @Override
+        public boolean hasMaxDamage() {
+            return this.maxDamage != null;
         }
-    }
 
-    @Override
-    public boolean removeAttributeModifier(@Nonnull Attribute attribute) {
-        Preconditions.checkNotNull(attribute, "Attribute cannot be null");
-        this.checkAttributeList();
-        return !this.attributeModifiers.removeAll(attribute).isEmpty();
-    }
+        @Override
+        public int getMaxDamage() {
+            Preconditions.checkState(this.hasMaxDamage(), "We don't have max_damage! Check hasMaxDamage first!");
+            return this.maxDamage;
+        }
 
-    @Override
-    public boolean removeAttributeModifier(@Nullable EquipmentSlot slot) {
-        this.checkAttributeList();
-        int removed = 0;
-        Iterator<Map.Entry<Attribute, AttributeModifier>> iter = this.attributeModifiers.entries().iterator();
+        @Override
+        public void setMaxDamage(Integer maxDamage) {
+            this.maxDamage = maxDamage;
+        }
 
-        while (iter.hasNext()) {
-            Map.Entry<Attribute, AttributeModifier> entry = iter.next();
-            // Explicitly match against null because (as of MC 1.13) AttributeModifiers without a -
-            // set slot are active in any slot.
-            if (entry.getValue().getSlot() == null || entry.getValue().getSlot() == slot) {
-                iter.remove();
-                ++removed;
+        @Override
+        public final boolean equals(Object object) {
+            if (object == null) {
+                return false;
             }
+            if (object == this) {
+                return true;
+            }
+            if (!(object instanceof CraftMetaItem)) {
+                return false;
+            }
+            return CraftItemFactory.instance().equals(this, (ItemMeta) object);
+        }
+
+        /**
+         * This method is almost as weird as notUncommon.
+         * Only return false if your common internals are unequal.
+         * Checking your own internals is redundant if you are not common, as notUncommon is meant for checking those 'not common' variables.
+         */
+        @Overridden
+        boolean equalsCommon(CraftMetaItem that) {
+            return ((this.hasDisplayName() ? that.hasDisplayName() && this.displayName.equals(that.displayName) : !that.hasDisplayName()))
+                    && (this.hasItemName() ? that.hasItemName() && this.itemName.equals(that.itemName) : !that.hasItemName())
+                    && (this.hasEnchants() ? that.hasEnchants() && this.enchantments.equals(that.enchantments) : !that.hasEnchants())
+                    && (Objects.equals(this.lore, that.lore))
+                    && (this.hasCustomModelData() ? that.hasCustomModelData() && this.customModelData.equals(that.customModelData) : !that.hasCustomModelData())
+                    && (this.hasBlockData() ? that.hasBlockData() && this.blockData.equals(that.blockData) : !that.hasBlockData())
+                    && (this.hasRepairCost() ? that.hasRepairCost() && this.repairCost == that.repairCost : !that.hasRepairCost())
+                    && (this.hasAttributeModifiers() ? that.hasAttributeModifiers() && CraftMetaItem.compareModifiers(this.attributeModifiers, that.attributeModifiers) : !that.hasAttributeModifiers())
+                    && (this.unhandledTags.equals(that.unhandledTags))
+                    && (this.removedTags.equals(that.removedTags))
+                    && (Objects.equals(this.customTag, that.customTag))
+                    && (this.persistentDataContainer.equals(that.persistentDataContainer))
+                    && (this.hideFlag == that.hideFlag)
+                    && (this.isHideTooltip() == that.isHideTooltip())
+                    && (this.isUnbreakable() == that.isUnbreakable())
+                    && (this.hasEnchantmentGlintOverride() ? that.hasEnchantmentGlintOverride() && this.enchantmentGlintOverride.equals(that.enchantmentGlintOverride) : !that.hasEnchantmentGlintOverride())
+                    && (this.fireResistant == that.fireResistant)
+                    && (this.hasMaxStackSize() ? that.hasMaxStackSize() && this.maxStackSize.equals(that.maxStackSize) : !that.hasMaxStackSize())
+                    && (this.rarity == that.rarity)
+                    && (this.hasFood() ? that.hasFood() && this.food.equals(that.food) : !that.hasFood())
+                    && (this.hasTool() ? that.hasTool() && this.tool.equals(that.tool) : !that.hasTool())
+                    && (this.hasJukeboxPlayable() ? that.hasJukeboxPlayable() && this.jukebox.equals(that.jukebox) : !that.hasJukeboxPlayable())
+                    && (this.hasDamage() ? that.hasDamage() && this.damage == that.damage : !that.hasDamage())
+                    && (this.hasMaxDamage() ? that.hasMaxDamage() && this.maxDamage.equals(that.maxDamage) : !that.hasMaxDamage())
+                    && (this.canPlaceOnPredicates != null ? that.canPlaceOnPredicates != null && this.canPlaceOnPredicates.equals(that.canPlaceOnPredicates) : that.canPlaceOnPredicates == null) // Paper
+                    && (this.canBreakPredicates != null ? that.canBreakPredicates != null && this.canBreakPredicates.equals(that.canBreakPredicates) : that.canBreakPredicates == null) // Paper
+                    && (this.version == that.version);
+        }
+
+        /**
+         * This method is a bit weird...
+         * Return true if you are a common class OR your uncommon parts are empty.
+         * Empty uncommon parts implies the NBT data would be equivalent if both were applied to an item
+         */
+        @Overridden
+        boolean notUncommon(CraftMetaItem meta) {
+            return true;
         }
-        return removed > 0;
-    }
 
-    @Override
-    public boolean removeAttributeModifier(@Nonnull Attribute attribute, @Nonnull AttributeModifier modifier) {
-        Preconditions.checkNotNull(attribute, "Attribute cannot be null");
-        Preconditions.checkNotNull(modifier, "AttributeModifier cannot be null");
-        this.checkAttributeList();
-        int removed = 0;
-        Iterator<Map.Entry<Attribute, AttributeModifier>> iter = this.attributeModifiers.entries().iterator();
-
-        while (iter.hasNext()) {
-            Map.Entry<Attribute, AttributeModifier> entry = iter.next();
-            if (entry.getKey() == null || entry.getValue() == null) {
-                iter.remove();
-                ++removed;
-                continue; // remove all null values while we are here
+        @Override
+        public final int hashCode() {
+            return this.applyHash();
+        }
+
+        @Overridden
+        int applyHash() {
+            int hash = 3;
+            hash = 61 * hash + (this.hasDisplayName() ? this.displayName.hashCode() : 0);
+            hash = 61 * hash + (this.hasItemName() ? this.itemName.hashCode() : 0);
+            hash = 61 * hash + ((this.lore != null) ? this.lore.hashCode() : 0);
+            hash = 61 * hash + (this.hasCustomModelData() ? this.customModelData.hashCode() : 0);
+            hash = 61 * hash + (this.hasBlockData() ? this.blockData.hashCode() : 0);
+            hash = 61 * hash + (this.hasEnchants() ? this.enchantments.hashCode() : 0);
+            hash = 61 * hash + (this.hasRepairCost() ? this.repairCost : 0);
+            hash = 61 * hash + this.unhandledTags.hashCode();
+            hash = 61 * hash + this.removedTags.hashCode();
+            hash = 61 * hash + ((this.customTag != null) ? this.customTag.hashCode() : 0);
+            hash = 61 * hash + (!this.persistentDataContainer.isEmpty() ? this.persistentDataContainer.hashCode() : 0);
+            hash = 61 * hash + this.hideFlag;
+            hash = 61 * hash + (this.isHideTooltip() ? 1231 : 1237);
+            hash = 61 * hash + (this.isUnbreakable() ? 1231 : 1237);
+            hash = 61 * hash + (this.hasEnchantmentGlintOverride() ? this.enchantmentGlintOverride.hashCode() : 0);
+            hash = 61 * hash + (this.isFireResistant() ? 1231 : 1237);
+            hash = 61 * hash + (this.hasMaxStackSize() ? this.maxStackSize.hashCode() : 0);
+            hash = 61 * hash + (this.hasRarity() ? this.rarity.hashCode() : 0);
+            hash = 61 * hash + (this.hasFood() ? this.food.hashCode() : 0);
+            hash = 61 * hash + (this.hasTool() ? this.tool.hashCode() : 0);
+            hash = 61 * hash + (this.hasJukeboxPlayable() ? this.jukebox.hashCode() : 0);
+            hash = 61 * hash + (this.hasDamage() ? this.damage : 0);
+            hash = 61 * hash + (this.hasMaxDamage() ? 1231 : 1237);
+            hash = 61 * hash + (this.hasAttributeModifiers() ? this.attributeModifiers.hashCode() : 0);
+            hash = 61 * hash + (this.canPlaceOnPredicates != null ? this.canPlaceOnPredicates.hashCode() : 0); // Paper
+            hash = 61 * hash + (this.canBreakPredicates != null ? this.canBreakPredicates.hashCode() : 0); // Paper
+            hash = 61 * hash + this.version;
+            return hash;
+        }
+
+        @Overridden
+        @Override
+        public CraftMetaItem clone() {
+            try {
+                CraftMetaItem clone = (CraftMetaItem) super.clone();
+                if (this.lore != null) {
+                    clone.lore = new ArrayList<Component>(this.lore);
+                }
+                clone.customModelData = this.customModelData;
+                clone.blockData = this.blockData;
+                if (this.enchantments != null) {
+                    clone.enchantments = new EnchantmentMap(this.enchantments); // Paper
+                }
+                if (this.hasAttributeModifiers()) {
+                    clone.attributeModifiers = LinkedHashMultimap.create(this.attributeModifiers);
+                }
+                if (this.customTag != null) {
+                    clone.customTag = this.customTag.copy();
+                }
+                clone.removedTags = Sets.newHashSet(this.removedTags);
+                clone.persistentDataContainer = new CraftPersistentDataContainer(this.persistentDataContainer.getTagsCloned(), CraftMetaItem.DATA_TYPE_REGISTRY); // Paper - deep clone NBT tags
+                clone.hideFlag = this.hideFlag;
+                clone.hideTooltip = this.hideTooltip;
+                clone.unbreakable = this.unbreakable;
+                clone.enchantmentGlintOverride = this.enchantmentGlintOverride;
+                clone.fireResistant = this.fireResistant;
+                clone.maxStackSize = this.maxStackSize;
+                clone.rarity = this.rarity;
+                if (this.hasFood()) {
+                    clone.food = new CraftFoodComponent(this.food);
+                }
+                if (this.hasTool()) {
+                    clone.tool = new CraftToolComponent(this.tool);
+                }
+                if (this.hasJukeboxPlayable()) {
+                    clone.jukebox = new CraftJukeboxComponent(this.jukebox);
+                }
+                clone.damage = this.damage;
+                clone.maxDamage = this.maxDamage;
+                clone.version = this.version;
+                // Paper start
+                if (this.canPlaceOnPredicates != null) {
+                    clone.canPlaceOnPredicates = List.copyOf(this.canPlaceOnPredicates);
+                }
+                if (this.canBreakPredicates != null) {
+                    clone.canBreakPredicates = List.copyOf(this.canBreakPredicates);
+                }
+                // Paper end
+                return clone;
+            } catch (CloneNotSupportedException e) {
+                throw new Error(e);
             }
+        }
 
-            if (entry.getKey() == attribute && entry.getValue().getKey().equals(modifier.getKey())) {
-                iter.remove();
-                ++removed;
-            }
+        @Override
+        public final Map<String, Object> serialize() {
+            ImmutableMap.Builder<String, Object> map = ImmutableMap.builder();
+            map.put(SerializableMeta.TYPE_FIELD, SerializableMeta.classMap.get(this.getClass()));
+            this.serialize(map);
+            return map.build();
         }
-        return removed > 0;
-    }
 
-    @Override
-    public String getAsString() {
-        CraftMetaItem.Applicator tag = new CraftMetaItem.Applicator();
-        this.applyToItem(tag);
-        DataComponentPatch patch = tag.build();
-        Tag nbt = DataComponentPatch.CODEC.encodeStart(MinecraftServer.getDefaultRegistryAccess().createSerializationContext(NbtOps.INSTANCE), patch).getOrThrow();
-        return nbt.toString();
-    }
+        @Overridden
+        ImmutableMap.Builder<String, Object> serialize(ImmutableMap.Builder<String, Object> builder) {
+            if (this.hasDisplayName()) {
+                builder.put(CraftMetaItem.NAME.BUKKIT, CraftChatMessage.toJSON(this.displayName));
+            }
 
-    @Override
-    public String getAsComponentString() {
-        CraftMetaItem.Applicator tag = new CraftMetaItem.Applicator();
-        this.applyToItem(tag);
-        DataComponentPatch patch = tag.build();
-
-        RegistryAccess registryAccess = CraftRegistry.getMinecraftRegistry();
-        DynamicOps<Tag> ops = registryAccess.createSerializationContext(NbtOps.INSTANCE);
-        Registry<DataComponentType<?>> componentTypeRegistry = registryAccess.registryOrThrow(Registries.DATA_COMPONENT_TYPE);
-
-        StringJoiner componentString = new StringJoiner(",", "[", "]");
-        for (Entry<DataComponentType<?>, Optional<?>> entry : patch.entrySet()) {
-            DataComponentType<?> componentType = entry.getKey();
-            Optional<?> componentValue = entry.getValue();
-            String componentKey = componentTypeRegistry.getResourceKey(componentType).orElseThrow().location().toString();
-
-            if (componentValue.isPresent()) {
-                Tag componentValueAsNBT = (Tag) ((DataComponentType) componentType).codecOrThrow().encodeStart(ops, componentValue.get()).getOrThrow();
-                String componentValueAsNBTString = new SnbtPrinterTagVisitor("", 0, new ArrayList<>()).visit(componentValueAsNBT);
-                componentString.add(componentKey + "=" + componentValueAsNBTString);
-            } else {
-                componentString.add("!" + componentKey);
+            if (this.hasItemName()) {
+                builder.put(CraftMetaItem.ITEM_NAME.BUKKIT, CraftChatMessage.toJSON(this.itemName));
             }
-        }
 
-        return componentString.toString();
-    }
+            if (this.hasLore()) {
+                // SPIGOT-7625: Convert lore to json before serializing it
+                List<String> jsonLore = new ArrayList<>();
 
-    @Override
-    public CustomItemTagContainer getCustomTagContainer() {
-        return new DeprecatedCustomTagContainer(this.getPersistentDataContainer());
-    }
+                for (Component component : this.lore) {
+                    jsonLore.add(CraftChatMessage.toJSON(component));
+                }
 
-    @Override
-    public PersistentDataContainer getPersistentDataContainer() {
-        return this.persistentDataContainer;
-    }
+                builder.put(CraftMetaItem.LORE.BUKKIT, jsonLore);
+            }
 
-    private static boolean compareModifiers(Multimap<Attribute, AttributeModifier> first, Multimap<Attribute, AttributeModifier> second) {
-        if (first == null || second == null) {
-            return false;
-        }
-        for (Map.Entry<Attribute, AttributeModifier> entry : first.entries()) {
-            if (!second.containsEntry(entry.getKey(), entry.getValue())) {
-                return false;
+            if (this.hasCustomModelData()) {
+                builder.put(CraftMetaItem.CUSTOM_MODEL_DATA.BUKKIT, this.customModelData);
             }
-        }
-        for (Map.Entry<Attribute, AttributeModifier> entry : second.entries()) {
-            if (!first.containsEntry(entry.getKey(), entry.getValue())) {
-                return false;
+            if (this.hasBlockData()) {
+                builder.put(CraftMetaItem.BLOCK_DATA.BUKKIT, this.blockData);
             }
-        }
-        return true;
-    }
 
-    @Override
-    public boolean hasDamage() {
-        return this.damage > 0;
-    }
+            CraftMetaItem.serializeEnchantments(this.enchantments, builder, CraftMetaItem.ENCHANTMENTS);
+            CraftMetaItem.serializeModifiers(this.attributeModifiers, builder, CraftMetaItem.ATTRIBUTES);
 
-    @Override
-    public int getDamage() {
-        return this.damage;
-    }
+            if (this.hasRepairCost()) {
+                builder.put(CraftMetaItem.REPAIR.BUKKIT, this.repairCost);
+            }
 
-    @Override
-    public void setDamage(int damage) {
-        this.damage = damage;
-    }
+            List<String> hideFlags = new ArrayList<String>();
+            for (ItemFlag hideFlagEnum : this.getItemFlags()) {
+                hideFlags.add(CraftItemFlag.bukkitToString(hideFlagEnum));
+            }
+            if (!hideFlags.isEmpty()) {
+                builder.put(CraftMetaItem.HIDEFLAGS.BUKKIT, hideFlags);
+            }
 
-    @Override
-    public boolean hasMaxDamage() {
-        return this.maxDamage != null;
-    }
+            if (this.isHideTooltip()) {
+                builder.put(CraftMetaItem.HIDE_TOOLTIP.BUKKIT, this.hideTooltip);
+            }
 
-    @Override
-    public int getMaxDamage() {
-        Preconditions.checkState(this.hasMaxDamage(), "We don't have max_damage! Check hasMaxDamage first!");
-        return this.maxDamage;
-    }
+            if (this.isUnbreakable()) {
+                builder.put(CraftMetaItem.UNBREAKABLE.BUKKIT, this.unbreakable);
+            }
 
-    @Override
-    public void setMaxDamage(Integer maxDamage) {
-        this.maxDamage = maxDamage;
-    }
+            if (this.hasEnchantmentGlintOverride()) {
+                builder.put(CraftMetaItem.ENCHANTMENT_GLINT_OVERRIDE.BUKKIT, this.enchantmentGlintOverride);
+            }
 
-    @Override
-    public final boolean equals(Object object) {
-        if (object == null) {
-            return false;
-        }
-        if (object == this) {
-            return true;
-        }
-        if (!(object instanceof CraftMetaItem)) {
-            return false;
-        }
-        return CraftItemFactory.instance().equals(this, (ItemMeta) object);
-    }
+            if (this.isFireResistant()) {
+                builder.put(CraftMetaItem.FIRE_RESISTANT.BUKKIT, this.fireResistant);
+            }
 
-    /**
-     * This method is almost as weird as notUncommon.
-     * Only return false if your common internals are unequal.
-     * Checking your own internals is redundant if you are not common, as notUncommon is meant for checking those 'not common' variables.
-     */
-    @Overridden
-    boolean equalsCommon(CraftMetaItem that) {
-        return ((this.hasDisplayName() ? that.hasDisplayName() && this.displayName.equals(that.displayName) : !that.hasDisplayName()))
-                && (this.hasItemName() ? that.hasItemName() && this.itemName.equals(that.itemName) : !that.hasItemName())
-                && (this.hasEnchants() ? that.hasEnchants() && this.enchantments.equals(that.enchantments) : !that.hasEnchants())
-                && (Objects.equals(this.lore, that.lore))
-                && (this.hasCustomModelData() ? that.hasCustomModelData() && this.customModelData.equals(that.customModelData) : !that.hasCustomModelData())
-                && (this.hasBlockData() ? that.hasBlockData() && this.blockData.equals(that.blockData) : !that.hasBlockData())
-                && (this.hasRepairCost() ? that.hasRepairCost() && this.repairCost == that.repairCost : !that.hasRepairCost())
-                && (this.hasAttributeModifiers() ? that.hasAttributeModifiers() && CraftMetaItem.compareModifiers(this.attributeModifiers, that.attributeModifiers) : !that.hasAttributeModifiers())
-                && (this.unhandledTags.equals(that.unhandledTags))
-                && (this.removedTags.equals(that.removedTags))
-                && (Objects.equals(this.customTag, that.customTag))
-                && (this.persistentDataContainer.equals(that.persistentDataContainer))
-                && (this.hideFlag == that.hideFlag)
-                && (this.isHideTooltip() == that.isHideTooltip())
-                && (this.isUnbreakable() == that.isUnbreakable())
-                && (this.hasEnchantmentGlintOverride() ? that.hasEnchantmentGlintOverride() && this.enchantmentGlintOverride.equals(that.enchantmentGlintOverride) : !that.hasEnchantmentGlintOverride())
-                && (this.fireResistant == that.fireResistant)
-                && (this.hasMaxStackSize() ? that.hasMaxStackSize() && this.maxStackSize.equals(that.maxStackSize) : !that.hasMaxStackSize())
-                && (this.rarity == that.rarity)
-                && (this.hasFood() ? that.hasFood() && this.food.equals(that.food) : !that.hasFood())
-                && (this.hasTool() ? that.hasTool() && this.tool.equals(that.tool) : !that.hasTool())
-                && (this.hasJukeboxPlayable() ? that.hasJukeboxPlayable() && this.jukebox.equals(that.jukebox) : !that.hasJukeboxPlayable())
-                && (this.hasDamage() ? that.hasDamage() && this.damage == that.damage : !that.hasDamage())
-                && (this.hasMaxDamage() ? that.hasMaxDamage() && this.maxDamage.equals(that.maxDamage) : !that.hasMaxDamage())
-                && (this.canPlaceOnPredicates != null ? that.canPlaceOnPredicates != null && this.canPlaceOnPredicates.equals(that.canPlaceOnPredicates) : that.canPlaceOnPredicates == null) // Paper
-                && (this.canBreakPredicates != null ? that.canBreakPredicates != null && this.canBreakPredicates.equals(that.canBreakPredicates) : that.canBreakPredicates == null) // Paper
-                && (this.version == that.version);
-    }
+            if (this.hasMaxStackSize()) {
+                builder.put(CraftMetaItem.MAX_STACK_SIZE.BUKKIT, this.maxStackSize);
+            }
 
-    /**
-     * This method is a bit weird...
-     * Return true if you are a common class OR your uncommon parts are empty.
-     * Empty uncommon parts implies the NBT data would be equivalent if both were applied to an item
-     */
-    @Overridden
-    boolean notUncommon(CraftMetaItem meta) {
-        return true;
-    }
+            if (this.hasRarity()) {
+                builder.put(CraftMetaItem.RARITY.BUKKIT, this.rarity.name());
+            }
 
-    @Override
-    public final int hashCode() {
-        return this.applyHash();
-    }
+            if (this.hasFood()) {
+                builder.put(CraftMetaItem.FOOD.BUKKIT, this.food);
+            }
 
-    @Overridden
-    int applyHash() {
-        int hash = 3;
-        hash = 61 * hash + (this.hasDisplayName() ? this.displayName.hashCode() : 0);
-        hash = 61 * hash + (this.hasItemName() ? this.itemName.hashCode() : 0);
-        hash = 61 * hash + ((this.lore != null) ? this.lore.hashCode() : 0);
-        hash = 61 * hash + (this.hasCustomModelData() ? this.customModelData.hashCode() : 0);
-        hash = 61 * hash + (this.hasBlockData() ? this.blockData.hashCode() : 0);
-        hash = 61 * hash + (this.hasEnchants() ? this.enchantments.hashCode() : 0);
-        hash = 61 * hash + (this.hasRepairCost() ? this.repairCost : 0);
-        hash = 61 * hash + this.unhandledTags.hashCode();
-        hash = 61 * hash + this.removedTags.hashCode();
-        hash = 61 * hash + ((this.customTag != null) ? this.customTag.hashCode() : 0);
-        hash = 61 * hash + (!this.persistentDataContainer.isEmpty() ? this.persistentDataContainer.hashCode() : 0);
-        hash = 61 * hash + this.hideFlag;
-        hash = 61 * hash + (this.isHideTooltip() ? 1231 : 1237);
-        hash = 61 * hash + (this.isUnbreakable() ? 1231 : 1237);
-        hash = 61 * hash + (this.hasEnchantmentGlintOverride() ? this.enchantmentGlintOverride.hashCode() : 0);
-        hash = 61 * hash + (this.isFireResistant() ? 1231 : 1237);
-        hash = 61 * hash + (this.hasMaxStackSize() ? this.maxStackSize.hashCode() : 0);
-        hash = 61 * hash + (this.hasRarity() ? this.rarity.hashCode() : 0);
-        hash = 61 * hash + (this.hasFood() ? this.food.hashCode() : 0);
-        hash = 61 * hash + (this.hasTool() ? this.tool.hashCode() : 0);
-        hash = 61 * hash + (this.hasJukeboxPlayable() ? this.jukebox.hashCode() : 0);
-        hash = 61 * hash + (this.hasDamage() ? this.damage : 0);
-        hash = 61 * hash + (this.hasMaxDamage() ? 1231 : 1237);
-        hash = 61 * hash + (this.hasAttributeModifiers() ? this.attributeModifiers.hashCode() : 0);
-        hash = 61 * hash + (this.canPlaceOnPredicates != null ? this.canPlaceOnPredicates.hashCode() : 0); // Paper
-        hash = 61 * hash + (this.canBreakPredicates != null ? this.canBreakPredicates.hashCode() : 0); // Paper
-        hash = 61 * hash + this.version;
-        return hash;
-    }
+            if (this.hasTool()) {
+                builder.put(CraftMetaItem.TOOL.BUKKIT, this.tool);
+            }
 
-    @Overridden
-    @Override
-    public CraftMetaItem clone() {
-        try {
-            CraftMetaItem clone = (CraftMetaItem) super.clone();
-            if (this.lore != null) {
-                clone.lore = new ArrayList<Component>(this.lore);
+            if (this.hasJukeboxPlayable()) {
+                builder.put(CraftMetaItem.JUKEBOX_PLAYABLE.BUKKIT, this.jukebox);
             }
-            clone.customModelData = this.customModelData;
-            clone.blockData = this.blockData;
-            if (this.enchantments != null) {
-                clone.enchantments = new EnchantmentMap(this.enchantments); // Paper
+
+            if (this.hasDamage()) {
+                builder.put(CraftMetaItem.DAMAGE.BUKKIT, this.damage);
             }
-            if (this.hasAttributeModifiers()) {
-                clone.attributeModifiers = LinkedHashMultimap.create(this.attributeModifiers);
+
+            if (this.hasMaxDamage()) {
+                builder.put(CraftMetaItem.MAX_DAMAGE.BUKKIT, this.maxDamage);
             }
-            if (this.customTag != null) {
-                clone.customTag = this.customTag.copy();
-            }
-            clone.removedTags = Sets.newHashSet(this.removedTags);
-            clone.persistentDataContainer = new CraftPersistentDataContainer(this.persistentDataContainer.getTagsCloned(), CraftMetaItem.DATA_TYPE_REGISTRY); // Paper - deep clone NBT tags
-            clone.hideFlag = this.hideFlag;
-            clone.hideTooltip = this.hideTooltip;
-            clone.unbreakable = this.unbreakable;
-            clone.enchantmentGlintOverride = this.enchantmentGlintOverride;
-            clone.fireResistant = this.fireResistant;
-            clone.maxStackSize = this.maxStackSize;
-            clone.rarity = this.rarity;
-            if (this.hasFood()) {
-                clone.food = new CraftFoodComponent(this.food);
+
+            final Map<String, Tag> internalTags = new HashMap<String, Tag>();
+            this.serializeInternal(internalTags);
+            if (!internalTags.isEmpty()) {
+                CompoundTag internal = new CompoundTag();
+                for (Map.Entry<String, Tag> e : internalTags.entrySet()) {
+                    internal.put(e.getKey(), e.getValue());
+                }
+                try {
+                    ByteArrayOutputStream buf = new ByteArrayOutputStream();
+                    NbtIo.writeCompressed(internal, buf);
+                    builder.put("internal", Base64.getEncoder().encodeToString(buf.toByteArray()));
+                } catch (IOException ex) {
+                    Logger.getLogger(CraftMetaItem.class.getName()).log(Level.SEVERE, null, ex);
+                }
             }
-            if (this.hasTool()) {
-                clone.tool = new CraftToolComponent(this.tool);
+
+            // Paper start
+            final boolean canBreakAddToUnhandled = this.canBreakPredicates != null && !this.canBreakPredicates.isEmpty();
+            if (canBreakAddToUnhandled) {
+                this.unhandledTags.set(DataComponents.CAN_BREAK, new net.minecraft.world.item.AdventureModePredicate(this.canBreakPredicates, !this.hasItemFlag(ItemFlag.HIDE_DESTROYS)));
             }
-            if (this.hasJukeboxPlayable()) {
-                clone.jukebox = new CraftJukeboxComponent(this.jukebox);
+            final boolean canPlaceOnAddToUnhandled = this.canPlaceOnPredicates != null && !this.canPlaceOnPredicates.isEmpty();
+            if (canPlaceOnAddToUnhandled) {
+                this.unhandledTags.set(DataComponents.CAN_PLACE_ON, new net.minecraft.world.item.AdventureModePredicate(this.canPlaceOnPredicates, !this.hasItemFlag(ItemFlag.HIDE_PLACED_ON)));
+            }
+            // Paper end
+            if (!this.unhandledTags.isEmpty()) {
+                Tag unhandled = DataComponentPatch.CODEC.encodeStart(MinecraftServer.getDefaultRegistryAccess().createSerializationContext(NbtOps.INSTANCE), this.unhandledTags.build()).getOrThrow(IllegalStateException::new);
+                try {
+                    ByteArrayOutputStream buf = new ByteArrayOutputStream();
+                    NbtIo.writeCompressed((CompoundTag) unhandled, buf);
+                    builder.put("unhandled", Base64.getEncoder().encodeToString(buf.toByteArray()));
+                } catch (IOException ex) {
+                    Logger.getLogger(CraftMetaItem.class.getName()).log(Level.SEVERE, null, ex);
+                }
             }
-            clone.damage = this.damage;
-            clone.maxDamage = this.maxDamage;
-            clone.version = this.version;
             // Paper start
-            if (this.canPlaceOnPredicates != null) {
-                clone.canPlaceOnPredicates = List.copyOf(this.canPlaceOnPredicates);
+            if (canBreakAddToUnhandled) {
+                this.unhandledTags.clear(DataComponents.CAN_BREAK);
             }
-            if (this.canBreakPredicates != null) {
-                clone.canBreakPredicates = List.copyOf(this.canBreakPredicates);
+            if (canPlaceOnAddToUnhandled) {
+                this.unhandledTags.clear(DataComponents.CAN_PLACE_ON);
             }
             // Paper end
-            return clone;
-        } catch (CloneNotSupportedException e) {
-            throw new Error(e);
-        }
-    }
 
-    @Override
-    public final Map<String, Object> serialize() {
-        ImmutableMap.Builder<String, Object> map = ImmutableMap.builder();
-        map.put(SerializableMeta.TYPE_FIELD, SerializableMeta.classMap.get(this.getClass()));
-        this.serialize(map);
-        return map.build();
-    }
+            if (!this.removedTags.isEmpty()) {
+                RegistryAccess registryAccess = CraftRegistry.getMinecraftRegistry();
+                Registry<DataComponentType<?>> componentTypeRegistry = registryAccess.registryOrThrow(Registries.DATA_COMPONENT_TYPE);
 
-    @Overridden
-    ImmutableMap.Builder<String, Object> serialize(ImmutableMap.Builder<String, Object> builder) {
-        if (this.hasDisplayName()) {
-            builder.put(CraftMetaItem.NAME.BUKKIT, CraftChatMessage.toJSON(this.displayName));
-        }
+                List<String> removedTags = new ArrayList<>();
+                for (DataComponentType<?> removed : this.removedTags) {
+                    String componentKey = componentTypeRegistry.getResourceKey(removed).orElseThrow().location().toString();
 
-        if (this.hasItemName()) {
-            builder.put(CraftMetaItem.ITEM_NAME.BUKKIT, CraftChatMessage.toJSON(this.itemName));
-        }
-
-        if (this.hasLore()) {
-            // SPIGOT-7625: Convert lore to json before serializing it
-            List<String> jsonLore = new ArrayList<>();
+                    removedTags.add(componentKey);
+                }
 
-            for (Component component : this.lore) {
-                jsonLore.add(CraftChatMessage.toJSON(component));
+                builder.put("removed", removedTags);
             }
 
-            builder.put(CraftMetaItem.LORE.BUKKIT, jsonLore);
-        }
-
-        if (this.hasCustomModelData()) {
-            builder.put(CraftMetaItem.CUSTOM_MODEL_DATA.BUKKIT, this.customModelData);
-        }
-        if (this.hasBlockData()) {
-            builder.put(CraftMetaItem.BLOCK_DATA.BUKKIT, this.blockData);
-        }
-
-        CraftMetaItem.serializeEnchantments(this.enchantments, builder, CraftMetaItem.ENCHANTMENTS);
-        CraftMetaItem.serializeModifiers(this.attributeModifiers, builder, CraftMetaItem.ATTRIBUTES);
-
-        if (this.hasRepairCost()) {
-            builder.put(CraftMetaItem.REPAIR.BUKKIT, this.repairCost);
-        }
-
-        List<String> hideFlags = new ArrayList<String>();
-        for (ItemFlag hideFlagEnum : this.getItemFlags()) {
-            hideFlags.add(CraftItemFlag.bukkitToString(hideFlagEnum));
-        }
-        if (!hideFlags.isEmpty()) {
-            builder.put(CraftMetaItem.HIDEFLAGS.BUKKIT, hideFlags);
-        }
-
-        if (this.isHideTooltip()) {
-            builder.put(CraftMetaItem.HIDE_TOOLTIP.BUKKIT, this.hideTooltip);
-        }
-
-        if (this.isUnbreakable()) {
-            builder.put(CraftMetaItem.UNBREAKABLE.BUKKIT, this.unbreakable);
-        }
-
-        if (this.hasEnchantmentGlintOverride()) {
-            builder.put(CraftMetaItem.ENCHANTMENT_GLINT_OVERRIDE.BUKKIT, this.enchantmentGlintOverride);
-        }
-
-        if (this.isFireResistant()) {
-            builder.put(CraftMetaItem.FIRE_RESISTANT.BUKKIT, this.fireResistant);
-        }
-
-        if (this.hasMaxStackSize()) {
-            builder.put(CraftMetaItem.MAX_STACK_SIZE.BUKKIT, this.maxStackSize);
-        }
+            if (!this.persistentDataContainer.isEmpty()) { // Store custom tags, wrapped in their compound
+                builder.put(CraftMetaItem.BUKKIT_CUSTOM_TAG.BUKKIT, this.persistentDataContainer.serialize());
+            }
 
-        if (this.hasRarity()) {
-            builder.put(CraftMetaItem.RARITY.BUKKIT, this.rarity.name());
-        }
+            if (this.customTag != null) {
+                try {
+                    ByteArrayOutputStream buf = new ByteArrayOutputStream();
+                    NbtIo.writeCompressed(this.customTag, buf);
+                    builder.put("custom", Base64.getEncoder().encodeToString(buf.toByteArray()));
+                } catch (IOException ex) {
+                    Logger.getLogger(CraftMetaItem.class.getName()).log(Level.SEVERE, null, ex);
+                }
+            }
 
-        if (this.hasFood()) {
-            builder.put(CraftMetaItem.FOOD.BUKKIT, this.food);
+            return builder;
         }
 
-        if (this.hasTool()) {
-            builder.put(CraftMetaItem.TOOL.BUKKIT, this.tool);
+        void serializeInternal(final Map<String, Tag> unhandledTags) {
         }
 
-        if (this.hasJukeboxPlayable()) {
-            builder.put(CraftMetaItem.JUKEBOX_PLAYABLE.BUKKIT, this.jukebox);
-        }
+        static void serializeEnchantments(Map<Enchantment, Integer> enchantments, ImmutableMap.Builder<String, Object> builder, ItemMetaKey key) {
+            if (enchantments == null || enchantments.isEmpty()) {
+                return;
+            }
 
-        if (this.hasDamage()) {
-            builder.put(CraftMetaItem.DAMAGE.BUKKIT, this.damage);
-        }
+            ImmutableMap.Builder<String, Integer> enchants = ImmutableMap.builder();
+            for (Map.Entry<? extends Enchantment, Integer> enchant : enchantments.entrySet()) {
+                enchants.put(CraftEnchantment.bukkitToString(enchant.getKey()), enchant.getValue());
+            }
 
-        if (this.hasMaxDamage()) {
-            builder.put(CraftMetaItem.MAX_DAMAGE.BUKKIT, this.maxDamage);
+            builder.put(key.BUKKIT, enchants.build());
         }
 
-        final Map<String, Tag> internalTags = new HashMap<String, Tag>();
-        this.serializeInternal(internalTags);
-        if (!internalTags.isEmpty()) {
-            CompoundTag internal = new CompoundTag();
-            for (Map.Entry<String, Tag> e : internalTags.entrySet()) {
-                internal.put(e.getKey(), e.getValue());
-            }
-            try {
-                ByteArrayOutputStream buf = new ByteArrayOutputStream();
-                NbtIo.writeCompressed(internal, buf);
-                builder.put("internal", Base64.getEncoder().encodeToString(buf.toByteArray()));
-            } catch (IOException ex) {
-                Logger.getLogger(CraftMetaItem.class.getName()).log(Level.SEVERE, null, ex);
+        static void serializeModifiers(Multimap<Attribute, AttributeModifier> modifiers, ImmutableMap.Builder<String, Object> builder, ItemMetaKey key) {
+            if (modifiers == null || modifiers.isEmpty()) {
+                return;
             }
-        }
 
-        // Paper start
-        final boolean canBreakAddToUnhandled = this.canBreakPredicates != null && !this.canBreakPredicates.isEmpty();
-        if (canBreakAddToUnhandled) {
-            this.unhandledTags.set(DataComponents.CAN_BREAK, new net.minecraft.world.item.AdventureModePredicate(this.canBreakPredicates, !this.hasItemFlag(ItemFlag.HIDE_DESTROYS)));
-        }
-        final boolean canPlaceOnAddToUnhandled = this.canPlaceOnPredicates != null && !this.canPlaceOnPredicates.isEmpty();
-        if (canPlaceOnAddToUnhandled) {
-            this.unhandledTags.set(DataComponents.CAN_PLACE_ON, new net.minecraft.world.item.AdventureModePredicate(this.canPlaceOnPredicates, !this.hasItemFlag(ItemFlag.HIDE_PLACED_ON)));
-        }
-        // Paper end
-        if (!this.unhandledTags.isEmpty()) {
-            Tag unhandled = DataComponentPatch.CODEC.encodeStart(MinecraftServer.getDefaultRegistryAccess().createSerializationContext(NbtOps.INSTANCE), this.unhandledTags.build()).getOrThrow(IllegalStateException::new);
-            try {
-                ByteArrayOutputStream buf = new ByteArrayOutputStream();
-                NbtIo.writeCompressed((CompoundTag) unhandled, buf);
-                builder.put("unhandled", Base64.getEncoder().encodeToString(buf.toByteArray()));
-            } catch (IOException ex) {
-                Logger.getLogger(CraftMetaItem.class.getName()).log(Level.SEVERE, null, ex);
+            Map<String, List<Object>> mods = new LinkedHashMap<>();
+            for (Map.Entry<Attribute, AttributeModifier> entry : modifiers.entries()) {
+                if (entry.getKey() == null) {
+                    continue;
+                }
+                Collection<AttributeModifier> modCollection = modifiers.get(entry.getKey());
+                if (modCollection == null || modCollection.isEmpty()) {
+                    continue;
+                }
+                mods.put(CraftAttribute.bukkitToString(entry.getKey()), new ArrayList<>(modCollection));
             }
+            builder.put(key.BUKKIT, mods);
         }
-        // Paper start
-        if (canBreakAddToUnhandled) {
-            this.unhandledTags.clear(DataComponents.CAN_BREAK);
-        }
-        if (canPlaceOnAddToUnhandled) {
-            this.unhandledTags.clear(DataComponents.CAN_PLACE_ON);
-        }
-        // Paper end
-
-        if (!this.removedTags.isEmpty()) {
-            RegistryAccess registryAccess = CraftRegistry.getMinecraftRegistry();
-            Registry<DataComponentType<?>> componentTypeRegistry = registryAccess.registryOrThrow(Registries.DATA_COMPONENT_TYPE);
-
-            List<String> removedTags = new ArrayList<>();
-            for (DataComponentType<?> removed : this.removedTags) {
-                String componentKey = componentTypeRegistry.getResourceKey(removed).orElseThrow().location().toString();
 
-                removedTags.add(componentKey);
+        static void safelyAdd(Iterable<?> addFrom, Collection<Component> addTo, boolean possiblyJsonInput) {
+            if (addFrom == null) {
+                return;
             }
 
-            builder.put("removed", removedTags);
-        }
+            for (Object object : addFrom) {
+                // Paper start - support components
+                if(object instanceof net.md_5.bungee.api.chat.BaseComponent[] baseComponentArr) {
+                    addTo.add(CraftChatMessage.fromJSON(net.md_5.bungee.chat.ComponentSerializer.toString(baseComponentArr)));
+                } else
+                // Paper end
+                if (!(object instanceof String)) {
+                    if (object != null) {
+                        // SPIGOT-7399: Null check via if is important,
+                        // otherwise object.getClass().getName() could throw an error for a valid argument -> when it is null which is valid,
+                        // when using Preconditions
+                        throw new IllegalArgumentException(addFrom + " cannot contain non-string " + object.getClass().getName());
+                    }
 
-        if (!this.persistentDataContainer.isEmpty()) { // Store custom tags, wrapped in their compound
-            builder.put(CraftMetaItem.BUKKIT_CUSTOM_TAG.BUKKIT, this.persistentDataContainer.serialize());
-        }
+                    addTo.add(Component.empty());
+                } else {
+                    String entry = object.toString();
+                    Component component = (possiblyJsonInput) ? CraftChatMessage.fromJSONOrString(entry) : CraftChatMessage.fromStringOrNull(entry);
 
-        if (this.customTag != null) {
-            try {
-                ByteArrayOutputStream buf = new ByteArrayOutputStream();
-                NbtIo.writeCompressed(this.customTag, buf);
-                builder.put("custom", Base64.getEncoder().encodeToString(buf.toByteArray()));
-            } catch (IOException ex) {
-                Logger.getLogger(CraftMetaItem.class.getName()).log(Level.SEVERE, null, ex);
+                    if (component != null) {
+                        addTo.add(component);
+                    } else {
+                        addTo.add(Component.empty());
+                    }
+                }
             }
         }
 
-        return builder;
-    }
-
-    void serializeInternal(final Map<String, Tag> unhandledTags) {
-    }
-
-    static void serializeEnchantments(Map<Enchantment, Integer> enchantments, ImmutableMap.Builder<String, Object> builder, ItemMetaKey key) {
-        if (enchantments == null || enchantments.isEmpty()) {
-            return;
-        }
-
-        ImmutableMap.Builder<String, Integer> enchants = ImmutableMap.builder();
-        for (Map.Entry<? extends Enchantment, Integer> enchant : enchantments.entrySet()) {
-            enchants.put(CraftEnchantment.bukkitToString(enchant.getKey()), enchant.getValue());
-        }
-
-        builder.put(key.BUKKIT, enchants.build());
-    }
-
-    static void serializeModifiers(Multimap<Attribute, AttributeModifier> modifiers, ImmutableMap.Builder<String, Object> builder, ItemMetaKey key) {
-        if (modifiers == null || modifiers.isEmpty()) {
-            return;
-        }
-
-        Map<String, List<Object>> mods = new LinkedHashMap<>();
-        for (Map.Entry<Attribute, AttributeModifier> entry : modifiers.entries()) {
-            if (entry.getKey() == null) {
-                continue;
-            }
-            Collection<AttributeModifier> modCollection = modifiers.get(entry.getKey());
-            if (modCollection == null || modCollection.isEmpty()) {
-                continue;
+        static boolean checkConflictingEnchants(Map<Enchantment, Integer> enchantments, Enchantment ench) {
+            if (enchantments == null || enchantments.isEmpty()) {
+                return false;
             }
-            mods.put(CraftAttribute.bukkitToString(entry.getKey()), new ArrayList<>(modCollection));
-        }
-        builder.put(key.BUKKIT, mods);
-    }
 
-    static void safelyAdd(Iterable<?> addFrom, Collection<Component> addTo, boolean possiblyJsonInput) {
-        if (addFrom == null) {
-            return;
-        }
-
-        for (Object object : addFrom) {
-            // Paper start - support components
-            if(object instanceof net.md_5.bungee.api.chat.BaseComponent[] baseComponentArr) {
-                addTo.add(CraftChatMessage.fromJSON(net.md_5.bungee.chat.ComponentSerializer.toString(baseComponentArr)));
-            } else
-            // Paper end
-            if (!(object instanceof String)) {
-                if (object != null) {
-                    // SPIGOT-7399: Null check via if is important,
-                    // otherwise object.getClass().getName() could throw an error for a valid argument -> when it is null which is valid,
-                    // when using Preconditions
-                    throw new IllegalArgumentException(addFrom + " cannot contain non-string " + object.getClass().getName());
-                }
-
-                addTo.add(Component.empty());
-            } else {
-                String entry = object.toString();
-                Component component = (possiblyJsonInput) ? CraftChatMessage.fromJSONOrString(entry) : CraftChatMessage.fromStringOrNull(entry);
-
-                if (component != null) {
-                    addTo.add(component);
-                } else {
-                    addTo.add(Component.empty());
+            for (Enchantment enchant : enchantments.keySet()) {
+                if (enchant.conflictsWith(ench)) {
+                    return true;
                 }
             }
-        }
-    }
 
-    static boolean checkConflictingEnchants(Map<Enchantment, Integer> enchantments, Enchantment ench) {
-        if (enchantments == null || enchantments.isEmpty()) {
             return false;
         }
 
-        for (Enchantment enchant : enchantments.keySet()) {
-            if (enchant.conflictsWith(ench)) {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    @Override
-    public final String toString() {
-        return SerializableMeta.classMap.get(this.getClass()) + "_META:" + this.serialize(); // TODO: cry
-    }
-
-    public int getVersion() {
-        return this.version;
-    }
-
-    @Override
-    public void setVersion(int version) {
-        this.version = version;
-    }
-
-    public static Set<DataComponentType> getHandledTags() {
-        synchronized (CraftMetaItem.HANDLED_TAGS) {
-            if (CraftMetaItem.HANDLED_TAGS.isEmpty()) {
-                CraftMetaItem.HANDLED_TAGS.addAll(Arrays.asList(
-                        CraftMetaItem.NAME.TYPE,
-                        CraftMetaItem.ITEM_NAME.TYPE,
-                        CraftMetaItem.LORE.TYPE,
-                        CraftMetaItem.CUSTOM_MODEL_DATA.TYPE,
-                        CraftMetaItem.BLOCK_DATA.TYPE,
-                        CraftMetaItem.REPAIR.TYPE,
-                        CraftMetaItem.ENCHANTMENTS.TYPE,
-                        CraftMetaItem.HIDE_ADDITIONAL_TOOLTIP.TYPE,
-                        CraftMetaItem.HIDE_TOOLTIP.TYPE,
-                        CraftMetaItem.UNBREAKABLE.TYPE,
-                        CraftMetaItem.ENCHANTMENT_GLINT_OVERRIDE.TYPE,
-                        CraftMetaItem.FIRE_RESISTANT.TYPE,
-                        CraftMetaItem.MAX_STACK_SIZE.TYPE,
-                        CraftMetaItem.RARITY.TYPE,
-                        CraftMetaItem.FOOD.TYPE,
-                        CraftMetaItem.TOOL.TYPE,
-                        CraftMetaItem.JUKEBOX_PLAYABLE.TYPE,
-                        CraftMetaItem.DAMAGE.TYPE,
-                        CraftMetaItem.MAX_DAMAGE.TYPE,
-                        CraftMetaItem.CUSTOM_DATA.TYPE,
-                        CraftMetaItem.ATTRIBUTES.TYPE,
-                        CraftMetaItem.CAN_PLACE_ON.TYPE, // Paper
-                        CraftMetaItem.CAN_BREAK.TYPE, // Paper
-                        CraftMetaArmor.TRIM.TYPE,
-                        CraftMetaArmorStand.ENTITY_TAG.TYPE,
-                        CraftMetaBanner.PATTERNS.TYPE,
-                        CraftMetaEntityTag.ENTITY_TAG.TYPE,
-                        CraftMetaLeatherArmor.COLOR.TYPE,
-                        CraftMetaMap.MAP_POST_PROCESSING.TYPE,
-                        CraftMetaMap.MAP_COLOR.TYPE,
-                        CraftMetaMap.MAP_ID.TYPE,
-                        CraftMetaPotion.POTION_CONTENTS.TYPE,
-                        CraftMetaSkull.SKULL_PROFILE.TYPE,
-                        CraftMetaSkull.NOTE_BLOCK_SOUND.TYPE,
-                        CraftMetaSpawnEgg.ENTITY_TAG.TYPE,
-                        CraftMetaBlockState.BLOCK_ENTITY_TAG.TYPE,
-                        CraftMetaBook.BOOK_CONTENT.TYPE,
-                        CraftMetaBookSigned.BOOK_CONTENT.TYPE,
-                        CraftMetaFirework.FIREWORKS.TYPE,
-                        CraftMetaEnchantedBook.STORED_ENCHANTMENTS.TYPE,
-                        CraftMetaCharge.EXPLOSION.TYPE,
-                        CraftMetaKnowledgeBook.BOOK_RECIPES.TYPE,
-                        CraftMetaTropicalFishBucket.ENTITY_TAG.TYPE,
-                        CraftMetaTropicalFishBucket.BUCKET_ENTITY_TAG.TYPE,
-                        CraftMetaAxolotlBucket.ENTITY_TAG.TYPE,
-                        CraftMetaAxolotlBucket.BUCKET_ENTITY_TAG.TYPE,
-                        CraftMetaCrossbow.CHARGED_PROJECTILES.TYPE,
-                        CraftMetaSuspiciousStew.EFFECTS.TYPE,
-                        CraftMetaCompass.LODESTONE_TARGET.TYPE,
-                        CraftMetaBundle.ITEMS.TYPE,
-                        CraftMetaMusicInstrument.GOAT_HORN_INSTRUMENT.TYPE,
-                        CraftMetaOminousBottle.OMINOUS_BOTTLE_AMPLIFIER.TYPE
-                ));
-            }
-            return CraftMetaItem.HANDLED_TAGS;
+        @Override
+        public final String toString() {
+            return SerializableMeta.classMap.get(this.getClass()) + "_META:" + this.serialize(); // TODO: cry
+        }
+
+        public int getVersion() {
+            return this.version;
+        }
+
+        @Override
+        public void setVersion(int version) {
+            this.version = version;
+        }
+
+        // Paper start - improve checking handled tags
+        @org.jetbrains.annotations.VisibleForTesting
+        public static final Map<Class<? extends CraftMetaItem>, Set<DataComponentType<?>>> HANDLED_DCTS_PER_TYPE = new HashMap<>();
+        private static final Set<DataComponentType<?>> DEFAULT_HANDLED_DCTS = Set.of(
+            CraftMetaItem.NAME.TYPE,
+            CraftMetaItem.ITEM_NAME.TYPE,
+            CraftMetaItem.LORE.TYPE,
+            CraftMetaItem.CUSTOM_MODEL_DATA.TYPE,
+            CraftMetaItem.BLOCK_DATA.TYPE,
+            CraftMetaItem.REPAIR.TYPE,
+            CraftMetaItem.ENCHANTMENTS.TYPE,
+            CraftMetaItem.HIDE_ADDITIONAL_TOOLTIP.TYPE,
+            CraftMetaItem.HIDE_TOOLTIP.TYPE,
+            CraftMetaItem.UNBREAKABLE.TYPE,
+            CraftMetaItem.ENCHANTMENT_GLINT_OVERRIDE.TYPE,
+            CraftMetaItem.FIRE_RESISTANT.TYPE,
+            CraftMetaItem.MAX_STACK_SIZE.TYPE,
+            CraftMetaItem.RARITY.TYPE,
+            CraftMetaItem.FOOD.TYPE,
+            CraftMetaItem.TOOL.TYPE,
+            CraftMetaItem.JUKEBOX_PLAYABLE.TYPE,
+            CraftMetaItem.DAMAGE.TYPE,
+            CraftMetaItem.MAX_DAMAGE.TYPE,
+            CraftMetaItem.CUSTOM_DATA.TYPE,
+            CraftMetaItem.ATTRIBUTES.TYPE,
+            CraftMetaItem.CAN_PLACE_ON.TYPE, // Paper
+            CraftMetaItem.CAN_BREAK.TYPE // Paper
+        );
+        public static Set<DataComponentType<?>> getTopLevelHandledDcts(final Class<? extends CraftMetaItem> clazz) {
+            synchronized (HANDLED_DCTS_PER_TYPE) {
+                if (HANDLED_DCTS_PER_TYPE.isEmpty()) {
+                    final Map<Class<? extends CraftMetaItem>, Set<DataComponentType<?>>> map = new HashMap<>();
+                    map.put(CraftMetaArmor.class, Set.of(CraftMetaArmor.TRIM.TYPE));
+                    map.put(CraftMetaArmorStand.class, Set.of(CraftMetaArmorStand.ENTITY_TAG.TYPE));
+                    map.put(CraftMetaAxolotlBucket.class, Set.of(CraftMetaAxolotlBucket.ENTITY_TAG.TYPE, CraftMetaAxolotlBucket.BUCKET_ENTITY_TAG.TYPE));
+                    map.put(CraftMetaBanner.class, Set.of(/*CraftMetaBlockState.BLOCK_ENTITY_TAG.NBT, */CraftMetaBanner.PATTERNS.TYPE)); // banner uses same tag as block state
+                    map.put(CraftMetaBlockState.class, Set.of(CraftMetaBlockState.BLOCK_ENTITY_TAG.TYPE));
+                    map.put(CraftMetaBook.class, Set.of(CraftMetaBook.BOOK_CONTENT.TYPE));
+                    map.put(CraftMetaBookSigned.class, Set.of(CraftMetaBookSigned.BOOK_CONTENT.TYPE));
+                    map.put(CraftMetaBundle.class, Set.of(CraftMetaBundle.ITEMS.TYPE));
+                    map.put(CraftMetaCharge.class, Set.of(CraftMetaCharge.EXPLOSION.TYPE));
+                    map.put(CraftMetaColorableArmor.class, Set.of(CraftMetaArmor.TRIM.TYPE, CraftMetaLeatherArmor.COLOR.TYPE));
+                    map.put(CraftMetaCompass.class, Set.of(CraftMetaCompass.LODESTONE_TARGET.TYPE));
+                    map.put(CraftMetaCrossbow.class, Set.of(CraftMetaCrossbow.CHARGED_PROJECTILES.TYPE));
+                    map.put(CraftMetaEnchantedBook.class, Set.of(CraftMetaEnchantedBook.STORED_ENCHANTMENTS.TYPE));
+                    map.put(CraftMetaEntityTag.class, Set.of(CraftMetaEntityTag.ENTITY_TAG.TYPE));
+                    map.put(CraftMetaFirework.class, Set.of(CraftMetaFirework.FIREWORKS.TYPE));
+                    map.put(CraftMetaKnowledgeBook.class, Set.of(CraftMetaKnowledgeBook.BOOK_RECIPES.TYPE));
+                    map.put(CraftMetaLeatherArmor.class, Set.of(CraftMetaLeatherArmor.COLOR.TYPE));
+                    map.put(CraftMetaMap.class, Set.of(CraftMetaMap.MAP_COLOR.TYPE, CraftMetaMap.MAP_POST_PROCESSING.TYPE, CraftMetaMap.MAP_ID.TYPE));
+                    map.put(CraftMetaMusicInstrument.class, Set.of(CraftMetaMusicInstrument.GOAT_HORN_INSTRUMENT.TYPE));
+                    map.put(CraftMetaOminousBottle.class, Set.of(CraftMetaOminousBottle.OMINOUS_BOTTLE_AMPLIFIER.TYPE));
+                    map.put(CraftMetaPotion.class, Set.of(CraftMetaPotion.POTION_CONTENTS.TYPE));
+                    map.put(CraftMetaSkull.class, Set.of(CraftMetaSkull.SKULL_PROFILE.TYPE, CraftMetaSkull.NOTE_BLOCK_SOUND.TYPE));
+                    map.put(CraftMetaSpawnEgg.class, Set.of(CraftMetaSpawnEgg.ENTITY_TAG.TYPE));
+                    map.put(CraftMetaSuspiciousStew.class, Set.of(CraftMetaSuspiciousStew.EFFECTS.TYPE));
+                    map.put(CraftMetaTropicalFishBucket.class, Set.of(CraftMetaTropicalFishBucket.ENTITY_TAG.TYPE, CraftMetaTropicalFishBucket.BUCKET_ENTITY_TAG.TYPE));
+
+                    for (final Map.Entry<Class<? extends CraftMetaItem>, Set<DataComponentType<?>>> entry : map.entrySet()) {
+                        final ArrayList<DataComponentType<?>> topLevelTags = new ArrayList<>(entry.getValue());
+                        // add tags common to CraftMetaItem to all
+                        topLevelTags.addAll(DEFAULT_HANDLED_DCTS);
+                        HANDLED_DCTS_PER_TYPE.put(entry.getKey(), Set.copyOf(topLevelTags));
+                    }
+                }
+                return HANDLED_DCTS_PER_TYPE.getOrDefault(clazz, DEFAULT_HANDLED_DCTS);
         }
     }
+    // Paper end - improve checking handled data component types
 
     protected static <T> Optional<? extends T> getOrEmpty(DataComponentPatch tag, ItemMetaKeyType<T> type) {
         Optional<? extends T> result = tag.get(type.TYPE);
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaKnowledgeBook.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaKnowledgeBook.java
index 573806b9200282f9842ab5289af4e2987905cafc..e47c1b9a52c938b145b721d9c088f4a916a01424 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaKnowledgeBook.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaKnowledgeBook.java
@@ -30,8 +30,8 @@ public class CraftMetaKnowledgeBook extends CraftMetaItem implements KnowledgeBo
         }
     }
 
-    CraftMetaKnowledgeBook(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaKnowledgeBook(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
 
         getOrEmpty(tag, CraftMetaKnowledgeBook.BOOK_RECIPES).ifPresent((pages) -> {
             for (int i = 0; i < pages.size(); i++) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaLeatherArmor.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaLeatherArmor.java
index 75a8ad69902103a2e33a457c3225a33860d075ed..e8c950aa74d31bf7a9128f4acc4bccee26bbcd7f 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaLeatherArmor.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaLeatherArmor.java
@@ -25,8 +25,8 @@ class CraftMetaLeatherArmor extends CraftMetaItem implements LeatherArmorMeta {
         CraftMetaLeatherArmor.readColor(this, meta);
     }
 
-    CraftMetaLeatherArmor(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaLeatherArmor(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
         CraftMetaLeatherArmor.readColor(this, tag);
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaMap.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaMap.java
index 08e18dcabbf52aae5c3843d49a72d1d52baa729b..149356981e586e4f67d4543d3df94a2ea99333fc 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaMap.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaMap.java
@@ -44,8 +44,8 @@ class CraftMetaMap extends CraftMetaItem implements MapMeta {
         this.color = map.color;
     }
 
-    CraftMetaMap(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaMap(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
 
         getOrEmpty(tag, CraftMetaMap.MAP_ID).ifPresent((mapId) -> {
             this.mapId = mapId.id();
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaMusicInstrument.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaMusicInstrument.java
index 3599ef1675b6091e9b67fb5241886460f106f9b4..2664d0dbe0d828a67ef551aa341a497a8bd0ea14 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaMusicInstrument.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaMusicInstrument.java
@@ -26,8 +26,8 @@ public class CraftMetaMusicInstrument extends CraftMetaItem implements MusicInst
         }
     }
 
-    CraftMetaMusicInstrument(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaMusicInstrument(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
 
         getOrEmpty(tag, CraftMetaMusicInstrument.GOAT_HORN_INSTRUMENT).ifPresent((instrument) -> {
             this.instrument = org.bukkit.craftbukkit.CraftRegistry.unwrapAndConvertHolder(org.bukkit.Registry.INSTRUMENT, instrument).orElse(null); // Paper - fix upstream not handling custom instruments
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaOminousBottle.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaOminousBottle.java
index 17336c177a969f04c51ff12de4599ef261d79fef..90c554dcbfe2bcca3f742379499f1e8e8665c512 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaOminousBottle.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaOminousBottle.java
@@ -23,8 +23,8 @@ public class CraftMetaOminousBottle extends CraftMetaItem implements OminousBott
         this.ominousBottleAmplifier = bottleMeta.ominousBottleAmplifier;
     }
 
-    CraftMetaOminousBottle(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaOminousBottle(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
         getOrEmpty(tag, CraftMetaOminousBottle.OMINOUS_BOTTLE_AMPLIFIER).ifPresent((amplifier) -> {
             this.ominousBottleAmplifier = amplifier;
         });
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaPotion.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaPotion.java
index d1cb8d520b6d7b0981d70412def71e7aab04560a..7f9182809f6e67ff571db0f365bc7e05f600775a 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaPotion.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaPotion.java
@@ -51,8 +51,8 @@ class CraftMetaPotion extends CraftMetaItem implements PotionMeta {
         }
     }
 
-    CraftMetaPotion(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaPotion(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
         getOrEmpty(tag, CraftMetaPotion.POTION_CONTENTS).ifPresent((potionContents) -> {
             potionContents.potion().ifPresent((potion) -> {
                 this.type = CraftPotionType.minecraftHolderToBukkit(potion);
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java
index d6e161374e0235031128a6ee86d1ffa875ea48aa..ab860f1179fa2618c8fbc30ac5f48ff78b8abb60 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java
@@ -49,8 +49,8 @@ class CraftMetaSkull extends CraftMetaItem implements SkullMeta {
         this.noteBlockSound = skullMeta.noteBlockSound;
     }
 
-    CraftMetaSkull(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaSkull(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
 
         getOrEmpty(tag, CraftMetaSkull.SKULL_PROFILE).ifPresent((resolvableProfile) -> {
             this.setProfile(resolvableProfile.gameProfile());
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSpawnEgg.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSpawnEgg.java
index 2c6ee95edea9dc959d8d31d689dc27fea4080467..e4b8637e6d82e2ce7cfee2130e6422f0ef4e1fbc 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSpawnEgg.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSpawnEgg.java
@@ -33,8 +33,8 @@ public class CraftMetaSpawnEgg extends CraftMetaItem implements SpawnEggMeta {
         this.entityTag = egg.entityTag;
     }
 
-    CraftMetaSpawnEgg(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaSpawnEgg(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
 
         getOrEmpty(tag, CraftMetaSpawnEgg.ENTITY_TAG).ifPresent((nbt) -> {
             this.entityTag = nbt.copyTag();
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSuspiciousStew.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSuspiciousStew.java
index 248efddbad2bfee4f9aa33ec738b5353054eda61..7a43e326e51300306b9c5c23a16ffae92030bd2b 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSuspiciousStew.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSuspiciousStew.java
@@ -33,8 +33,8 @@ public class CraftMetaSuspiciousStew extends CraftMetaItem implements Suspicious
         }
     }
 
-    CraftMetaSuspiciousStew(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaSuspiciousStew(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
         getOrEmpty(tag, CraftMetaSuspiciousStew.EFFECTS).ifPresent((suspiciousStewEffects) -> {
             List<SuspiciousStewEffects.Entry> list = suspiciousStewEffects.effects();
             int length = list.size();
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaTropicalFishBucket.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaTropicalFishBucket.java
index a514fe98d3d2b65d2cfd029079c69189bcb99c01..17705059b81942e4df43a4a5180092e09c985ade 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaTropicalFishBucket.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaTropicalFishBucket.java
@@ -38,8 +38,8 @@ class CraftMetaTropicalFishBucket extends CraftMetaItem implements TropicalFishB
         this.bucketEntityTag = bucket.bucketEntityTag;
     }
 
-    CraftMetaTropicalFishBucket(DataComponentPatch tag) {
-        super(tag);
+    CraftMetaTropicalFishBucket(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
+        super(tag, extraHandledDcts); // Paper
 
         getOrEmpty(tag, CraftMetaTropicalFishBucket.ENTITY_TAG).ifPresent((nbt) -> {
             this.entityTag = nbt.copyTag();
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/DeprecatedItemMetaCustomValueTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/DeprecatedItemMetaCustomValueTest.java
index 51e2acf125bdff2ba6d8fd8af9f22e233d7c74a7..6bed0a5c8d9f1ca72678cdf4699128e441a24541 100644
--- a/src/test/java/org/bukkit/craftbukkit/inventory/DeprecatedItemMetaCustomValueTest.java
+++ b/src/test/java/org/bukkit/craftbukkit/inventory/DeprecatedItemMetaCustomValueTest.java
@@ -96,7 +96,7 @@ public class DeprecatedItemMetaCustomValueTest extends AbstractTestingBase {
         CraftMetaItem.Applicator compound = new CraftMetaItem.Applicator();
         itemMeta.applyToItem(compound);
 
-        assertEquals(itemMeta, new CraftMetaItem(compound.build()));
+        assertEquals(itemMeta, new CraftMetaItem(compound.build(), null)); // Paper
     }
 
     @Test
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/MetaHandledTagsTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/MetaHandledTagsTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..43fca566e139d370a37b2d56156df4ed7d0d0b66
--- /dev/null
+++ b/src/test/java/org/bukkit/craftbukkit/inventory/MetaHandledTagsTest.java
@@ -0,0 +1,32 @@
+package org.bukkit.craftbukkit.inventory;
+
+import io.github.classgraph.ClassGraph;
+import io.github.classgraph.ClassInfo;
+import io.github.classgraph.ClassInfoList;
+import io.github.classgraph.ScanResult;
+import org.bukkit.support.AbstractTestingBase;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+// in cb package because of package-private stuff
+class MetaHandledTagsTest extends AbstractTestingBase {
+
+    @Test
+    public void checkAllMetasHaveHandledTags() {
+        try (final ScanResult result = new ClassGraph()
+            .whitelistPackages("org.bukkit.craftbukkit.inventory")
+            .enableClassInfo().scan()) {
+            final ClassInfoList subclasses = result.getSubclasses(CraftMetaItem.class.getName());
+            assertFalse(subclasses.isEmpty(), "found 0 sub types");
+            for (final ClassInfo subclass : subclasses) {
+                final Class<CraftMetaItem> clazz = subclass.loadClass(CraftMetaItem.class);
+                CraftMetaItem.getTopLevelHandledDcts(clazz); // load into map
+                assertTrue(CraftMetaItem.HANDLED_DCTS_PER_TYPE.containsKey(clazz), subclass.getName() + " not found in handled tags map");
+            }
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+}
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/PersistentDataContainerTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/PersistentDataContainerTest.java
index 30da18cbc878fb1ac2a134f3bcbfcb8d7bec3938..6f94c7a19f2f598a836ec7db30332dd95f8675a6 100644
--- a/src/test/java/org/bukkit/craftbukkit/inventory/PersistentDataContainerTest.java
+++ b/src/test/java/org/bukkit/craftbukkit/inventory/PersistentDataContainerTest.java
@@ -130,7 +130,7 @@ public class PersistentDataContainerTest extends AbstractTestingBase {
         CraftMetaItem.Applicator compound = new CraftMetaItem.Applicator();
         itemMeta.applyToItem(compound);
 
-        assertEquals(itemMeta, new CraftMetaItem(compound.build()));
+        assertEquals(itemMeta, new CraftMetaItem(compound.build(), null)); // Paper
     }
 
     @Test
@@ -463,7 +463,7 @@ public class PersistentDataContainerTest extends AbstractTestingBase {
 
     @Test
     public void testEmptyListApplicationToAnyType() throws IOException {
-        final CraftMetaItem craftItem = new CraftMetaItem(DataComponentPatch.EMPTY);
+        final CraftMetaItem craftItem = new CraftMetaItem(DataComponentPatch.EMPTY, null); // Paper
         final PersistentDataContainer container = craftItem.getPersistentDataContainer();
 
         container.set(PersistentDataContainerTest.requestKey("list"), PersistentDataType.LIST.strings(), List.of());
@@ -476,7 +476,7 @@ public class PersistentDataContainerTest extends AbstractTestingBase {
         final CraftMetaItem.Applicator storage = new CraftMetaItem.Applicator();
         craftItem.applyToItem(storage);
 
-        final CraftMetaItem readItem = new CraftMetaItem(storage.build());
+        final CraftMetaItem readItem = new CraftMetaItem(storage.build(), null); // Paper
         final PersistentDataContainer readContainer = readItem.getPersistentDataContainer();
 
         assertTrue(readContainer.has(PersistentDataContainerTest.requestKey("list"), PersistentDataType.LIST.strings()));

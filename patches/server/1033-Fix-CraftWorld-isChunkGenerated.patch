From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jason Penilla <11360596+jpenilla@users.noreply.github.com>
Date: Tue, 18 Jun 2024 12:43:06 -0700
Subject: [PATCH] Fix CraftWorld#isChunkGenerated

The upstream implementation is returning true for non-full chunks.

diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index fe9e8d1d4ae1f7a4e8f4cf5688004fc969422b3c..8045d6c9398d1c88595da6e41aa1ed27fb6fbad0 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -367,11 +367,28 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public boolean isChunkGenerated(int x, int z) {
-        try {
-            return this.isChunkLoaded(x, z) || this.world.getChunkSource().chunkMap.read(new ChunkPos(x, z)).get().isPresent();
-        } catch (InterruptedException | ExecutionException ex) {
-            throw new RuntimeException(ex);
+        // Paper start - Fix this method
+        if (!Bukkit.isPrimaryThread()) {
+            return java.util.concurrent.CompletableFuture.supplyAsync(() -> {
+                return CraftWorld.this.isChunkGenerated(x, z);
+            }, world.getChunkSource().mainThreadProcessor).join();
+        }
+        ChunkAccess chunk = world.getChunkSource().getChunkAtImmediately(x, z);
+        if (chunk != null) {
+            return chunk instanceof ImposterProtoChunk || chunk instanceof net.minecraft.world.level.chunk.LevelChunk;
         }
+        final java.util.concurrent.CompletableFuture<ChunkAccess> future = new java.util.concurrent.CompletableFuture<>();
+        ca.spottedleaf.moonrise.patches.chunk_system.ChunkSystem.scheduleChunkLoad(
+            this.world, x, z, false, ChunkStatus.EMPTY, true, ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.NORMAL, future::complete
+        );
+        world.getChunkSource().mainThreadProcessor.managedBlock(future::isDone);
+        return future.thenApply(c -> {
+            if (c != null) {
+                return c.getPersistedStatus() == ChunkStatus.FULL;
+            }
+            return false;
+        }).join();
+        // Paper end - Fix this method
     }
 
     @Override

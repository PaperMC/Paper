From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Sat, 11 Apr 2020 03:56:07 -0400
Subject: [PATCH] Implement Chunk Priority / Urgency System for Chunks

Mark chunks that are blocking main thread for world generation as urgent

Implements a general priority system so that chunks that are sorted in
the generator queues can prioritize certain chunks over another.

Urgent chunks will jump to the front of the line, ensuring that a
sync chunk load on an ungenerated chunk does not lag the server for
a long period of time if the servers generator queues are filled with
lots of chunks already.

This massively reduces the lag spikes from sync chunk gens.

Then we further prioritize loading order so nearby chunks have higher
priority than distant chunks, reducing the pressure a high no tick
view distance holds on you.

Chunks in front of the player have higher priority, to help with
fast traveling players keep up with their movement.

diff --git a/src/main/java/com/destroystokyo/paper/io/chunk/ChunkTaskManager.java b/src/main/java/com/destroystokyo/paper/io/chunk/ChunkTaskManager.java
index af40e473521f408aa0e112953c43bdbce164a48b..68860a3b6db2aa50373d71aec9502c18d48ab8b9 100644
--- a/src/main/java/com/destroystokyo/paper/io/chunk/ChunkTaskManager.java
+++ b/src/main/java/com/destroystokyo/paper/io/chunk/ChunkTaskManager.java
@@ -107,7 +107,7 @@ public final class ChunkTaskManager {
     }
 
     static void dumpChunkInfo(Set<ChunkHolder> seenChunks, ChunkHolder chunkHolder, int x, int z) {
-        dumpChunkInfo(seenChunks, chunkHolder, x, z, 0, 1);
+        dumpChunkInfo(seenChunks, chunkHolder, x, z, 0, 4); // Paper - 1->4
     }
 
     static void dumpChunkInfo(Set<ChunkHolder> seenChunks, ChunkHolder chunkHolder, int x, int z, int indent, int maxDepth) {
@@ -128,6 +128,31 @@ public final class ChunkTaskManager {
             PaperFileIOThread.LOGGER.error(indentStr + "Chunk Status - " + ((chunk == null) ? "null chunk" : chunk.getStatus().toString()));
             PaperFileIOThread.LOGGER.error(indentStr + "Chunk Ticket Status - "  + ChunkHolder.getStatus(chunkHolder.getTicketLevel()));
             PaperFileIOThread.LOGGER.error(indentStr + "Chunk Holder Status - " + ((holderStatus == null) ? "null" : holderStatus.toString()));
+            // Paper start
+            PaperFileIOThread.LOGGER.error(indentStr + "Chunk Holder Priority - " + chunkHolder.queueLevel);
+
+            if (!chunkHolder.neighbors.isEmpty()) {
+                if (indent >= maxDepth) {
+                    PaperFileIOThread.LOGGER.error(indentStr + "Chunk Neighbors: (Can't show, too deeply nested)");
+                    return;
+                }
+                PaperFileIOThread.LOGGER.error(indentStr + "Chunk Neighbors: ");
+                for (ChunkHolder neighbor : chunkHolder.neighbors.keySet()) {
+                    ChunkStatus status = neighbor.getChunkHolderStatus();
+                    if (status != null && status.isOrAfter(ChunkHolder.getStatus(neighbor.getTicketLevel()))) {
+                        continue;
+                    }
+                    int nx = neighbor.pos.x;
+                    int nz = neighbor.pos.z;
+                    if (seenChunks.contains(neighbor)) {
+                        PaperFileIOThread.LOGGER.error(indentStr + "  " + nx + "," + nz + " in " + chunkHolder.getWorld().getWorld().getName() + " (CIRCULAR)");
+                        continue;
+                    }
+                    PaperFileIOThread.LOGGER.error(indentStr + "  " + nx + "," + nz + " in " + chunkHolder.getWorld().getWorld().getName() + ":");
+                    dumpChunkInfo(seenChunks, neighbor, nx, nz, indent + 1, maxDepth);
+                }
+            }
+            // Paper end
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/ChunkSystem.java b/src/main/java/net/minecraft/server/ChunkSystem.java
index 7f76c304f5eb3c2f27b348918588ab67b795b1ba..1b1bfd5f92f85f46ad9661a0a64a2a1b4c33a80d 100644
--- a/src/main/java/net/minecraft/server/ChunkSystem.java
+++ b/src/main/java/net/minecraft/server/ChunkSystem.java
@@ -55,6 +55,19 @@ public final class ChunkSystem {
 
     static final TicketType<Long> CHUNK_LOAD = TicketType.create("chunk_load", Long::compareTo);
 
+    // Paper start - priority
+    private static int getPriorityBoost(final PrioritisedExecutor.Priority priority) {
+        if (priority.isLowerOrEqualPriority(PrioritisedExecutor.Priority.NORMAL)) {
+            return 0;
+        }
+
+        int dist = PrioritisedExecutor.Priority.BLOCKING.ordinal() - PrioritisedExecutor.Priority.NORMAL.ordinal();
+
+
+        return (net.minecraft.server.level.DistanceManager.URGENT_PRIORITY * (priority.ordinal() - PrioritisedExecutor.Priority.NORMAL.ordinal())) / dist;
+    }
+    // Paper end - priority
+
     private static long chunkLoadCounter = 0L;
     public static void scheduleChunkLoad(final ServerLevel level, final int chunkX, final int chunkZ, final ChunkStatus toStatus,
                                          final boolean addTicket, final PrioritisedExecutor.Priority priority, final Consumer<ChunkAccess> onComplete) {
@@ -68,12 +81,19 @@ public final class ChunkSystem {
         final int minLevel = 33 + ChunkStatus.getDistance(toStatus);
         final Long chunkReference = addTicket ? Long.valueOf(++chunkLoadCounter) : null;
         final ChunkPos chunkPos = new ChunkPos(chunkX, chunkZ);
+        final int priorityBoost = getPriorityBoost(priority);
 
         if (addTicket) {
             level.chunkSource.addTicketAtLevel(CHUNK_LOAD, chunkPos, minLevel, chunkReference);
         }
         level.chunkSource.runDistanceManagerUpdates();
 
+        if (priorityBoost == net.minecraft.server.level.DistanceManager.URGENT_PRIORITY) {
+            level.chunkSource.markUrgent(chunkPos);
+        } else if (priorityBoost != 0) {
+            level.chunkSource.markHighPriority(chunkPos, priorityBoost);
+        }
+
         final Consumer<ChunkAccess> loadCallback = (final ChunkAccess chunk) -> {
             try {
                 if (onComplete != null) {
@@ -89,6 +109,11 @@ public final class ChunkSystem {
                     level.chunkSource.addTicketAtLevel(TicketType.UNKNOWN, chunkPos, minLevel, chunkPos);
                     level.chunkSource.removeTicketAtLevel(CHUNK_LOAD, chunkPos, minLevel, chunkReference);
                 }
+                if (priorityBoost == net.minecraft.server.level.DistanceManager.URGENT_PRIORITY) {
+                    level.chunkSource.clearUrgent(chunkPos);
+                } else if (priorityBoost != 0) {
+                    level.chunkSource.clearPriorityTickets(chunkPos);
+                }
             }
         };
 
@@ -135,12 +160,17 @@ public final class ChunkSystem {
         final int radius = toStatus.ordinal() - 1;
         final Long chunkReference = addTicket ? Long.valueOf(++chunkLoadCounter) : null;
         final ChunkPos chunkPos = new ChunkPos(chunkX, chunkZ);
+        final int priorityBoost = getPriorityBoost(priority);
 
         if (addTicket) {
             level.chunkSource.addTicketAtLevel(CHUNK_LOAD, chunkPos, minLevel, chunkReference);
         }
         level.chunkSource.runDistanceManagerUpdates();
 
+        if (priorityBoost != 0) {
+            level.chunkSource.markAreaHighPriority(chunkPos, priorityBoost, radius);
+        }
+
         final Consumer<LevelChunk> loadCallback = (final LevelChunk chunk) -> {
             try {
                 if (onComplete != null) {
@@ -156,6 +186,9 @@ public final class ChunkSystem {
                     level.chunkSource.addTicketAtLevel(TicketType.UNKNOWN, chunkPos, minLevel, chunkPos);
                     level.chunkSource.removeTicketAtLevel(CHUNK_LOAD, chunkPos, minLevel, chunkReference);
                 }
+                if (priorityBoost != 0) {
+                    level.chunkSource.clearAreaPriorityTickets(chunkPos, radius);
+                }
             }
         };
 
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index 2e56c52e3ee45b0304a9e6a5eab863ef96b2aab0..5eb6ce20ee17d87db0f6c2dcee96d6d0891d6c50 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -634,6 +634,7 @@ public final class MCUtil {
                 chunkData.addProperty("x", playerChunk.pos.x);
                 chunkData.addProperty("z", playerChunk.pos.z);
                 chunkData.addProperty("ticket-level", playerChunk.getTicketLevel());
+                chunkData.addProperty("priority", playerChunk.queueLevel); // Paper - priority
                 chunkData.addProperty("state", ChunkHolder.getFullChunkStatus(playerChunk.getTicketLevel()).toString());
                 chunkData.addProperty("queued-for-unload", chunkMap.toDrop.contains(playerChunk.pos.longKey));
                 chunkData.addProperty("status", status == null ? "unloaded" : status.toString());
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index e30893d6cbe3b42338d04453d0f452babeb61d8a..a52932d665ca45a5e066d7cef0ec0313d1c3f69f 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -60,7 +60,7 @@ public class ChunkHolder {
     private final DebugBuffer<ChunkHolder.ChunkSaveDebug> chunkToSaveHistory;
     public int oldTicketLevel;
     private int ticketLevel;
-    private int queueLevel;
+    public volatile int queueLevel; // Paper - private->public, make volatile since this is concurrently accessed
     public final ChunkPos pos;
     private boolean hasChangedSections;
     private final ShortSet[] changedBlocksPerSection;
@@ -73,6 +73,7 @@ public class ChunkHolder {
     private boolean resendLight;
     private CompletableFuture<Void> pendingFullStateConfirmation;
 
+    public ServerLevel getWorld() { return chunkMap.level; } // Paper
     boolean isUpdateQueued = false; // Paper
     private final ChunkMap chunkMap; // Paper
 
@@ -438,12 +439,18 @@ public class ChunkHolder {
         });
     }
 
+    // Paper start
+    private boolean loadCallbackScheduled = false;
+    private boolean unloadCallbackScheduled = false;
+    // Paper end
+
     private void demoteFullChunk(ChunkMap playerchunkmap, ChunkHolder.FullChunkStatus playerchunk_state) {
         this.pendingFullStateConfirmation.cancel(false);
         playerchunkmap.onFullChunkStatusChange(this.pos, playerchunk_state);
     }
 
     protected void updateFutures(ChunkMap chunkStorage, Executor executor) {
+        io.papermc.paper.util.TickThread.ensureTickThread("Async ticket level update"); // Paper
         ChunkStatus chunkstatus = ChunkHolder.getStatus(this.oldTicketLevel);
         ChunkStatus chunkstatus1 = ChunkHolder.getStatus(this.ticketLevel);
         boolean flag = this.oldTicketLevel <= ChunkMap.MAX_CHUNK_DISTANCE;
@@ -454,9 +461,22 @@ public class ChunkHolder {
         // ChunkUnloadEvent: Called before the chunk is unloaded: isChunkLoaded is still true and chunk can still be modified by plugins.
         if (playerchunk_state.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && !playerchunk_state1.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
             this.getFutureIfPresentUnchecked(ChunkStatus.FULL).thenAccept((either) -> {
+                io.papermc.paper.util.TickThread.ensureTickThread("Async full status chunk future completion"); // Paper
                 LevelChunk chunk = (LevelChunk)either.left().orElse(null);
-                if (chunk != null) {
+                if (chunk != null && chunk.wasLoadCallbackInvoked() && ChunkHolder.this.ticketLevel > 33) { // Paper - only invoke unload if load was called
+                    // Paper  start - only schedule once, now the future is no longer completed as RIGHT if unloaded...
+                    if (ChunkHolder.this.unloadCallbackScheduled) {
+                        return;
+                    }
+                    ChunkHolder.this.unloadCallbackScheduled = true;
+                    // Paper  end - only schedule once, now the future is no longer completed as RIGHT if unloaded...
                     chunkStorage.callbackExecutor.execute(() -> {
+                        // Paper  start - only schedule once, now the future is no longer completed as RIGHT if unloaded...
+                        ChunkHolder.this.unloadCallbackScheduled = false;
+                        if (ChunkHolder.this.ticketLevel <= 33) {
+                            return;
+                        }
+                        // Paper  end - only schedule once, now the future is no longer completed as RIGHT if unloaded...
                         // Minecraft will apply the chunks tick lists to the world once the chunk got loaded, and then store the tick
                         // lists again inside the chunk once the chunk becomes inaccessible and set the chunk's needsSaving flag.
                         // These actions may however happen deferred, so we manually set the needsSaving flag already here.
@@ -501,11 +521,13 @@ public class ChunkHolder {
             this.scheduleFullChunkPromotion(chunkStorage, this.fullChunkFuture, executor, ChunkHolder.FullChunkStatus.BORDER);
             // Paper start - cache ticking ready status
             this.fullChunkFuture.thenAccept(either -> {
+                io.papermc.paper.util.TickThread.ensureTickThread("Async full chunk future completion"); // Paper
                 final Optional<LevelChunk> left = either.left();
                 if (left.isPresent() && ChunkHolder.this.fullChunkCreateCount == expectCreateCount) {
                     LevelChunk fullChunk = either.left().get();
                     ChunkHolder.this.isFullChunkReady = true;
                     net.minecraft.server.ChunkSystem.onChunkBorder(fullChunk, this);
+                    this.chunkMap.distanceManager.clearPriorityTickets(pos); // Paper - chunk priority
                 }
             });
             this.updateChunkToSave(this.fullChunkFuture, "full");
@@ -531,6 +553,7 @@ public class ChunkHolder {
             this.scheduleFullChunkPromotion(chunkStorage, this.tickingChunkFuture, executor, ChunkHolder.FullChunkStatus.TICKING);
             // Paper start - cache ticking ready status
             this.tickingChunkFuture.thenAccept(either -> {
+                io.papermc.paper.util.TickThread.ensureTickThread("Async full chunk future completion"); // Paper
                 either.ifLeft(chunk -> {
                     // note: Here is a very good place to add callbacks to logic waiting on this.
                     ChunkHolder.this.isTickingReady = true;
@@ -563,6 +586,7 @@ public class ChunkHolder {
             this.scheduleFullChunkPromotion(chunkStorage, this.entityTickingChunkFuture, executor, ChunkHolder.FullChunkStatus.ENTITY_TICKING);
             // Paper start - cache ticking ready status
             this.entityTickingChunkFuture.thenAccept(either -> {
+                io.papermc.paper.util.TickThread.ensureTickThread("Async full chunk future completion"); // Paper
                 either.ifLeft(chunk -> {
                     ChunkHolder.this.isEntityTickingReady = true;
                     net.minecraft.server.ChunkSystem.onChunkEntityTicking(chunk, this);
@@ -586,16 +610,45 @@ public class ChunkHolder {
             this.demoteFullChunk(chunkStorage, playerchunk_state1);
         }
 
-        this.onLevelChange.onLevelChange(this.pos, this::getQueueLevel, this.ticketLevel, this::setQueueLevel);
+        //this.onLevelChange.onLevelChange(this.pos, this::getQueueLevel, this.ticketLevel, this::setQueueLevel);
+        // Paper start - raise IO/load priority if priority changes, use our preferred priority
+        priorityBoost = chunkMap.distanceManager.getChunkPriority(pos);
+        int currRequestedPriority = this.requestedPriority;
+        int priority = getDemandedPriority();
+        int newRequestedPriority = this.requestedPriority = priority;
+        if (this.queueLevel > priority) {
+            int ioPriority = com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY;
+            if (priority <= 10) {
+                ioPriority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY;
+            } else if (priority <= 20) {
+                ioPriority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGH_PRIORITY;
+            }
+            chunkMap.level.asyncChunkTaskManager.raisePriority(pos.x, pos.z, ioPriority);
+            chunkMap.level.getChunkSource().getLightEngine().queue.changePriority(pos.toLong(), this.queueLevel, priority); // Paper // Restore this in chunk priority later?
+        }
+        if (currRequestedPriority != newRequestedPriority) {
+            this.onLevelChange.onLevelChange(this.pos, () -> this.queueLevel, priority, p -> this.queueLevel = p); // use preferred priority
+            int neighborsPriority = getNeighborsPriority();
+            this.neighbors.forEach((neighbor, neighborDesired) -> neighbor.setNeighborPriority(this, neighborsPriority));
+        }
+        // Paper end
         this.oldTicketLevel = this.ticketLevel;
         // CraftBukkit start
         // ChunkLoadEvent: Called after the chunk is loaded: isChunkLoaded returns true and chunk is ready to be modified by plugins.
         if (!playerchunk_state.isOrAfter(ChunkHolder.FullChunkStatus.BORDER) && playerchunk_state1.isOrAfter(ChunkHolder.FullChunkStatus.BORDER)) {
             this.getFutureIfPresentUnchecked(ChunkStatus.FULL).thenAccept((either) -> {
+                io.papermc.paper.util.TickThread.ensureTickThread("Async full status chunk future completion"); // Paper
                 LevelChunk chunk = (LevelChunk)either.left().orElse(null);
-                if (chunk != null) {
+                if (chunk != null && ChunkHolder.this.oldTicketLevel <= 33 && !chunk.wasLoadCallbackInvoked()) { // Paper - ensure ticket level is set to loaded before calling, as now this can complete with ticket level > 33
+                    // Paper  start - only schedule once, now the future is no longer completed as RIGHT if unloaded...
+                    if (ChunkHolder.this.loadCallbackScheduled) {
+                        return;
+                    }
+                    ChunkHolder.this.loadCallbackScheduled = true;
+                    // Paper  end - only schedule once, now the future is no longer completed as RIGHT if unloaded...
                     chunkStorage.callbackExecutor.execute(() -> {
-                        chunk.loadCallback();
+                        ChunkHolder.this.loadCallbackScheduled = false; // Paper  - only schedule once, now the future is no longer completed as RIGHT if unloaded...
+                        if (ChunkHolder.this.oldTicketLevel <= 33) chunk.loadCallback(); // Paper "
                     });
                 }
             }).exceptionally((throwable) -> {
@@ -696,7 +749,134 @@ public class ChunkHolder {
         };
     }
 
-    // Paper start
+    // Paper start - Chunk gen/load priority system
+    volatile int neighborPriority = -1;
+    volatile int priorityBoost = 0;
+    public final java.util.concurrent.ConcurrentHashMap<ChunkHolder, ChunkStatus> neighbors = new java.util.concurrent.ConcurrentHashMap<>();
+    public final it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<Integer> neighborPriorities = new it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<>();
+    int requestedPriority = ChunkMap.MAX_CHUNK_DISTANCE + 1; // this priority is possible pending, but is used to ensure needless updates are not queued
+
+    private int getDemandedPriority() {
+        int priority = neighborPriority; // if we have a neighbor priority, use it
+        int myPriority = getMyPriority();
+
+        if (priority == -1 || (ticketLevel <= 33 && priority > myPriority)) {
+            priority = myPriority;
+        }
+
+        return Math.max(1, Math.min(Math.max(ticketLevel, ChunkMap.MAX_CHUNK_DISTANCE), priority));
+    }
+
+    private int getMyPriority() {
+        if (priorityBoost == DistanceManager.URGENT_PRIORITY) {
+            return 2; // Urgent - ticket level isn't always 31 so 33-30 = 3, but allow 1 more tasks to go below this for dependents
+        }
+        return ticketLevel - priorityBoost;
+    }
+
+    private int getNeighborsPriority() {
+        return (neighborPriorities.isEmpty() ? getMyPriority() : getDemandedPriority()) + 1;
+    }
+
+    public void onNeighborRequest(ChunkHolder neighbor, ChunkStatus status) {
+        neighbor.setNeighborPriority(this, getNeighborsPriority());
+        this.neighbors.compute(neighbor, (playerChunk, currentWantedStatus) -> {
+            if (currentWantedStatus == null || !currentWantedStatus.isOrAfter(status)) {
+                //System.out.println(this + " request " + neighbor + " at " + status + " currently " + currentWantedStatus);
+                return status;
+            } else {
+                //System.out.println(this + " requested " + neighbor + " at " + status + " but thats lower than other wanted status " + currentWantedStatus);
+                return currentWantedStatus;
+            }
+        });
+
+    }
+
+    public void onNeighborDone(ChunkHolder neighbor, ChunkStatus chunkstatus, ChunkAccess chunk) {
+        this.neighbors.compute(neighbor, (playerChunk, wantedStatus) -> {
+            if (wantedStatus != null && chunkstatus.isOrAfter(wantedStatus)) {
+                //System.out.println(this + " neighbor done at " + neighbor + " for status " + chunkstatus + " wanted " + wantedStatus);
+                neighbor.removeNeighborPriority(this);
+                return null;
+            } else {
+                //System.out.println(this + " neighbor finished our previous request at " + neighbor + " for status " + chunkstatus + " but we now want instead " + wantedStatus);
+                return wantedStatus;
+            }
+        });
+    }
+
+    private void removeNeighborPriority(ChunkHolder requester) {
+        synchronized (neighborPriorities) {
+            neighborPriorities.remove(requester.pos.toLong());
+            recalcNeighborPriority();
+        }
+        checkPriority();
+    }
+
+
+    private void setNeighborPriority(ChunkHolder requester, int priority) {
+        synchronized (neighborPriorities) {
+            if (!Integer.valueOf(priority).equals(neighborPriorities.put(requester.pos.toLong(), Integer.valueOf(priority)))) {
+                recalcNeighborPriority();
+            }
+        }
+        checkPriority();
+    }
+
+    private void recalcNeighborPriority() {
+        neighborPriority = -1;
+        if (!neighborPriorities.isEmpty()) {
+            synchronized (neighborPriorities) {
+                for (Integer neighbor : neighborPriorities.values()) {
+                    if (neighbor < neighborPriority || neighborPriority == -1) {
+                        neighborPriority = neighbor;
+                    }
+                }
+            }
+        }
+    }
+    private void checkPriority() {
+        if (this.requestedPriority != getDemandedPriority()) this.chunkMap.queueHolderUpdate(this);
+    }
+
+    public final double getDistance(ServerPlayer player) {
+        return getDistance(player.getX(), player.getZ());
+    }
+    public final double getDistance(double blockX, double blockZ) {
+        int cx = net.minecraft.server.MCUtil.fastFloor(blockX) >> 4;
+        int cz = net.minecraft.server.MCUtil.fastFloor(blockZ) >> 4;
+        final double x = pos.x - cx;
+        final double z = pos.z - cz;
+        return (x * x) + (z * z);
+    }
+
+    public final double getDistanceFrom(BlockPos pos) {
+        return getDistance(pos.getX(), pos.getZ());
+    }
+
+    public static ChunkStatus getNextStatus(ChunkStatus status) {
+        if (status == ChunkStatus.FULL) {
+            return status;
+        }
+        return CHUNK_STATUSES.get(status.getIndex() + 1);
+    }
+    public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getStatusFutureUncheckedMain(ChunkStatus chunkstatus) {
+        return ensureMain(getFutureIfPresentUnchecked(chunkstatus));
+    }
+    public <T> CompletableFuture<T> ensureMain(CompletableFuture<T> future) {
+        return future.thenApplyAsync(r -> r, chunkMap.mainInvokingExecutor);
+    }
+
+    @Override
+    public String toString() {
+        return "PlayerChunk{" +
+            "location=" + pos +
+            ", ticketLevel=" + ticketLevel + "/" + getStatus(this.ticketLevel) +
+            ", chunkHolderStatus=" + getChunkHolderStatus() +
+            ", neighborPriority=" + getNeighborsPriority() +
+            ", priority=(" + ticketLevel + " - " + priorityBoost +" vs N " + neighborPriority + ") = " + getDemandedPriority() + " A " + queueLevel +
+            '}';
+    }
     public final boolean isEntityTickingReady() {
         return this.isEntityTickingReady;
     }
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index c3bbaf32373a32417f8b83f386f8cf327c6e0893..46bfaf04867d913c1782d851de101d913376c63a 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -131,6 +131,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public final ServerLevel level;
     private final ThreadedLevelLightEngine lightEngine;
     private final BlockableEventLoop<Runnable> mainThreadExecutor;
+    final java.util.concurrent.Executor mainInvokingExecutor; // Paper
     public ChunkGenerator generator;
     private RandomState randomState;
     public final Supplier<DimensionDataStorage> overworldDataStorage;
@@ -267,6 +268,15 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
 
         this.mainThreadExecutor = mainThreadExecutor;
+        // Paper start
+        this.mainInvokingExecutor = (run) -> {
+            if (MCUtil.isMainThread()) {
+                run.run();
+            } else {
+                mainThreadExecutor.execute(run);
+            }
+        };
+        // Paper end
         ProcessorMailbox<Runnable> threadedmailbox = ProcessorMailbox.create(executor, "worldgen");
 
         Objects.requireNonNull(mainThreadExecutor);
@@ -309,6 +319,37 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         });
     }
 
+    // Paper start - Chunk Prioritization
+    public void queueHolderUpdate(ChunkHolder playerchunk) {
+        Runnable runnable = () -> {
+            if (isUnloading(playerchunk)) {
+                return; // unloaded
+            }
+            distanceManager.pendingChunkUpdates.add(playerchunk);
+            if (!distanceManager.pollingPendingChunkUpdates) {
+                level.getChunkSource().runDistanceManagerUpdates();
+            }
+        };
+        if (MCUtil.isMainThread()) {
+            // We can't use executor here because it will not execute tasks if its currently in the middle of executing tasks...
+            runnable.run();
+        } else {
+            mainThreadExecutor.execute(runnable);
+        }
+    }
+
+    private boolean isUnloading(ChunkHolder playerchunk) {
+        return playerchunk == null || toDrop.contains(playerchunk.pos.toLong());
+    }
+
+    private void updateChunkPriorityMap(it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap map, long chunk, int level) {
+        int prev = map.getOrDefault(chunk, -1);
+        if (level > prev) {
+            map.put(chunk, level);
+        }
+    }
+    // Paper end
+
     private static double euclideanDistanceSquared(ChunkPos pos, Entity entity) {
         double d0 = (double) SectionPos.sectionToBlockCoord(pos.x, 8);
         double d1 = (double) SectionPos.sectionToBlockCoord(pos.z, 8);
@@ -399,6 +440,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         List<ChunkHolder> list1 = new ArrayList();
         int j = centerChunk.x;
         int k = centerChunk.z;
+        ChunkHolder requestingNeighbor = getUpdatingChunkIfPresent(centerChunk.toLong()); // Paper
 
         for (int l = -margin; l <= margin; ++l) {
             for (int i1 = -margin; i1 <= margin; ++i1) {
@@ -417,6 +459,14 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
                 ChunkStatus chunkstatus = (ChunkStatus) distanceToStatus.apply(j1);
                 CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = playerchunk.getOrScheduleFuture(chunkstatus, this);
+                // Paper start
+                if (requestingNeighbor != null && requestingNeighbor != playerchunk && !completablefuture.isDone()) {
+                    requestingNeighbor.onNeighborRequest(playerchunk, chunkstatus);
+                    completablefuture.thenAccept(either -> {
+                        requestingNeighbor.onNeighborDone(playerchunk, chunkstatus, either.left().orElse(null));
+                    });
+                }
+                // Paper end
 
                 list1.add(playerchunk);
                 list.add(completablefuture);
@@ -733,11 +783,19 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         if (requiredStatus == ChunkStatus.EMPTY) {
             return this.scheduleChunkLoad(chunkcoordintpair);
         } else {
+            // Paper start - revert 1.17 chunk system changes
+            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = holder.getOrScheduleFuture(requiredStatus.getParent(), this);
+        return future.thenComposeAsync((either) -> {
+            Optional<ChunkAccess> optional = either.left();
+            if (!optional.isPresent()) {
+                return CompletableFuture.completedFuture(either);
+            }
+            // Paper end - revert 1.17 chunk system changes
             if (requiredStatus == ChunkStatus.LIGHT) {
                 this.distanceManager.addTicket(TicketType.LIGHT, chunkcoordintpair, 33 + ChunkStatus.getDistance(ChunkStatus.LIGHT), chunkcoordintpair);
             }
 
-            Optional<ChunkAccess> optional = ((Either) holder.getOrScheduleFuture(requiredStatus.getParent(), this).getNow(ChunkHolder.UNLOADED_CHUNK)).left();
+            // Paper - revert 1.17 chunk system changes
 
             if (optional.isPresent() && ((ChunkAccess) optional.get()).getStatus().isOrAfter(requiredStatus)) {
                 CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = requiredStatus.load(this.level, this.structureTemplateManager, this.lightEngine, (ichunkaccess) -> {
@@ -749,6 +807,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             } else {
                 return this.scheduleChunkGeneration(holder, requiredStatus);
             }
+        }, this.mainThreadExecutor).thenComposeAsync(CompletableFuture::completedFuture, this.mainThreadExecutor); // Paper - revert 1.17 chunk system changes
         }
     }
 
@@ -788,14 +847,24 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         };
 
         CompletableFuture<CompoundTag> chunkSaveFuture = this.level.asyncChunkTaskManager.getChunkSaveFuture(pos.x, pos.z);
+        // Paper start
+        ChunkHolder playerChunk = getUpdatingChunkIfPresent(pos.toLong());
+        int chunkPriority = playerChunk != null ? playerChunk.requestedPriority : 33;
+        int priority = com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY;
+
+        if (chunkPriority <= 10) {
+            priority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY;
+        } else if (chunkPriority <= 20) {
+            priority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGH_PRIORITY;
+        }
+        boolean isHighestPriority = priority == com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY;
+        // Paper end
         if (chunkSaveFuture != null) {
-            this.level.asyncChunkTaskManager.scheduleChunkLoad(pos.x, pos.z,
-                com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGH_PRIORITY, chunkHolderConsumer, false, chunkSaveFuture);
-            this.level.asyncChunkTaskManager.raisePriority(pos.x, pos.z, com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGH_PRIORITY);
+            this.level.asyncChunkTaskManager.scheduleChunkLoad(pos.x, pos.z, priority, chunkHolderConsumer, isHighestPriority, chunkSaveFuture); // Paper
         } else {
-            this.level.asyncChunkTaskManager.scheduleChunkLoad(pos.x, pos.z,
-                com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY, chunkHolderConsumer, false);
+            this.level.asyncChunkTaskManager.scheduleChunkLoad(pos.x, pos.z, priority, chunkHolderConsumer, isHighestPriority); // Paper
         }
+        this.level.asyncChunkTaskManager.raisePriority(pos.x, pos.z, priority); // Paper
         return ret;
         // Paper end - Async chunk io
     }
@@ -874,7 +943,10 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 this.releaseLightTicket(chunkcoordintpair);
                 return CompletableFuture.completedFuture(Either.right(playerchunk_failure));
             });
-        }, executor);
+        }, executor).thenComposeAsync((either) -> { // Paper start - force competion on the main thread
+            return CompletableFuture.completedFuture(either);
+        }, this.mainThreadExecutor); // use the main executor, we want to ensure only one chunk callback can be completed per runnable execute
+        // Paper end - force competion on the main thread
     }
 
     protected void releaseLightTicket(ChunkPos pos) {
@@ -957,7 +1029,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             long i = chunkHolder.getPos().toLong();
 
             Objects.requireNonNull(chunkHolder);
-            mailbox.tell(ChunkTaskPriorityQueueSorter.message(runnable, i, chunkHolder::getTicketLevel));
+            mailbox.tell(ChunkTaskPriorityQueueSorter.message(runnable, i, () -> 1)); // Paper - final loads are always urgent!
         });
     }
 
diff --git a/src/main/java/net/minecraft/server/level/DistanceManager.java b/src/main/java/net/minecraft/server/level/DistanceManager.java
index 1d6ab658c48bb765f66624f276ec7b05cf33c1d5..b9b56068cdacd984f873cfb2a06a312e9912893d 100644
--- a/src/main/java/net/minecraft/server/level/DistanceManager.java
+++ b/src/main/java/net/minecraft/server/level/DistanceManager.java
@@ -114,6 +114,7 @@ public abstract class DistanceManager {
     }
 
     private static int getTicketLevelAt(SortedArraySet<Ticket<?>> tickets) {
+        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::getTicketLevelAt"); // Paper
         return !tickets.isEmpty() ? ((Ticket) tickets.first()).getTicketLevel() : ChunkMap.MAX_CHUNK_DISTANCE + 1;
     }
 
@@ -128,6 +129,7 @@ public abstract class DistanceManager {
     public boolean runAllUpdates(ChunkMap chunkStorage) {
         this.naturalSpawnChunkCounter.runAllUpdates();
         this.tickingTicketsTracker.runAllUpdates();
+        org.spigotmc.AsyncCatcher.catchOp("DistanceManagerTick"); // Paper
         this.playerTicketManager.runAllUpdates();
         int i = Integer.MAX_VALUE - this.ticketTracker.runDistanceUpdates(Integer.MAX_VALUE);
         boolean flag = i != 0;
@@ -138,11 +140,13 @@ public abstract class DistanceManager {
 
         // Paper start
         if (!this.pendingChunkUpdates.isEmpty()) {
+            this.pollingPendingChunkUpdates = true; try { // Paper - Chunk priority
             while(!this.pendingChunkUpdates.isEmpty()) {
                 ChunkHolder remove = this.pendingChunkUpdates.remove();
                 remove.isUpdateQueued = false;
                 remove.updateFutures(chunkStorage, this.mainThreadExecutor);
             }
+            } finally { this.pollingPendingChunkUpdates = false; } // Paper - Chunk priority
             // Paper end
             return true;
         } else {
@@ -178,8 +182,10 @@ public abstract class DistanceManager {
             return flag;
         }
     }
+    boolean pollingPendingChunkUpdates = false; // Paper - Chunk priority
 
     boolean addTicket(long i, Ticket<?> ticket) { // CraftBukkit - void -> boolean
+        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::addTicket"); // Paper
         SortedArraySet<Ticket<?>> arraysetsorted = this.getTickets(i);
         int j = DistanceManager.getTicketLevelAt(arraysetsorted);
         Ticket<?> ticket1 = (Ticket) arraysetsorted.addOrGet(ticket);
@@ -193,7 +199,9 @@ public abstract class DistanceManager {
     }
 
     boolean removeTicket(long i, Ticket<?> ticket) { // CraftBukkit - void -> boolean
+        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::removeTicket"); // Paper
         SortedArraySet<Ticket<?>> arraysetsorted = this.getTickets(i);
+        int oldLevel = getTicketLevelAt(arraysetsorted); // Paper
 
         boolean removed = false; // CraftBukkit
         if (arraysetsorted.remove(ticket)) {
@@ -225,7 +233,12 @@ public abstract class DistanceManager {
             this.tickets.remove(i);
         }
 
-        this.ticketTracker.update(i, DistanceManager.getTicketLevelAt(arraysetsorted), false);
+        // Paper start - Chunk priority
+        int newLevel = getTicketLevelAt(arraysetsorted);
+        if (newLevel > oldLevel) {
+            this.ticketTracker.update(i, newLevel, false);
+        }
+        // Paper end
         return removed; // CraftBukkit
     }
 
@@ -275,6 +288,112 @@ public abstract class DistanceManager {
         });
     }
 
+    // Paper start - Chunk priority
+    public static final int PRIORITY_TICKET_LEVEL = ChunkMap.MAX_CHUNK_DISTANCE;
+    public static final int URGENT_PRIORITY = 29;
+    public boolean delayDistanceManagerTick = false;
+    public boolean markUrgent(ChunkPos coords) {
+        return addPriorityTicket(coords, TicketType.URGENT, URGENT_PRIORITY);
+    }
+    public boolean markHighPriority(ChunkPos coords, int priority) {
+        priority = Math.min(URGENT_PRIORITY - 1, Math.max(1, priority));
+        return addPriorityTicket(coords, TicketType.PRIORITY, priority);
+    }
+
+    public void markAreaHighPriority(ChunkPos center, int priority, int radius) {
+        delayDistanceManagerTick = true;
+        priority = Math.min(URGENT_PRIORITY - 1, Math.max(1, priority));
+        int finalPriority = priority;
+        net.minecraft.server.MCUtil.getSpiralOutChunks(center.getWorldPosition(), radius).forEach(coords -> {
+            addPriorityTicket(coords, TicketType.PRIORITY, finalPriority);
+        });
+        delayDistanceManagerTick = false;
+        chunkMap.level.getChunkSource().runDistanceManagerUpdates();
+    }
+
+    public void clearAreaPriorityTickets(ChunkPos center, int radius) {
+        delayDistanceManagerTick = true;
+        net.minecraft.server.MCUtil.getSpiralOutChunks(center.getWorldPosition(), radius).forEach(coords -> {
+            this.removeTicket(coords.toLong(), new Ticket<ChunkPos>(TicketType.PRIORITY, PRIORITY_TICKET_LEVEL, coords));
+        });
+        delayDistanceManagerTick = false;
+        chunkMap.level.getChunkSource().runDistanceManagerUpdates();
+    }
+
+    private boolean addPriorityTicket(ChunkPos coords, TicketType<ChunkPos> ticketType, int priority) {
+        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::addPriorityTicket");
+        long pair = coords.toLong();
+        ChunkHolder chunk = chunkMap.getUpdatingChunkIfPresent(pair);
+        if ((chunk != null && chunk.isFullChunkReady())) {
+            return false;
+        }
+
+        boolean success;
+        if (!(success = updatePriorityTicket(coords, ticketType, priority))) {
+            Ticket<ChunkPos> ticket = new Ticket<ChunkPos>(ticketType, PRIORITY_TICKET_LEVEL, coords);
+            ticket.priority = priority;
+            success = this.addTicket(pair, ticket);
+        } else {
+            if (chunk == null) {
+                chunk = chunkMap.getUpdatingChunkIfPresent(pair);
+            }
+            chunkMap.queueHolderUpdate(chunk);
+        }
+
+        //chunkMap.world.getWorld().spawnParticle(priority <= 15 ? org.bukkit.Particle.EXPLOSION_HUGE : org.bukkit.Particle.EXPLOSION_NORMAL, chunkMap.world.getWorld().getPlayers(), null, coords.x << 4, 70, coords.z << 4, 2, 0, 0, 0, 1, null, true);
+
+        chunkMap.level.getChunkSource().runDistanceManagerUpdates();
+
+        return success;
+    }
+
+    private boolean updatePriorityTicket(ChunkPos coords, TicketType<ChunkPos> type, int priority) {
+        SortedArraySet<Ticket<?>> tickets = this.tickets.get(coords.toLong());
+        if (tickets == null) {
+            return false;
+        }
+        for (Ticket<?> ticket : tickets) {
+            if (ticket.getType() == type) {
+                // We only support increasing, not decreasing, too complicated
+                ticket.setCreatedTick(this.ticketTickCounter);
+                ticket.priority = Math.max(ticket.priority, priority);
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    public int getChunkPriority(ChunkPos coords) {
+        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::getChunkPriority");
+        SortedArraySet<Ticket<?>> tickets = this.tickets.get(coords.toLong());
+        if (tickets == null) {
+            return 0;
+        }
+        for (Ticket<?> ticket : tickets) {
+            if (ticket.getType() == TicketType.URGENT) {
+                return URGENT_PRIORITY;
+            }
+        }
+        for (Ticket<?> ticket : tickets) {
+            if (ticket.getType() == TicketType.PRIORITY && ticket.priority > 0) {
+                return ticket.priority;
+            }
+        }
+        return 0;
+    }
+
+    public void clearPriorityTickets(ChunkPos coords) {
+        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::clearPriority");
+        this.removeTicket(coords.toLong(), new Ticket<ChunkPos>(TicketType.PRIORITY, PRIORITY_TICKET_LEVEL, coords));
+    }
+
+    public void clearUrgent(ChunkPos coords) {
+        org.spigotmc.AsyncCatcher.catchOp("ChunkMapDistance::clearUrgent");
+        this.removeTicket(coords.toLong(), new Ticket<ChunkPos>(TicketType.URGENT, PRIORITY_TICKET_LEVEL, coords));
+    }
+    // Paper end
+
     protected void updateChunkForced(ChunkPos pos, boolean forced) {
         Ticket<ChunkPos> ticket = new Ticket<>(TicketType.FORCED, 31, pos);
         long i = pos.toLong();
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 3ff5e35e45a71dc03552dedb65c7338317e9d0a9..2400212e65c72d3ce6604b3cf200db0ae7032f2a 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -407,6 +407,30 @@ public class ServerChunkCache extends ChunkSource {
             return CompletableFuture.completedFuture(either);
         }, this.mainThreadProcessor);
     }
+
+    public boolean markUrgent(ChunkPos coords) {
+        return this.distanceManager.markUrgent(coords);
+    }
+
+    public boolean markHighPriority(ChunkPos coords, int priority) {
+        return this.distanceManager.markHighPriority(coords, priority);
+    }
+
+    public void markAreaHighPriority(ChunkPos center, int priority, int radius) {
+        this.distanceManager.markAreaHighPriority(center, priority, radius);
+    }
+
+    public void clearAreaPriorityTickets(ChunkPos center, int radius) {
+        this.distanceManager.clearAreaPriorityTickets(center, radius);
+    }
+
+    public void clearPriorityTickets(ChunkPos coords) {
+        this.distanceManager.clearPriorityTickets(coords);
+    }
+
+    public void clearUrgent(ChunkPos coords) {
+        this.distanceManager.clearUrgent(coords);
+    }
     // Paper end - async chunk io
 
     @Nullable
@@ -441,6 +465,8 @@ public class ServerChunkCache extends ChunkSource {
             Objects.requireNonNull(completablefuture);
             if (!completablefuture.isDone()) { // Paper
                 // Paper start - async chunk io/loading
+                ChunkPos pair = new ChunkPos(x1, z1); // Paper - Chunk priority
+                this.distanceManager.markUrgent(pair); // Paper - Chunk priority
                 this.level.asyncChunkTaskManager.raisePriority(x1, z1, com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY);
                 com.destroystokyo.paper.io.chunk.ChunkTaskManager.pushChunkWait(this.level, x1, z1);
                 // Paper end
@@ -448,6 +474,8 @@ public class ServerChunkCache extends ChunkSource {
             chunkproviderserver_b.managedBlock(completablefuture::isDone);
                 com.destroystokyo.paper.io.chunk.ChunkTaskManager.popChunkWait(); // Paper - async chunk debug
                 this.level.timings.syncChunkLoad.stopTiming(); // Paper
+                this.distanceManager.clearPriorityTickets(pair); // Paper - Chunk priority
+                this.distanceManager.clearUrgent(pair); // Paper - Chunk priority
             } // Paper
             ichunkaccess = (ChunkAccess) ((Either) completablefuture.join()).map((ichunkaccess1) -> {
                 return ichunkaccess1;
@@ -553,10 +581,12 @@ public class ServerChunkCache extends ChunkSource {
         if (create && !currentlyUnloading) {
             // CraftBukkit end
             this.distanceManager.addTicket(TicketType.UNKNOWN, chunkcoordintpair, l, chunkcoordintpair);
+            if (isUrgent) this.distanceManager.markUrgent(chunkcoordintpair); // Paper - Chunk priority
             if (this.chunkAbsent(playerchunk, l)) {
                 ProfilerFiller gameprofilerfiller = this.level.getProfiler();
 
                 gameprofilerfiller.push("chunkLoad");
+                distanceManager.delayDistanceManagerTick = false; // Paper - Chunk priority - ensure this is never false
                 this.runDistanceManagerUpdates();
                 playerchunk = this.getVisibleChunkIfPresent(k);
                 gameprofilerfiller.pop();
@@ -566,7 +596,13 @@ public class ServerChunkCache extends ChunkSource {
             }
         }
 
-        return this.chunkAbsent(playerchunk, l) ? ChunkHolder.UNLOADED_CHUNK_FUTURE : playerchunk.getOrScheduleFuture(leastStatus, this.chunkMap);
+        // Paper start - Chunk priority
+        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = this.chunkAbsent(playerchunk, l) ? ChunkHolder.UNLOADED_CHUNK_FUTURE : playerchunk.getOrScheduleFuture(leastStatus, this.chunkMap);
+        if (isUrgent) {
+            future.thenAccept(either -> this.distanceManager.clearUrgent(chunkcoordintpair));
+        }
+        return future;
+        // Paper end
     }
 
     private boolean chunkAbsent(@Nullable ChunkHolder holder, int maxLevel) {
@@ -618,6 +654,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public boolean runDistanceManagerUpdates() {
+        if (distanceManager.delayDistanceManagerTick) return false; // Paper - Chunk priority
         boolean flag = this.distanceManager.runAllUpdates(this.chunkMap);
         boolean flag1 = this.chunkMap.promoteChunkMap();
 
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 9ab4588e4e512176b881ad4c252e400ff6ea97bd..4adf2d503015cac85b12fbaae833b33eeeb44403 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -191,6 +191,7 @@ public class ServerPlayer extends Player {
     private int lastRecordedArmor = Integer.MIN_VALUE;
     private int lastRecordedLevel = Integer.MIN_VALUE;
     private int lastRecordedExperience = Integer.MIN_VALUE;
+    public boolean isRealPlayer; // Paper - chunk priority
     private float lastSentHealth = -1.0E8F;
     private int lastSentFood = -99999999;
     private boolean lastFoodSaturationZero = true;
@@ -318,6 +319,21 @@ public class ServerPlayer extends Player {
         this.bukkitPickUpLoot = true;
         this.maxHealthCache = this.getMaxHealth();
     }
+    // Paper start - Chunk priority
+    public BlockPos getPointInFront(double inFront) {
+        double rads = Math.toRadians(net.minecraft.server.MCUtil.normalizeYaw(this.yRot + 90)); // MC rotates yaw 90 for some odd reason
+        final double x = getX() + inFront * Math.cos(rads);
+        final double z = getZ() + inFront * Math.sin(rads);
+        return new BlockPos(x, getY(), z);
+    }
+
+    public ChunkPos getChunkInFront(double inFront) {
+        double rads = Math.toRadians(net.minecraft.server.MCUtil.normalizeYaw(this.yRot + 90)); // MC rotates yaw 90 for some odd reason
+        final double x = getX() + (inFront * 16) * Math.cos(rads);
+        final double z = getZ() + (inFront * 16) * Math.sin(rads);
+        return new ChunkPos(Mth.floor(x) >> 4, Mth.floor(z) >> 4);
+    }
+    // Paper end
 
     // Yes, this doesn't match Vanilla, but it's the best we can do for now.
     // If this is an issue, PRs are welcome
diff --git a/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java b/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java
index 5b238e41ffa3e374b52ee955cb39087571c6ffc2..5539f2a7e069cbe98997b734f3b1cd498148f09b 100644
--- a/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java
+++ b/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java
@@ -26,15 +26,140 @@ import org.slf4j.Logger;
 public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCloseable {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final ProcessorMailbox<Runnable> taskMailbox;
-    private final ObjectList<Pair<ThreadedLevelLightEngine.TaskType, Runnable>> lightTasks = new ObjectArrayList<>();
-    private final ChunkMap chunkMap;
+    // Paper start
+    private static final int MAX_PRIORITIES = ChunkMap.MAX_CHUNK_DISTANCE + 2;
+
+    static class ChunkLightQueue {
+        public boolean shouldFastUpdate;
+        java.util.ArrayDeque<Runnable> pre = new java.util.ArrayDeque<Runnable>();
+        java.util.ArrayDeque<Runnable> post = new java.util.ArrayDeque<Runnable>();
+
+        ChunkLightQueue(long chunk) {}
+    }
+
+    static class PendingLightTask {
+        long chunkId;
+        IntSupplier priority;
+        Runnable pre;
+        Runnable post;
+        boolean fastUpdate;
+
+        public PendingLightTask(long chunkId, IntSupplier priority, Runnable pre, Runnable post, boolean fastUpdate) {
+            this.chunkId = chunkId;
+            this.priority = priority;
+            this.pre = pre;
+            this.post = post;
+            this.fastUpdate = fastUpdate;
+        }
+    }
+
+
+    // Retain the chunks priority level for queued light tasks
+    class LightQueue {
+        private int size = 0;
+        private final it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap<ChunkLightQueue>[] buckets = new it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap[MAX_PRIORITIES];
+        private final java.util.concurrent.ConcurrentLinkedQueue<PendingLightTask> pendingTasks = new java.util.concurrent.ConcurrentLinkedQueue<>();
+        private final java.util.concurrent.ConcurrentLinkedQueue<Runnable> priorityChanges = new java.util.concurrent.ConcurrentLinkedQueue<>();
+
+        private LightQueue() {
+            for (int i = 0; i < buckets.length; i++) {
+                buckets[i] = new it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap<>();
+            }
+        }
+
+        public void changePriority(long pair, int currentPriority, int priority) {
+            this.priorityChanges.add(() -> {
+                ChunkLightQueue remove = this.buckets[currentPriority].remove(pair);
+                if (remove != null) {
+                    ChunkLightQueue existing = this.buckets[Math.max(1, priority)].put(pair, remove);
+                    if (existing != null) {
+                        remove.pre.addAll(existing.pre);
+                        remove.post.addAll(existing.post);
+                    }
+                }
+            });
+        }
+
+        public final void addChunk(long chunkId, IntSupplier priority, Runnable pre, Runnable post) {
+            pendingTasks.add(new PendingLightTask(chunkId, priority, pre, post, true));
+            tryScheduleUpdate();
+        }
+
+        public final void add(long chunkId, IntSupplier priority, ThreadedLevelLightEngine.TaskType type, Runnable run) {
+            pendingTasks.add(new PendingLightTask(chunkId, priority, type == TaskType.PRE_UPDATE ? run : null, type == TaskType.POST_UPDATE ? run : null, false));
+        }
+        public final void add(PendingLightTask update) {
+            int priority = update.priority.getAsInt();
+            ChunkLightQueue lightQueue = this.buckets[priority].computeIfAbsent(update.chunkId, ChunkLightQueue::new);
+
+            if (update.pre != null) {
+                this.size++;
+                lightQueue.pre.add(update.pre);
+            }
+            if (update.post != null) {
+                this.size++;
+                lightQueue.post.add(update.post);
+            }
+            if (update.fastUpdate) {
+                lightQueue.shouldFastUpdate = true;
+            }
+        }
+
+        public final boolean isEmpty() {
+            return this.size == 0 && this.pendingTasks.isEmpty();
+        }
+
+        public final int size() {
+            return this.size;
+        }
+
+        public boolean poll(java.util.List<Runnable> pre, java.util.List<Runnable> post) {
+            PendingLightTask pending;
+            while ((pending = pendingTasks.poll()) != null) {
+                add(pending);
+            }
+            Runnable run;
+            while ((run = priorityChanges.poll()) != null) {
+                run.run();
+            }
+            boolean hasWork = false;
+            it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap<ChunkLightQueue>[] buckets = this.buckets;
+            int priority = 0;
+            while (priority < MAX_PRIORITIES && !isEmpty()) {
+                it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap<ChunkLightQueue> bucket = buckets[priority];
+                if (bucket.isEmpty()) {
+                    priority++;
+                    if (hasWork) {
+                        return true;
+                    } else {
+                        continue;
+                    }
+                }
+                ChunkLightQueue queue = bucket.removeFirst();
+                this.size -= queue.pre.size() + queue.post.size();
+                pre.addAll(queue.pre);
+                post.addAll(queue.post);
+                queue.pre.clear();
+                queue.post.clear();
+                hasWork = true;
+                if (queue.shouldFastUpdate) {
+                    return true;
+                }
+            }
+            return hasWork;
+        }
+    }
+
+    final LightQueue queue = new LightQueue();
+    // Paper end
+    private final ChunkMap chunkMap; private final ChunkMap playerChunkMap; // Paper
     private final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> sorterMailbox;
     private volatile int taskPerBatch = 5;
     private final AtomicBoolean scheduled = new AtomicBoolean();
 
     public ThreadedLevelLightEngine(LightChunkGetter chunkProvider, ChunkMap chunkStorage, boolean hasBlockLight, ProcessorMailbox<Runnable> processor, ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> executor) {
         super(chunkProvider, true, hasBlockLight);
-        this.chunkMap = chunkStorage;
+        this.chunkMap = chunkStorage; this.playerChunkMap = chunkMap; // Paper
         this.sorterMailbox = executor;
         this.taskMailbox = processor;
     }
@@ -120,13 +245,9 @@ public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCl
     }
 
     private void addTask(int x, int z, IntSupplier completedLevelSupplier, ThreadedLevelLightEngine.TaskType stage, Runnable task) {
-        this.sorterMailbox.tell(ChunkTaskPriorityQueueSorter.message(() -> {
-            this.lightTasks.add(Pair.of(stage, task));
-            if (this.lightTasks.size() >= this.taskPerBatch) {
-                this.runUpdate();
-            }
-
-        }, ChunkPos.asLong(x, z), completedLevelSupplier));
+        // Paper start - replace method
+        this.queue.add(ChunkPos.asLong(x, z), completedLevelSupplier, stage, task);
+        // Paper end
     }
 
     @Override
@@ -154,8 +275,14 @@ public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCl
 
     public CompletableFuture<ChunkAccess> lightChunk(ChunkAccess chunk, boolean excludeBlocks) {
         ChunkPos chunkPos = chunk.getPos();
-        chunk.setLightCorrect(false);
-        this.addTask(chunkPos.x, chunkPos.z, ThreadedLevelLightEngine.TaskType.PRE_UPDATE, Util.name(() -> {
+        // Paper start
+        //ichunkaccess.b(false); // Don't need to disable this
+        long pair = chunkPos.toLong();
+        CompletableFuture<ChunkAccess> future = new CompletableFuture<>();
+        IntSupplier prioritySupplier = playerChunkMap.getChunkQueueLevel(pair);
+        boolean[] skippedPre = {false};
+        this.queue.addChunk(pair, prioritySupplier, Util.name(() -> {
+            // Paper end
             LevelChunkSection[] levelChunkSections = chunk.getSections();
 
             for(int i = 0; i < chunk.getSectionsCount(); ++i) {
@@ -175,51 +302,45 @@ public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCl
 
         }, () -> {
             return "lightChunk " + chunkPos + " " + excludeBlocks;
-        }));
-        return CompletableFuture.supplyAsync(() -> {
+            // Paper start  - merge the 2 together
+        }), () -> {
+            this.chunkMap.releaseLightTicket(chunkPos); // Paper - moved from below, we want to call this even when returning early
+            if (skippedPre[0]) return; // Paper - future's already complete
             chunk.setLightCorrect(true);
             super.retainData(chunkPos, false);
-            this.chunkMap.releaseLightTicket(chunkPos);
-            return chunk;
-        }, (runnable) -> {
-            this.addTask(chunkPos.x, chunkPos.z, ThreadedLevelLightEngine.TaskType.POST_UPDATE, runnable);
+            //this.chunkMap.releaseLightTicket(chunkPos); // Paper - moved up
+            future.complete(chunk);
         });
+        return future;
+        // Paper end
     }
 
     public void tryScheduleUpdate() {
-        if ((!this.lightTasks.isEmpty() || super.hasLightWork()) && this.scheduled.compareAndSet(false, true)) {
+        if ((!this.queue.isEmpty() || super.hasLightWork()) && this.scheduled.compareAndSet(false, true)) { // Paper
             this.taskMailbox.tell(() -> {
                 this.runUpdate();
                 this.scheduled.set(false);
+                tryScheduleUpdate(); // Paper - if we still have work to do, do it!
             });
         }
 
     }
 
+    // Paper start - replace impl
+    private final java.util.List<Runnable> pre = new java.util.ArrayList<>();
+    private final java.util.List<Runnable> post = new java.util.ArrayList<>();
     private void runUpdate() {
-        int i = Math.min(this.lightTasks.size(), this.taskPerBatch);
-        ObjectListIterator<Pair<ThreadedLevelLightEngine.TaskType, Runnable>> objectListIterator = this.lightTasks.iterator();
-
-        int j;
-        for(j = 0; objectListIterator.hasNext() && j < i; ++j) {
-            Pair<ThreadedLevelLightEngine.TaskType, Runnable> pair = objectListIterator.next();
-            if (pair.getFirst() == ThreadedLevelLightEngine.TaskType.PRE_UPDATE) {
-                pair.getSecond().run();
-            }
+        if (queue.poll(pre, post)) {
+            pre.forEach(Runnable::run);
+            pre.clear();
+            super.runUpdates(Integer.MAX_VALUE, true, true);
+            post.forEach(Runnable::run);
+            post.clear();
+        } else {
+            // might have level updates to go still
+            super.runUpdates(Integer.MAX_VALUE, true, true);
         }
-
-        objectListIterator.back(j);
-        super.runUpdates(Integer.MAX_VALUE, true, true);
-
-        for(int var5 = 0; objectListIterator.hasNext() && var5 < i; ++var5) {
-            Pair<ThreadedLevelLightEngine.TaskType, Runnable> pair2 = objectListIterator.next();
-            if (pair2.getFirst() == ThreadedLevelLightEngine.TaskType.POST_UPDATE) {
-                pair2.getSecond().run();
-            }
-
-            objectListIterator.remove();
-        }
-
+        // Paper end
     }
 
     public void setTaskPerBatch(int taskBatchSize) {
diff --git a/src/main/java/net/minecraft/server/level/Ticket.java b/src/main/java/net/minecraft/server/level/Ticket.java
index f1128f0d4a9a0241ac6c9bc18dd13b431c616bb1..2b2b7851d5f68bcdb41d58bcc64740ba58bf1ef4 100644
--- a/src/main/java/net/minecraft/server/level/Ticket.java
+++ b/src/main/java/net/minecraft/server/level/Ticket.java
@@ -8,6 +8,7 @@ public final class Ticket<T> implements Comparable<Ticket<?>> {
     public final T key;
     public long createdTick;
     public long delayUnloadBy; // Paper
+    public int priority; // Paper - Chunk priority
 
     protected Ticket(TicketType<T> type, int level, T argument) {
         this.type = type;
diff --git a/src/main/java/net/minecraft/server/level/TicketType.java b/src/main/java/net/minecraft/server/level/TicketType.java
index 10fa6cec911950f72407ae7f45c8cf48caa9421a..478109526cff7ceb0565cea3b5e97b9a07fbf8d1 100644
--- a/src/main/java/net/minecraft/server/level/TicketType.java
+++ b/src/main/java/net/minecraft/server/level/TicketType.java
@@ -9,6 +9,8 @@ import net.minecraft.world.level.ChunkPos;
 public class TicketType<T> {
     public static final TicketType<Long> FUTURE_AWAIT = create("future_await", Long::compareTo); // Paper
     public static final TicketType<Long> ASYNC_LOAD = create("async_load", Long::compareTo); // Paper
+    public static final TicketType<ChunkPos> PRIORITY = create("priority", Comparator.comparingLong(ChunkPos::toLong), 300); // Paper
+    public static final TicketType<ChunkPos> URGENT = create("urgent", Comparator.comparingLong(ChunkPos::toLong), 300); // Paper
 
     private final String name;
     private final Comparator<T> comparator;
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 5833cc3d5014dad82607afc4d643b6bed885be64..8e0f73dcef189442450b4518437fb3a1c34b9a47 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -177,6 +177,7 @@ public abstract class PlayerList {
     }
 
     public void placeNewPlayer(Connection connection, ServerPlayer player) {
+        player.isRealPlayer = true; // Paper - Chunk priority
         GameProfile gameprofile = player.getGameProfile();
         GameProfileCache usercache = this.server.getProfileCache();
         Optional<GameProfile> optional = usercache.get(gameprofile.getId());
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 47a05aa42739f4cfce828c0de42b4f1da467093e..70c338f5bf605d2f51a21670634c716177cd6f97 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -212,7 +212,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     private BlockPos blockPosition;
     private ChunkPos chunkPosition;
     private Vec3 deltaMovement;
-    private float yRot;
+    public float yRot; // Paper - private->public
     private float xRot;
     public float yRotO;
     public float xRotO;
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 58a245b2ca6e65d491694142ad04d38236b46434..893051059df51133a127b0870e27ab67461052fa 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -134,7 +134,7 @@ public class LevelChunk extends ChunkAccess {
         return NEIGHBOUR_CACHE_RADIUS;
     }
 
-    boolean loadedTicketLevel;
+    boolean loadedTicketLevel; public final boolean wasLoadCallbackInvoked() { return this.loadedTicketLevel; } // Paper - public accessor
     private long neighbourChunksLoadedBitset;
     private final LevelChunk[] loadedNeighbourChunks = new LevelChunk[(NEIGHBOUR_CACHE_RADIUS * 2 + 1) * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)];
 
@@ -653,6 +653,7 @@ public class LevelChunk extends ChunkAccess {
 
     // CraftBukkit start
     public void loadCallback() {
+        if (this.loadedTicketLevel) { LOGGER.error("Double calling chunk load!", new Throwable()); } // Paper
         // Paper start - neighbour cache
         int chunkX = this.chunkPos.x;
         int chunkZ = this.chunkPos.z;
@@ -707,6 +708,7 @@ public class LevelChunk extends ChunkAccess {
     }
 
     public void unloadCallback() {
+        if (!this.loadedTicketLevel) { LOGGER.error("Double calling chunk unload!", new Throwable()); } // Paper
         org.bukkit.Server server = this.level.getCraftServer();
         org.bukkit.event.world.ChunkUnloadEvent unloadEvent = new org.bukkit.event.world.ChunkUnloadEvent(this.bukkitChunk, this.isUnsaved());
         server.getPluginManager().callEvent(unloadEvent);

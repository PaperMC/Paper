From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Potrebic <jake.m.potrebic@gmail.com>
Date: Sat, 27 Apr 2024 20:56:17 -0700
Subject: [PATCH] General ItemMeta fixes

== AT ==
private-f net/minecraft/world/item/ItemStack components
public net/minecraft/world/food/FoodProperties DEFAULT_EAT_SECONDS
public org/bukkit/craftbukkit/block/CraftBlockStates getBlockState(Lorg/bukkit/World;Lnet/minecraft/core/BlockPos;Lnet/minecraft/world/level/block/state/BlockState;Lnet/minecraft/world/level/block/entity/BlockEntity;)Lorg/bukkit/craftbukkit/block/CraftBlockState;
public net/minecraft/world/level/block/entity/BlockEntity saveId(Lnet/minecraft/nbt/CompoundTag;)V

Co-authored-by: GhastCraftHD <julius.gruenberg@leghast.de>

diff --git a/src/main/java/net/minecraft/world/item/ItemStack.java b/src/main/java/net/minecraft/world/item/ItemStack.java
index 486c3769a0e6a1ecb5530a35e2591f78776619b9..b800b03ae034b276740c3b41555a52b778ad9aad 100644
--- a/src/main/java/net/minecraft/world/item/ItemStack.java
+++ b/src/main/java/net/minecraft/world/item/ItemStack.java
@@ -1275,6 +1275,11 @@ public final class ItemStack implements DataComponentHolder {
     public void setItem(Item item) {
         this.bukkitStack = null; // Paper
         this.item = item;
+        // Paper start - change base component prototype
+        final DataComponentPatch patch = this.getComponentsPatch();
+        this.components = new PatchedDataComponentMap(this.item.components());
+        this.applyComponents(patch);
+        // Paper end - change base component prototype
     }
     // CraftBukkit end
 
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
index 6207c6063cd11ccb1177fe7016c49c02a3416990..cd3b952a228c09077c2e74183a34ddb32811280b 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
@@ -139,6 +139,11 @@ public abstract class BlockEntity {
         CompoundTag nbttagcompound = new CompoundTag();
 
         this.saveAdditional(nbttagcompound, registryLookup);
+        // Paper start - store PDC here as well
+        if (this.persistentDataContainer != null && !this.persistentDataContainer.isEmpty()) {
+            nbttagcompound.put("PublicBukkitValues", this.persistentDataContainer.toTagCompound());
+        }
+        // Paper end
         return nbttagcompound;
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
index e28bc898786542f695017ff0a036676840eb79fe..cee3fe00cc662f095e7d726b5f1a913cd8199210 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
@@ -135,6 +135,19 @@ public abstract class CraftBlockEntityState<T extends BlockEntity> extends Craft
         return nbt;
     }
 
+    // Paper start - properly save blockentity itemstacks
+    public CompoundTag getSnapshotCustomNbtOnly() {
+        this.applyTo(this.snapshot);
+        final CompoundTag nbt = this.snapshot.saveCustomOnly(this.getRegistryAccess());
+        this.snapshot.removeComponentsFromTag(nbt);
+        if (!nbt.isEmpty()) {
+            // have to include the "id" if it's going to have block entity data
+            this.snapshot.saveId(nbt);
+        }
+        return nbt;
+    }
+    // Paper end
+
     // copies the data of the given tile entity to this block state
     protected void load(T tileEntity) {
         if (tileEntity != null && tileEntity != this.snapshot) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
index 7672128ecca3052f2dc422349a863484c301310e..be36336a3c7d1ae88277f4ee1be70075001de7a7 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
@@ -339,7 +339,14 @@ public final class CraftItemStack extends ItemStack {
     // Paper end - improve handled tags on type change
     // Paper start
     public static void applyMetaToItem(net.minecraft.world.item.ItemStack itemStack, ItemMeta itemMeta) {
-        final CraftMetaItem.Applicator tag = new CraftMetaItem.Applicator();
+        // Paper start - support updating profile after resolving it
+        final CraftMetaItem.Applicator tag = new CraftMetaItem.Applicator() {
+            @Override
+            void skullCallback(final com.mojang.authlib.GameProfile gameProfile) {
+                itemStack.set(DataComponents.PROFILE, new net.minecraft.world.item.component.ResolvableProfile(gameProfile));
+            }
+        };
+        // Paper end - support updating profile after resolving it
         ((CraftMetaItem) itemMeta).applyToItem(tag);
         itemStack.applyComponents(tag.build());
     }
@@ -387,15 +394,20 @@ public final class CraftItemStack extends ItemStack {
         if (itemMeta == null) return true;
 
         if (!((CraftMetaItem) itemMeta).isEmpty()) {
-            CraftMetaItem.Applicator tag = new CraftMetaItem.Applicator();
+            // Paper start - support updating profile after resolving it
+            CraftMetaItem.Applicator tag = new CraftMetaItem.Applicator() {
+                @Override
+                void skullCallback(final com.mojang.authlib.GameProfile gameProfile) {
+                    item.set(DataComponents.PROFILE, new net.minecraft.world.item.component.ResolvableProfile(gameProfile));
+                }
+            };
+            // Paper end - support updating profile after resolving it
 
             ((CraftMetaItem) itemMeta).applyToItem(tag);
-            item.restorePatch(tag.build());
-        }
-        // SpigotCraft#463 this is required now by the Vanilla client, so mimic ItemStack constructor in ensuring it
-        if (item.getItem() != null && item.getMaxDamage() > 0) {
-            item.setDamageValue(item.getDamageValue());
+            item.restorePatch(DataComponentPatch.EMPTY); // Paper - properly apply the new patch from itemmeta
+            item.applyComponents(tag.build()); // Paper - properly apply the new patch from itemmeta
         }
+        // Paper - this is no longer needed
 
         return true;
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaAxolotlBucket.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaAxolotlBucket.java
index 169fefb64e1af444f7c2efb1234cb6e7779fb717..cb49ff5c94f33f00f626a31d958d2025819d1da8 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaAxolotlBucket.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaAxolotlBucket.java
@@ -118,14 +118,13 @@ public class CraftMetaAxolotlBucket extends CraftMetaItem implements AxolotlBuck
 
     @Override
     public Axolotl.Variant getVariant() {
+        com.google.common.base.Preconditions.checkState(this.hasVariant(), "Variant is absent, check hasVariant first!"); // Paper - fix NPE
         return Axolotl.Variant.values()[this.variant];
     }
 
     @Override
     public void setVariant(Axolotl.Variant variant) {
-        if (variant == null) {
-            variant = Axolotl.Variant.LUCY;
-        }
+        com.google.common.base.Preconditions.checkArgument(variant != null, "Variant cannot be null!"); // Paper
         this.variant = variant.ordinal();
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBanner.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBanner.java
index 1c17fb294d83d99ae657eff6a8a986bf72c6ec47..b9d6a4a8f78a0e26d888b6bfdff25c3a3ac17e48 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBanner.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBanner.java
@@ -69,6 +69,7 @@ public class CraftMetaBanner extends CraftMetaItem implements BannerMeta {
     void applyToItem(CraftMetaItem.Applicator tag) {
         super.applyToItem(tag);
 
+        if (this.patterns.isEmpty()) return; // Paper - don't write empty patterns
         List<BannerPatternLayers.Layer> newPatterns = new ArrayList<>();
 
         for (Pattern p : this.patterns) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBlockState.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBlockState.java
index d7e5491cc0296563fb9fdf28d64b21a10c08ea4a..224ea52574b80bb087c5c62eaf1d46261c1252af 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBlockState.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBlockState.java
@@ -50,9 +50,24 @@ public class CraftMetaBlockState extends CraftMetaItem implements BlockStateMeta
 
     @ItemMetaKey.Specific(ItemMetaKey.Specific.To.NBT)
     static final ItemMetaKeyType<CustomData> BLOCK_ENTITY_TAG = new ItemMetaKeyType<>(DataComponents.BLOCK_ENTITY_DATA, "BlockEntityTag");
+    static final ItemMetaKey BLOCK_ENTITY_TAG_CUSTOM_DATA = new ItemMetaKey("block-entity-tag"); // Paper
+    static final ItemMetaKey BLOCK_ENTITY_COMPONENTS = new ItemMetaKey("block-entity-components"); // Paper
 
     final Material material;
-    private CraftBlockEntityState<?> blockEntityTag;
+    // Paper start - store data separately
+    DataComponentMap components;
+    CustomData blockEntityTag;
+    {
+        // this is because the fields are possibly assigned in the super constructor (via deserializeInternal)
+        // and a direct field initialization happens **after** the super constructor. So we only want to
+        // set them to empty if they weren't assigned by the super constructor (via deserializeInternal)
+        this.components = this.components != null ? this.components : DataComponentMap.EMPTY;
+        this.blockEntityTag = this.blockEntityTag != null ? this.blockEntityTag : CustomData.EMPTY;
+    }
+    private Material materialForBlockEntityType() {
+        return (this.material != Material.SHIELD) ? this.material : CraftMetaBlockState.shieldToBannerHack();
+    }
+    // Paper end
     private CompoundTag internalTag;
 
     CraftMetaBlockState(CraftMetaItem meta, Material material) {
@@ -61,41 +76,61 @@ public class CraftMetaBlockState extends CraftMetaItem implements BlockStateMeta
 
         if (!(meta instanceof CraftMetaBlockState)
                 || ((CraftMetaBlockState) meta).material != material) {
-            this.blockEntityTag = null;
+            // Paper start
+            this.components = DataComponentMap.EMPTY;
+            this.blockEntityTag = CustomData.EMPTY;
+            // Paper end
             return;
         }
 
         CraftMetaBlockState te = (CraftMetaBlockState) meta;
+        // Paper start
+        this.components = te.components;
         this.blockEntityTag = te.blockEntityTag;
+        // Paper end
     }
 
     CraftMetaBlockState(DataComponentPatch tag, Material material, final Set<DataComponentType<?>> extraHandledDcts) { // Paper
         super(tag, extraHandledDcts); // Paper
         this.material = material;
 
+        // Paper start - move to separate method to be re-called
+        this.updateBlockState(tag);
+    }
+
+    private void updateBlockState(final DataComponentPatch tag) {
+        // Paper end
         getOrEmpty(tag, CraftMetaBlockState.BLOCK_ENTITY_TAG).ifPresent((nbt) -> {
-            this.blockEntityTag = CraftMetaBlockState.getBlockState(material, nbt.copyTag());
+            this.blockEntityTag = nbt; // Paper
         });
 
         if (!tag.isEmpty()) {
-            CraftBlockEntityState<?> blockEntityTag = this.blockEntityTag;
-            if (blockEntityTag == null) {
-                blockEntityTag = CraftMetaBlockState.getBlockState(material, null);
-            }
-
-            // Convert to map
-            PatchedDataComponentMap map = new PatchedDataComponentMap(DataComponentMap.EMPTY);
-            map.applyPatch(tag);
-            // Apply
-            Set<DataComponentType<?>> applied = blockEntityTag.applyComponents(map, tag);
+            // Paper start - store data in a DataComponentMap to be used to construct CraftBlockEntityStates
+            final DataComponentMap.Builder map = DataComponentMap.builder();
+            final net.minecraft.world.level.block.entity.BlockEntity dummyBlockEntity = java.util.Objects.requireNonNull(
+                org.bukkit.craftbukkit.block.CraftBlockStates.createNewTileEntity(this.materialForBlockEntityType())
+            );
+
+            // we don't care about what's in here, all
+            // we want is to know which data component types are referenced
+            Set<DataComponentType<?>> applied = dummyBlockEntity.applyComponentsSet(DataComponentMap.EMPTY, DataComponentPatch.EMPTY);
+            // Paper end - store data in a DataComponentMap to be used to construct CraftBlockEntityStates
             // Mark applied components as handled
             for (DataComponentType<?> seen : applied) {
                 this.unhandledTags.clear(seen);
             }
             // Only set blockEntityTag if something was applied
             if (!applied.isEmpty()) {
-                this.blockEntityTag = blockEntityTag;
+                // Paper start
+                for (final DataComponentType type : applied) {
+                    if (CraftMetaItem.DEFAULT_HANDLED_DCTS.contains(type)) continue;
+                    getOrEmpty(tag, type).ifPresent(value -> {
+                        map.set(type, value);
+                    });
+                }
+                // Paper end
             }
+            this.components = map.build(); // Paper
         }
     }
 
@@ -108,7 +143,10 @@ public class CraftMetaBlockState extends CraftMetaItem implements BlockStateMeta
         } else {
             this.material = Material.AIR;
         }
-        this.blockEntityTag = CraftMetaBlockState.getBlockState(this.material, this.internalTag);
+        // Paper start
+        if (this.internalTag != null) { // legacy
+            this.setBlockState(CraftMetaBlockState.getBlockState(this.material, this.internalTag));
+        }
         this.internalTag = null;
     }
 
@@ -116,13 +154,21 @@ public class CraftMetaBlockState extends CraftMetaItem implements BlockStateMeta
     void applyToItem(CraftMetaItem.Applicator tag) {
         super.applyToItem(tag);
 
-        if (this.blockEntityTag != null) {
-            tag.put(CraftMetaBlockState.BLOCK_ENTITY_TAG, CustomData.of(this.blockEntityTag.getSnapshotNBTWithoutComponents()));
+        // Paper start - accurately replicate logic for creating ItemStack from BlockEntity
+        // taken from BlockEntity#saveToItem and BlockItem#setBlockEntityData
+        final CompoundTag nbt = this.blockEntityTag.copyTag();
+        if (nbt.contains("id", CraftMagicNumbers.NBT.TAG_STRING)) {
+            tag.put(CraftMetaBlockState.BLOCK_ENTITY_TAG, CustomData.of(nbt));
+        } else if (!nbt.isEmpty()) {
+            BlockEntity.addEntityType(nbt, java.util.Objects.requireNonNull(CraftBlockStates.getBlockEntityType(this.materialForBlockEntityType())));
+            tag.put(CraftMetaBlockState.BLOCK_ENTITY_TAG, CustomData.of(nbt));
+        }
 
-            for (TypedDataComponent<?> component : this.blockEntityTag.collectComponents()) {
-                tag.putIfAbsent(component);
-            }
+        for (final TypedDataComponent<?> component : this.components) {
+            if (CraftMetaItem.DEFAULT_HANDLED_DCTS.contains(component.type())) continue; // if the component type was already handled by CraftMetaItem, don't add it again
+            tag.builder.set(component);
         }
+        // Paper end
     }
 
     @Override
@@ -131,14 +177,29 @@ public class CraftMetaBlockState extends CraftMetaItem implements BlockStateMeta
 
         if (tag.contains(CraftMetaBlockState.BLOCK_ENTITY_TAG.NBT, CraftMagicNumbers.NBT.TAG_COMPOUND)) {
             this.internalTag = tag.getCompound(CraftMetaBlockState.BLOCK_ENTITY_TAG.NBT);
+            return; // Paper - if legacy, don't check anything else
+        }
+        // Paper start - new serialization format
+        if (tag.contains(CraftMetaBlockState.BLOCK_ENTITY_TAG_CUSTOM_DATA.NBT, CraftMagicNumbers.NBT.TAG_COMPOUND)) {
+            this.blockEntityTag = CustomData.of(tag.getCompound(CraftMetaBlockState.BLOCK_ENTITY_TAG_CUSTOM_DATA.NBT));
         }
+        if (tag.contains(CraftMetaBlockState.BLOCK_ENTITY_COMPONENTS.NBT, CraftMagicNumbers.NBT.TAG_COMPOUND)) {
+            this.components = DataComponentMap.CODEC.parse(org.bukkit.craftbukkit.CraftRegistry.getMinecraftRegistry().createSerializationContext(net.minecraft.nbt.NbtOps.INSTANCE), tag.getCompound(CraftMetaBlockState.BLOCK_ENTITY_COMPONENTS.NBT)).getOrThrow();
+        }
+        // Paper end - new serialization format
     }
 
     @Override
     void serializeInternal(final Map<String, Tag> internalTags) {
-        if (this.blockEntityTag != null) {
-            internalTags.put(CraftMetaBlockState.BLOCK_ENTITY_TAG.NBT, this.blockEntityTag.getSnapshotNBT());
+        // Paper start - new serialization format
+        if (!this.blockEntityTag.isEmpty()) {
+            internalTags.put(CraftMetaBlockState.BLOCK_ENTITY_TAG_CUSTOM_DATA.NBT, this.blockEntityTag.getUnsafe()); // unsafe because it's serialized right away
+        }
+        if (!this.components.isEmpty()) {
+            final Tag componentsTag = DataComponentMap.CODEC.encodeStart(org.bukkit.craftbukkit.CraftRegistry.getMinecraftRegistry().createSerializationContext(net.minecraft.nbt.NbtOps.INSTANCE), this.components).getOrThrow();
+            internalTags.put(CraftMetaBlockState.BLOCK_ENTITY_COMPONENTS.NBT, componentsTag);
         }
+        // Paper end - new serialization format
     }
 
     @Override
@@ -152,9 +213,10 @@ public class CraftMetaBlockState extends CraftMetaItem implements BlockStateMeta
     int applyHash() {
         final int original;
         int hash = original = super.applyHash();
-        if (this.blockEntityTag != null) {
-            hash = 61 * hash + this.blockEntityTag.hashCode();
-        }
+        // Paper start
+        hash = 61 * hash + this.blockEntityTag.hashCode();
+        hash = 61 * hash + this.components.hashCode();
+        // Paper end
         return original != hash ? CraftMetaBlockState.class.hashCode() ^ hash : hash;
     }
 
@@ -166,45 +228,71 @@ public class CraftMetaBlockState extends CraftMetaItem implements BlockStateMeta
         if (meta instanceof CraftMetaBlockState) {
             CraftMetaBlockState that = (CraftMetaBlockState) meta;
 
-            return Objects.equal(this.blockEntityTag, that.blockEntityTag);
+            return Objects.equal(this.blockEntityTag, that.blockEntityTag) && Objects.equal(this.components, that.components); // Paper
         }
         return true;
     }
 
     @Override
     boolean notUncommon(CraftMetaItem meta) {
-        return super.notUncommon(meta) && (meta instanceof CraftMetaBlockState || this.blockEntityTag == null);
+        return super.notUncommon(meta) && (meta instanceof CraftMetaBlockState || (this.blockEntityTag.isEmpty() && this.components.isEmpty())); // Paper
     }
 
     @Override
     boolean isEmpty() {
-        return super.isEmpty() && this.blockEntityTag == null;
+        return super.isEmpty() && this.blockEntityTag.isEmpty() && this.components.isEmpty(); // Paper
     }
 
     @Override
     public CraftMetaBlockState clone() {
         CraftMetaBlockState meta = (CraftMetaBlockState) super.clone();
-        if (this.blockEntityTag != null) {
-            meta.blockEntityTag = this.blockEntityTag.copy();
-        }
+        // Paper start - no need for "clone" because they are essentially immutables
+        meta.blockEntityTag = this.blockEntityTag;
+        meta.components = this.components;
+        // Paper end
         return meta;
     }
 
     @Override
     public boolean hasBlockState() {
-        return this.blockEntityTag != null;
+        return !this.blockEntityTag.isEmpty() || !this.components.isEmpty(); // Paper
     }
 
     // Paper start - add method to clear block state
     @Override
     public void clearBlockState() {
-        this.blockEntityTag = null;
+        // Paper start
+        this.blockEntityTag = CustomData.EMPTY;
+        this.components = DataComponentMap.EMPTY;
+        // Paper end
     }
     // Paper end - add method to clear block state
 
     @Override
-    public BlockState getBlockState() {
-        return (this.blockEntityTag != null) ? this.blockEntityTag.copy() : CraftMetaBlockState.getBlockState(this.material, null);
+    // Paper start - create blockstate on-demand
+    public CraftBlockEntityState<?> getBlockState() {
+        BlockPos pos = BlockPos.ZERO;
+        final Material stateMaterial = this.materialForBlockEntityType();
+        if (!this.blockEntityTag.isEmpty()) {
+            // Paper "id" field is always present now
+            pos = BlockEntity.getPosFromTag(this.blockEntityTag.getUnsafe()); // unsafe is fine here, just querying
+        }
+        final net.minecraft.world.level.block.entity.BlockEntityType<?> type = java.util.Objects.requireNonNull(CraftBlockStates.getBlockEntityType(stateMaterial));
+        final net.minecraft.world.level.block.state.BlockState nmsBlockState = ((org.bukkit.craftbukkit.block.data.CraftBlockData) this.getBlockData(stateMaterial)).getState();
+        final net.minecraft.world.level.block.entity.BlockEntity blockEntity = java.util.Objects.requireNonNull(type.create(pos, nmsBlockState));
+        if (!this.blockEntityTag.isEmpty()) {
+            this.blockEntityTag.loadInto(blockEntity, org.bukkit.craftbukkit.CraftRegistry.getMinecraftRegistry());
+        }
+        final PatchedDataComponentMap patchedMap = new PatchedDataComponentMap(nmsBlockState.getBlock().asItem().components());
+        patchedMap.setAll(this.components);
+        final Applicator applicator = new Applicator() {};
+        super.applyToItem(applicator);
+        patchedMap.applyPatch(applicator.build());
+        blockEntity.applyComponents(nmsBlockState.getBlock().asItem().components(), patchedMap.asPatch());
+
+        // This is expected to always return a CraftBlockEntityState for the passed material:
+        return (CraftBlockEntityState<?>) CraftBlockStates.getBlockState(null, pos, nmsBlockState, blockEntity);
+        // Paper end
     }
 
     private static CraftBlockEntityState<?> getBlockState(Material material, CompoundTag blockEntityTag) {
@@ -234,7 +322,23 @@ public class CraftMetaBlockState extends CraftMetaItem implements BlockStateMeta
         Class<?> blockStateType = CraftBlockStates.getBlockStateType(stateMaterial);
         Preconditions.checkArgument(blockStateType == blockState.getClass() && blockState instanceof CraftBlockEntityState, "Invalid blockState for " + this.material);
 
-        this.blockEntityTag = (CraftBlockEntityState<?>) blockState;
+        // Paper start - when a new BlockState is set, the components from that block entity
+        // have to be used to update the fields on CraftMetaItem
+        final CraftBlockEntityState<?> craftBlockState = (CraftBlockEntityState<?>) blockState;
+        final CompoundTag data = craftBlockState.getSnapshotCustomNbtOnly();
+        final PatchedDataComponentMap patchedMap = new net.minecraft.core.component.PatchedDataComponentMap(craftBlockState.getHandle().getBlock().asItem().components());
+        final net.minecraft.core.component.DataComponentMap map = craftBlockState.collectComponents();
+        patchedMap.setAll(map);
+        if (!data.isEmpty()) {
+            patchedMap.set(BLOCK_ENTITY_TAG.TYPE, CustomData.of(data));
+        }
+        final DataComponentPatch patch = patchedMap.asPatch();
+        this.updateFromPatch(patch, null);
+        // we have to reset the fields because this should be like a "new" block entity is being used
+        this.blockEntityTag = CustomData.EMPTY;
+        this.components = DataComponentMap.EMPTY;
+        this.updateBlockState(patch);
+        // Paper end
     }
 
     private static Material shieldToBannerHack() {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java
index a395c7ce952f4a60a5edf80e8731afa6388d18ea..e213ac74f8f4a62b7b8b2b7889250f5cdeb348fe 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java
@@ -34,7 +34,7 @@ public class CraftMetaBook extends CraftMetaItem implements BookMeta, WritableBo
     @ItemMetaKey.Specific(ItemMetaKey.Specific.To.NBT)
     static final ItemMetaKeyType<WritableBookContent> BOOK_CONTENT = new ItemMetaKeyType<>(DataComponents.WRITABLE_BOOK_CONTENT);
     static final ItemMetaKey BOOK_PAGES = new ItemMetaKey("pages");
-    static final int MAX_PAGES = Integer.MAX_VALUE; // SPIGOT-6911: Use Minecraft limits
+    static final int MAX_PAGES = WritableBookContent.MAX_PAGES; // SPIGOT-6911: Use Minecraft limits // Paper
     static final int MAX_PAGE_LENGTH = WritableBookContent.PAGE_EDIT_LENGTH; // SPIGOT-6911: Use Minecraft limits
 
     // We store the pages in their raw original text representation. See SPIGOT-5063, SPIGOT-5350, SPIGOT-3206
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBookSigned.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBookSigned.java
index 3f78a0935d738854182254b345064e3c225dcd5f..218df87c596d47b431dbbf2aa42822ef174f948f 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBookSigned.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBookSigned.java
@@ -116,8 +116,8 @@ public class CraftMetaBookSigned extends CraftMetaItem implements BookMeta {
             }
         }
 
-        this.resolved = SerializableMeta.getObject(Boolean.class, map, CraftMetaBookSigned.RESOLVED.BUKKIT, true);
-        this.generation = SerializableMeta.getObject(Integer.class, map, CraftMetaBookSigned.GENERATION.BUKKIT, true);
+        this.resolved = SerializableMeta.getBoolean(map, CraftMetaBookSigned.RESOLVED.BUKKIT); // Paper - General ItemMeta fixes
+        this.generation = SerializableMeta.getObjectOptionally(Integer.class, map, CraftMetaBookSigned.GENERATION.BUKKIT, true).orElse(0); // Paper - General ItemMeta Fixes
     }
 
     @Override
@@ -129,7 +129,7 @@ public class CraftMetaBookSigned extends CraftMetaItem implements BookMeta {
             for (Component page : this.pages) {
                 list.add(Filterable.passThrough(page));
             }
-            itemData.put(CraftMetaBookSigned.BOOK_CONTENT, new WrittenBookContent(Filterable.from(FilteredText.passThrough(this.title)), this.author, this.generation, list, this.resolved));
+            itemData.put(CraftMetaBookSigned.BOOK_CONTENT, new WrittenBookContent(Filterable.from(FilteredText.passThrough(this.title == null ? "" : this.title)), this.author == null ? "" : this.author, this.generation, list, this.resolved));
         }
     }
 
@@ -358,7 +358,13 @@ public class CraftMetaBookSigned extends CraftMetaItem implements BookMeta {
         }
 
         if (this.pages != null) {
-            builder.put(CraftMetaBookSigned.BOOK_PAGES.BUKKIT, ImmutableList.copyOf(this.pages));
+            // Paper start - deserialization expects json
+            final List<String> jsonPages = new ArrayList<>(this.pages.size());
+            for (final Component page : this.pages) {
+                jsonPages.add(CraftChatMessage.toJSON(page));
+            }
+            builder.put(CraftMetaBookSigned.BOOK_PAGES.BUKKIT, ImmutableList.copyOf(jsonPages));
+            // Paper end - deserialization expects json
         }
 
         if (this.resolved) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBundle.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBundle.java
index 2736a87a6c481da0575e6e29ea08faa539c24378..51da0db4da3549efd69f367e28450408968fa8d0 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBundle.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBundle.java
@@ -41,7 +41,7 @@ public class CraftMetaBundle extends CraftMetaItem implements BundleMeta {
             bundle.items().forEach((item) -> {
                 ItemStack itemStack = CraftItemStack.asCraftMirror(item);
 
-                if (!itemStack.getType().isAir()) { // SPIGOT-7174 - Avoid adding air
+                if (!itemStack.isEmpty()) { // SPIGOT-7174 - Avoid adding air // Paper
                     this.addItem(itemStack);
                 }
             });
@@ -54,7 +54,7 @@ public class CraftMetaBundle extends CraftMetaItem implements BundleMeta {
         Iterable<?> items = SerializableMeta.getObject(Iterable.class, map, CraftMetaBundle.ITEMS.BUKKIT, true);
         if (items != null) {
             for (Object stack : items) {
-                if (stack instanceof ItemStack itemStack && !itemStack.getType().isAir()) { // SPIGOT-7174 - Avoid adding air
+                if (stack instanceof ItemStack itemStack && !itemStack.isEmpty()) { // SPIGOT-7174 - Avoid adding air // Paper
                     this.addItem(itemStack);
                 }
             }
@@ -110,7 +110,7 @@ public class CraftMetaBundle extends CraftMetaItem implements BundleMeta {
 
     @Override
     public void addItem(ItemStack item) {
-        Preconditions.checkArgument(item != null && !item.getType().isAir(), "item is null or air");
+        Preconditions.checkArgument(item != null && !item.isEmpty(), "item is null or empty"); // Paper
 
         if (this.items == null) {
             this.items = new ArrayList<>();
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaColorableArmor.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaColorableArmor.java
index 6517ec4933b0eae761fceb117ea1db175755d0b1..299f2f4f143f753f3cd8a020c8e6ae46298e0f6f 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaColorableArmor.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaColorableArmor.java
@@ -11,16 +11,30 @@ import org.bukkit.inventory.meta.ColorableArmorMeta;
 @DelegateDeserialization(SerializableMeta.class)
 public class CraftMetaColorableArmor extends CraftMetaArmor implements ColorableArmorMeta {
 
-    private Color color = DEFAULT_LEATHER_COLOR;
+    private Integer color; // Paper - keep color component consistent with vanilla (top byte is ignored)
 
     CraftMetaColorableArmor(CraftMetaItem meta) {
         super(meta);
-        CraftMetaLeatherArmor.readColor(this, meta);
+        // Paper start
+        if (!(meta instanceof CraftMetaColorableArmor armorMeta)) {
+            return;
+        }
+
+        this.color = armorMeta.color;
+        // Paper end
     }
 
     CraftMetaColorableArmor(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
         super(tag, extraHandledDcts); // Paper
-        CraftMetaLeatherArmor.readColor(this, tag);
+        // Paper start
+        getOrEmpty(tag, CraftMetaLeatherArmor.COLOR).ifPresent((dyedItemColor) -> {
+            if (!dyedItemColor.showInTooltip()) {
+                this.addItemFlags(org.bukkit.inventory.ItemFlag.HIDE_DYE);
+            }
+
+            this.color = dyedItemColor.rgb();
+        });
+        // Paper end
     }
 
     CraftMetaColorableArmor(Map<String, Object> map) {
@@ -31,7 +45,11 @@ public class CraftMetaColorableArmor extends CraftMetaArmor implements Colorable
     @Override
     void applyToItem(CraftMetaItem.Applicator itemTag) {
         super.applyToItem(itemTag);
-        CraftMetaLeatherArmor.applyColor(this, itemTag);
+        // Paper start
+        if (this.hasColor()) {
+            itemTag.put(CraftMetaLeatherArmor.COLOR, new net.minecraft.world.item.component.DyedItemColor(this.color, !this.hasItemFlag(org.bukkit.inventory.ItemFlag.HIDE_DYE)));
+        }
+        // Paper end
     }
 
     @Override
@@ -52,16 +70,16 @@ public class CraftMetaColorableArmor extends CraftMetaArmor implements Colorable
 
     @Override
     public Color getColor() {
-        return this.color;
+        return this.color == null ? DEFAULT_LEATHER_COLOR : Color.fromRGB(this.color & 0xFFFFFF); // Paper - this should really be nullable
     }
 
     @Override
     public void setColor(Color color) {
-        this.color = color == null ? DEFAULT_LEATHER_COLOR : color;
+        this.color = color == null ? null : color.asRGB(); // Paper
     }
 
     boolean hasColor() {
-        return CraftMetaLeatherArmor.hasColor(this);
+        return this.color != null; // Paper
     }
 
     @Override
@@ -81,7 +99,7 @@ public class CraftMetaColorableArmor extends CraftMetaArmor implements Colorable
         if (meta instanceof CraftMetaColorableArmor) {
             CraftMetaColorableArmor that = (CraftMetaColorableArmor) meta;
 
-            return this.color.equals(that.color);
+            return this.hasColor() ? that.hasColor() && this.color.equals(that.color) : !that.hasColor(); // Paper - allow null
         }
         return true;
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCompass.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCompass.java
index 69a112b3a9726966aecbe687d905fd1a11cfa1e3..6362df65424e53098701b8d54c74b5905648b78a 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCompass.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCompass.java
@@ -35,7 +35,7 @@ public class CraftMetaCompass extends CraftMetaItem implements CompassMeta {
     private int lodestoneX;
     private int lodestoneY;
     private int lodestoneZ;
-    private boolean tracked = true;
+    private Boolean tracked = null; // Paper - tri-state
 
     CraftMetaCompass(CraftMetaItem meta) {
         super(meta);
@@ -79,7 +79,7 @@ public class CraftMetaCompass extends CraftMetaItem implements CompassMeta {
                 this.setLodestone(lodestone);
             }
         }
-        this.tracked = SerializableMeta.getBoolean(map, CraftMetaCompass.LODESTONE_TRACKED.BUKKIT);
+        this.tracked = SerializableMeta.getObjectOptionally(Boolean.class, map, CraftMetaCompass.LODESTONE_TRACKED.BUKKIT, true).orElse(null); // Paper - tri-state
     }
 
     @Override
@@ -140,12 +140,12 @@ public class CraftMetaCompass extends CraftMetaItem implements CompassMeta {
     }
 
     boolean hasLodestoneTracked() {
-        return !this.tracked;
+        return this.tracked != null; // Paper - tri-state
     }
 
     @Override
     public boolean isLodestoneTracked() {
-        return this.tracked;
+        return this.tracked != null && this.tracked; // Paper - tri-state
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCrossbow.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCrossbow.java
index 0807c2172c5a4bee675cef265a45a9350e98b880..88ea260fb84a5f8eaab3a23a9a65d0411215a6a1 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCrossbow.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCrossbow.java
@@ -117,7 +117,7 @@ public class CraftMetaCrossbow extends CraftMetaItem implements CrossbowMeta {
     @Override
     public void addChargedProjectile(ItemStack item) {
         Preconditions.checkArgument(item != null, "item");
-        Preconditions.checkArgument(item.getType() == Material.FIREWORK_ROCKET || CraftItemType.bukkitToMinecraft(item.getType()) instanceof ArrowItem, "Item %s is not an arrow or firework rocket", item);
+        Preconditions.checkArgument(!item.isEmpty(), "Item cannot be empty"); // Paper
 
         if (this.chargedProjectiles == null) {
             this.chargedProjectiles = new ArrayList<>();
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaEntityTag.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaEntityTag.java
index 3f6c5cbbf63631e4b72dc43558651ea94f31ca78..da474a5b963d8e6769d120e9091e60ed0a468a9f 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaEntityTag.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaEntityTag.java
@@ -98,7 +98,7 @@ public class CraftMetaEntityTag extends CraftMetaItem {
         if (meta instanceof CraftMetaEntityTag) {
             CraftMetaEntityTag that = (CraftMetaEntityTag) meta;
 
-            return this.entityTag != null ? that.entityTag != null && this.entityTag.equals(that.entityTag) : this.entityTag == null;
+            return this.entityTag != null ? that.entityTag != null && this.entityTag.equals(that.entityTag) : that.entityTag == null; // Paper
         }
         return true;
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaFirework.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaFirework.java
index 97b7085250d749c5e46352b372068b51de89bc7f..7277e7ee566aabf6e01937072d949ed67c3e8e38 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaFirework.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaFirework.java
@@ -54,7 +54,7 @@ class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
 
         this.power = that.power;
 
-        if (that.hasEffects()) {
+        if (that.effects != null) { // Paper
             this.effects = new ArrayList<>(that.effects);
         }
     }
@@ -85,19 +85,14 @@ class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
                 .with(CraftMetaFirework.getEffectType(explosion.shape()));
 
         IntList colors = explosion.colors();
-        // People using buggy command generators specify a list rather than an int here, so recover with dummy data.
-        // Wrong: Colors: [1234]
-        // Right: Colors: [I;1234]
-        if (colors.isEmpty()) {
-            effect.withColor(Color.WHITE);
-        }
+        // Paper - this is no longer needed
 
         for (int color : colors) {
-            effect.withColor(Color.fromRGB(color));
+            effect.withColor(Color.fromRGB(color & 0xFFFFFF)); // Paper - try to keep color component consistent with vanilla (top byte is ignored), this will however change the color component for out of bound color
         }
 
         for (int color : explosion.fadeColors()) {
-            effect.withFade(Color.fromRGB(color));
+            effect.withFade(Color.fromRGB(color & 0xFFFFFF)); // Paper
         }
 
         return effect.build();
@@ -153,7 +148,7 @@ class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
         }
 
         Iterable<?> effects = SerializableMeta.getObject(Iterable.class, map, CraftMetaFirework.EXPLOSIONS.BUKKIT, true);
-        this.safelyAddEffects(effects);
+        this.safelyAddEffects(effects, false); // Paper - limit firework effects
     }
 
     @Override
@@ -161,7 +156,7 @@ class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
         return !(this.effects == null || this.effects.isEmpty());
     }
 
-    void safelyAddEffects(Iterable<?> collection) {
+    void safelyAddEffects(Iterable<?> collection, final boolean throwOnOversize) { // Paper
         if (collection == null || (collection instanceof Collection && ((Collection<?>) collection).isEmpty())) {
             return;
         }
@@ -173,6 +168,15 @@ class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
 
         for (Object obj : collection) {
             Preconditions.checkArgument(obj instanceof FireworkEffect, "%s in %s is not a FireworkEffect", obj, collection);
+            // Paper start - limit firework effects
+            if (effects.size() + 1 > Fireworks.MAX_EXPLOSIONS) {
+                if (throwOnOversize) {
+                    throw new IllegalArgumentException("Cannot have more than " + Fireworks.MAX_EXPLOSIONS + " firework effects");
+                } else {
+                    continue;
+                }
+            }
+            // Paper end - limit firework effects
             effects.add((FireworkEffect) obj);
         }
     }
@@ -185,9 +189,13 @@ class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
         }
 
         List<FireworkExplosion> effects = new ArrayList<>();
-        for (FireworkEffect effect : this.effects) {
-            effects.add(CraftMetaFirework.getExplosion(effect));
+        // Paper start - fix NPE with effects list being null
+        if (this.effects != null) {
+            for (FireworkEffect effect : this.effects) {
+                effects.add(CraftMetaFirework.getExplosion(effect));
+            }
         }
+        // Paper end
 
         itemTag.put(CraftMetaFirework.FIREWORKS, new Fireworks(this.power, effects));
     }
@@ -212,7 +220,7 @@ class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
     }
 
     boolean isFireworkEmpty() {
-        return !(this.hasEffects() || this.hasPower());
+        return !(this.effects != null || this.hasPower()); // Paper - empty effects list should stay on the item
     }
 
     boolean hasPower() {
@@ -228,7 +236,7 @@ class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
         if (meta instanceof CraftMetaFirework that) {
 
             return (this.hasPower() ? that.hasPower() && this.power == that.power : !that.hasPower())
-                    && (this.hasEffects() ? that.hasEffects() && this.effects.equals(that.effects) : !that.hasEffects());
+                    && (this.effects != null ? that.effects != null && this.effects.equals(that.effects) : that.effects == null); // Paper
         }
 
         return true;
@@ -246,7 +254,7 @@ class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
         if (this.hasPower()) {
             hash = 61 * hash + this.power;
         }
-        if (this.hasEffects()) {
+        if (this.effects != null) { // Paper
             hash = 61 * hash + 13 * this.effects.hashCode();
         }
         return hash != original ? CraftMetaFirework.class.hashCode() ^ hash : hash;
@@ -256,7 +264,7 @@ class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
     Builder<String, Object> serialize(Builder<String, Object> builder) {
         super.serialize(builder);
 
-        if (this.hasEffects()) {
+        if (this.effects != null) { // Paper
             builder.put(CraftMetaFirework.EXPLOSIONS.BUKKIT, ImmutableList.copyOf(this.effects));
         }
 
@@ -281,6 +289,7 @@ class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
     @Override
     public void addEffect(FireworkEffect effect) {
         Preconditions.checkArgument(effect != null, "FireworkEffect cannot be null");
+        Preconditions.checkArgument(this.effects == null || this.effects.size() + 1 <= Fireworks.MAX_EXPLOSIONS, "cannot have more than %s firework effects", Fireworks.MAX_EXPLOSIONS); // Paper - limit firework effects
         if (this.effects == null) {
             this.effects = new ArrayList<FireworkEffect>();
         }
@@ -290,6 +299,10 @@ class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
     @Override
     public void addEffects(FireworkEffect... effects) {
         Preconditions.checkArgument(effects != null, "effects cannot be null");
+        // Paper start - limit firework effects
+        final int initialSize = this.effects == null ? 0 : this.effects.size();
+        Preconditions.checkArgument(initialSize + effects.length <= Fireworks.MAX_EXPLOSIONS, "Cannot have more than %s firework effects", Fireworks.MAX_EXPLOSIONS);
+        // Paper end - limit firework effects
         if (effects.length == 0) {
             return;
         }
@@ -308,7 +321,7 @@ class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
     @Override
     public void addEffects(Iterable<FireworkEffect> effects) {
         Preconditions.checkArgument(effects != null, "effects cannot be null");
-        this.safelyAddEffects(effects);
+        this.safelyAddEffects(effects, true); // Paper - limit firework effects
     }
 
     @Override
@@ -343,7 +356,7 @@ class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
     @Override
     public void setPower(int power) {
         Preconditions.checkArgument(power >= 0, "power cannot be less than zero: %s", power);
-        Preconditions.checkArgument(power < 0x80, "power cannot be more than 127: %s", power);
+        Preconditions.checkArgument(power <= 0xFF, "power cannot be more than 255: %s", power); // Paper - set correct limit
         this.power = power;
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
index 8cfce9c557c4411914adffd10872bf3129435423..d9d4b983672b4340df926d98a7fa6708acad8a05 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
@@ -182,9 +182,10 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         }
     }
 
-    static final class Applicator {
+    static abstract class Applicator { // Paper - support updating profile after resolving it
 
-        private final DataComponentPatch.Builder builder = DataComponentPatch.builder();
+        final DataComponentPatch.Builder builder = DataComponentPatch.builder(); // Paper - private -> package-private
+        void skullCallback(com.mojang.authlib.GameProfile gameProfile) {} // Paper - support updating profile after resolving it
 
         <T> Applicator put(ItemMetaKeyType<T> key, T value) {
             this.builder.set(key.TYPE, value);
@@ -310,7 +311,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
             this.enchantments = new EnchantmentMap(meta.enchantments); // Paper
         }
 
-        if (meta.hasAttributeModifiers()) {
+        if (meta.attributeModifiers != null) { // Paper
             this.attributeModifiers = LinkedHashMultimap.create(meta.attributeModifiers);
         }
 
@@ -347,6 +348,11 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
     }
 
     CraftMetaItem(DataComponentPatch tag, Set<DataComponentType<?>> extraHandledTags) { // Paper - improve handled tags on type changes
+        // Paper start - properly support data components in BlockEntity
+        this.updateFromPatch(tag, extraHandledTags);
+    }
+    protected final void updateFromPatch(DataComponentPatch tag, Set<DataComponentType<?>> extraHandledTags) {
+        // Paper end - properly support data components in BlockEntity
         CraftMetaItem.getOrEmpty(tag, CraftMetaItem.NAME).ifPresent((component) -> {
             this.displayName = component;
         });
@@ -802,7 +808,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         Map<?, ?> mods = SerializableMeta.getObject(Map.class, map, key.BUKKIT, true);
         Multimap<Attribute, AttributeModifier> result = LinkedHashMultimap.create();
         if (mods == null) {
-            return result;
+            return null; // Paper - null is different from an empty map
         }
 
         for (Object obj : mods.keySet()) {
@@ -970,10 +976,8 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
     }
 
     void applyModifiers(Multimap<Attribute, AttributeModifier> modifiers, CraftMetaItem.Applicator tag) {
-        if (modifiers == null || modifiers.isEmpty()) {
-            if (this.hasItemFlag(ItemFlag.HIDE_ATTRIBUTES)) {
-                tag.put(CraftMetaItem.ATTRIBUTES, new ItemAttributeModifiers(Collections.emptyList(), false));
-            }
+        if (modifiers == null/* || modifiers.isEmpty()*/) { // Paper - empty modifiers has a specific meaning, they should still be saved
+            // Paper - don't save ItemFlag if the underlying data isn't present
             return;
         }
 
@@ -1106,6 +1110,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
 
     @Override
     public void lore(final List<? extends net.kyori.adventure.text.Component> lore) {
+        Preconditions.checkArgument(lore == null || lore.size() <= ItemLore.MAX_LINES, "lore cannot have more than %s lines", ItemLore.MAX_LINES); // Paper - limit lore lines
         this.lore = lore != null ? io.papermc.paper.adventure.PaperAdventure.asVanilla(lore) : null;
     }
     // Paper end
@@ -1164,7 +1169,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
     @Override
     public void removeEnchantments() {
         if (this.hasEnchants()) {
-            this.enchantments.clear();
+            this.enchantments = null; // Paper - Correctly clear enchantments
         }
     }
 
@@ -1230,6 +1235,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
     // Paper end
     @Override
     public void setLore(List<String> lore) {
+        Preconditions.checkArgument(lore == null || lore.size() <= ItemLore.MAX_LINES, "lore cannot have more than %s lines", ItemLore.MAX_LINES); // Paper - limit lore lines
         if (lore == null || lore.isEmpty()) {
             this.lore = null;
         } else {
@@ -1245,6 +1251,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
     // Paper start
     @Override
     public void setLoreComponents(List<net.md_5.bungee.api.chat.BaseComponent[]> lore) {
+        Preconditions.checkArgument(lore == null || lore.size() <= ItemLore.MAX_LINES, "lore cannot have more than %s lines", ItemLore.MAX_LINES); // Paper - limit lore lines
         if (lore == null) {
             this.lore = null;
         } else {
@@ -1386,7 +1393,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
 
     @Override
     public FoodComponent getFood() {
-        return (this.hasFood()) ? new CraftFoodComponent(this.food) : new CraftFoodComponent(new FoodProperties(0, 0, false, 0, Optional.empty(), Collections.emptyList()));
+        return (this.hasFood()) ? new CraftFoodComponent(this.food) : new CraftFoodComponent(new FoodProperties(0, 0, false, FoodProperties.DEFAULT_EAT_SECONDS, Optional.empty(), Collections.emptyList())); // Paper - create a valid food properties
     }
 
     @Override
@@ -1442,7 +1449,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
 
     @Override
     public Multimap<Attribute, AttributeModifier> getAttributeModifiers(@Nullable EquipmentSlot slot) {
-        this.checkAttributeList();
+        if (this.attributeModifiers == null) return LinkedHashMultimap.create(); // Paper - don't change the components
         SetMultimap<Attribute, AttributeModifier> result = LinkedHashMultimap.create();
         for (Map.Entry<Attribute, AttributeModifier> entry : this.attributeModifiers.entries()) {
             if (entry.getValue().getSlot() == null || entry.getValue().getSlot() == slot) {
@@ -1455,6 +1462,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
     @Override
     public Collection<AttributeModifier> getAttributeModifiers(@Nonnull Attribute attribute) {
         Preconditions.checkNotNull(attribute, "Attribute cannot be null");
+        if (this.attributeModifiers == null) return null; // Paper - fix NPE
         return this.attributeModifiers.containsKey(attribute) ? ImmutableList.copyOf(this.attributeModifiers.get(attribute)) : null;
     }
 
@@ -1462,10 +1470,12 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
     public boolean addAttributeModifier(@Nonnull Attribute attribute, @Nonnull AttributeModifier modifier) {
         Preconditions.checkNotNull(attribute, "Attribute cannot be null");
         Preconditions.checkNotNull(modifier, "AttributeModifier cannot be null");
-        this.checkAttributeList();
+        if (this.attributeModifiers != null) { // Paper
         for (Map.Entry<Attribute, AttributeModifier> entry : this.attributeModifiers.entries()) {
             Preconditions.checkArgument(!entry.getValue().getKey().equals(modifier.getKey()) && entry.getKey() == attribute, "Cannot register AttributeModifier. Modifier is already applied! %s", modifier); // Paper - attribute modifiers with same namespaced key but on different attributes are fine
         }
+        } // Paper
+        this.checkAttributeList(); // Paper - moved down
         return this.attributeModifiers.put(attribute, modifier);
     }
 
@@ -1476,8 +1486,11 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
             return;
         }
 
-        this.checkAttributeList();
-        this.attributeModifiers.clear();
+        // Paper start - fix modifiers meta
+        if (this.attributeModifiers != null) {
+            this.attributeModifiers.clear();
+        }
+        // Paper end
 
         Iterator<Map.Entry<Attribute, AttributeModifier>> iterator = attributeModifiers.entries().iterator();
         while (iterator.hasNext()) {
@@ -1487,6 +1500,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
                 iterator.remove();
                 continue;
             }
+            this.checkAttributeList(); // Paper - moved down
             this.attributeModifiers.put(next.getKey(), next.getValue());
         }
     }
@@ -1494,13 +1508,13 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
     @Override
     public boolean removeAttributeModifier(@Nonnull Attribute attribute) {
         Preconditions.checkNotNull(attribute, "Attribute cannot be null");
-        this.checkAttributeList();
+        if (this.attributeModifiers == null) return false; // Paper
         return !this.attributeModifiers.removeAll(attribute).isEmpty();
     }
 
     @Override
     public boolean removeAttributeModifier(@Nullable EquipmentSlot slot) {
-        this.checkAttributeList();
+        if (this.attributeModifiers == null) return false; // Paper
         int removed = 0;
         Iterator<Map.Entry<Attribute, AttributeModifier>> iter = this.attributeModifiers.entries().iterator();
 
@@ -1520,7 +1534,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
     public boolean removeAttributeModifier(@Nonnull Attribute attribute, @Nonnull AttributeModifier modifier) {
         Preconditions.checkNotNull(attribute, "Attribute cannot be null");
         Preconditions.checkNotNull(modifier, "AttributeModifier cannot be null");
-        this.checkAttributeList();
+        if (this.attributeModifiers == null) return false; // Paper
         int removed = 0;
         Iterator<Map.Entry<Attribute, AttributeModifier>> iter = this.attributeModifiers.entries().iterator();
 
@@ -1542,7 +1556,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
 
     @Override
     public String getAsString() {
-        CraftMetaItem.Applicator tag = new CraftMetaItem.Applicator();
+        CraftMetaItem.Applicator tag = new CraftMetaItem.Applicator() {}; // Paper - support updating profile after resolving it
         this.applyToItem(tag);
         DataComponentPatch patch = tag.build();
         Tag nbt = DataComponentPatch.CODEC.encodeStart(MinecraftServer.getDefaultRegistryAccess().createSerializationContext(NbtOps.INSTANCE), patch).getOrThrow();
@@ -1551,7 +1565,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
 
     @Override
     public String getAsComponentString() {
-        CraftMetaItem.Applicator tag = new CraftMetaItem.Applicator();
+        CraftMetaItem.Applicator tag = new CraftMetaItem.Applicator() {}; // Paper
         this.applyToItem(tag);
         DataComponentPatch patch = tag.build();
 
@@ -1591,6 +1605,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         if (first == null || second == null) {
             return false;
         }
+        if (first.isEmpty() && second.isEmpty()) return true; // Paper - empty modifiers are equivalent
         for (Map.Entry<Attribute, AttributeModifier> entry : first.entries()) {
             if (!second.containsEntry(entry.getKey(), entry.getValue())) {
                 return false;
@@ -1616,6 +1631,8 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
 
     @Override
     public void setDamage(int damage) {
+        Preconditions.checkArgument(damage >= 0, "Damage cannot be negative"); // Paper
+        Preconditions.checkArgument(!this.hasMaxDamage() || damage <= this.maxDamage, "Damage cannot exceed max damage"); // Paper
         this.damage = damage;
     }
 
@@ -1632,6 +1649,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
 
     @Override
     public void setMaxDamage(Integer maxDamage) {
+        Preconditions.checkArgument(maxDamage == null || maxDamage > 0, "Max damage should be positive"); // Paper
         this.maxDamage = maxDamage;
     }
 
@@ -1663,7 +1681,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
                 && (this.hasCustomModelData() ? that.hasCustomModelData() && this.customModelData.equals(that.customModelData) : !that.hasCustomModelData())
                 && (this.hasBlockData() ? that.hasBlockData() && this.blockData.equals(that.blockData) : !that.hasBlockData())
                 && (this.hasRepairCost() ? that.hasRepairCost() && this.repairCost == that.repairCost : !that.hasRepairCost())
-                && (this.hasAttributeModifiers() ? that.hasAttributeModifiers() && CraftMetaItem.compareModifiers(this.attributeModifiers, that.attributeModifiers) : !that.hasAttributeModifiers())
+                && (this.attributeModifiers != null ? that.attributeModifiers != null && CraftMetaItem.compareModifiers(this.attributeModifiers, that.attributeModifiers) : that.attributeModifiers == null) // Paper - track only null modifiers
                 && (this.unhandledTags.equals(that.unhandledTags))
                 && (this.removedTags.equals(that.removedTags))
                 && (Objects.equals(this.customTag, that.customTag))
@@ -1725,8 +1743,8 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         hash = 61 * hash + (this.hasTool() ? this.tool.hashCode() : 0);
         hash = 61 * hash + (this.hasJukeboxPlayable() ? this.jukebox.hashCode() : 0);
         hash = 61 * hash + (this.hasDamage() ? this.damage : 0);
-        hash = 61 * hash + (this.hasMaxDamage() ? 1231 : 1237);
-        hash = 61 * hash + (this.hasAttributeModifiers() ? this.attributeModifiers.hashCode() : 0);
+        hash = 61 * hash + (this.hasMaxDamage() ? this.maxDamage.hashCode() : 0); // Paper - max damage is not a boolean
+        hash = 61 * hash + (this.attributeModifiers != null ? this.attributeModifiers.hashCode() : 0); // Paper - track only null attributes
         hash = 61 * hash + (this.canPlaceOnPredicates != null ? this.canPlaceOnPredicates.hashCode() : 0); // Paper
         hash = 61 * hash + (this.canBreakPredicates != null ? this.canBreakPredicates.hashCode() : 0); // Paper
         hash = 61 * hash + this.version;
@@ -1746,7 +1764,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
             if (this.enchantments != null) {
                 clone.enchantments = new EnchantmentMap(this.enchantments); // Paper
             }
-            if (this.hasAttributeModifiers()) {
+            if (this.attributeModifiers != null) { // Paper
                 clone.attributeModifiers = LinkedHashMultimap.create(this.attributeModifiers);
             }
             if (this.customTag != null) {
@@ -1975,7 +1993,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
     }
 
     static void serializeModifiers(Multimap<Attribute, AttributeModifier> modifiers, ImmutableMap.Builder<String, Object> builder, ItemMetaKey key) {
-        if (modifiers == null || modifiers.isEmpty()) {
+        if (modifiers == null/* || modifiers.isEmpty()*/) { // Paper - null and an empty map have different behaviors
             return;
         }
 
@@ -2057,7 +2075,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
     // Paper start - improve checking handled tags
     @org.jetbrains.annotations.VisibleForTesting
     public static final Map<Class<? extends CraftMetaItem>, Set<DataComponentType<?>>> HANDLED_DCTS_PER_TYPE = new HashMap<>();
-    private static final Set<DataComponentType<?>> DEFAULT_HANDLED_DCTS = Set.of(
+    protected static final Set<DataComponentType<?>> DEFAULT_HANDLED_DCTS = Set.of(
         CraftMetaItem.NAME.TYPE,
         CraftMetaItem.ITEM_NAME.TYPE,
         CraftMetaItem.LORE.TYPE,
@@ -2125,7 +2143,12 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
     // Paper end - improve checking handled data component types
 
     protected static <T> Optional<? extends T> getOrEmpty(DataComponentPatch tag, ItemMetaKeyType<T> type) {
-        Optional<? extends T> result = tag.get(type.TYPE);
+        // Paper start
+        return getOrEmpty(tag, type.TYPE);
+    }
+    protected static <T> Optional<? extends T> getOrEmpty(final DataComponentPatch tag, final DataComponentType<T> type) {
+        Optional<? extends T> result = tag.get(type);
+        // Paper end
 
         return (result != null) ? result : Optional.empty();
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaLeatherArmor.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaLeatherArmor.java
index e8c950aa74d31bf7a9128f4acc4bccee26bbcd7f..f1dbfba7ec11b12ead627f098a0b833f49be8000 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaLeatherArmor.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaLeatherArmor.java
@@ -18,16 +18,30 @@ class CraftMetaLeatherArmor extends CraftMetaItem implements LeatherArmorMeta {
 
     static final ItemMetaKeyType<DyedItemColor> COLOR = new ItemMetaKeyType<>(DataComponents.DYED_COLOR, "color");
 
-    private Color color = DEFAULT_LEATHER_COLOR;
+    private Integer color; // Paper - keep color component consistent with vanilla (top byte is ignored)
 
     CraftMetaLeatherArmor(CraftMetaItem meta) {
         super(meta);
-        CraftMetaLeatherArmor.readColor(this, meta);
+        // Paper start
+        if (!(meta instanceof CraftMetaLeatherArmor leatherMeta)) {
+            return;
+        }
+
+        this.color = leatherMeta.color;
+        // Paper end
     }
 
     CraftMetaLeatherArmor(DataComponentPatch tag, java.util.Set<net.minecraft.core.component.DataComponentType<?>> extraHandledDcts) { // Paper
         super(tag, extraHandledDcts); // Paper
-        CraftMetaLeatherArmor.readColor(this, tag);
+        // Paper start
+        getOrEmpty(tag, CraftMetaLeatherArmor.COLOR).ifPresent((dyedItemColor) -> {
+            if (!dyedItemColor.showInTooltip()) {
+                this.addItemFlags(ItemFlag.HIDE_DYE);
+            }
+
+            this.color = dyedItemColor.rgb();
+        });
+        // Paper end
     }
 
     CraftMetaLeatherArmor(Map<String, Object> map) {
@@ -38,7 +52,11 @@ class CraftMetaLeatherArmor extends CraftMetaItem implements LeatherArmorMeta {
     @Override
     void applyToItem(CraftMetaItem.Applicator itemTag) {
         super.applyToItem(itemTag);
-        CraftMetaLeatherArmor.applyColor(this, itemTag);
+        // Paper start
+        if (this.hasColor()) {
+            itemTag.put(CraftMetaLeatherArmor.COLOR, new DyedItemColor(this.color, !this.hasItemFlag(ItemFlag.HIDE_DYE)));
+        }
+        // Paper end
     }
 
     @Override
@@ -66,16 +84,16 @@ class CraftMetaLeatherArmor extends CraftMetaItem implements LeatherArmorMeta {
 
     @Override
     public Color getColor() {
-        return this.color;
+        return this.color == null ? DEFAULT_LEATHER_COLOR : Color.fromRGB(this.color & 0xFFFFFF); // Paper
     }
 
     @Override
     public void setColor(Color color) {
-        this.color = color == null ? DEFAULT_LEATHER_COLOR : color;
+        this.color = color == null ? null : color.asRGB(); // Paper
     }
 
     boolean hasColor() {
-        return CraftMetaLeatherArmor.hasColor(this);
+        return this.color != null; // Paper
     }
 
     @Override
@@ -95,7 +113,7 @@ class CraftMetaLeatherArmor extends CraftMetaItem implements LeatherArmorMeta {
         if (meta instanceof CraftMetaLeatherArmor) {
             CraftMetaLeatherArmor that = (CraftMetaLeatherArmor) meta;
 
-            return this.color.equals(that.color);
+            return this.hasColor() ? that.hasColor() && this.color.equals(that.color) : !that.hasColor(); // Paper - allow null
         }
         return true;
     }
@@ -115,14 +133,16 @@ class CraftMetaLeatherArmor extends CraftMetaItem implements LeatherArmorMeta {
         return original != hash ? CraftMetaLeatherArmor.class.hashCode() ^ hash : hash;
     }
 
+    @io.papermc.paper.annotation.DoNotUse // Paper
     static void readColor(LeatherArmorMeta meta, CraftMetaItem other) {
         if (!(other instanceof CraftMetaLeatherArmor armorMeta)) {
             return;
         }
 
-        meta.setColor(armorMeta.color);
+        // meta.setColor(armorMeta.color); // Paper - commented out, color is now an integer and cannot be passed to setColor
     }
 
+    @io.papermc.paper.annotation.DoNotUse // Paper
     static void readColor(LeatherArmorMeta meta, DataComponentPatch tag) {
         getOrEmpty(tag, CraftMetaLeatherArmor.COLOR).ifPresent((dyedItemColor) -> {
             if (!dyedItemColor.showInTooltip()) {
@@ -145,6 +165,7 @@ class CraftMetaLeatherArmor extends CraftMetaItem implements LeatherArmorMeta {
         return !DEFAULT_LEATHER_COLOR.equals(meta.getColor());
     }
 
+    @io.papermc.paper.annotation.DoNotUse // Paper
     static void applyColor(LeatherArmorMeta meta, CraftMetaItem.Applicator tag) {
         if (CraftMetaLeatherArmor.hasColor(meta)) {
             tag.put(CraftMetaLeatherArmor.COLOR, new DyedItemColor(meta.getColor().asRGB(), !meta.hasItemFlag(ItemFlag.HIDE_DYE)));
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaMap.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaMap.java
index 149356981e586e4f67d4543d3df94a2ea99333fc..06c72ed83dab9492b70bfd13f7f9c1a4cbef9e2f 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaMap.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaMap.java
@@ -29,7 +29,7 @@ class CraftMetaMap extends CraftMetaItem implements MapMeta {
 
     private Integer mapId;
     private byte scaling = CraftMetaMap.SCALING_EMPTY;
-    private Color color;
+    private Integer color; // Paper - keep color component consistent with vanilla (top byte is ignored)
 
     CraftMetaMap(CraftMetaItem meta) {
         super(meta);
@@ -57,7 +57,7 @@ class CraftMetaMap extends CraftMetaItem implements MapMeta {
 
         getOrEmpty(tag, CraftMetaMap.MAP_COLOR).ifPresent((mapColor) -> {
             try {
-                this.color = Color.fromRGB(mapColor.rgb());
+                this.color = mapColor.rgb(); // Paper
             } catch (IllegalArgumentException ex) {
                 // Invalid colour
             }
@@ -101,7 +101,7 @@ class CraftMetaMap extends CraftMetaItem implements MapMeta {
         }
 
         if (this.hasColor()) {
-            tag.put(CraftMetaMap.MAP_COLOR, new MapItemColor(this.color.asRGB()));
+            tag.put(CraftMetaMap.MAP_COLOR, new MapItemColor(this.color)); // Paper
         }
     }
 
@@ -121,6 +121,7 @@ class CraftMetaMap extends CraftMetaItem implements MapMeta {
 
     @Override
     public int getMapId() {
+        Preconditions.checkState(this.hasMapId(), "Item does not have map associated - check hasMapId() first!"); // Paper - fix NPE
         return this.mapId;
     }
 
@@ -181,12 +182,12 @@ class CraftMetaMap extends CraftMetaItem implements MapMeta {
 
     @Override
     public Color getColor() {
-        return this.color;
+        return this.color == null ? null : Color.fromRGB(this.color & 0xFFFFFF); // Paper
     }
 
     @Override
     public void setColor(Color color) {
-        this.color = color;
+        this.color = color == null ? null : color.asRGB(); // Paper
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaOminousBottle.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaOminousBottle.java
index 90c554dcbfe2bcca3f742379499f1e8e8665c512..14acdd2bd02de7e99b7f237151633ed71396db5f 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaOminousBottle.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaOminousBottle.java
@@ -69,6 +69,7 @@ public class CraftMetaOminousBottle extends CraftMetaItem implements OminousBott
 
     @Override
     public int getAmplifier() {
+        Preconditions.checkState(this.hasAmplifier(), "'ominous_bottle_amplifier' data component is absent. Check hasAmplifier first!"); // Paper - fix NPE
         return this.ominousBottleAmplifier;
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaPotion.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaPotion.java
index 7f9182809f6e67ff571db0f365bc7e05f600775a..01c49df291f721bab3acb788ff2f27879b38bfc7 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaPotion.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaPotion.java
@@ -37,7 +37,7 @@ class CraftMetaPotion extends CraftMetaItem implements PotionMeta {
 
     private PotionType type;
     private List<PotionEffect> customEffects;
-    private Color color;
+    private Integer color; // Paper - keep color component consistent with vanilla (top byte is ignored)
 
     CraftMetaPotion(CraftMetaItem meta) {
         super(meta);
@@ -60,7 +60,7 @@ class CraftMetaPotion extends CraftMetaItem implements PotionMeta {
 
             potionContents.customColor().ifPresent((customColor) -> {
                 try {
-                    this.color = Color.fromRGB(customColor);
+                    this.color = customColor; // Paper
                 } catch (IllegalArgumentException ex) {
                     // Invalid colour
                 }
@@ -116,7 +116,7 @@ class CraftMetaPotion extends CraftMetaItem implements PotionMeta {
         super.applyToItem(tag);
 
         Optional<Holder<Potion>> defaultPotion = (this.hasBasePotionType()) ? Optional.of(CraftPotionType.bukkitToMinecraftHolder(this.type)) : Optional.empty();
-        Optional<Integer> potionColor = (this.hasColor()) ? Optional.of(this.color.asRGB()) : Optional.empty();
+        Optional<Integer> potionColor = (this.hasColor()) ? Optional.of(this.color) : Optional.empty(); // Paper
 
         List<MobEffectInstance> effectList = new ArrayList<>();
         if (this.customEffects != null) {
@@ -280,12 +280,12 @@ class CraftMetaPotion extends CraftMetaItem implements PotionMeta {
 
     @Override
     public Color getColor() {
-        return this.color;
+        return this.color == null ? null : Color.fromRGB(this.color & 0xFFFFFF); // Paper
     }
 
     @Override
     public void setColor(Color color) {
-        this.color = color;
+        this.color = color == null ? null : color.asRGB(); // Paper
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java
index ab860f1179fa2618c8fbc30ac5f48ff78b8abb60..7de2ed297d0b2bf8adf2058e75a9b594ec2197bd 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java
@@ -117,10 +117,10 @@ class CraftMetaSkull extends CraftMetaItem implements SkullMeta {
             // Fill in textures
             PlayerProfile ownerProfile = new CraftPlayerProfile(this.profile); // getOwnerProfile may return null
             if (ownerProfile.getTextures().isEmpty()) {
-                ownerProfile.update().thenAccept((filledProfile) -> {
+                ownerProfile.update().thenAcceptAsync((filledProfile) -> { // Paper - run on main thread
                     this.setOwnerProfile(filledProfile);
-                    tag.put(CraftMetaSkull.SKULL_PROFILE, new ResolvableProfile(this.profile));
-                });
+                    tag.skullCallback(this.profile); // Paper - actually set profile on itemstack
+                }, ((org.bukkit.craftbukkit.CraftServer) org.bukkit.Bukkit.getServer()).getServer()); // Paper - run on main thread
             }
         }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSpawnEgg.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSpawnEgg.java
index e4b8637e6d82e2ce7cfee2130e6422f0ef4e1fbc..49751354ecd3d401726e8989eb3c09b2de7ae4dc 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSpawnEgg.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSpawnEgg.java
@@ -121,6 +121,7 @@ public class CraftMetaSpawnEgg extends CraftMetaItem implements SpawnEggMeta {
 
     @Override
     public EntitySnapshot getSpawnedEntity() {
+        if (this.entityTag == null) return null; // Paper - fix NPE
         return CraftEntitySnapshot.create(this.entityTag);
     }
 
@@ -138,7 +139,7 @@ public class CraftMetaSpawnEgg extends CraftMetaItem implements SpawnEggMeta {
         if (meta instanceof CraftMetaSpawnEgg) {
             CraftMetaSpawnEgg that = (CraftMetaSpawnEgg) meta;
 
-            return this.entityTag != null ? that.entityTag != null && this.entityTag.equals(that.entityTag) : this.entityTag == null;
+            return this.entityTag != null ? that.entityTag != null && this.entityTag.equals(that.entityTag) : that.entityTag == null; // Paper
         }
         return true;
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaTropicalFishBucket.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaTropicalFishBucket.java
index 17705059b81942e4df43a4a5180092e09c985ade..80e6b85a107d5236edba99540cb5074e2dc1485a 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaTropicalFishBucket.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaTropicalFishBucket.java
@@ -120,6 +120,7 @@ class CraftMetaTropicalFishBucket extends CraftMetaItem implements TropicalFishB
 
     @Override
     public DyeColor getPatternColor() {
+        com.google.common.base.Preconditions.checkState(this.hasVariant(), "This bucket doesn't have variant, check hasVariant first!"); // Paper - fix NPE
         return CraftTropicalFish.getPatternColor(this.variant);
     }
 
@@ -133,6 +134,7 @@ class CraftMetaTropicalFishBucket extends CraftMetaItem implements TropicalFishB
 
     @Override
     public DyeColor getBodyColor() {
+        com.google.common.base.Preconditions.checkState(this.hasVariant(), "This bucket doesn't have variant, check hasVariant first!"); // Paper - fix NPE
         return CraftTropicalFish.getBodyColor(this.variant);
     }
 
@@ -146,6 +148,7 @@ class CraftMetaTropicalFishBucket extends CraftMetaItem implements TropicalFishB
 
     @Override
     public TropicalFish.Pattern getPattern() {
+        com.google.common.base.Preconditions.checkState(this.hasVariant(), "This bucket doesn't have variant, check hasVariant first!"); // Paper - fix NPE
         return CraftTropicalFish.getPattern(this.variant);
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/SerializableMeta.java b/src/main/java/org/bukkit/craftbukkit/inventory/SerializableMeta.java
index 8b407a33b04af6ae396ada0b8aca7dc246d314ef..d204845cf0b9de00589593469755cb8e42e0aa67 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/SerializableMeta.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/SerializableMeta.java
@@ -123,4 +123,21 @@ public final class SerializableMeta implements ConfigurationSerializable {
         }
         throw new IllegalArgumentException(field + "(" + object + ") is not a valid " + clazz);
     }
+
+    // Paper start - General ItemMeta Fixes
+    public static <T> java.util.Optional<T> getObjectOptionally(Class<T> clazz, Map<?, ?> map, Object field, boolean nullable) {
+        final Object object = map.get(field);
+
+        if (clazz.isInstance(object)) {
+            return java.util.Optional.of(clazz.cast(object));
+        }
+        if (object == null) {
+            if (!nullable) {
+                throw new NoSuchElementException(map + " does not contain " + field);
+            }
+            return java.util.Optional.empty();
+        }
+        throw new IllegalArgumentException(field + "(" + object + ") is not a valid " + clazz);
+    }
+    // Paper end - General ItemMeta Fixes
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/components/CraftFoodComponent.java b/src/main/java/org/bukkit/craftbukkit/inventory/components/CraftFoodComponent.java
index 63fc9138dc3388ceb9acf672b3f75ba0976e8e54..cad52601583c1f304f94de954c4d18a6005906e3 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/components/CraftFoodComponent.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/components/CraftFoodComponent.java
@@ -109,6 +109,7 @@ public final class CraftFoodComponent implements FoodComponent {
 
     @Override
     public void setEatSeconds(float eatSeconds) {
+        Preconditions.checkArgument(eatSeconds > 0, "Eat seconds must be positive"); // Paper - validate eat_seconds
         this.handle = new FoodProperties(this.handle.nutrition(), this.handle.saturation(), this.handle.canAlwaysEat(), eatSeconds, this.handle.usingConvertsTo(), this.handle.effects());
     }
 
@@ -134,6 +135,7 @@ public final class CraftFoodComponent implements FoodComponent {
 
     @Override
     public FoodEffect addEffect(PotionEffect effect, float probability) {
+        Preconditions.checkArgument(0 <= probability && probability <= 1, "Probability cannot be outside range [0,1]"); // Paper
         List<FoodProperties.PossibleEffect> effects = new ArrayList<>(this.handle.effects());
 
         FoodProperties.PossibleEffect newEffect = new net.minecraft.world.food.FoodProperties.PossibleEffect(CraftPotionUtil.fromBukkit(effect), probability);
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/DeprecatedItemMetaCustomValueTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/DeprecatedItemMetaCustomValueTest.java
index 6bed0a5c8d9f1ca72678cdf4699128e441a24541..8e03e14d0e65bfdf2196a08220d1408b1297aa0d 100644
--- a/src/test/java/org/bukkit/craftbukkit/inventory/DeprecatedItemMetaCustomValueTest.java
+++ b/src/test/java/org/bukkit/craftbukkit/inventory/DeprecatedItemMetaCustomValueTest.java
@@ -93,7 +93,7 @@ public class DeprecatedItemMetaCustomValueTest extends AbstractTestingBase {
     public void testNBTTagStoring() {
         CraftMetaItem itemMeta = this.createComplexItemMeta();
 
-        CraftMetaItem.Applicator compound = new CraftMetaItem.Applicator();
+        CraftMetaItem.Applicator compound = new CraftMetaItem.Applicator() {}; // Paper
         itemMeta.applyToItem(compound);
 
         assertEquals(itemMeta, new CraftMetaItem(compound.build(), null)); // Paper
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaTest.java
index d6018439015583fa0344c7c01b2e60a13de29795..aabe3730fa582f442ee0544dd1a9f3123f719c68 100644
--- a/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaTest.java
+++ b/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaTest.java
@@ -66,7 +66,7 @@ import org.junit.jupiter.api.Test;
 
 public class ItemMetaTest extends AbstractTestingBase {
 
-    static final int MAX_FIREWORK_POWER = 127; // Please update ItemStackFireworkTest if/when this gets changed.
+    static final int MAX_FIREWORK_POWER = 255; // Please update ItemStackFireworkTest if/when this gets changed. // Paper - it changed
 
     @Test
     public void testPowerLimitExact() {
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/PersistentDataContainerTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/PersistentDataContainerTest.java
index 6f94c7a19f2f598a836ec7db30332dd95f8675a6..54ffbfd91a03efa2d0d271ed10db4209a2309638 100644
--- a/src/test/java/org/bukkit/craftbukkit/inventory/PersistentDataContainerTest.java
+++ b/src/test/java/org/bukkit/craftbukkit/inventory/PersistentDataContainerTest.java
@@ -127,7 +127,7 @@ public class PersistentDataContainerTest extends AbstractTestingBase {
     public void testNBTTagStoring() {
         CraftMetaItem itemMeta = this.createComplexItemMeta();
 
-        CraftMetaItem.Applicator compound = new CraftMetaItem.Applicator();
+        CraftMetaItem.Applicator compound = new CraftMetaItem.Applicator() {}; // Paper
         itemMeta.applyToItem(compound);
 
         assertEquals(itemMeta, new CraftMetaItem(compound.build(), null)); // Paper
@@ -473,7 +473,7 @@ public class PersistentDataContainerTest extends AbstractTestingBase {
         assertEquals(List.of(), container.get(PersistentDataContainerTest.requestKey("list"), PersistentDataType.LIST.strings()));
 
         // Write and read the entire container to NBT
-        final CraftMetaItem.Applicator storage = new CraftMetaItem.Applicator();
+        final CraftMetaItem.Applicator storage = new CraftMetaItem.Applicator() {}; // Paper
         craftItem.applyToItem(storage);
 
         final CraftMetaItem readItem = new CraftMetaItem(storage.build(), null); // Paper

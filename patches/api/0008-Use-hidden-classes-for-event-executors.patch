From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: SirYwell <hannesgreule@outlook.de>
Date: Fri, 29 Nov 2024 10:23:18 +0100
Subject: [PATCH] Use hidden classes for event executors

Static final MethodHandles perform similar to direct calls. Additionally,
hidden classes simplify logic around ClassLoaders as they can be defined
weakly coupled to their defining class loader. All variants of methods
(static, private, non-void) can be covered by this mechanism.

diff --git a/src/main/java/io/papermc/paper/event/executor/EventExecutorFactory.java b/src/main/java/io/papermc/paper/event/executor/EventExecutorFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..2e3e21c3e9ca8c1fab82250fac9400686242061b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/event/executor/EventExecutorFactory.java
@@ -0,0 +1,74 @@
+package io.papermc.paper.event.executor;
+
+import org.bukkit.event.Event;
+import org.bukkit.event.Listener;
+import org.bukkit.plugin.EventExecutor;
+import org.jetbrains.annotations.ApiStatus;
+import org.jspecify.annotations.NullMarked;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.constant.ConstantDescs;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.List;
+import java.util.Objects;
+
+@ApiStatus.Internal
+@NullMarked
+public final class EventExecutorFactory {
+    private static final byte[] TEMPLATE_CLASS_BYTES;
+
+    static {
+        try (final InputStream is = EventExecutorFactory.class.getResourceAsStream("MethodHandleEventExecutorTemplate.class")) {
+            TEMPLATE_CLASS_BYTES = Objects.requireNonNull(is, "template class is missing").readAllBytes();
+        } catch (IOException e) {
+            throw new AssertionError(e);
+        }
+    }
+
+    private EventExecutorFactory() {
+
+    }
+
+    /**
+     * {@return an {@link EventExecutor} implemented by a hidden class calling a method handle}
+     *
+     * @param method     the method to be invoked by the created event executor
+     * @param eventClass the class of the event to handle
+     */
+    public static EventExecutor create(final Method method, final Class<? extends Event> eventClass) {
+        final List<?> classData = List.of(method, eventClass);
+        try {
+            final MethodHandles.Lookup newClass = MethodHandles.lookup().defineHiddenClassWithClassData(TEMPLATE_CLASS_BYTES, classData, true);
+            return newClass.lookupClass().asSubclass(EventExecutor.class).getDeclaredConstructor().newInstance();
+        } catch (ReflectiveOperationException e) {
+            throw new AssertionError(e);
+        }
+    }
+
+    record ClassData(Method method, MethodHandle methodHandle, Class<? extends Event> eventClass) {
+
+    }
+
+    /**
+     * Extracts the class data and creates an adjusted MethodHandle directly usable by the lookup class.
+     * The logic is kept here to minimize memory usage per created class.
+     */
+    static ClassData classData(final MethodHandles.Lookup lookup) {
+        try {
+            final Method method = MethodHandles.classDataAt(lookup, ConstantDescs.DEFAULT_NAME, Method.class, 0);
+            MethodHandle mh = lookup.unreflect(method);
+            if (Modifier.isStatic(method.getModifiers())) {
+                mh = MethodHandles.dropArguments(mh, 0, Listener.class);
+            }
+            mh = mh.asType(MethodType.methodType(void.class, Listener.class, Event.class));
+            final Class<?> eventClass = MethodHandles.classDataAt(lookup, ConstantDescs.DEFAULT_NAME, Class.class, 1);
+            return new ClassData(method, mh, eventClass.asSubclass(Event.class));
+        } catch (ReflectiveOperationException e) {
+            throw new AssertionError(e);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/event/executor/MethodHandleEventExecutorTemplate.java b/src/main/java/io/papermc/paper/event/executor/MethodHandleEventExecutorTemplate.java
new file mode 100644
index 0000000000000000000000000000000000000000..996a400aaaf4db2fa876dd8182233040e4451775
--- /dev/null
+++ b/src/main/java/io/papermc/paper/event/executor/MethodHandleEventExecutorTemplate.java
@@ -0,0 +1,51 @@
+package io.papermc.paper.event.executor;
+
+import com.destroystokyo.paper.util.SneakyThrow;
+import org.bukkit.event.Event;
+import org.bukkit.event.EventException;
+import org.bukkit.event.Listener;
+import org.bukkit.plugin.EventExecutor;
+import org.jetbrains.annotations.ApiStatus;
+import org.jspecify.annotations.NullMarked;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.reflect.Method;
+
+/**
+ * This class is designed to be used as hidden class template.
+ * Initializing the class directly will fail due to missing {@code classData}.
+ * Instead, {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClassWithClassData(byte[], Object, boolean, MethodHandles.Lookup.ClassOption...)}
+ * must be used, with the {@code classData} object being a list consisting of two elements:
+ * <ol>
+ *     <li>A {@link Method} representing the event handler method</li>
+ *     <li>A {@link Class} representing the event type</li>
+ * </ol>
+ * The method must take {@link Event} or a subtype of it as its single parameter.
+ * If the method is non-static, it also needs to reside in a class implementing {@link Listener}.
+ */
+@SuppressWarnings("unused")
+@ApiStatus.Internal
+@NullMarked
+class MethodHandleEventExecutorTemplate implements EventExecutor {
+    private static final Method METHOD;
+    private static final MethodHandle HANDLE;
+    private static final Class<? extends Event> EVENT_CLASS;
+
+    static {
+        final MethodHandles.Lookup lookup = MethodHandles.lookup();
+        final EventExecutorFactory.ClassData classData = EventExecutorFactory.classData(lookup);
+        METHOD = classData.method();
+        HANDLE = classData.methodHandle();
+        EVENT_CLASS = classData.eventClass();
+    }
+
+    @Override
+    public void execute(final Listener listener, final Event event) throws EventException {
+        if (!EVENT_CLASS.isInstance(event)) return;
+        try {
+            HANDLE.invokeExact(listener, event);
+        } catch (Throwable t) {
+            SneakyThrow.sneaky(t);
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/plugin/EventExecutor.java b/src/main/java/org/bukkit/plugin/EventExecutor.java
index a850f0780de05463fc0d3f9e15ff7f19d88b2aed..7b37614a1aeceb0aee062f13effb4aeabb3e1227 100644
--- a/src/main/java/org/bukkit/plugin/EventExecutor.java
+++ b/src/main/java/org/bukkit/plugin/EventExecutor.java
@@ -5,9 +5,34 @@ import org.bukkit.event.EventException;
 import org.bukkit.event.Listener;
 import org.jetbrains.annotations.NotNull;
 
+// Paper start
+import io.papermc.paper.event.executor.EventExecutorFactory;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+
+import com.google.common.base.Preconditions;
+// Paper end
+
 /**
  * Interface which defines the class for event call backs to plugins
  */
 public interface EventExecutor {
     public void execute(@NotNull Listener listener, @NotNull Event event) throws EventException;
+
+    // Paper start
+    @NotNull
+    public static EventExecutor create(@NotNull Method m, @NotNull Class<? extends Event> eventClass) {
+        Preconditions.checkNotNull(m, "Null method");
+        Preconditions.checkArgument(m.getParameterCount() != 0, "Incorrect number of arguments %s", m.getParameterCount());
+        Preconditions.checkArgument(m.getParameterTypes()[0] == eventClass, "First parameter %s doesn't match event class %s", m.getParameterTypes()[0], eventClass);
+        if (!m.trySetAccessible()) {
+            final org.bukkit.plugin.java.JavaPlugin plugin = org.bukkit.plugin.java.JavaPlugin.getProvidingPlugin(m.getDeclaringClass());
+            throw new AssertionError(
+                "@EventHandler method " + m.getDeclaringClass().getName() + (Modifier.isStatic(m.getModifiers()) ? '.' : '#') + m.getName() + " is not accessible."
+                    + " This should be reported to the developers of " + plugin.getDescription().getName() + " (" + String.join(",", plugin.getDescription().getAuthors()) + ')'
+            );
+        }
+        return EventExecutorFactory.create(m, eventClass);
+    }
+    // Paper end
 }

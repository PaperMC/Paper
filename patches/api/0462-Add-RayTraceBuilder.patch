From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Tamion <70228790+notTamion@users.noreply.github.com>
Date: Sat, 10 Feb 2024 12:41:21 +0100
Subject: [PATCH] Add RayTraceBuilder


diff --git a/src/main/java/io/papermc/paper/RayTraceBuilder.java b/src/main/java/io/papermc/paper/RayTraceBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..facf81183810d39fcff7357088307c6e979f1dbe
--- /dev/null
+++ b/src/main/java/io/papermc/paper/RayTraceBuilder.java
@@ -0,0 +1,248 @@
+package io.papermc.paper;
+
+import org.bukkit.FluidCollisionMode;
+import org.bukkit.Location;
+import org.bukkit.block.Block;
+import org.bukkit.entity.Entity;
+import org.bukkit.util.RayTraceResult;
+import org.bukkit.util.Vector;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import java.util.function.Predicate;
+
+/**
+ * Helps with casting a raytrace.
+ */
+public class RayTraceBuilder {
+
+    private Location start;
+    private Vector direction;
+    private double maxDistance;
+    private FluidCollisionMode fluidCollisionMode = FluidCollisionMode.NEVER;
+    private boolean ignorePassableBlocks;
+    private double raySize = 0.0D;
+    private Predicate<? super Entity> entityFilter;
+    private Predicate<? super Block> blockFilter;
+
+    /**
+     * Creates a new RayTraceBuilder.
+     *
+     * @param start starting location of the raytrace
+     * @param direction direction of the raytrace
+     * @param maxDistance maximum distance of the raytrace
+     */
+    public RayTraceBuilder(@NotNull Location start, @NotNull Vector direction, double maxDistance) {
+        this.start = start;
+        this.direction = direction;
+        this.maxDistance = maxDistance;
+    }
+
+    /**
+     * Gets the current starting location.
+     *
+     * @return the current starting location
+     */
+    @NotNull
+    public Location start() {
+        return start;
+    }
+
+    /**
+     * Sets the starting location.
+     *
+     * @param start the new direction
+     * @return a reference to this object
+     */
+    @NotNull
+    public RayTraceBuilder start(@NotNull Location start) {
+        this.start = start;
+        return this;
+    }
+
+    /**
+     * Gets the current direction.
+     *
+     * @return the current direction
+     */
+    @NotNull
+    public Vector direction() {
+        return direction;
+    }
+
+    /**
+     * Sets the direction in which the raytrace gets cast.
+     *
+     * @param direction the new direction
+     * @return a reference to this object
+     */
+    @NotNull
+    public RayTraceBuilder direction(@NotNull Vector direction) {
+        this.direction = direction;
+        return this;
+    }
+
+    /**
+     * Gets the current maximum distance.
+     *
+     * @return the current maximum distance
+     */
+    public double maxDistance() {
+        return maxDistance;
+    }
+
+    /**
+     * Sets the maximum distance.
+     *
+     * @param maxDistance the new maximum distance
+     * @return a reference to this object
+     */
+    @NotNull
+    public RayTraceBuilder maxDistance(double maxDistance) {
+        this.maxDistance = maxDistance;
+        return this;
+    }
+
+    /**
+     * Gets the current FluidCollisionMode when scanning for block collisions.
+     *
+     * @return the current FluidCollisionMode
+     */
+    @NotNull
+    public FluidCollisionMode fluidCollisionMode() {
+        return fluidCollisionMode;
+    }
+
+    /**
+     * Sets the FluidCollisionMode when scanning for block collisions.
+     *
+     * @param fluidCollisionMode the new FluidCollisionMode
+     * @return a reference to this object
+     */
+    @NotNull
+    public RayTraceBuilder fluidCollisionMode(@NotNull FluidCollisionMode fluidCollisionMode) {
+        this.fluidCollisionMode = fluidCollisionMode;
+        return this;
+    }
+
+    /**
+     * Gets if the raytrace will currently ignore passable blocks when scanning for block collisions.
+     *
+     * @return if the raytrace will currently ignore passable blocks
+     */
+    public boolean ignorePassableBlocks() {
+        return ignorePassableBlocks;
+    }
+
+    /**
+     * Sets if the raytrace will ignore passable blocks when scanning for block collisions.
+     *
+     * @param ignorePassableBlocks if the raytrace should ignore passable blocks
+     * @return a reference to this object
+     */
+    @NotNull
+    public RayTraceBuilder ignorePassableBlocks(boolean ignorePassableBlocks) {
+        this.ignorePassableBlocks = ignorePassableBlocks;
+        return this;
+    }
+
+    /**
+     * Gets the current size of the raytrace when scanning for entity collisions.
+     *
+     * @return the current size of the raytrace
+     */
+    public double raySize() {
+        return raySize;
+    }
+
+    /**
+     * Sets the size of the raytrace when scanning for entity collisions.
+     *
+     * @param raySize the new size of the raytrace
+     * @return a reference to this object
+     */
+    @NotNull
+    public RayTraceBuilder raySize(double raySize) {
+        this.raySize = raySize;
+        return this;
+    }
+
+    /**
+     * Gets the current entity filter.
+     *
+     * @return predicate for entities the ray can potentially collide with, or null to consider all entities
+     */
+    @Nullable
+    public Predicate<? super Entity> entityFilter() {
+        return entityFilter;
+    }
+
+    /**
+     * Sets the entity filter.
+     *
+     * @param entityFilter predicate for entities the ray can potentially collide with, or null to consider all entities
+     * @return a reference to this object
+     */
+    @NotNull
+    public RayTraceBuilder entityFilter(@Nullable Predicate<? super Entity> entityFilter) {
+        this.entityFilter = entityFilter;
+        return this;
+    }
+
+    /**
+     * Gets the current block filter.
+     *
+     * @return predicate for blocks the ray can potentially collide with, or null to consider all blocks
+     */
+    @Nullable
+    public Predicate<? super Block> blockFilter() {
+        return blockFilter;
+    }
+
+    /**
+     * Sets the block filter
+     *
+     * @param blockFilter predicate for blocks the ray can potentially collide with, or null to consider all blocks
+     * @return a reference to this object
+     */
+    @NotNull
+    public RayTraceBuilder blockFilter(@Nullable Predicate<? super Block> blockFilter) {
+        this.blockFilter = blockFilter;
+        return this;
+    }
+
+    /**
+     * Casts the raytrace with the specified type.
+     *
+     * @param type what type of collisions you want to catch
+     * @return the result of the raytrace
+     */
+    @Nullable
+    public RayTraceResult cast(@NotNull Type type) {
+        return switch (type) {
+            case ALL ->
+                this.start.getWorld().rayTrace(start, direction, maxDistance, fluidCollisionMode, ignorePassableBlocks, raySize, entityFilter, blockFilter);
+            case ENTITIES ->
+                this.start.getWorld().rayTraceEntities(start, direction, maxDistance, raySize, entityFilter);
+            case BLOCKS ->
+                this.start.getWorld().rayTraceBlocks(start, direction, maxDistance, fluidCollisionMode, ignorePassableBlocks, blockFilter);
+        };
+    }
+
+    /**
+     * The type of the raytrace being used.
+     */
+    public enum Type {
+        /**
+         * Will check for both entity and block collisions.
+         */
+        ALL,
+        /**
+         * Will check for entity collisions.
+         */
+        ENTITIES,
+        /**
+         * Will check for block collisions.
+         */
+        BLOCKS
+    }
+}

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Warrior <50800980+Warriorrrr@users.noreply.github.com>
Date: Sat, 19 Nov 2022 19:46:44 +0100
Subject: [PATCH] Add /paper dumplisteners command


diff --git a/src/main/java/co/aikar/timings/TimedEventExecutor.java b/src/main/java/co/aikar/timings/TimedEventExecutor.java
index be275c25664e0c76123371c6c8fac601f87fa492..8f29c1561ba5916cb5634392edd8bd2a5a294a51 100644
--- a/src/main/java/co/aikar/timings/TimedEventExecutor.java
+++ b/src/main/java/co/aikar/timings/TimedEventExecutor.java
@@ -81,4 +81,10 @@ public class TimedEventExecutor implements EventExecutor {
             executor.execute(listener, event);
         }
     }
+
+    @Override
+    @NotNull
+    public String toString() {
+        return "TimedEventExecutor['" + this.executor.toString() + "']";
+    }
 }
diff --git a/src/main/java/com/destroystokyo/paper/event/executor/MethodHandleEventExecutor.java b/src/main/java/com/destroystokyo/paper/event/executor/MethodHandleEventExecutor.java
index 5b28e9b1daba7834af67dbc193dd656bedd9a994..fbebf649e893cf872be9b27091146a7c2f451aca 100644
--- a/src/main/java/com/destroystokyo/paper/event/executor/MethodHandleEventExecutor.java
+++ b/src/main/java/com/destroystokyo/paper/event/executor/MethodHandleEventExecutor.java
@@ -14,10 +14,12 @@ import org.jetbrains.annotations.NotNull;
 public class MethodHandleEventExecutor implements EventExecutor {
     private final Class<? extends Event> eventClass;
     private final MethodHandle handle;
+    private final Method method;
 
     public MethodHandleEventExecutor(@NotNull Class<? extends Event> eventClass, @NotNull MethodHandle handle) {
         this.eventClass = eventClass;
         this.handle = handle;
+        this.method = null;
     }
 
     public MethodHandleEventExecutor(@NotNull Class<? extends Event> eventClass, @NotNull Method m) {
@@ -28,6 +30,7 @@ public class MethodHandleEventExecutor implements EventExecutor {
         } catch (IllegalAccessException e) {
             throw new AssertionError("Unable to set accessible", e);
         }
+        this.method = m;
     }
 
     @Override
@@ -39,4 +42,10 @@ public class MethodHandleEventExecutor implements EventExecutor {
             SneakyThrow.sneaky(t);
         }
     }
+
+    @Override
+    @NotNull
+    public String toString() {
+        return "MethodHandleEventExecutor['" + this.method + "']";
+    }
 }
diff --git a/src/main/java/com/destroystokyo/paper/event/executor/StaticMethodHandleEventExecutor.java b/src/main/java/com/destroystokyo/paper/event/executor/StaticMethodHandleEventExecutor.java
index 827f2b27f70a7ec0bc11d039305c3e58c02a4ef4..52da2d040e3b335f9e47bc5dc26e17d9c06d9569 100644
--- a/src/main/java/com/destroystokyo/paper/event/executor/StaticMethodHandleEventExecutor.java
+++ b/src/main/java/com/destroystokyo/paper/event/executor/StaticMethodHandleEventExecutor.java
@@ -17,6 +17,7 @@ import org.jetbrains.annotations.NotNull;
 public class StaticMethodHandleEventExecutor implements EventExecutor {
     private final Class<? extends Event> eventClass;
     private final MethodHandle handle;
+    private final Method method;
 
     public StaticMethodHandleEventExecutor(@NotNull Class<? extends Event> eventClass, @NotNull Method m) {
         Preconditions.checkArgument(Modifier.isStatic(m.getModifiers()), "Not a static method: %s", m);
@@ -28,6 +29,7 @@ public class StaticMethodHandleEventExecutor implements EventExecutor {
         } catch (IllegalAccessException e) {
             throw new AssertionError("Unable to set accessible", e);
         }
+        this.method = m;
     }
 
     @Override
@@ -39,4 +41,10 @@ public class StaticMethodHandleEventExecutor implements EventExecutor {
             SneakyThrow.sneaky(throwable);
         }
     }
+
+    @Override
+    @NotNull
+    public String toString() {
+        return "StaticMethodHandleEventExecutor['" + this.method + "']";
+    }
 }
diff --git a/src/main/java/org/bukkit/event/HandlerList.java b/src/main/java/org/bukkit/event/HandlerList.java
index ed78cca71f83b296d082d0af147ca8d622c7606a..2292bd460ce2be113beb4ba6b4eb19350060f01c 100644
--- a/src/main/java/org/bukkit/event/HandlerList.java
+++ b/src/main/java/org/bukkit/event/HandlerList.java
@@ -33,6 +33,13 @@ public class HandlerList {
      */
     private static ArrayList<HandlerList> allLists = new ArrayList<HandlerList>();
 
+    // Paper start
+    /**
+     * Event types which have instantiated a {@link HandlerList}.
+     */
+    private static final java.util.Set<String> EVENT_TYPES = java.util.concurrent.ConcurrentHashMap.newKeySet();
+    // Paper end
+
     /**
      * Bake all handler lists. Best used just after all normal event
      * registration is complete, ie just after all plugins are loaded if
@@ -94,6 +101,12 @@ public class HandlerList {
      * The HandlerList is then added to meta-list for use in bakeAll()
      */
     public HandlerList() {
+        // Paper start
+        java.lang.StackWalker.getInstance(java.util.EnumSet.of(java.lang.StackWalker.Option.RETAIN_CLASS_REFERENCE), 4)
+            .walk(s -> s.filter(f -> Event.class.isAssignableFrom(f.getDeclaringClass())).findFirst())
+            .map(f -> f.getDeclaringClass().getName())
+            .ifPresent(EVENT_TYPES::add);
+        // Paper end
         handlerslots = new EnumMap<EventPriority, ArrayList<RegisteredListener>>(EventPriority.class);
         for (EventPriority o : EventPriority.values()) {
             handlerslots.put(o, new ArrayList<RegisteredListener>());
diff --git a/src/main/java/org/bukkit/plugin/EventExecutor.java b/src/main/java/org/bukkit/plugin/EventExecutor.java
index 5fa52419f21d8e8b3d8f9aafd248b05774a28348..60e086be70529e0804280b24a2a3e7ae72d8d363 100644
--- a/src/main/java/org/bukkit/plugin/EventExecutor.java
+++ b/src/main/java/org/bukkit/plugin/EventExecutor.java
@@ -70,9 +70,18 @@ public interface EventExecutor {
             try {
                 EventExecutor asmExecutor = executorClass.newInstance();
                 // Define a wrapper to conform to bukkit stupidity (passing in events that don't match and wrapper exception)
-                return (listener, event) -> {
-                    if (!eventClass.isInstance(event)) return;
-                    asmExecutor.execute(listener, event);
+                return new EventExecutor() {
+                    @Override
+                    public void execute(@NotNull Listener listener, @NotNull Event event) throws EventException {
+                        if (!eventClass.isInstance(event)) return;
+                        asmExecutor.execute(listener, event);
+                    }
+
+                    @Override
+                    @NotNull
+                    public String toString() {
+                        return "ASMEventExecutor['" + m + "']";
+                    }
                 };
             } catch (InstantiationException | IllegalAccessException e) {
                 throw new AssertionError("Unable to initialize generated event executor", e);
diff --git a/src/main/java/org/bukkit/plugin/RegisteredListener.java b/src/main/java/org/bukkit/plugin/RegisteredListener.java
index 419aec56b0e3fa8bcec2ea7f340caa3456b57d00..3b3d9642a8d63798dc28f2f8df77f0466451cbff 100644
--- a/src/main/java/org/bukkit/plugin/RegisteredListener.java
+++ b/src/main/java/org/bukkit/plugin/RegisteredListener.java
@@ -78,4 +78,27 @@ public class RegisteredListener {
     public boolean isIgnoringCancelled() {
         return ignoreCancelled;
     }
+
+    // Paper start
+    /**
+     * Get the executor for this registration.
+     *
+     * @return executor
+     */
+    @NotNull
+    public EventExecutor getExecutor() {
+        return this.executor;
+    }
+
+    @Override
+    public String toString() {
+        return "RegisteredListener{"
+            + "plugin=\"" + this.plugin.getName()
+            + "\", listener=\"" + this.listener
+            + "\", executor=\"" + this.executor
+            + "\", priority=\"" + this.priority.name() + " (" + this.priority.getSlot() + ")"
+            + "\", ignoringCancelled=" + this.ignoreCancelled
+            + "}";
+    }
+    // Paper end
 }
